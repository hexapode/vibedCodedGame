<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rogue Opus â€“ The Ashen Reaches</title>
  <style>
/* ============================================================
   Elin Clone â€” Main Stylesheet
   ============================================================ */

:root {
  --bg-dark: #0a0a12;
  --bg-panel: #12121e;
  --bg-panel-alt: #1a1a2e;
  --border: #2a2a4a;
  --text: #d0d0e0;
  --text-dim: #8888aa;
  --text-bright: #f0f0ff;
  --accent: #6a8fdf;
  --accent-hover: #8ab0ff;
  --hp-color: #d04040;
  --mp-color: #4060d0;
  --sp-color: #d0a020;
  --food-color: #40a040;
  --gold: #ffd700;
  --danger: #e04040;
  --success: #40c040;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Inter', sans-serif;
  background: var(--bg-dark);
  color: var(--text);
  overflow: hidden;
  width: 100vw;
  height: 100vh;
}

.screen { display: flex; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
.screen.hidden { display: none !important; }

/* â”€â”€ Main Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#mainMenu {
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
}

.menu-bg {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  background: radial-gradient(ellipse at 50% 30%, rgba(100, 140, 220, 0.12) 0%, transparent 70%);
  pointer-events: none;
}

.menu-content {
  position: relative;
  text-align: center;
  z-index: 1;
}

.game-title {
  font-family: 'Press Start 2P', monospace;
  font-size: 3rem;
  color: var(--accent);
  text-shadow: 0 0 40px rgba(106, 143, 223, 0.5);
  margin-bottom: 0.5rem;
}

.subtitle {
  color: var(--text-dim);
  font-size: 1.1rem;
  margin-bottom: 3rem;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  align-items: center;
}

.btn {
  font-family: 'Inter', sans-serif;
  font-size: 1rem;
  font-weight: 600;
  padding: 0.8rem 2.5rem;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 220px;
}

.btn-primary {
  background: var(--accent);
  color: #fff;
}
.btn-primary:hover {
  background: var(--accent-hover);
  transform: translateY(-2px);
  box-shadow: 0 4px 20px rgba(106, 143, 223, 0.4);
}

.btn-secondary {
  background: var(--bg-panel-alt);
  color: var(--text);
  border: 1px solid var(--border);
}
.btn-secondary:hover {
  background: var(--border);
  transform: translateY(-1px);
}

.btn-small {
  padding: 0.4rem 1.2rem;
  font-size: 0.85rem;
  background: var(--bg-panel-alt);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  margin-top: 0.5rem;
}
.btn-small:hover { background: var(--border); }

.hidden { display: none !important; }

/* â”€â”€ Character Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#charCreation {
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--bg-dark);
  padding: 2rem;
}

.creation-panel {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 2rem;
  max-width: 1000px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
}

.creation-panel h2 {
  text-align: center;
  color: var(--accent);
  margin-bottom: 1.5rem;
  font-family: 'Press Start 2P', monospace;
  font-size: 1.2rem;
}

.creation-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
}

.creation-section {
  background: var(--bg-panel-alt);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 1rem;
}

.creation-section label {
  display: block;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.creation-section input,
.creation-section select {
  width: 100%;
  padding: 0.6rem;
  background: var(--bg-dark);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-bright);
  font-size: 1rem;
}

.option-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
  max-height: 200px;
  overflow-y: auto;
}

.option-btn {
  padding: 0.4rem 0.8rem;
  background: var(--bg-dark);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.15s;
}
.option-btn:hover { border-color: var(--accent); color: var(--accent); }
.option-btn.selected { background: var(--accent); color: #fff; border-color: var(--accent); }

.info-box {
  margin-top: 0.5rem;
  padding: 0.6rem;
  background: var(--bg-dark);
  border-radius: 4px;
  font-size: 0.8rem;
  color: var(--text-dim);
  min-height: 60px;
}

.info-box .desc { margin-bottom: 0.3rem; color: var(--text); }
.info-box p { margin: 0.15rem 0; }

.char-section {
  margin-bottom: 0.8rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border);
}
.char-section h4 {
  font-size: 0.8rem;
  color: var(--accent);
  margin-bottom: 0.3rem;
}
.char-section p {
  font-size: 0.78rem;
  margin: 0.15rem 0;
}

.preview-stats {
  font-family: 'Press Start 2P', monospace;
  font-size: 0.65rem;
  line-height: 1.8;
  color: var(--text);
}

.creation-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-top: 1.5rem;
}

/* â”€â”€ Game Screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#gameScreen {
  flex-direction: column;
}

/* Top HUD */
.hud-top {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border);
  padding: 0.4rem 1rem;
  height: 50px;
  flex-shrink: 0;
}

.hud-player-info {
  display: flex;
  gap: 0.8rem;
  align-items: center;
}
.hud-name { font-weight: 700; color: var(--text-bright); }
.hud-race-class { font-size: 0.8rem; color: var(--text-dim); }
.hud-level { font-size: 0.8rem; color: var(--accent); font-weight: 600; }

.hud-bars {
  display: flex;
  gap: 0.8rem;
  align-items: center;
}

.bar-group {
  display: flex;
  align-items: center;
  gap: 0.3rem;
}
.bar-group label {
  font-size: 0.7rem;
  color: var(--text-dim);
  font-weight: 600;
  width: 30px;
}

.bar {
  width: 100px;
  height: 14px;
  background: var(--bg-dark);
  border-radius: 3px;
  position: relative;
  overflow: hidden;
  border: 1px solid var(--border);
}

.bar-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.3s;
}
.bar-hp .bar-fill { background: var(--hp-color); }
.bar-mp .bar-fill { background: var(--mp-color); }
.bar-sp .bar-fill { background: var(--sp-color); }
.bar-food .bar-fill { background: var(--food-color); }

.bar-text {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.6rem;
  font-weight: 600;
  color: #fff;
  text-shadow: 0 0 3px #000;
}

.hud-right-info {
  display: flex;
  gap: 1rem;
  font-size: 0.75rem;
  color: var(--text-dim);
}

/* Middle area: canvas + side panel */
#gameViewport {
  flex: 1;
  display: flex;
  overflow: hidden;
  position: relative;
}

#gameCanvas {
  flex: 1;
  min-width: 0;
  background: #0a0a0f;
  image-rendering: pixelated;
}

.side-panel {
  width: 300px;
  background: var(--bg-panel);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}

.side-panel-inner {
  flex: 1;
  display: flex;
  flex-direction: row;
  overflow: hidden;
}

.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  min-width: 0;
}

.tab-bar {
  display: flex;
  flex-direction: column;
  border-left: 1px solid var(--border);
  overflow-y: auto;
  overflow-x: hidden;
  flex-shrink: 0;
  width: 52px;
  scrollbar-width: none;
}
.tab-bar::-webkit-scrollbar { display: none; }

.tab-btn {
  padding: 0.5rem 0.2rem;
  background: var(--bg-panel-alt);
  border: none;
  border-bottom: 1px solid var(--border);
  color: var(--text-dim);
  cursor: pointer;
  font-size: 0.6rem;
  font-weight: 600;
  transition: all 0.15s;
  white-space: nowrap;
  text-align: center;
  line-height: 1.3;
  flex-shrink: 0;
}
.tab-btn.active {
  background: var(--bg-panel);
  color: var(--accent);
  border-left: 2px solid var(--accent);
}
.tab-btn:hover { color: var(--text); background: var(--bg-panel); }

.tab-panel {
  display: none;
  padding: 0.8rem;
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.tab-panel.active { display: flex; flex-direction: column; }
.tab-panel h3 {
  font-size: 0.85rem;
  color: var(--accent);
  margin-bottom: 0.5rem;
}

.scroll-list {
  font-size: 0.78rem;
  line-height: 1.6;
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 0.2rem 0;
  font-size: 0.78rem;
}
.stat-label { color: var(--text-dim); }
.stat-value { color: var(--text-bright); font-weight: 600; }

.skill-row {
  display: flex;
  justify-content: space-between;
  padding: 0.15rem 0;
  font-size: 0.75rem;
}
.skill-name { color: var(--text); }
.skill-level { color: var(--accent); font-weight: 600; }

/* Context action hints bar */
.context-actions-bar {
  display: flex;
  gap: 0.2rem;
  flex-wrap: wrap;
  background: rgba(15, 15, 28, 0.95);
  border-top: 1px solid var(--border);
  padding: 0.25rem 0.8rem;
  flex-shrink: 0;
  min-height: 26px;
  align-items: center;
}

.ctx-action {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.15rem 0.5rem;
  border-radius: 3px;
  font-size: 0.72rem;
  color: var(--text-dim);
  cursor: pointer;
  transition: all 0.12s;
  white-space: nowrap;
  border: 1px solid transparent;
}

.ctx-action:hover {
  background: rgba(106, 143, 223, 0.15);
  color: var(--text-bright);
  border-color: var(--border);
}

.ctx-action.ctx-highlight {
  color: var(--text);
  background: rgba(106, 143, 223, 0.08);
}

.ctx-action .ctx-key {
  display: inline-block;
  padding: 0.05rem 0.35rem;
  background: rgba(106, 143, 223, 0.2);
  border: 1px solid rgba(106, 143, 223, 0.35);
  border-radius: 3px;
  font-family: 'Press Start 2P', monospace;
  font-size: 0.55rem;
  color: var(--accent);
  min-width: 18px;
  text-align: center;
  line-height: 1.4;
}

.ctx-action.ctx-highlight .ctx-key {
  background: rgba(106, 143, 223, 0.3);
  border-color: var(--accent);
  color: var(--accent-hover);
}

.ctx-action .ctx-label {
  color: inherit;
}

.ctx-action .ctx-icon {
  font-size: 0.8rem;
}

.ctx-sep {
  width: 1px;
  height: 16px;
  background: var(--border);
  margin: 0 0.2rem;
  flex-shrink: 0;
}

/* Message log */
.message-log {
  height: 100px;
  background: var(--bg-panel);
  border-top: 1px solid var(--border);
  overflow-y: auto;
  padding: 0.5rem 1rem;
  font-size: 0.78rem;
  line-height: 1.5;
  flex-shrink: 0;
}

.msg { color: var(--text-dim); }
.msg-combat { color: var(--hp-color); }
.msg-item { color: var(--gold); }
.msg-system { color: var(--accent); }

/* Action bar */
.action-bar {
  display: flex;
  gap: 0.3rem;
  background: var(--bg-panel);
  border-top: 1px solid var(--border);
  padding: 0.4rem 1rem;
  flex-shrink: 0;
}

.action-btn {
  padding: 0.4rem 0.8rem;
  background: var(--bg-panel-alt);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  cursor: pointer;
  font-size: 0.75rem;
  transition: all 0.15s;
}
.action-btn:hover {
  background: var(--border);
  color: var(--text-bright);
}

/* â”€â”€ Game Over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#gameOver {
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(10, 10, 18, 0.95);
  overflow-y: auto;
}

.gameover-panel {
  text-align: center;
  max-width: 640px;
  width: 100%;
  padding: 2rem 1rem;
}
.gameover-panel h1 {
  font-family: 'Press Start 2P', monospace;
  font-size: 2rem;
  color: var(--danger);
  margin-bottom: 1rem;
}
.gameover-panel p {
  color: var(--text-dim);
  margin-bottom: 1.5rem;
}

/* Death Recap */
.death-recap {
  text-align: left;
  margin-bottom: 2rem;
}

.recap-killer {
  text-align: center;
  font-size: 1.1rem;
  color: var(--danger);
  background: rgba(200, 40, 40, 0.12);
  border: 1px solid rgba(200, 40, 40, 0.35);
  border-radius: 8px;
  padding: 0.75rem 1rem;
  margin-bottom: 1.2rem;
  font-weight: 700;
}

.recap-columns {
  display: flex;
  gap: 1rem;
  margin-bottom: 1.2rem;
}

.recap-section {
  flex: 1;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 0.75rem;
}
.recap-section h3 {
  font-size: 0.8rem;
  color: var(--accent);
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.recap-list {
  font-size: 0.78rem;
}
.recap-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.25rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  color: var(--text);
}
.recap-list-item:last-child {
  border-bottom: none;
}
.recap-list-item .source {
  color: var(--text-bright);
  font-weight: 600;
}
.recap-list-item .damage {
  color: var(--danger);
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}
.recap-list-item .turn-num {
  color: var(--text-dim);
  font-size: 0.7rem;
  margin-left: 0.5rem;
}

.recap-stats {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 0.75rem;
  margin-bottom: 1.2rem;
}
.recap-stats h3 {
  font-size: 0.8rem;
  color: var(--accent);
  margin-bottom: 0.6rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-align: center;
}

.recap-stat-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.3rem 1.5rem;
  font-size: 0.78rem;
}
.recap-stat {
  display: flex;
  justify-content: space-between;
  padding: 0.2rem 0;
}
.recap-stat .label {
  color: var(--text-dim);
}
.recap-stat .value {
  color: var(--text-bright);
  font-weight: 600;
  font-variant-numeric: tabular-nums;
}

/* â”€â”€ Card Book â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card-book-header {
  margin-bottom: 0.5rem;
}
.card-book-stats {
  display: flex;
  justify-content: space-between;
  font-size: 0.75rem;
  color: var(--text-dim);
  margin-bottom: 0.3rem;
}
.card-book-stats strong {
  color: var(--text-bright);
}
.card-book-progress {
  height: 4px;
  background: var(--bg-dark);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: 0.4rem;
}
.card-book-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), #e040fb);
  border-radius: 2px;
  transition: width 0.3s;
}

.card-subsection-header {
  text-align: center;
  font-size: 0.7rem;
  color: var(--text-dim);
  margin: 0.5rem 0 0.3rem;
  letter-spacing: 0.5px;
}

.card-shop-section {
  background: rgba(224, 64, 251, 0.06);
  border: 1px solid rgba(224, 64, 251, 0.25);
  border-radius: 6px;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
}
.card-shop-section h4 {
  font-size: 0.8rem;
  color: #e040fb;
  margin-bottom: 0.3rem;
  text-align: center;
}

.card-shop-item {
  display: flex;
  align-items: center;
  gap: 0.4rem;
  padding: 0.25rem 0.3rem;
  border-radius: 4px;
  margin-bottom: 2px;
  font-size: 0.75rem;
  transition: background 0.1s;
}
.card-shop-item:hover {
  background: rgba(255,255,255,0.05);
}
.card-shop-item .card-preview {
  font-size: 1rem;
  width: 1.4rem;
  text-align: center;
  flex-shrink: 0;
}
.card-shop-item .card-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  line-height: 1.2;
}
.card-shop-item .card-name {
  font-weight: 600;
  font-size: 0.75rem;
}
.card-shop-item .card-detail {
  font-size: 0.65rem;
  color: var(--text-dim);
}
.btn-card-buy, .btn-card-sell {
  background: var(--bg-panel-alt);
  border: 1px solid var(--border);
  color: var(--gold);
  font-size: 0.65rem;
  padding: 2px 6px;
  border-radius: 3px;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
}
.btn-card-buy:hover { background: rgba(255,215,0,0.15); border-color: var(--gold); }
.btn-card-sell:hover { background: rgba(255,215,0,0.15); border-color: var(--gold); }

.card-empty {
  text-align: center;
  color: var(--text-dim);
  font-size: 0.75rem;
  padding: 0.5rem;
  font-style: italic;
}

.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
  gap: 0.4rem;
  padding: 0.2rem 0;
}

.card-item {
  cursor: default;
}
.card-frame {
  border: 2px solid #666;
  border-radius: 6px;
  background: var(--bg-dark);
  padding: 0.3rem;
  text-align: center;
  position: relative;
  transition: transform 0.15s, box-shadow 0.15s;
}
.card-frame:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}
.card-rarity-rare .card-frame {
  background: linear-gradient(135deg, #1a1a12 0%, #2a2200 100%);
  box-shadow: 0 0 6px rgba(255,215,0,0.15);
}
.card-rarity-superFoil .card-frame {
  background: linear-gradient(135deg, #1a0a20 0%, #200030 100%);
  box-shadow: 0 0 10px rgba(224,64,251,0.2);
  animation: foilShimmer 3s ease-in-out infinite;
}
@keyframes foilShimmer {
  0%, 100% { box-shadow: 0 0 8px rgba(224,64,251,0.2); }
  50% { box-shadow: 0 0 16px rgba(224,64,251,0.4), 0 0 4px rgba(255,215,0,0.2); }
}

.card-monster {
  font-size: 1.6rem;
  line-height: 1.4;
  padding: 0.2rem 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.card-monster-sprite {
  width: 36px;
  height: 36px;
  image-rendering: pixelated;
}
.card-name-plate {
  font-size: 0.6rem;
  font-weight: 700;
  padding: 1px 3px;
  border-radius: 2px;
  margin-bottom: 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.card-meta {
  display: flex;
  justify-content: space-between;
  font-size: 0.55rem;
  color: var(--text-dim);
}
.card-qty {
  position: absolute;
  top: 2px;
  right: 4px;
  font-size: 0.6rem;
  font-weight: 700;
  color: var(--text-bright);
  background: rgba(0,0,0,0.6);
  padding: 0 3px;
  border-radius: 3px;
}

/* Death recap card section */
.recap-cards {
  background: rgba(224, 64, 251, 0.06);
  border: 1px solid rgba(224, 64, 251, 0.25);
  border-radius: 8px;
  padding: 0.75rem;
  margin-bottom: 1.2rem;
}
.recap-cards h3 {
  font-size: 0.8rem;
  color: #e040fb;
  margin-bottom: 0.6rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-align: center;
}

/* â”€â”€ Scrollbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-dark); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--accent); }

/* â”€â”€ Tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */


/* â”€â”€ Skill List â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.skill-category-header {
  padding: 6px 4px 3px;
  font-size: 10px;
  font-weight: 700;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid var(--border);
  margin-top: 4px;
}
.skill-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 4px;
  font-size: 11px;
  border-bottom: 1px solid #1a1a2a;
  cursor: pointer;
  transition: background 0.12s;
}
.skill-row:hover {
  background: rgba(100, 180, 255, 0.08);
}
.skill-name {
  color: var(--text);
}
.skill-meta {
  display: flex;
  gap: 6px;
  align-items: center;
}
.skill-attr {
  color: #888;
  font-size: 9px;
}
.skill-level {
  color: #4af;
  font-weight: 600;
  min-width: 32px;
  text-align: right;
}

/* â”€â”€ Skill Popup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.skill-popup {
  position: fixed;
  z-index: 1100;
  background: var(--bg-panel);
  border: 1px solid var(--accent);
  border-radius: 8px;
  width: 260px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.65);
  animation: ctxFadeIn 0.12s ease-out;
  overflow: hidden;
}
.skill-popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 10px;
  background: var(--bg-panel-alt);
  border-bottom: 1px solid var(--border);
}
.skill-popup-name {
  font-weight: 700;
  font-size: 13px;
  color: var(--text-bright);
}
.skill-popup-close {
  cursor: pointer;
  color: var(--text-dim);
  font-size: 14px;
  line-height: 1;
  transition: color 0.15s;
}
.skill-popup-close:hover {
  color: var(--danger, #f55);
}
.skill-popup-tags {
  display: flex;
  gap: 6px;
  padding: 6px 10px;
  flex-wrap: wrap;
  border-bottom: 1px solid var(--border);
}
.skill-popup-tag {
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 4px;
  background: rgba(100, 180, 255, 0.1);
  color: #8cf;
  white-space: nowrap;
}
.skill-popup-desc {
  padding: 8px 10px 10px;
  font-size: 11px;
  line-height: 1.5;
  color: var(--text-dim);
}

.tooltip {
  position: absolute;
  background: var(--bg-panel);
  border: 1px solid var(--accent);
  border-radius: 6px;
  padding: 0.6rem;
  font-size: 0.78rem;
  color: var(--text);
  max-width: 250px;
  z-index: 100;
  pointer-events: none;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}
.tooltip-title { font-weight: 700; color: var(--text-bright); margin-bottom: 0.3rem; }
.tooltip-desc { color: var(--text-dim); }

/* â”€â”€ Inventory Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.inv-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, 48px);
  gap: 4px;
  padding: 6px;
  justify-content: start;
}

.inv-cell {
  width: 48px;
  height: 48px;
  background: var(--bg-dark);
  border: 2px solid #333;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  transition: all 0.12s;
  user-select: none;
}
.inv-cell:hover {
  background: var(--bg-panel-alt);
  border-color: var(--accent);
  transform: scale(1.08);
  z-index: 2;
  box-shadow: 0 0 10px rgba(106, 143, 223, 0.3);
}
.inv-cell-equipped {
  background: rgba(106, 143, 223, 0.12);
  box-shadow: inset 0 0 8px rgba(106, 143, 223, 0.2);
}

.inv-cell-icon {
  font-size: 20px;
  line-height: 1;
  text-shadow: 0 0 6px currentColor;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}

.inv-cell-sprite {
  width: 36px;
  height: 36px;
  image-rendering: pixelated;
  pointer-events: none;
  filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.15));
}

.inv-cell-qty {
  position: absolute;
  bottom: 1px;
  right: 2px;
  font-size: 9px;
  font-weight: 700;
  color: #fff;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 3px;
  padding: 0 3px;
  line-height: 14px;
  min-width: 14px;
  text-align: center;
}

.inv-cell-equip-badge {
  position: absolute;
  top: 1px;
  left: 2px;
  font-size: 8px;
  font-weight: 700;
  color: var(--accent);
  background: rgba(0, 0, 0, 0.75);
  border-radius: 2px;
  padding: 0 2px;
  line-height: 12px;
}

.inventory-gold {
  padding: 6px 8px;
  font-weight: 600;
  color: var(--gold);
  font-size: 0.8rem;
  border-bottom: 1px solid var(--border);
}

/* â”€â”€ Inventory Context Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

.inv-ctx-sprite {
  width: 24px;
  height: 24px;
  image-rendering: pixelated;
  vertical-align: middle;
  margin-right: 4px;
  filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.2));
}

.shop-item-sprite {
  width: 20px;
  height: 20px;
  image-rendering: pixelated;
  vertical-align: middle;
  margin-right: 3px;
  filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.15));
}
.inv-context-menu {
  position: fixed;
  z-index: 1000;
  background: var(--bg-panel);
  border: 1px solid var(--accent);
  border-radius: 8px;
  min-width: 160px;
  max-width: 220px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
  overflow: hidden;
  animation: ctxFadeIn 0.1s ease-out;
}

@keyframes ctxFadeIn {
  from { opacity: 0; transform: scale(0.95); }
  to { opacity: 1; transform: scale(1); }
}

.inv-ctx-header {
  padding: 8px 10px;
  font-size: 12px;
  font-weight: 700;
  color: var(--text-bright);
  background: var(--bg-panel-alt);
  border-bottom: 1px solid var(--border);
}

.inv-ctx-stats {
  padding: 4px 10px;
  font-size: 10px;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  background: rgba(0,0,0,0.15);
}

.inv-ctx-action {
  padding: 7px 12px;
  font-size: 11px;
  color: var(--text);
  cursor: pointer;
  transition: background 0.1s;
}
.inv-ctx-action:hover {
  background: var(--accent);
  color: #fff;
}
.inv-ctx-danger {
  color: var(--danger);
}
.inv-ctx-danger:hover {
  background: var(--danger);
  color: #fff;
}

/* â”€â”€ Action Progress Bar Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.action-progress-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.35);
  pointer-events: none;
  animation: fadeInOverlay 0.1s ease-out;
}
.action-progress-overlay.hidden {
  display: none !important;
}

@keyframes fadeInOverlay {
  from { opacity: 0; }
  to   { opacity: 1; }
}

.action-progress-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  background: rgba(18, 18, 30, 0.95);
  border: 2px solid var(--accent);
  border-radius: 12px;
  padding: 20px 36px 16px;
  box-shadow: 0 0 40px rgba(106, 143, 223, 0.3), inset 0 0 20px rgba(106, 143, 223, 0.05);
  min-width: 260px;
}

.action-progress-icon {
  font-size: 2rem;
  filter: drop-shadow(0 0 8px rgba(106, 143, 223, 0.5));
  animation: pulseIcon 1s ease-in-out infinite;
}

@keyframes pulseIcon {
  0%, 100% { transform: scale(1); }
  50%      { transform: scale(1.15); }
}

.action-progress-label {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-bright);
  letter-spacing: 0.5px;
}

.action-progress-bar-container {
  position: relative;
  width: 220px;
  height: 18px;
  background: var(--bg-dark);
  border-radius: 9px;
  border: 1px solid var(--border);
  overflow: hidden;
}

.action-progress-fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--accent) 0%, #8ab0ff 60%, #a0d0ff 100%);
  border-radius: 9px;
  transition: width 0.08s linear;
  box-shadow: 0 0 8px rgba(106, 143, 223, 0.5);
}

.action-progress-fill.fill-fast {
  background: linear-gradient(90deg, var(--success) 0%, #6de06d 60%, #a0ffa0 100%);
  box-shadow: 0 0 8px rgba(64, 192, 64, 0.5);
}

.action-progress-fill.fill-slow {
  background: linear-gradient(90deg, var(--sp-color) 0%, #e0c040 60%, #ffe080 100%);
  box-shadow: 0 0 8px rgba(208, 160, 32, 0.5);
}

.action-progress-ticks {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 700;
  color: var(--text-bright);
  text-shadow: 0 1px 3px rgba(0,0,0,0.8);
  pointer-events: none;
}

.action-progress-hint {
  font-size: 0.7rem;
  color: var(--text-dim);
  margin-top: 2px;
}

/* Cancel flash animation */
@keyframes cancelFlash {
  0%   { border-color: var(--danger); box-shadow: 0 0 20px rgba(224, 64, 64, 0.4); }
  100% { border-color: var(--border); box-shadow: none; }
}
.action-progress-content.cancelled {
  animation: cancelFlash 0.3s ease-out;
}

</style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- â•â•â•â•â•â•â•â•â•â•â• MAIN MENU â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="mainMenu" class="screen active">
    <div class="menu-bg"></div>
    <div class="menu-content">
      <h1 class="game-title">âš” Rogue Opus (4.6) âš”</h1>
      <p class="subtitle">A Roguelike Adventure in the Ashen Reaches</p>
      <div class="menu-buttons">
        <button id="btnNewGame" class="btn btn-primary">New Game</button>
        <button id="btnLoadGame" class="btn btn-secondary">Load Game</button>
      </div>
      <div id="saveList"></div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â• CHARACTER CREATION â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="charCreation" class="screen hidden">
    <div class="creation-panel">
      <h2>Create Your Character</h2>
      <div class="creation-grid">
        <div class="creation-section">
          <label>Name</label>
          <input type="text" id="charName" value="Adventurer" maxlength="20">
        </div>
        <div class="creation-section">
          <label>Race</label>
          <select id="raceSelect"></select>
          <div id="raceInfo" class="info-box"></div>
        </div>
        <div class="creation-section">
          <label>Class</label>
          <select id="classSelect"></select>
          <div id="classInfo" class="info-box"></div>
        </div>
      </div>
      <div class="creation-actions">
        <button id="btnStartGame" class="btn btn-primary">Begin Adventure</button>
        <button id="btnBackToMenu" class="btn btn-secondary">Back</button>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â• GAME SCREEN â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="gameScreen" class="screen hidden">
    <!-- Top HUD -->
    <div id="topHud" class="hud-top">
      <div class="hud-player-info">
        <span id="hudName" class="hud-name"></span>
        <span id="hudLevel" class="hud-level"></span>
      </div>
      <div class="hud-bars">
        <div class="bar-group">
          <label>HP</label>
          <div class="bar bar-hp"><div id="hpFill" class="bar-fill"></div><span id="hpText" class="bar-text"></span></div>
        </div>
        <div class="bar-group">
          <label>MP</label>
          <div class="bar bar-mp"><div id="mpFill" class="bar-fill"></div><span id="mpText" class="bar-text"></span></div>
        </div>
        <div class="bar-group">
          <label>SP</label>
          <div class="bar bar-sp"><div id="spFill" class="bar-fill"></div><span id="spText" class="bar-text"></span></div>
        </div>
        <div class="bar-group">
          <label>Food</label>
          <div class="bar bar-food"><div id="foodFill" class="bar-fill"></div><span id="foodText" class="bar-text"></span></div>
        </div>
      </div>
      <div class="hud-right-info">
        <span id="hudTime"></span>
        <span id="hudWeather"></span>
      </div>
    </div>

    <!-- Main viewport -->
    <div id="gameViewport">
      <canvas id="gameCanvas"></canvas>
      <!-- Side panel -->
      <div id="sidePanel" class="side-panel">
        <div class="side-panel-inner">
        <div class="tab-content">
        <div id="inventory" class="tab-panel active">
          <h3>Inventory</h3>
          <div id="inventoryList" class="scroll-list"></div>
        </div>
        <div id="spellsTab" class="tab-panel">
          <h3>Spells</h3>
          <div id="spellList" class="scroll-list"></div>
        </div>
        <div id="shopTab" class="tab-panel">
          <h3>Shop</h3>
          <div id="shopPanel" class="scroll-list"></div>
        </div>
        <div id="craftTab" class="tab-panel">
          <h3>Crafting</h3>
          <div id="craftPanel" class="scroll-list"></div>
        </div>
        <div id="questTab" class="tab-panel">
          <h3>Quests</h3>
          <div id="questPanel" class="scroll-list"></div>
        </div>
        <div id="petsTab" class="tab-panel">
          <h3>Pets</h3>
          <div id="petPanel" class="scroll-list"></div>
        </div>
        <div id="faithTab" class="tab-panel">
          <h3>Faith</h3>
          <div id="faithPanel" class="scroll-list"></div>
        </div>
        <div id="character" class="tab-panel">
          <h3>Character</h3>
          <div id="characterInfo"></div>
        </div>
        <div id="skills" class="tab-panel">
          <h3>Skills</h3>
          <div id="skillsList" class="scroll-list"></div>
        </div>
        <div id="cardBookTab" class="tab-panel">
          <h3>ğŸƒ Card Book</h3>
          <div id="cardBookPanel" class="scroll-list"></div>
        </div>
        </div><!-- /.tab-content -->
        <div class="tab-bar">
          <button class="tab-btn active" data-tab="inventory" title="Inventory">ğŸ“¦ Inv</button>
          <button class="tab-btn" data-tab="spellsTab" title="Spells">âœ¨ Magic</button>
          <button class="tab-btn" data-tab="shopTab" title="Shop">ğŸª Shop</button>
          <button class="tab-btn" data-tab="craftTab" title="Crafting">ğŸ”¨ Craft</button>
          <button class="tab-btn" data-tab="questTab" title="Quests">ğŸ“œ Quests</button>
          <button class="tab-btn" data-tab="petsTab" title="Pets">ğŸ¾ Pets</button>
          <button class="tab-btn" data-tab="faithTab" title="Faith">ğŸ™ Faith</button>
          <button class="tab-btn" data-tab="cardBookTab" title="Card Book">ğŸƒ Cards</button>
          <button class="tab-btn" data-tab="character" title="Character">ğŸ‘¤ Char</button>
          <button class="tab-btn" data-tab="skills" title="Skills">ğŸ“Š Skills</button>
        </div>
        </div><!-- /.side-panel-inner -->
      </div>
    </div>

    <!-- Context action hints -->
    <div id="contextActions" class="context-actions-bar"></div>

    <!-- Action Progress Bar Overlay -->
    <div id="actionProgressOverlay" class="action-progress-overlay hidden">
      <div class="action-progress-content">
        <span id="actionProgressIcon" class="action-progress-icon"></span>
        <span id="actionProgressLabel" class="action-progress-label"></span>
        <div class="action-progress-bar-container">
          <div id="actionProgressFill" class="action-progress-fill"></div>
          <span id="actionProgressTicks" class="action-progress-ticks"></span>
        </div>
        <span class="action-progress-hint">Hold key to continue Â· Release to cancel</span>
      </div>
    </div>

    <!-- Bottom message log -->
    <div id="messageLog" class="message-log"></div>

    <!-- Action buttons -->
    <div id="actionBar" class="action-bar">
      <button id="btnWait" class="action-btn" title="Wait (.)">â³ Wait</button>
      <button id="btnPickup" class="action-btn" title="Pickup (g)">ğŸ“¦ Get</button>
      <button id="btnEat" class="action-btn" title="Eat (e)">ğŸ– Eat</button>
      <button id="btnMagic" class="action-btn" title="Spells (z)">âœ¨ Magic</button>
      <button id="btnShoot" class="action-btn" title="Shoot (f)">ğŸ¹ Shoot</button>
      <button id="btnCraft" class="action-btn" title="Craft (c)">ğŸ”¨ Craft</button>
      <button id="btnQuest" class="action-btn" title="Quests (q)">ğŸ“œ Quests</button>
      <button id="btnTame" class="action-btn" title="Tame (t)">ğŸ¾ Tame</button>
      <button id="btnGather" class="action-btn" title="Gather (m)">â› Gather</button>
      <button id="btnPray" class="action-btn" title="Pray (r)">ğŸ™ Pray</button>
      <button id="btnPlant" class="action-btn" title="Plant (p)">ğŸŒ± Plant</button>
      <button id="btnHarvest" class="action-btn" title="Harvest (H)">ğŸŒ¾ Harvest</button>
      <button id="btnDescend" class="action-btn" title="Descend (>)">â¬‡ Down</button>
      <button id="btnAscend" class="action-btn" title="Ascend (<)">â¬† Up</button>
      <button id="btnEnter" class="action-btn" title="Enter (Enter)">ğŸšª Enter</button>

      <button id="btnSave" class="action-btn" title="Save game">ğŸ’¾ Save</button>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â• GAME OVER â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="gameOver" class="screen hidden">
    <div class="gameover-panel">
      <h1>â˜  You Have Died â˜ </h1>
      <p id="deathMessage"></p>

      <div id="deathRecap" class="death-recap">
        <div class="recap-killer" id="recapKiller"></div>

        <div class="recap-columns">
          <div class="recap-section">
            <h3>ğŸ“œ Last Hits</h3>
            <div id="recapLastHits" class="recap-list"></div>
          </div>
          <div class="recap-section">
            <h3>âš” Top Damage Sources</h3>
            <div id="recapTopSources" class="recap-list"></div>
          </div>
        </div>

        <div class="recap-stats">
          <h3>ğŸ“Š Adventure Summary</h3>
          <div id="recapStats" class="recap-stat-grid"></div>
        </div>

        <div class="recap-cards">
          <h3>ğŸƒ Card Collection</h3>
          <div id="recapCards" class="recap-card-summary"></div>
        </div>
      </div>

      <button id="btnReturnMenu" class="btn btn-primary">Return to Menu</button>
    </div>
  </div>

  <script>
// ============================================================
// Game Data Loader â€” Browser version, fetches JSON from /data/
// ============================================================

const ATTRIBUTES = ['STR', 'END', 'DEX', 'PER', 'LRN', 'WIL', 'MAG', 'CHA'];

let RACES = {};
let CLASSES = {};
let SKILL_DEFS = {};
let ITEM_TEMPLATES = {};
let MONSTER_TEMPLATES = {};
let MONSTER_TIERS = [];
let WORLD_LOCATIONS = {};
let BIOMES = {};
let TILE_TYPES = {};
let SPELL_DEFS = {};
let CROP_DEFS = {};
let SHOP_DEFS = {};
let RECIPE_DEFS = {};
let QUEST_DEFS = {};
let WEATHER_TYPES = {};
let WEATHER_EFFECTS = {};
let GOD_DEFS = {};


// [BUNDLED] All game data is embedded â€” no fetch() needed
async function loadAllGameData() {
  RACES = {"yerles":{"id":"yerles","name":"Yerles","description":"A technologically advanced human race. Fast learners with talent in negotiation and marksmanship.","attributes":{"STR":7,"END":8,"DEX":8,"PER":8,"LRN":12,"WIL":7,"MAG":7,"CHA":8},"baseLife":110,"baseMana":90,"baseSpeed":100,"bonusSkills":["marksman","investing","negotiation","gun"],"feat":"Fast Learner","featDesc":"Reduces Feat EXP needed to level up by 20%.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"eulderna":{"id":"eulderna","name":"Eulderna","description":"An elegant race with deep magic affinity. Bonded with mana and precise in spellcasting.","attributes":{"STR":7,"END":7,"DEX":7,"PER":8,"LRN":7,"WIL":10,"MAG":12,"CHA":9},"baseLife":90,"baseMana":110,"baseSpeed":100,"bonusSkills":["literacy","casting","magicDevice"],"feat":"Bonded with Mana","featDesc":"Reduces mana overflow damage by 66%.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"fairy":{"id":"fairy","name":"Fairy","description":"A tiny magical being. Cannot wear heavy equipment but has incredible evasion and magic resistance.","attributes":{"STR":3,"END":4,"DEX":9,"PER":10,"LRN":8,"WIL":7,"MAG":13,"CHA":12},"baseLife":35,"baseMana":130,"baseSpeed":180,"bonusSkills":["pickpocket","stealth","casting"],"feat":"Tiny Body","featDesc":"Levitation. Cannot equip heavy items. DV +50.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"hillfolk":{"id":"hillfolk","name":"Hillfolk","description":"Sturdy dwarven race. Expert miners with powerful melee capabilities but low magic.","attributes":{"STR":12,"END":11,"DEX":8,"PER":6,"LRN":6,"WIL":8,"MAG":6,"CHA":6},"baseLife":120,"baseMana":80,"baseSpeed":100,"bonusSkills":["mining","weightlifting","heavyArmor"],"feat":"Mead Blood","featDesc":"Bonuses when drunk. Underground dweller.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"juere":{"id":"juere","name":"Juere","description":"Nomadic wanderers. Skilled in stealth and travel, efficient with food.","attributes":{"STR":7,"END":7,"DEX":12,"PER":11,"LRN":9,"WIL":6,"MAG":7,"CHA":10},"baseLife":100,"baseMana":100,"baseSpeed":105,"bonusSkills":["stealth","spotHidden","travel"],"feat":"Efficient Feeder","featDesc":"Increases food effects by 25%.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"elea":{"id":"elea","name":"Elea","description":"Ancient forest elves with unparalleled magical capacity and willpower.","attributes":{"STR":5,"END":6,"DEX":10,"PER":10,"LRN":7,"WIL":12,"MAG":13,"CHA":13},"baseLife":80,"baseMana":130,"baseSpeed":110,"bonusSkills":["meditation","magicCapacity","casting"],"feat":"Bonded with Mana","featDesc":"Reduces mana overflow damage by 66%. Ether resist +20.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"lich":{"id":"lich","name":"Lich","description":"Undead sorcerer. Immune to fear, resistant to poison and nerve. Weak to fire and holy.","attributes":{"STR":5,"END":6,"DEX":6,"PER":7,"LRN":8,"WIL":13,"MAG":15,"CHA":5},"baseLife":60,"baseMana":150,"baseSpeed":100,"bonusSkills":["meditation","casting","magicDevice"],"feat":"Undead","featDesc":"Immune to fear. Poison/Nerve resist +5. Dark/Nether resist +10. Fire/Holy weakness.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}},"golem":{"id":"golem","name":"Golem","description":"Construct of stone and magic. Incredible endurance but slow. Immune to dim and bleeding.","attributes":{"STR":10,"END":14,"DEX":4,"PER":5,"LRN":4,"WIL":10,"MAG":6,"CHA":5},"baseLife":150,"baseMana":70,"baseSpeed":70,"bonusSkills":["twoHanded","weightlifting","magicCapacity"],"feat":"Arcane Core","featDesc":"Immune to Dim, Bleeding. Poison/Cut resist +20. Lightning weakness.","bodyParts":{"head":1,"neck":1,"back":1,"body":1,"hand":2,"ring":2,"arm":1,"waist":1,"foot":1}}};
  CLASSES = {"warrior":{"id":"warrior","name":"Warrior","description":"A master of melee combat. High strength and endurance with weapon mastery.","attributes":{"STR":10,"END":10,"DEX":2,"PER":0,"LRN":0,"WIL":3,"MAG":0,"CHA":0},"bonusSkills":["twoHanded","regeneration","shield","heavyArmor","tactics","longSword","axe","mace"],"domains":["fire","cold","cut"],"feat":"Weapon Mastery 2","featDesc":"Melee weapons gain +0.10 damage multiplier."},"thief":{"id":"thief","name":"Thief","description":"Nimble and cunning. Excels at lockpicking, pickpocketing, and dual wielding.","attributes":{"STR":4,"END":4,"DEX":8,"PER":5,"LRN":4,"WIL":0,"MAG":0,"CHA":0},"bonusSkills":["lockpicking","pickpocket","disarmTrap","dualWield","evasion","negotiation","shortSword"],"domains":["poison","darkness","chaos"],"feat":"Thief's Luck 2","featDesc":"+30 Luck."},"wizard":{"id":"wizard","name":"Wizard","description":"Supreme magical power. Mastery over spells, rods, and arcane devices.","attributes":{"STR":0,"END":0,"DEX":0,"PER":4,"LRN":3,"WIL":8,"MAG":10,"CHA":0},"bonusSkills":["literacy","memorization","casting","magicDevice","controlMagic","staff"],"domains":["fire","cold","lightning","magic"],"feat":"Magic Mastery 2","featDesc":"+2 Specialized Domain."},"farmer":{"id":"farmer","name":"Farmer","description":"Connected to the land. Strong farming, cooking, and regeneration abilities.","attributes":{"STR":5,"END":5,"DEX":2,"PER":0,"LRN":8,"WIL":5,"MAG":0,"CHA":0},"bonusSkills":["regeneration","farming","cooking","faith","riding","scythe","staff"],"domains":["fire","cold","lightning"],"feat":"Farming Legs 2","featDesc":"Reduced stamina usage. Show all food traits."},"archer":{"id":"archer","name":"Archer","description":"Deadly at range. Master of bows and crossbows with keen perception.","attributes":{"STR":6,"END":4,"DEX":8,"PER":5,"LRN":2,"WIL":0,"MAG":0,"CHA":0},"bonusSkills":["lightArmor","evasion","marksman","anatomy","riding","bow","crossbow"],"domains":["lightning","poison","cut"],"feat":"Ranged Mastery 2","featDesc":"Ranged weapons gain +0.10 damage multiplier."},"priest":{"id":"priest","name":"Priest","description":"Devoted to the gods. Powerful healing and protective magic with decent melee.","attributes":{"STR":2,"END":2,"DEX":0,"PER":2,"LRN":2,"WIL":10,"MAG":7,"CHA":2},"bonusSkills":["shield","heavyArmor","literacy","faith","casting","mace","staff"],"domains":["fire","lightning","holy","magic"],"feat":"Devout 1","featDesc":"+15% benefit from God blessing."},"pianist":{"id":"pianist","name":"Pianist","description":"An entertainer and performer. Music, negotiation, and throwing skills.","attributes":{"STR":4,"END":0,"DEX":2,"PER":5,"LRN":6,"WIL":0,"MAG":2,"CHA":8},"bonusSkills":["weightlifting","throwing","literacy","music","negotiation"],"domains":["sound","mind","nerve"],"feat":"Musician 2","featDesc":"Enhanced performance quality. Bonus to rewards."},"tourist":{"id":"tourist","name":"Tourist","description":"An inexperienced traveler. No bonuses but great store prices. Hard mode!","attributes":{"STR":0,"END":0,"DEX":0,"PER":0,"LRN":0,"WIL":0,"MAG":0,"CHA":0},"bonusSkills":["swimming","fishing","travel"],"domains":["fire","sound","chaos"],"feat":"Vacation Vibe 5","featDesc":"Store price +100%. Store inventory +25%."}};
  SKILL_DEFS = {"mining":{"id":"mining","name":"Mining","attr":"STR","category":"general","description":"Ability to extract ores and minerals from rock. Higher levels yield rarer materials and faster extraction."},"weightlifting":{"id":"weightlifting","name":"Weightlifting","attr":"STR","category":"general","description":"Increases your carrying capacity. Each level lets you haul more loot before becoming burdened."},"lumberjacking":{"id":"lumberjacking","name":"Lumberjacking","attr":"END","category":"general","description":"Skill at felling trees and processing wood. Higher levels produce better quality timber."},"regeneration":{"id":"regeneration","name":"Regeneration","attr":"END","category":"general","description":"Passively restores HP over time. Higher levels accelerate natural healing between battles."},"farming":{"id":"farming","name":"Farming","attr":"END","category":"general","description":"Knowledge of planting, tending, and harvesting crops. Better farming leads to higher yields and rarer produce."},"swimming":{"id":"swimming","name":"Swimming","attr":"END","category":"general","description":"Allows traversal of water tiles and reduces stamina drain while swimming. Prevents drowning at higher levels."},"lockpicking":{"id":"lockpicking","name":"Lockpicking","attr":"DEX","category":"general","description":"The art of opening locked doors and chests without a key. Higher levels tackle more complex mechanisms."},"pickpocket":{"id":"pickpocket","name":"Pickpocket","attr":"DEX","category":"general","description":"Steal items from NPCs without being noticed. Higher skill reduces the chance of getting caught."},"disarmTrap":{"id":"disarmTrap","name":"Disarm Trap","attr":"DEX","category":"general","description":"Safely neutralise traps found in dungeons and the wilderness. Failure may trigger the trap."},"stealth":{"id":"stealth","name":"Stealth","attr":"PER","category":"general","description":"Move unseen by enemies. Higher stealth allows you to avoid fights and get surprise attacks."},"spotHidden":{"id":"spotHidden","name":"Spot Hidden","attr":"PER","category":"general","description":"Detect hidden traps, secret doors, and concealed enemies. Improves your awareness of the surroundings."},"literacy":{"id":"literacy","name":"Literacy","attr":"LRN","category":"general","description":"Ability to read scrolls, ancient texts, and spell books. Required to learn new spells from written sources."},"gathering":{"id":"gathering","name":"Gathering","attr":"LRN","category":"general","description":"Collect herbs, mushrooms, and other natural resources. Higher levels reveal rarer ingredients."},"anatomy":{"id":"anatomy","name":"Anatomy","attr":"LRN","category":"general","description":"Knowledge of weak points in creatures. Increases your critical hit chance in melee combat."},"memorization":{"id":"memorization","name":"Memorization","attr":"LRN","category":"general","description":"Improves spell retention and reduces the chance of forgetting spells after casting them."},"meditation":{"id":"meditation","name":"Meditation","attr":"WIL","category":"general","description":"Accelerates natural MP recovery. Higher levels restore mana faster while resting or waiting."},"faith":{"id":"faith","name":"Faith","attr":"WIL","category":"general","description":"Strengthens your connection with your deity. Higher faith increases the power of prayers and divine blessings."},"fishing":{"id":"fishing","name":"Fishing","attr":"WIL","category":"general","description":"Catch fish from bodies of water. Higher levels let you reel in rarer and more nutritious fish."},"riding":{"id":"riding","name":"Riding","attr":"WIL","category":"general","description":"Ability to ride tamed creatures. Higher skill improves mounted movement speed and combat effectiveness."},"travel":{"id":"travel","name":"Travel","attr":"WIL","category":"general","description":"Reduces travel time on the world map and lowers the chance of random encounters while journeying."},"casting":{"id":"casting","name":"Casting","attr":"MAG","category":"general","description":"General spellcasting proficiency. Improves spell accuracy and reduces the chance of spell failure."},"controlMagic":{"id":"controlMagic","name":"Control Magic","attr":"MAG","category":"general","description":"Prevents your area spells from harming allies. Higher skill gives finer control over magical effects."},"magicDevice":{"id":"magicDevice","name":"Magic Device","attr":"MAG","category":"general","description":"Proficiency with wands, rods, and other magical devices. Improves their effectiveness when used."},"magicCapacity":{"id":"magicCapacity","name":"Magic Capacity","attr":"MAG","category":"general","description":"Increases your maximum mana pool. Each level grants additional MP for casting more spells."},"investing":{"id":"investing","name":"Investing","attr":"CHA","category":"general","description":"Invest gold into shops to improve their stock quality and variety. Better returns at higher levels."},"music":{"id":"music","name":"Music","attr":"CHA","category":"general","description":"Perform music to earn gold from NPCs and buff nearby allies. Higher skill produces more powerful melodies."},"negotiation":{"id":"negotiation","name":"Negotiation","attr":"CHA","category":"general","description":"Get better prices when buying and selling at shops. Higher levels dramatically improve trade margins."},"taming":{"id":"taming","name":"Taming","attr":"END","category":"general","description":"Attempt to tame wild creatures as pets. Higher skill allows taming stronger and rarer monsters."},"carpentry":{"id":"carpentry","name":"Carpentry","attr":"STR","category":"crafting","description":"Craft wooden furniture, tools, and structures. Higher levels unlock more complex woodworking recipes."},"blacksmith":{"id":"blacksmith","name":"Blacksmith","attr":"STR","category":"crafting","description":"Forge metal weapons and armor at an anvil. Higher skill produces gear with better base stats."},"alchemy":{"id":"alchemy","name":"Alchemy","attr":"LRN","category":"crafting","description":"Brew potions and elixirs from gathered ingredients. Higher levels create more potent concoctions."},"cooking":{"id":"cooking","name":"Cooking","attr":"LRN","category":"crafting","description":"Prepare food that restores nutrition and grants temporary buffs. Better cooking produces superior meals."},"jewelry":{"id":"jewelry","name":"Jewelry","attr":"DEX","category":"crafting","description":"Craft rings, amulets, and other accessories. Higher levels allow creation of enchanted jewellery."},"weaving":{"id":"weaving","name":"Weaving","attr":"DEX","category":"crafting","description":"Create cloth armor, cloaks, and fabric items. Higher skill produces garments with better enchantments."},"crafting":{"id":"crafting","name":"Crafting","attr":"DEX","category":"crafting","description":"General crafting proficiency. Affects the quality of all crafted items and unlocks advanced recipes."},"sculpting":{"id":"sculpting","name":"Sculpting","attr":"END","category":"crafting","description":"Shape stone and clay into useful objects and decorations. Higher levels produce masterwork sculptures."},"twoHanded":{"id":"twoHanded","name":"Two Handed","attr":"STR","category":"combat","description":"Proficiency with two-handed weapons. Increases damage and accuracy when wielding greatswords, battleaxes, and similar arms."},"heavyArmor":{"id":"heavyArmor","name":"Heavy Armor","attr":"END","category":"combat","description":"Reduces the speed penalty from heavy armor and improves its damage reduction effectiveness."},"shield":{"id":"shield","name":"Shield","attr":"END","category":"combat","description":"Improves blocking with shields. Higher skill increases the chance to negate incoming attacks entirely."},"throwing":{"id":"throwing","name":"Throwing","attr":"DEX","category":"combat","description":"Accuracy and damage with thrown weapons like javelins and throwing knives. Higher skill increases range."},"dualWield":{"id":"dualWield","name":"Dual Wield","attr":"DEX","category":"combat","description":"Fight with a weapon in each hand. Higher skill reduces the accuracy penalty for the off-hand weapon."},"lightArmor":{"id":"lightArmor","name":"Light Armor","attr":"DEX","category":"combat","description":"Maximises the protection of light armor while maintaining agility. Improves evasion while armored."},"tactics":{"id":"tactics","name":"Tactics","attr":"PER","category":"combat","description":"Tactical awareness in combat. Increases melee damage and the chance of landing critical strikes."},"evasion":{"id":"evasion","name":"Evasion","attr":"PER","category":"combat","description":"Ability to dodge incoming attacks. Higher evasion makes you harder to hit in close combat."},"marksman":{"id":"marksman","name":"Marksman","attr":"PER","category":"combat","description":"Skill with ranged weapons. Increases accuracy and damage with bows, crossbows, and firearms."},"eyeOfMind":{"id":"eyeOfMind","name":"Eye of Mind","attr":"PER","category":"combat","description":"Sharpens your senses in battle, boosting critical hit rate and ability to see through enemy defences."},"greaterEvasion":{"id":"greaterEvasion","name":"Greater Evasion","attr":"PER","category":"combat","description":"An advanced evasion technique. Grants a chance to completely avoid even magical and area attacks."},"strategy":{"id":"strategy","name":"Strategy","attr":"LRN","category":"combat","description":"Knowledge of battlefield strategy. Boosts the effectiveness of your pets and allies in combat."},"symbiosis":{"id":"symbiosis","name":"Symbiosis","attr":"CHA","category":"combat","description":"Strengthens the bond with your pets. They gain bonus stats and share experience more efficiently."},"martialArt":{"id":"martialArt","name":"Martial Art","attr":"STR","category":"weapon","description":"Unarmed combat skill. Increases damage when fighting bare-handed and unlocks powerful melee techniques."},"longSword":{"id":"longSword","name":"Long Sword","attr":"STR","category":"weapon","description":"Proficiency with long swords. Improves damage, accuracy, and critical chance with this weapon type."},"axe":{"id":"axe","name":"Axe","attr":"STR","category":"weapon","description":"Proficiency with axes. Axes deal heavy damage and have a chance to cleave through enemy armor."},"scythe":{"id":"scythe","name":"Scythe","attr":"STR","category":"weapon","description":"Proficiency with scythes. Long reach weapons that can hit enemies before they close to melee range."},"staff":{"id":"staff","name":"Staff","attr":"END","category":"weapon","description":"Proficiency with staves. Staves boost magic power and can be used for both melee and spellcasting."},"polearm":{"id":"polearm","name":"Polearm","attr":"END","category":"weapon","description":"Proficiency with spears and halberds. Polearms offer excellent reach and defensive capabilities."},"mace":{"id":"mace","name":"Mace","attr":"END","category":"weapon","description":"Proficiency with maces and hammers. Blunt weapons are effective against armored foes."},"bow":{"id":"bow","name":"Bow","attr":"DEX","category":"weapon","description":"Proficiency with bows. Allows rapid firing at range with increasing accuracy and damage per level."},"shortSword":{"id":"shortSword","name":"Short Sword","attr":"DEX","category":"weapon","description":"Proficiency with short swords and daggers. Fast weapons that excel at landing multiple hits."},"gun":{"id":"gun","name":"Gun","attr":"PER","category":"weapon","description":"Proficiency with firearms. Guns deal high damage per shot but require ammunition to fire."},"crossbow":{"id":"crossbow","name":"Crossbow","attr":"PER","category":"weapon","description":"Proficiency with crossbows. Slower than bows but deal more damage per bolt with better armor penetration."}};
  ITEM_TEMPLATES = {"brokenSword":{"id":"brokenSword","name":"Broken Sword","type":"weapon","subtype":"longSword","dice":"1d5","weight":3,"value":10,"damageType":"cut","char":"â€ ","color":"#999"},"longSword":{"id":"longSword","name":"Long Sword","type":"weapon","subtype":"longSword","dice":"2d6","weight":5,"value":80,"damageType":"cut","char":"â€ ","color":"#c0c0d0"},"battleAxe":{"id":"battleAxe","name":"Battle Axe","type":"weapon","subtype":"axe","dice":"2d8","weight":8,"value":120,"damageType":"cut","char":"âŒ ","color":"#a0a0b0"},"shortBow":{"id":"shortBow","name":"Short Bow","type":"weapon","subtype":"bow","dice":"1d8","weight":3,"value":60,"damageType":"pierce","ranged":true,"char":")","color":"#8a6a3a"},"oakStaff":{"id":"oakStaff","name":"Oak Staff","type":"weapon","subtype":"staff","dice":"1d6","weight":4,"value":40,"damageType":"impact","char":"/","color":"#7a5a2a"},"dagger":{"id":"dagger","name":"Dagger","type":"weapon","subtype":"shortSword","dice":"1d4","weight":1,"value":30,"damageType":"cut","char":"â€ ","color":"#b0b0c0"},"woodenMace":{"id":"woodenMace","name":"Wooden Mace","type":"weapon","subtype":"mace","dice":"2d5","weight":6,"value":50,"damageType":"impact","char":"â™£","color":"#888"},"raggedCloth":{"id":"raggedCloth","name":"Ragged Cloth","type":"armor","slot":"body","PV":1,"DV":1,"weight":2,"value":5,"char":"â™¦","color":"#8a6a40"},"leatherArmor":{"id":"leatherArmor","name":"Leather Armor","type":"armor","slot":"body","PV":5,"DV":0,"weight":8,"value":80,"char":"â™¦","color":"#a07040"},"chainMail":{"id":"chainMail","name":"Chain Mail","type":"armor","slot":"body","PV":10,"DV":-2,"weight":15,"value":200,"char":"â™¦","color":"#888"},"leatherBoots":{"id":"leatherBoots","name":"Leather Boots","type":"armor","slot":"foot","PV":2,"DV":0,"weight":3,"value":30,"char":"â™¦","color":"#7a5a30"},"ironHelm":{"id":"ironHelm","name":"Iron Helm","type":"armor","slot":"head","PV":4,"DV":-1,"weight":5,"value":60,"char":"â™¦","color":"#888"},"woodenShield":{"id":"woodenShield","name":"Wooden Shield","type":"armor","slot":"hand","PV":3,"DV":2,"weight":5,"value":40,"char":"â™¦","color":"#8a7030"},"ration":{"id":"ration","name":"Ration","type":"food","nutrition":2000,"weight":1,"value":20,"char":"â™ ","color":"#c8a060"},"bread":{"id":"bread","name":"Bread","type":"food","nutrition":1500,"weight":1,"value":10,"char":"â™ ","color":"#daa520"},"herbGreen":{"id":"herbGreen","name":"Green Herb","type":"food","nutrition":500,"weight":0.5,"value":15,"healHP":20,"char":"â™ ","color":"#3aaa3a"},"potionHeal":{"id":"potionHeal","name":"Potion of Healing","type":"potion","weight":1,"value":50,"healHP":50,"char":"!","color":"#d04040"},"potionMana":{"id":"potionMana","name":"Potion of Mana","type":"potion","weight":1,"value":50,"healMP":40,"char":"!","color":"#4060d0"},"oreIron":{"id":"oreIron","name":"Iron Ore","type":"resource","char":"â—","color":"#888","weight":3,"value":15},"oreCopper":{"id":"oreCopper","name":"Copper Ore","type":"resource","char":"â—","color":"#b87333","weight":3,"value":8},"oreSilver":{"id":"oreSilver","name":"Silver Ore","type":"resource","char":"â—","color":"#c0c0d0","weight":3,"value":40},"oreGold":{"id":"oreGold","name":"Gold Ore","type":"resource","char":"â—","color":"#ffd700","weight":4,"value":80},"oreMythril":{"id":"oreMythril","name":"Mythril Ore","type":"resource","char":"â—","color":"#66ccff","weight":2,"value":200},"woodLog":{"id":"woodLog","name":"Wood Log","type":"resource","char":"=","color":"#a73","weight":4,"value":8},"oakLog":{"id":"oakLog","name":"Oak Log","type":"resource","char":"=","color":"#8a6a30","weight":5,"value":12},"pineLog":{"id":"pineLog","name":"Pine Log","type":"resource","char":"=","color":"#c8a060","weight":3,"value":6},"birchLog":{"id":"birchLog","name":"Birch Log","type":"resource","char":"=","color":"#d8c8a0","weight":3,"value":10},"mapleLog":{"id":"mapleLog","name":"Maple Log","type":"resource","char":"=","color":"#c06020","weight":4,"value":18},"yewLog":{"id":"yewLog","name":"Yew Log","type":"resource","char":"=","color":"#5a3a1a","weight":6,"value":35},"leather":{"id":"leather","name":"Leather","type":"resource","char":"â–¡","color":"#a86","weight":2,"value":12},"string":{"id":"string","name":"String","type":"resource","char":"~","color":"#ccc","weight":0.5,"value":5},"emptyBottle":{"id":"emptyBottle","name":"Empty Bottle","type":"resource","char":"â—‹","color":"#aef","weight":0.5,"value":3},"crystalBlue":{"id":"crystalBlue","name":"Blue Crystal","type":"resource","char":"â—†","color":"#48f","weight":1,"value":30},"berryRed":{"id":"berryRed","name":"Red Berries","type":"food","nutrition":600,"char":"â—","color":"#cc3344","weight":0.3,"value":8},"berryBlue":{"id":"berryBlue","name":"Blue Berries","type":"food","nutrition":600,"char":"â—","color":"#4466cc","weight":0.3,"value":10},"berryPoison":{"id":"berryPoison","name":"Poison Berries","type":"food","nutrition":300,"char":"â—","color":"#884488","weight":0.3,"value":15,"healHP":-20},"mushroom":{"id":"mushroom","name":"Mushroom","type":"food","nutrition":800,"char":"â™ ","color":"#aa7744","weight":0.3,"value":10},"mushroomGlow":{"id":"mushroomGlow","name":"Glowing Mushroom","type":"resource","char":"â™ ","color":"#44ddaa","weight":0.3,"value":30},"mushroomPoison":{"id":"mushroomPoison","name":"Poison Mushroom","type":"food","nutrition":400,"char":"â™ ","color":"#cc4444","weight":0.3,"value":12,"healHP":-30},"clay":{"id":"clay","name":"Clay","type":"resource","char":"â—Š","color":"#b07050","weight":3,"value":5},"sand":{"id":"sand","name":"Sand","type":"resource","char":"â—Š","color":"#d8c878","weight":3,"value":3},"flint":{"id":"flint","name":"Flint","type":"resource","char":"â—","color":"#555544","weight":1,"value":8},"reeds":{"id":"reeds","name":"Reeds","type":"resource","char":"â€–","color":"#8aaa5a","weight":1,"value":4},"sap":{"id":"sap","name":"Tree Sap","type":"resource","char":"â—‹","color":"#d8a030","weight":0.5,"value":12},"bark":{"id":"bark","name":"Bark","type":"resource","char":"â–¡","color":"#6a4a2a","weight":1,"value":5},"amber":{"id":"amber","name":"Amber","type":"resource","char":"â—†","color":"#cc8800","weight":0.5,"value":50},"rawFish":{"id":"rawFish","name":"Raw Fish","type":"food","nutrition":1200,"char":"â‰ˆ","color":"#6a8aaa","weight":1,"value":12},"rareFish":{"id":"rareFish","name":"Rare Fish","type":"food","nutrition":2500,"char":"â‰ˆ","color":"#44aadd","weight":2,"value":50},"pearl":{"id":"pearl","name":"Pearl","type":"resource","char":"â—‹","color":"#eeddff","weight":0.5,"value":100},"driftwood":{"id":"driftwood","name":"Driftwood","type":"resource","char":"=","color":"#9a8a6a","weight":2,"value":3},"hatchet":{"id":"hatchet","name":"Hatchet","type":"tool","subtype":"axeTool","toolPower":1,"dice":"1d3","weight":2,"value":25,"damageType":"cut","char":"âŒ ","color":"#8a6a3a","description":"A basic woodcutting hatchet. Improves wood gathering speed."},"ironAxeTool":{"id":"ironAxeTool","name":"Iron Woodcutter's Axe","type":"tool","subtype":"axeTool","toolPower":2,"dice":"1d4","weight":4,"value":80,"damageType":"cut","char":"âŒ ","color":"#888","description":"A sturdy iron axe for felling trees. Good gathering speed."},"steelAxeTool":{"id":"steelAxeTool","name":"Steel Woodcutter's Axe","type":"tool","subtype":"axeTool","toolPower":3,"dice":"1d5","weight":4,"value":200,"damageType":"cut","char":"âŒ ","color":"#b0b0c0","description":"A fine steel axe. Excellent for all tree types."},"mythrilAxeTool":{"id":"mythrilAxeTool","name":"Mythril Woodcutter's Axe","type":"tool","subtype":"axeTool","toolPower":5,"dice":"1d6","weight":2,"value":600,"damageType":"cut","char":"âŒ ","color":"#66ccff","description":"A mythril axe that cuts through any wood effortlessly."},"stonePickaxe":{"id":"stonePickaxe","name":"Stone Pickaxe","type":"tool","subtype":"pickaxe","toolPower":1,"dice":"1d3","weight":3,"value":20,"damageType":"impact","char":"âŒ ","color":"#777","description":"A crude stone pickaxe. Suitable for copper and iron."},"ironPickaxe":{"id":"ironPickaxe","name":"Iron Pickaxe","type":"tool","subtype":"pickaxe","toolPower":2,"dice":"1d4","weight":5,"value":80,"damageType":"impact","char":"âŒ ","color":"#888","description":"A reliable iron pickaxe. Can mine most ores."},"steelPickaxe":{"id":"steelPickaxe","name":"Steel Pickaxe","type":"tool","subtype":"pickaxe","toolPower":3,"dice":"1d5","weight":5,"value":200,"damageType":"impact","char":"âŒ ","color":"#b0b0c0","description":"A sharp steel pickaxe. Effective on precious ores."},"mythrilPickaxe":{"id":"mythrilPickaxe","name":"Mythril Pickaxe","type":"tool","subtype":"pickaxe","toolPower":5,"dice":"1d6","weight":3,"value":600,"damageType":"impact","char":"âŒ ","color":"#66ccff","description":"A mythril pickaxe that shatters any stone with ease."},"goldCoin":{"id":"goldCoin","name":"Gold Coin","type":"currency","weight":0,"value":1,"stackable":true,"char":"$","color":"#ffd700"},"grandFeast":{"id":"grandFeast","name":"Grand Feast","type":"food","nutrition":5000,"weight":3,"value":120,"char":"â™ ","color":"#fa4","healHP":40},"seedTurnip":{"id":"seedTurnip","name":"Turnip Seeds","type":"seed","cropId":"turnip","char":"Â°","color":"#6a4","weight":0.1,"value":15},"seedPotato":{"id":"seedPotato","name":"Potato Seeds","type":"seed","cropId":"potato","char":"Â°","color":"#6a4","weight":0.1,"value":20},"seedStrawberry":{"id":"seedStrawberry","name":"Strawberry Seeds","type":"seed","cropId":"strawberry","char":"Â°","color":"#d44","weight":0.1,"value":30},"seedCorn":{"id":"seedCorn","name":"Corn Seeds","type":"seed","cropId":"corn","char":"Â°","color":"#cc4","weight":0.1,"value":25},"seedTomato":{"id":"seedTomato","name":"Tomato Seeds","type":"seed","cropId":"tomato","char":"Â°","color":"#e32","weight":0.1,"value":20},"seedCarrot":{"id":"seedCarrot","name":"Carrot Seeds","type":"seed","cropId":"carrot","char":"Â°","color":"#e82","weight":0.1,"value":15},"seedHerb":{"id":"seedHerb","name":"Herb Seeds","type":"seed","cropId":"herb","char":"Â°","color":"#0c0","weight":0.1,"value":25},"seedPumpkin":{"id":"seedPumpkin","name":"Pumpkin Seeds","type":"seed","cropId":"pumpkin","char":"Â°","color":"#e80","weight":0.1,"value":35},"seedWheat":{"id":"seedWheat","name":"Wheat Seeds","type":"seed","cropId":"wheat","char":"Â°","color":"#da4","weight":0.1,"value":18},"cropTurnip":{"id":"cropTurnip","name":"Turnip","type":"food","nutrition":1500,"weight":1,"value":30,"char":"â™£","color":"#2d2"},"cropPotato":{"id":"cropPotato","name":"Potato","type":"food","nutrition":2000,"weight":1,"value":40,"char":"â—","color":"#ca8"},"cropStrawberry":{"id":"cropStrawberry","name":"Strawberry","type":"food","nutrition":800,"weight":0.5,"value":50,"char":"â—","color":"#d44"},"cropCorn":{"id":"cropCorn","name":"Ear of Corn","type":"food","nutrition":1800,"weight":1,"value":45,"char":"Î¨","color":"#cc4"},"cropTomato":{"id":"cropTomato","name":"Tomato","type":"food","nutrition":1200,"weight":0.5,"value":35,"char":"â—","color":"#e32"},"cropCarrot":{"id":"cropCarrot","name":"Carrot","type":"food","nutrition":1200,"weight":0.5,"value":25,"char":"â†‘","color":"#e82"},"cropHerb":{"id":"cropHerb","name":"Medicinal Herb","type":"food","nutrition":500,"weight":0.5,"value":40,"char":"â™ ","color":"#0c0","healHP":30},"cropPumpkin":{"id":"cropPumpkin","name":"Pumpkin","type":"food","nutrition":3000,"weight":3,"value":80,"char":"â—‰","color":"#e80"},"cropWheat":{"id":"cropWheat","name":"Wheat","type":"food","nutrition":1000,"weight":1,"value":20,"char":"Î¨","color":"#da4"},"spellbookMagicArrow":{"id":"spellbookMagicArrow","name":"Spellbook of Magic Arrow","type":"spellbook","spellId":"magicArrow","char":"+","color":"#c8f","weight":2,"value":120,"charges":4,"difficulty":1},"spellbookIceBolt":{"id":"spellbookIceBolt","name":"Spellbook of Ice Bolt","type":"spellbook","spellId":"iceBolt","char":"+","color":"#6cf","weight":2,"value":200,"charges":4,"difficulty":3},"spellbookFireBolt":{"id":"spellbookFireBolt","name":"Spellbook of Fire Bolt","type":"spellbook","spellId":"fireBolt","char":"+","color":"#f64","weight":2,"value":240,"charges":4,"difficulty":4},"spellbookLightningBolt":{"id":"spellbookLightningBolt","name":"Spellbook of Lightning Bolt","type":"spellbook","spellId":"lightningBolt","char":"+","color":"#ff4","weight":2,"value":400,"charges":3,"difficulty":8},"spellbookDarkBolt":{"id":"spellbookDarkBolt","name":"Spellbook of Dark Bolt","type":"spellbook","spellId":"darkBolt","char":"+","color":"#a4f","weight":2,"value":350,"charges":3,"difficulty":7},"spellbookFireBall":{"id":"spellbookFireBall","name":"Spellbook of Fire Ball","type":"spellbook","spellId":"fireBall","char":"+","color":"#f84","weight":2,"value":500,"charges":2,"difficulty":10},"spellbookIceBall":{"id":"spellbookIceBall","name":"Spellbook of Ice Ball","type":"spellbook","spellId":"iceBall","char":"+","color":"#8ef","weight":2,"value":420,"charges":2,"difficulty":8},"spellbookChaosBall":{"id":"spellbookChaosBall","name":"Spellbook of Chaos Ball","type":"spellbook","spellId":"chaosBall","char":"+","color":"#f0f","weight":2,"value":800,"charges":2,"difficulty":15},"spellbookHeal":{"id":"spellbookHeal","name":"Spellbook of Heal","type":"spellbook","spellId":"heal","char":"+","color":"#4f4","weight":2,"value":150,"charges":5,"difficulty":1},"spellbookHealCritical":{"id":"spellbookHealCritical","name":"Spellbook of Heal Critical","type":"spellbook","spellId":"healCritical","char":"+","color":"#2f2","weight":2,"value":500,"charges":3,"difficulty":8},"spellbookHolyLight":{"id":"spellbookHolyLight","name":"Spellbook of Holy Light","type":"spellbook","spellId":"holyLight","char":"+","color":"#ffa","weight":2,"value":300,"charges":3,"difficulty":5},"spellbookHolyVeil":{"id":"spellbookHolyVeil","name":"Spellbook of Holy Veil","type":"spellbook","spellId":"holyVeil","char":"+","color":"#ffa","weight":2,"value":350,"charges":3,"difficulty":6},"spellbookMist":{"id":"spellbookMist","name":"Spellbook of Mist of Silence","type":"spellbook","spellId":"mist","char":"+","color":"#aaf","weight":2,"value":280,"charges":3,"difficulty":5},"spellbookSpeed":{"id":"spellbookSpeed","name":"Spellbook of Speed","type":"spellbook","spellId":"speed","char":"+","color":"#4ff","weight":2,"value":400,"charges":3,"difficulty":7},"spellbookTeleport":{"id":"spellbookTeleport","name":"Spellbook of Teleport","type":"spellbook","spellId":"teleport","char":"+","color":"#f8f","weight":2,"value":250,"charges":4,"difficulty":4},"spellbookShortTeleport":{"id":"spellbookShortTeleport","name":"Spellbook of Short Teleport","type":"spellbook","spellId":"shortTeleport","char":"+","color":"#88f","weight":2,"value":120,"charges":5,"difficulty":2},"spellbookMagicStorm":{"id":"spellbookMagicStorm","name":"Spellbook of Magic Storm","type":"spellbook","spellId":"magicStorm","char":"+","color":"#f4f","weight":2,"value":1200,"charges":1,"difficulty":18},"scrollEnchant":{"id":"scrollEnchant","name":"Scroll of Enchant Weapon","type":"scroll","enchantTier":1,"enchantType":"enhance","char":"?","color":"#ffa","weight":0.5,"value":200},"scrollEnchantArmor":{"id":"scrollEnchantArmor","name":"Scroll of Enchant Armor","type":"scroll","enchantTier":1,"enchantType":"enhance","char":"?","color":"#aaf","weight":0.5,"value":200},"scrollGreaterEnchant":{"id":"scrollGreaterEnchant","name":"Scroll of Greater Enchant","type":"scroll","enchantTier":2,"enchantType":"enhance","char":"?","color":"#ff4","weight":0.5,"value":500},"scrollSupremeEnchant":{"id":"scrollSupremeEnchant","name":"Scroll of Supreme Enchant","type":"scroll","enchantTier":3,"enchantType":"enhance","char":"?","color":"#f4f","weight":0.5,"value":1200},"scrollFireEnchant":{"id":"scrollFireEnchant","name":"Scroll of Fire Enchant","type":"scroll","enchantTier":1,"enchantType":"fire","char":"?","color":"#f64","weight":0.5,"value":350},"scrollIceEnchant":{"id":"scrollIceEnchant","name":"Scroll of Ice Enchant","type":"scroll","enchantTier":1,"enchantType":"ice","char":"?","color":"#6cf","weight":0.5,"value":350},"scrollLightningEnchant":{"id":"scrollLightningEnchant","name":"Scroll of Lightning Enchant","type":"scroll","enchantTier":1,"enchantType":"lightning","char":"?","color":"#ff4","weight":0.5,"value":350},"scrollHolyEnchant":{"id":"scrollHolyEnchant","name":"Scroll of Holy Enchant","type":"scroll","enchantTier":1,"enchantType":"holy","char":"?","color":"#ffa","weight":0.5,"value":400},"scrollSpeedEnchant":{"id":"scrollSpeedEnchant","name":"Scroll of Speed Enchant","type":"scroll","enchantTier":1,"enchantType":"speed","char":"?","color":"#4ff","weight":0.5,"value":400},"bedroll":{"id":"bedroll","name":"Bedroll","type":"furniture","subtype":"bed","comfort":20,"weight":3,"value":30,"char":"â‰¡","color":"#8a6a40","description":"A thin bedroll. Better than sleeping on bare ground. 20% SP recovery."},"strawMat":{"id":"strawMat","name":"Straw Mat","type":"furniture","subtype":"bed","comfort":35,"weight":5,"value":60,"char":"â‰¡","color":"#c8a060","description":"A mat stuffed with straw. Somewhat comfortable. 35% SP recovery."},"woodenBed":{"id":"woodenBed","name":"Wooden Bed","type":"furniture","subtype":"bed","comfort":50,"weight":15,"value":150,"char":"â‰¡","color":"#a07040","description":"A simple wooden bed frame with a thin mattress. 50% SP recovery."},"comfortableBed":{"id":"comfortableBed","name":"Comfortable Bed","type":"furniture","subtype":"bed","comfort":75,"weight":20,"value":400,"char":"â‰¡","color":"#6a8aaa","description":"A well-crafted bed with a feather mattress. 75% SP recovery."},"royalBed":{"id":"royalBed","name":"Royal Bed","type":"furniture","subtype":"bed","comfort":100,"weight":30,"value":1200,"char":"â‰¡","color":"#c060c0","description":"A luxurious canopy bed fit for royalty. Full SP recovery."},"torch":{"id":"torch","name":"Torch","type":"light","lightRadius":3,"weight":1,"value":15,"char":"Â¡","color":"#f80","description":"A crude wooden torch that illuminates nearby tiles."},"lantern":{"id":"lantern","name":"Lantern","type":"light","lightRadius":5,"weight":2,"value":80,"char":"Â¡","color":"#ff4","description":"A sturdy lantern that casts a wide circle of light."},"magicLight":{"id":"magicLight","name":"Everlight Orb","type":"light","lightRadius":7,"weight":1,"value":400,"char":"Â¡","color":"#8ff","description":"A magical orb that glows with a brilliant, unfading light."},"workshopCrudeWorkbench":{"id":"workshopCrudeWorkbench","name":"Crude Workbench","type":"furniture","subtype":"workshop","workshopType":"crudeWorkbench","weight":10,"value":30,"char":"Ï€","color":"#8a6a3a","description":"A rough wooden workbench. Allows basic crafting, leatherwork, and building other workshops."},"workshopCampfire":{"id":"workshopCampfire","name":"Campfire","type":"furniture","subtype":"workshop","workshopType":"campfire","weight":5,"value":20,"char":"â™¨","color":"#f80","description":"A simple campfire for cooking basic meals like bread and rations."},"workshopCarpentryBench":{"id":"workshopCarpentryBench","name":"Carpentry Bench","type":"furniture","subtype":"workshop","workshopType":"carpentryBench","weight":15,"value":80,"char":"Ï€","color":"#a07040","description":"A proper woodworking bench with clamps and tools for crafting wooden items and furniture."},"workshopAnvil":{"id":"workshopAnvil","name":"Anvil","type":"furniture","subtype":"workshop","workshopType":"anvil","weight":25,"value":100,"char":"âˆ©","color":"#888","description":"A heavy iron anvil for forging metal weapons, armor, and tools."},"workshopCookingStation":{"id":"workshopCookingStation","name":"Cooking Station","type":"furniture","subtype":"workshop","workshopType":"cookingStation","weight":12,"value":60,"char":"â™¨","color":"#c44","description":"A proper cooking station with an oven for preparing advanced dishes."},"workshopAlchemyLab":{"id":"workshopAlchemyLab","name":"Alchemy Lab","type":"furniture","subtype":"workshop","workshopType":"alchemyLab","weight":10,"value":90,"char":"âš—","color":"#6cf","description":"A lab bench with distilling equipment for brewing potions and elixirs."},"workshopLoom":{"id":"workshopLoom","name":"Loom","type":"furniture","subtype":"workshop","workshopType":"loom","weight":12,"value":70,"char":"âŠ","color":"#ca8","description":"A weaving loom for creating cloth and fabric items."},"workshopForge":{"id":"workshopForge","name":"Forge","type":"furniture","subtype":"workshop","workshopType":"forge","weight":30,"value":250,"char":"âŠ•","color":"#f64","description":"A high-temperature forge for working mythril and rare metals."},"workshopJewelerTable":{"id":"workshopJewelerTable","name":"Jeweler's Table","type":"furniture","subtype":"workshop","workshopType":"jewelerTable","weight":8,"value":120,"char":"â—‡","color":"#c8f","description":"A fine workbench with precision tools for crafting jewelry."},"workshopSculptorStation":{"id":"workshopSculptorStation","name":"Sculptor's Station","type":"furniture","subtype":"workshop","workshopType":"sculptorStation","weight":15,"value":50,"char":"â—Š","color":"#b07050","description":"A workstation for shaping stone and clay."},"cloth":{"id":"cloth","name":"Cloth","type":"resource","char":"â–¡","color":"#d8d0c0","weight":1,"value":10},"plank":{"id":"plank","name":"Wooden Plank","type":"resource","char":"â”€","color":"#c8a060","weight":2,"value":6},"woodenStool":{"id":"woodenStool","name":"Wooden Stool","type":"furniture","subtype":"decoration","beauty":2,"weight":3,"value":20,"char":"â•¥","color":"#a07040","description":"A simple three-legged stool."},"woodenChair":{"id":"woodenChair","name":"Wooden Chair","type":"furniture","subtype":"decoration","beauty":4,"weight":5,"value":40,"char":"â•¥","color":"#8a6a3a","description":"A sturdy wooden chair with a straight back."},"oakChair":{"id":"oakChair","name":"Oak Chair","type":"furniture","subtype":"decoration","beauty":8,"weight":6,"value":80,"char":"â•¥","color":"#7a5a2a","description":"A finely carved oak chair. Quite comfortable."},"cushionedChair":{"id":"cushionedChair","name":"Cushioned Chair","type":"furniture","subtype":"decoration","beauty":14,"weight":7,"value":180,"char":"â•¥","color":"#6a8aaa","description":"A padded chair upholstered in soft cloth."},"ornateThrone":{"id":"ornateThrone","name":"Ornate Throne","type":"furniture","subtype":"decoration","beauty":30,"weight":25,"value":1500,"char":"â•¥","color":"#ffd700","description":"A magnificent gilded throne. Radiates authority."},"smallTable":{"id":"smallTable","name":"Small Table","type":"furniture","subtype":"decoration","beauty":2,"weight":5,"value":25,"char":"â•¤","color":"#a07040","description":"A small wooden side table."},"diningTable":{"id":"diningTable","name":"Dining Table","type":"furniture","subtype":"decoration","beauty":6,"weight":12,"value":80,"char":"â•¤","color":"#8a6a3a","description":"A sturdy table that seats four."},"oakDiningTable":{"id":"oakDiningTable","name":"Oak Dining Table","type":"furniture","subtype":"decoration","beauty":12,"weight":18,"value":200,"char":"â•¤","color":"#7a5a2a","description":"A grand oak dining table for six."},"writingDesk":{"id":"writingDesk","name":"Writing Desk","type":"furniture","subtype":"decoration","beauty":10,"weight":10,"value":150,"char":"â•¤","color":"#8a7040","description":"A compact desk with a sloped writing surface and ink well."},"grandDiningTable":{"id":"grandDiningTable","name":"Grand Dining Table","type":"furniture","subtype":"decoration","beauty":25,"weight":30,"value":800,"char":"â•¤","color":"#c06020","description":"A magnificent banquet table that seats twelve."},"woodenCrate":{"id":"woodenCrate","name":"Wooden Crate","type":"furniture","subtype":"decoration","beauty":1,"weight":4,"value":15,"char":"â–¡","color":"#a07040","description":"A simple wooden crate for storing goods."},"barrel":{"id":"barrel","name":"Barrel","type":"furniture","subtype":"decoration","beauty":1,"weight":6,"value":25,"char":"â—","color":"#8a6a3a","description":"A watertight wooden barrel. Good for storing liquids."},"woodenShelfUnit":{"id":"woodenShelfUnit","name":"Wooden Shelf","type":"furniture","subtype":"decoration","beauty":3,"weight":6,"value":35,"char":"â•¦","color":"#a07040","description":"A wall-mounted wooden shelf for displaying items."},"bookshelf":{"id":"bookshelf","name":"Bookshelf","type":"furniture","subtype":"decoration","beauty":8,"weight":12,"value":100,"char":"â•¦","color":"#7a5a2a","description":"A tall bookshelf lined with volumes. Inspires learning."},"woodenChest":{"id":"woodenChest","name":"Wooden Chest","type":"furniture","subtype":"decoration","beauty":4,"weight":8,"value":60,"char":"â–£","color":"#8a6a3a","description":"A lockable wooden chest for valuables."},"dresser":{"id":"dresser","name":"Dresser","type":"furniture","subtype":"decoration","beauty":6,"weight":12,"value":100,"char":"â–£","color":"#a07040","description":"A wooden dresser with several drawers."},"wardrobe":{"id":"wardrobe","name":"Wardrobe","type":"furniture","subtype":"decoration","beauty":10,"weight":20,"value":250,"char":"â–£","color":"#7a5a2a","description":"A large wardrobe of polished oak. Keeps clothes moth-free."},"displayCase":{"id":"displayCase","name":"Display Case","type":"furniture","subtype":"decoration","beauty":15,"weight":14,"value":350,"char":"â–£","color":"#aef","description":"A glass-fronted case for showcasing prized possessions."},"trophyCase":{"id":"trophyCase","name":"Trophy Case","type":"furniture","subtype":"decoration","beauty":20,"weight":16,"value":600,"char":"â–£","color":"#ffd700","description":"A prestigious case for displaying conquests and achievements."},"flowerPot":{"id":"flowerPot","name":"Flower Pot","type":"furniture","subtype":"decoration","beauty":5,"weight":3,"value":30,"char":"â™£","color":"#4a4","description":"A clay pot with a cheerful flowering plant."},"wovenRug":{"id":"wovenRug","name":"Woven Rug","type":"furniture","subtype":"decoration","beauty":6,"weight":4,"value":50,"char":"â–¨","color":"#c06040","description":"A colorful handwoven rug that warms any room."},"paintingFrame":{"id":"paintingFrame","name":"Painting","type":"furniture","subtype":"decoration","beauty":8,"weight":3,"value":80,"char":"â–§","color":"#ca8","description":"A framed landscape painting. Adds character to any wall."},"weaponRack":{"id":"weaponRack","name":"Weapon Rack","type":"furniture","subtype":"decoration","beauty":6,"weight":8,"value":90,"char":"â•¬","color":"#888","description":"A sturdy rack for displaying swords, axes, and bows."},"armorStand":{"id":"armorStand","name":"Armor Stand","type":"furniture","subtype":"decoration","beauty":6,"weight":6,"value":90,"char":"â•¬","color":"#a0a0b0","description":"A wooden mannequin for displaying a suit of armor."},"candelabra":{"id":"candelabra","name":"Candelabra","type":"furniture","subtype":"decoration","beauty":10,"weight":4,"value":120,"char":"Â¥","color":"#ffd700","lightRadius":4,"description":"An elegant multi-armed candle holder that casts warm light."},"wineRack":{"id":"wineRack","name":"Wine Rack","type":"furniture","subtype":"decoration","beauty":8,"weight":10,"value":120,"char":"â•¦","color":"#8a3030","description":"A wooden rack for aging wine bottles."},"grandfatherClock":{"id":"grandfatherClock","name":"Grandfather Clock","type":"furniture","subtype":"decoration","beauty":18,"weight":25,"value":500,"char":"âŒ‚","color":"#7a5a2a","description":"A tall pendulum clock that chimes on the hour."},"ornateMirror":{"id":"ornateMirror","name":"Ornate Mirror","type":"furniture","subtype":"decoration","beauty":15,"weight":8,"value":400,"char":"â—ˆ","color":"#c0c0d0","description":"A silver-framed mirror with exquisite filigree."},"crystalChandelier":{"id":"crystalChandelier","name":"Crystal Chandelier","type":"furniture","subtype":"decoration","beauty":30,"weight":12,"value":1200,"char":"â‹","color":"#aef","lightRadius":6,"description":"A dazzling chandelier of cut crystal that fills the room with rainbows."},"kitchenCounter":{"id":"kitchenCounter","name":"Kitchen Counter","type":"furniture","subtype":"decoration","beauty":4,"weight":14,"value":80,"char":"â•¤","color":"#b07050","description":"A stone-topped counter for food preparation."},"woodenBench":{"id":"woodenBench","name":"Wooden Bench","type":"furniture","subtype":"decoration","beauty":3,"weight":8,"value":35,"char":"â•","color":"#8a6a3a","description":"A long wooden bench. Seats three."},"signpost":{"id":"signpost","name":"Signpost","type":"furniture","subtype":"decoration","beauty":1,"weight":3,"value":10,"char":"âŒ","color":"#a07040","description":"A simple wooden signpost."},"woodenFence":{"id":"woodenFence","name":"Wooden Fence","type":"furniture","subtype":"decoration","beauty":1,"weight":3,"value":12,"char":"â•«","color":"#a07040","description":"A short wooden fence section."},"stonePillar":{"id":"stonePillar","name":"Stone Pillar","type":"furniture","subtype":"decoration","beauty":8,"weight":20,"value":100,"char":"â•‘","color":"#999","description":"A carved stone pillar. Stately and imposing."},"stoneStatue":{"id":"stoneStatue","name":"Stone Statue","type":"furniture","subtype":"decoration","beauty":12,"weight":25,"value":200,"char":"Î©","color":"#aaa","description":"A sculpted stone figure. A work of artisan skill."},"fountainBasin":{"id":"fountainBasin","name":"Fountain","type":"furniture","subtype":"decoration","beauty":20,"weight":30,"value":600,"char":"â™¨","color":"#68c","description":"A stone fountain that gently trickles water. Very soothing."},"pianoBench":{"id":"pianoBench","name":"Piano","type":"furniture","subtype":"decoration","beauty":22,"weight":35,"value":800,"char":"â™ª","color":"#333","description":"An upright piano. Play it to soothe the soul."},"ironChandelier":{"id":"ironChandelier","name":"Iron Chandelier","type":"furniture","subtype":"decoration","beauty":8,"weight":10,"value":150,"char":"â‹","color":"#888","lightRadius":4,"description":"A wrought-iron chandelier holding several candles."},"wallTapestry":{"id":"wallTapestry","name":"Wall Tapestry","type":"furniture","subtype":"decoration","beauty":12,"weight":5,"value":180,"char":"â–§","color":"#8a3040","description":"A richly woven tapestry depicting a heroic scene."},"plantPot":{"id":"plantPot","name":"Potted Fern","type":"furniture","subtype":"decoration","beauty":4,"weight":4,"value":25,"char":"â™£","color":"#3a8a3a","description":"A lush green fern in a ceramic pot."},"bearskinRug":{"id":"bearskinRug","name":"Bearskin Rug","type":"furniture","subtype":"decoration","beauty":10,"weight":8,"value":200,"char":"â–¨","color":"#6a4a2a","description":"A thick bearskin rug. Luxuriously warm underfoot."},"diningChairSet":{"id":"diningChairSet","name":"Dining Chair Set","type":"furniture","subtype":"decoration","beauty":10,"weight":16,"value":160,"char":"â•¥","color":"#7a5a2a","description":"A matched set of four carved dining chairs."},"mapTable":{"id":"mapTable","name":"Map Table","type":"furniture","subtype":"decoration","beauty":10,"weight":14,"value":200,"char":"â•¤","color":"#8a7050","description":"A large table covered with maps and charts. Aids in planning."},"recipePaper":{"id":"recipePaper","name":"Recipe Paper","type":"recipePaper","char":"?","color":"#dda","weight":0.2,"value":50,"description":"A paper describing how to craft something. Read it to learn the recipe."}};
  MONSTER_TEMPLATES = {"putit":{"id":"putit","name":"Putit","race":"slime","level":1,"hp":15,"mp":0,"speed":80,"attack":"1d3","xp":5,"ai":"predator","biomes":["plains","forest"],"drops":["herbGreen"]},"kobold":{"id":"kobold","name":"Kobold","race":"kobold","level":2,"hp":20,"mp":0,"speed":90,"attack":"1d4","xp":10,"ai":"thief","biomes":["plains","mountain"],"drops":["dagger","goldCoin"]},"goblin":{"id":"goblin","name":"Goblin","race":"goblin","level":3,"hp":30,"mp":0,"speed":95,"attack":"1d5","xp":15,"ai":"warrior","biomes":["forest","plains"],"drops":["brokenSword","goldCoin"]},"rat":{"id":"rat","name":"Giant Rat","race":"rat","level":1,"hp":10,"mp":0,"speed":110,"attack":"1d2","xp":3,"ai":"predator","biomes":["plains","forest","beach"],"drops":[]},"zombie":{"id":"zombie","name":"Zombie","race":"zombie","level":5,"hp":50,"mp":0,"speed":60,"attack":"2d4","xp":25,"ai":"predator","biomes":["forest","snow"],"drops":["ration"]},"skeleton":{"id":"skeleton","name":"Skeleton","race":"skeleton","level":6,"hp":35,"mp":0,"speed":85,"attack":"2d5","xp":30,"ai":"warrior","biomes":["desert","mountain"],"drops":["brokenSword"]},"wolf":{"id":"wolf","name":"Wild Wolf","race":"wolf","level":4,"hp":25,"mp":0,"speed":120,"attack":"1d6","xp":20,"ai":"predator","biomes":["forest","snow","plains"],"drops":[]},"bat":{"id":"bat","name":"Cave Bat","race":"bat","level":2,"hp":12,"mp":0,"speed":140,"attack":"1d3","xp":8,"ai":"predator","biomes":["mountain","forest"],"drops":[]},"imp":{"id":"imp","name":"Imp","race":"imp","level":8,"hp":40,"mp":20,"speed":100,"attack":"1d6","xp":40,"ai":"hexer","biomes":["desert","mountain"],"drops":["potionMana"]},"orc":{"id":"orc","name":"Orc","race":"orc","level":7,"hp":55,"mp":0,"speed":85,"attack":"2d6","xp":35,"ai":"warrior","biomes":["mountain","forest"],"drops":["battleAxe","goldCoin"]},"minotaur":{"id":"minotaur","name":"Minotaur","race":"minotaur","level":12,"hp":100,"mp":0,"speed":80,"attack":"3d6","xp":80,"ai":"warrior","biomes":["mountain"],"drops":["battleAxe","chainMail"]},"drake":{"id":"drake","name":"Drake","race":"drake","level":15,"hp":150,"mp":30,"speed":100,"attack":"3d8","xp":120,"ai":"predator","biomes":["mountain","desert"],"drops":["longSword"]},"troll":{"id":"troll","name":"Troll","race":"troll","level":10,"hp":120,"mp":0,"speed":70,"attack":"2d8","xp":60,"ai":"warrior","biomes":["forest","mountain"],"drops":["woodenMace"]},"sandViper":{"id":"sandViper","name":"Sand Viper","race":"snake","level":3,"hp":18,"mp":0,"speed":130,"attack":"1d4","xp":12,"ai":"predator","biomes":["desert","beach"],"drops":["herbGreen"]},"scorpion":{"id":"scorpion","name":"Giant Scorpion","race":"insect","level":5,"hp":35,"mp":0,"speed":90,"attack":"1d6","xp":22,"ai":"predator","biomes":["desert"],"drops":[]},"mummy":{"id":"mummy","name":"Mummy","race":"undead","level":9,"hp":70,"mp":10,"speed":55,"attack":"2d6","xp":50,"ai":"predator","biomes":["desert"],"drops":["goldCoin","goldCoin"]},"dustWraith":{"id":"dustWraith","name":"Dust Wraith","race":"spirit","level":11,"hp":55,"mp":30,"speed":110,"attack":"2d5","xp":65,"ai":"hexer","biomes":["desert"],"drops":["potionMana"]},"cactoid":{"id":"cactoid","name":"Cactoid","race":"plant","level":4,"hp":28,"mp":0,"speed":50,"attack":"1d6","xp":18,"ai":"predator","biomes":["desert"],"drops":["herbGreen"]},"frostWolf":{"id":"frostWolf","name":"Frost Wolf","race":"wolf","level":6,"hp":38,"mp":0,"speed":125,"attack":"2d4","xp":28,"ai":"predator","biomes":["snow"],"drops":["leather"]},"iceElemental":{"id":"iceElemental","name":"Ice Elemental","race":"elemental","level":10,"hp":80,"mp":20,"speed":70,"attack":"2d6","xp":55,"ai":"hexer","biomes":["snow"],"drops":["crystalBlue"]},"snowHarpy":{"id":"snowHarpy","name":"Snow Harpy","race":"harpy","level":7,"hp":32,"mp":10,"speed":135,"attack":"1d8","xp":35,"ai":"predator","biomes":["snow","mountain"],"drops":[]},"yeti":{"id":"yeti","name":"Yeti","race":"beast","level":13,"hp":130,"mp":0,"speed":75,"attack":"3d6","xp":90,"ai":"warrior","biomes":["snow"],"drops":["leather","ration"]},"forestSpider":{"id":"forestSpider","name":"Forest Spider","race":"insect","level":3,"hp":20,"mp":0,"speed":105,"attack":"1d5","xp":14,"ai":"predator","biomes":["forest"],"drops":["string"]},"treant":{"id":"treant","name":"Treant","race":"plant","level":9,"hp":90,"mp":0,"speed":45,"attack":"2d8","xp":55,"ai":"warrior","biomes":["forest"],"drops":["woodLog","woodLog"]},"willOWisp":{"id":"willOWisp","name":"Will-o'-Wisp","race":"spirit","level":6,"hp":22,"mp":25,"speed":150,"attack":"1d4","xp":30,"ai":"hexer","biomes":["forest","beach"],"drops":["potionMana"]},"bear":{"id":"bear","name":"Wild Bear","race":"beast","level":5,"hp":45,"mp":0,"speed":85,"attack":"2d5","xp":25,"ai":"predator","biomes":["forest","mountain"],"drops":["leather"]},"mushMan":{"id":"mushMan","name":"Mushroom Man","race":"plant","level":2,"hp":16,"mp":5,"speed":65,"attack":"1d3","xp":8,"ai":"predator","biomes":["forest"],"drops":["herbGreen"]},"stoneGolem":{"id":"stoneGolem","name":"Stone Golem","race":"golem","level":11,"hp":110,"mp":0,"speed":50,"attack":"3d5","xp":70,"ai":"warrior","biomes":["mountain"],"drops":["oreIron"]},"rockWorm":{"id":"rockWorm","name":"Rock Worm","race":"worm","level":4,"hp":30,"mp":0,"speed":60,"attack":"1d6","xp":18,"ai":"predator","biomes":["mountain"],"drops":["oreIron"]},"griffin":{"id":"griffin","name":"Griffin","race":"beast","level":14,"hp":120,"mp":0,"speed":130,"attack":"3d6","xp":100,"ai":"predator","biomes":["mountain","plains"],"drops":["leather"]},"mountainOgre":{"id":"mountainOgre","name":"Mountain Ogre","race":"ogre","level":8,"hp":75,"mp":0,"speed":65,"attack":"2d8","xp":45,"ai":"warrior","biomes":["mountain"],"drops":["woodenMace","goldCoin"]},"crab":{"id":"crab","name":"Giant Crab","race":"crustacean","level":3,"hp":25,"mp":0,"speed":70,"attack":"1d6","xp":14,"ai":"predator","biomes":["beach","sea"],"drops":[]},"siren":{"id":"siren","name":"Siren","race":"spirit","level":8,"hp":35,"mp":30,"speed":100,"attack":"1d6","xp":42,"ai":"hexer","biomes":["sea","beach"],"drops":["potionMana","goldCoin"]},"seaSerpent":{"id":"seaSerpent","name":"Sea Serpent","race":"snake","level":12,"hp":95,"mp":0,"speed":110,"attack":"3d5","xp":75,"ai":"predator","biomes":["sea"],"drops":["longSword"]},"jellyfish":{"id":"jellyfish","name":"Man-o'-War","race":"slime","level":2,"hp":14,"mp":0,"speed":60,"attack":"1d4","xp":8,"ai":"predator","biomes":["sea","beach"],"drops":[]},"plainsStalker":{"id":"plainsStalker","name":"Plains Stalker","race":"beast","level":5,"hp":30,"mp":0,"speed":130,"attack":"1d8","xp":24,"ai":"predator","biomes":["plains"],"drops":["leather"]},"wildBoar":{"id":"wildBoar","name":"Wild Boar","race":"beast","level":3,"hp":28,"mp":0,"speed":100,"attack":"1d5","xp":13,"ai":"predator","biomes":["plains","forest"],"drops":["ration"]},"hawkRider":{"id":"hawkRider","name":"Hawk Rider Goblin","race":"goblin","level":6,"hp":35,"mp":0,"speed":120,"attack":"2d4","xp":32,"ai":"warrior","biomes":["plains"],"drops":["shortBow","goldCoin"]},"centaur":{"id":"centaur","name":"Centaur","race":"centaur","level":9,"hp":65,"mp":0,"speed":115,"attack":"2d6","xp":48,"ai":"warrior","biomes":["plains"],"drops":["shortBow","leatherArmor"]}};
  MONSTER_TIERS = [{"minDanger":1,"maxDanger":5,"monsters":["putit","rat","bat","kobold","sandViper","mushMan","jellyfish","crab","wildBoar","rockWorm"]},{"minDanger":3,"maxDanger":10,"monsters":["goblin","wolf","skeleton","scorpion","forestSpider","cactoid","bear","plainsStalker","hawkRider","frostWolf","willOWisp"]},{"minDanger":6,"maxDanger":15,"monsters":["zombie","orc","imp","snowHarpy","mountainOgre","siren","treant","centaur","mummy"]},{"minDanger":10,"maxDanger":25,"monsters":["troll","minotaur","iceElemental","dustWraith","stoneGolem","seaSerpent","yeti"]},{"minDanger":15,"maxDanger":50,"monsters":["drake","griffin"]}];
  WORLD_LOCATIONS = {"stonehaven": {"id":"stonehaven","name":"Stonehaven","type":"town","x":48,"y":32,"description":"A small mining town nestled in the foothills. Good place for beginners.","danger":0,"layout":{"width":48,"height":36,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","o":"rock","â‰ˆ":"farmSoil","t":"table","c":"chair","b":"bookshelf","B":"barrel","C":"crate","w":"well","n":"counter","L":"lamp","v":"oven","e":"bedTile","s":"stoneFloor","d":"woodFloor","F":"fountain","f":"fenceH","S":"statue"},"rows":["################################################","#,,,,,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,,,,,#","#,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,#","#,,,,###########,,,,,,,,,,,,,,,###########,,,,,#","#,,,,#bbb..tc..+,,,,,,,,,,,,,,,#..tc..bbe+,,,,,#","#,,,,#.........#,,,,,,,,,,,,,,,#.........#,,,,,#","#,,,,#..tc..ec.#,,,,,,,,,,,,,,,#.ec..tc..#,,,,,#","#,,,,###########,,,,,,w,,,,,,,,###########,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,=====,,,,,,###########,,,,,#","#,,#nnn......+,,,,,=,,,,,=,,,,,#BBB..tc..+,,,,,#","#,,#.........#,,,,,=,L,L,=,,,,,#.........#,,,,,#","#,,#..BB.tc..#,,,,,=,,,,,=,,,,,#..tc..ec.#,,,,,#","#,,###########,,,,,,=====,,,,,,###########,,,T,#","#,,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,,#","#==============================================#","#,,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,=====,,,,,,###########,,,,,#","#,,#bbb......+,,,,,,=,F,=,,,,,,#.tc..nnv#+,,,,,#","#,,#..tc..tc..#,,,,,=,,,=,,,,,,#.........#,,,,,#","#,,#..........#,,,,,=====,,,,,,#..BB..tc.#,,,,,#","#,,#.tc..tc..c#,,,,,,,,,,,,,,,,###########,,,,,#","#,,###########,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###########,,,,,#","#,,,T,,,,,,,,,,,,,,,,,,,,,,,T,,#.ec..bbb#+,,,,,#","#,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,#.........#,,,,,,#","#,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,ooo,,,,,,,,#.tc..ec..#,,,,,,#","#,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,ooo,,,,,,,,###########,,,,,,#","#,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,oo,,,,,,,,,,,,,,,,,,,,,T,,,#","#,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,ooo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,ooooo,,,,,,,,,,,T,,,,,,,,,T,,,,,,,,,,,#","#,,,,,,,,,ooo,,,,,T,,,,,,,,,,,,,,,,,,,,,,,T,,,,#","#,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","################################################"]},"ambientNPCs":[{"name":"Miner","char":"M","color":"#B8860B","dialogue":["The mines are rich with copper this season.","Watch out for critters in the deeper shafts.","Stonehaven was built on ore, friend."]},{"name":"Guard","char":"G","color":"#7799DD","dialogue":["Stay safe in the mines.","All's quiet in Stonehaven today.","We keep the peace 'round here."]},{"name":"Townsman","char":"P","color":"#DDA877","dialogue":["Nice day for a stroll.","Have you tried the tavern?","The blacksmith does fine work."]},{"name":"Old Woman","char":"W","color":"#CC99CC","dialogue":["I remember when this town was just a camp.","My bones ache... the rain is coming.","Bless you, young one."]},{"name":"Child","char":"k","color":"#FFB86C","dialogue":["Tag! You're it!","I wanna be an adventurer when I grow up!","Momma says I can't go near the mines."]}]},"millfield": {"id":"millfield","name":"Millfield","type":"town","x":32,"y":56,"description":"A peaceful farming village surrounded by golden fields.","danger":0,"layout":{"width":48,"height":36,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","â‰ˆ":"farmSoil","t":"table","c":"chair","b":"bookshelf","B":"barrel","C":"crate","w":"well","n":"counter","L":"lamp","v":"oven","e":"bedTile","d":"woodFloor","f":"fenceH","F":"fountain"},"rows":["################################################","#,,T,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,T,#","#,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,#","#,,T,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,T,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,,,,,,,,,,,###########,,,#","#,,#bbb..tc..#+,,,,,,,,,,,,,,,,,,#nnn..BB..#+,,#","#,,#.........#,,,,,,,,,,,,,,,,,,,#.........#,,,#","#,,#..tc..ec.#,,,,,,,,,,,,,,,,,,,#..BB.tc..#,,,#","#,,###########,,,,,,,,,,,,,,,,,,,###########,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,w,,,,,,,,,###########,,,#","#,,#vn...tc..#+,,,,,,,,,,,,,,,,,T#..tc..tc.#+,,#","#,,#.........#,,,,,,,,,,,,,,,,,,,#..........#,,#","#,,#..BB.tc..#,,,,,,,,,,,,,,,,,,,#.tc..tc.c.#,,#","#,,###########,,,,,,,,,,,,,,,,,,,############,,#","#,,,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,#","#==============================================#","#,,,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,=====,,,,,,,,,###########,,,#","#,,#..ec.bbb.#+,,,,=,L,=,,,,,,,,#..tc..nnv#+,,,#","#,,#..........#,,,,=,,,=,,,,,,,,,,#.........#,,#","#,,#..tc..ec..#,,,,=====,,,,,,,,,,#..BB..tc.#,,#","#,,############,,,,,,,,,,,,,,,,,,,###########,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,T,,,,,,,,,,,,,~~,,,,,,,,,,T,,,,,,,,,,T,,,,,#","#,,,,,,,,T,,,,,,,~~~~,,,,,,,,,,,,,,,,,,,,,,,,,T#","#,,,,,,,,,,,,,,,,,~~,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,#","#,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,#","#,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,T,,,,,,,,,T,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,T,,,,,#","#,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,,,,,,,,,â‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆâ‰ˆ,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,T,,,,,,,,,,,T,,,,,,,,,,,,,,,,,T,,,,,,,,,,,T,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","################################################"]},"ambientNPCs":[{"name":"Farmer","char":"F","color":"#88AA44","dialogue":["The harvest looks good this year!","Nothing beats fresh-grown turnips.","Rain's been steady â€” crops are happy."]},{"name":"Farmwife","char":"W","color":"#CC99AA","dialogue":["My husband works the fields all day.","Would you like some fresh bread?","The children love playing by the pond."]},{"name":"Shepherd","char":"S","color":"#BBAA88","dialogue":["Lost a sheep to wolves last week.","The meadows are peaceful this time of year.","Baa? Oh, that's just old Patches."]},{"name":"Miller","char":"M","color":"#AA8855","dialogue":["The mill's been running since dawn.","Good wheat makes good bread, I always say.","We supply flour to half the realm."]},{"name":"Guard","char":"G","color":"#7799DD","dialogue":["Wolves have been spotted near the fields.","Farm life is quiet, but someone's gotta watch.","Nothing to report, traveler."]},{"name":"Child","char":"k","color":"#FFB86C","dialogue":["I found a frog by the pond!","Can I pet your horse?","Papa says I'll be a farmer too!"]}]},"crownhold": {"id":"crownhold","name":"Crownhold","type":"town","x":80,"y":48,"description":"The grand capital of the Ashen Reaches. Hub of commerce and power.","danger":0,"layout":{"width":56,"height":42,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","o":"rock","t":"table","c":"chair","b":"bookshelf","B":"barrel","C":"crate","w":"well","n":"counter","L":"lamp","v":"oven","e":"bedTile","s":"stoneFloor","d":"woodFloor","F":"fountain","f":"fenceH","S":"statue","r":"rugRed","R":"rugBlue","a":"banner"},"rows":["########################################################","#,,,,,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,,,#","#,,T,,,,,###########,,,,,,,,,,,,,################,,,,,,#","#,,,,,,,,#bbb..tc..#+,,,,,,,,,,,,#..rrrr..rrrr..+,,,T,,#","#,,,,,,,,#..........#,,,,,,,,,,,,#..tc....tc....#,,,,,,#","#,,,,,,,,#..tc..ec..#,,,,,,,,,,,,#..........tc..#,,,,,,#","#,,,,,,,,############,,,,,,,,,,,,#..tc....tc....#,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,################,,,,,,#","#,,###########,,,,,,,,,F,,,,,,,,,,,,,,,,,,,###########,#","#,,#nnn..BB..#+,,,,,,,,,,,,,,,,,,,,,,,,,T,,#bbb.bbb.#+,#","#,,#..........#,,,,,,=====,,,,,,,,,,,,,,,,,,#..........#","#,,#..BB..tc..#,,,,,=,S,S,=,,,,,,,,,,,,,,,,,#..tc..tc.##","#,,###########,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,###########","#,,,,,,,,,,,,,,,,,,,=,L,L,=,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=,,,,,=,,###########,,,,,,,,,,,,,,,#","#,,###########,,,,,,=,S,S,=,,#aaRRRRaa.#+,,,,,,,,,,,,,,#","#,,#vn...tc..#+,,,,,,=====,,,#..RRRR....#,##############","#,,#..........#,,,,,,,,=,,,,,#..tc..tc..#,#bbbb..tc..bb#","#,,#..tc..BB..#,,,,,,,,=,,,,,#..........#,+............#","#,,###########,,,,,,,,=======,,##########,#..tc....tc..#","#=======================================================","#,,###########,,,,,,,=======,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,#..ec.bbb.#+,,,,,,,,=,,,,,###########,,,###########,#","#,,#..........#,,,,,,,,=,,,,,#bbb..tc..#+,,#..ec.bbb.#+#","#,,#..tc..ec..#,,,,,,,,=,,,,,#..........#,,#..........##","#,,############,,,,,,=====,,,#..tc..tc..#,,#..tc..ec..##","#,,,,,,,,,,,,,,,,,,,,=,w,=,,,###########,,,#############","#,,###########,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,#nnn....BB#+,,,,,,=====,,,###########,,,,,,,,,,,,,,,#","#,,#..........#,,,,,,,,,,,,,,#..ec..tc..#+,,,,,T,,,,,,,#","#,,#..tc..CB..#,,,,,,,,,,,,,,#..........#,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,,,,,,,,#..ec..bb.#,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,###########,,,,,,,,T,,,,#","#,,T,,,,,,,,,,,,,,,,,~~,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,T,,,,,,,,~~~~,,,,,,,,,,,,T,,,,,,,,,T,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,~~,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,#","#,,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,,,,,,,,,,,,,,#","#,,,,,,,,T,,,,,,,,,,,,,,,,,,,,T,,,,,,,,,,,,,,,,,,,,T,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,T,,,,,,,T,,,,,,,,,,T,,,,,,,,,T,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","########################################################"]},"ambientNPCs":[{"name":"Royal Guard","char":"G","color":"#DDAA33","dialogue":["Long live the Crown!","Move along, citizen.","The King holds court in the palace."]},{"name":"Guard","char":"G","color":"#7799DD","dialogue":["Keep the peace, traveler.","No trouble in Crownhold, understood?","The capital is well-protected."]},{"name":"Noble","char":"N","color":"#D4AF37","dialogue":["The capital thrives under wise rule.","Have you attended the court?","Ugh, the common folk smell awful."]},{"name":"Scholar","char":"S","color":"#88AADD","dialogue":["The royal library holds ancient secrets.","Knowledge is power, friend.","I'm researching the old Nefia ruins."]},{"name":"Merchant","char":"M","color":"#DDA877","dialogue":["Trade is booming in the capital!","Finest goods from across the realm!","Looking for something special?"]},{"name":"Priest","char":"P","color":"#FFEEAA","dialogue":["May the gods watch over you.","Visit the altar, child.","Faith guides us through dark times."]},{"name":"Bard","char":"B","color":"#CC77DD","dialogue":["â™ª Oh, the ballad of Crownhold! â™ª","Hear my tale of mighty heroes!","A coin for a song, friend?"]},{"name":"Servant","char":"s","color":"#AA9988","dialogue":["The palace kitchens are busy today.","Yes, right away!","The nobles keep us on our toes."]},{"name":"Townswoman","char":"W","color":"#CC99CC","dialogue":["The market has wonderful wares today.","Have you seen the fountain?","My daughter is studying at Archgate."]},{"name":"Child","char":"k","color":"#FFB86C","dialogue":["I saw the King once!","I'm gonna be a knight!","Race you to the fountain!"]}]},"duskmarket": {"id":"duskmarket","name":"Duskmarket","type":"town","x":22,"y":38,"description":"A shady town shrouded in mist, home to the Thieves Guild.","danger":0,"layout":{"width":48,"height":36,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","o":"rock","t":"table","c":"chair","b":"bookshelf","B":"barrel","C":"crate","w":"well","n":"counter","L":"lamp","v":"oven","e":"bedTile","d":"woodFloor","s":"stoneFloor"},"rows":["################################################","#,,T,,,,,,,,,,,T,,,,,,,,,,T,,,,,,,,,,,,T,,,,,,,#","#,,,,###########,,,,,,,,,,,,,,###########,,,,T,#","#,,,,#bbb.tc...#+,,,,,T,,,,,,,,#nnn..BB..#+,,,,#","#,,,,#..........#,,,,,,,,,,,,,,#..........#,,,,#","#,,,,#..tc..ec..#,,,,,,,,,,,,,,#..BB..tc..#,,,,#","#,,,,############,,,,,,,,,,,,,,###########,,,,T#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,,,,,,,,,###########,,,,,#","#,,#..CC.BB..#+,,,,,,,,,,,,,,,,#..tc.nnn.#+,,,,#","#,,#..........#,,,,,,,,,,,,,,,,#..........#,,,,#","#,,#..BB.CC.tc#,,,,,,,,,,,,,,,,#..BB..tc..#,,,,#","#,,###########,,,,,,,,,,,,,,,,,###########,,,T,#","#,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,T,,,,,,,,,,,,=====,,,,,,,,,,,,,,,,,T,,,,,#","#,,,,,,,,,,,,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,#","#==============================================#","#,,,,,,,,,,,,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,T,,,,,,,,,,,,=====,,,,,,,,,,,,,,T,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,=,,,,,,,,,,###########,,,,#","#,,#..ec.bbb..#+,,,,,,,,,,,,,T,,#..tc..ec.#+,,,#","#,,#...........#,,,,,,,,,,,,,,,,#..........#,,,#","#,,#..tc..ec...#,,,,,,,,,,,,,,,,#..ec..bb..#,,,#","#,,############,,,,,,,,,,,,,,,,,,###########,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,,,,T,,,,,,###########,,,#","#,,#..tc.nnn..#+,,,,,,,,,,,,,,,,#..BB.CC..#+,,,#","#,,#...........#,,,,,T,,,,,,,,,,#..........#,,,#","#,,#..BB..tc.c.#,,,,,,,,,,,,,,,,#..tc..tc..#,,T#","#,,############,,,,,,,,,,,,,,,,,,###########,,,#","#,,,,,,,,,,T,,,,,,,,,,,,,,,,,T,,,,,,,,,,,,,,,,,#","#,,,T,,,,,,,,,,,T,,,,,,,,,,,,,,,,,,,T,,,,,,,,T,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","################################################"]},"ambientNPCs":[{"name":"Shady Figure","char":"?","color":"#666688","dialogue":["Psst... need something special?","Keep your voice down.","I didn't see nothin', you didn't see nothin'."]},{"name":"Thief","char":"T","color":"#8877AA","dialogue":["Watch your pockets around here.","The Guild takes care of its own.","Looking for work? Talk to the boss."]},{"name":"Beggar","char":"b","color":"#887766","dialogue":["Spare a coin for the poor?","I used to be somebody...","The mist hides many secrets."]},{"name":"Guard","char":"G","color":"#6688AA","dialogue":["Move along... nothing to see here.","I look the other way for the right price.","Duskmarket has its own laws."]},{"name":"Bartender","char":"B","color":"#AA8855","dialogue":["What'll it be?","Don't start trouble in my bar.","I hear things... for a price."]},{"name":"Cloaked Woman","char":"W","color":"#9977BB","dialogue":["The shadows have eyes.","Seeking forbidden knowledge?","Trust no one in Duskmarket."]}]},"tidereach": {"id":"tidereach","name":"Tidereach","type":"town","x":100,"y":72,"description":"A bustling port city with a fighter arena overlooking the sea.","danger":0,"layout":{"width":50,"height":38,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","o":"rock","t":"table","c":"chair","b":"bookshelf","B":"barrel","C":"crate","n":"counter","L":"lamp","v":"oven","e":"bedTile","s":"stoneFloor","F":"fountain","S":"statue","r":"rugRed"},"rows":["##################################################","#,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,,,#","#,,,,###########,,,,,,,,,,,,,,,,###########,,,,,,#","#,,,,#nnn..BB..#+,,,,,,,,,,,,,,,#..tc..tc..#+,,,,#","#,,,,#..........#,,,,,,,,,,,,,,,#..........#,,,,,#","#,,,,#..BB..tc..#,,,,,,,,,,,,,,,#.tc..tc.c.#,,,,,#","#,,,,###########,,,,,,,,,,,,,,,,###########,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,#","#,,###########,,,,,,,,F,,,,,,,,,,###########,,,,,#","#,,#vn...tc..#+,,,,,,,,,,,,,,,,,,#..ec.bbb.#+,,,,#","#,,#..........#,,,,,,=====,,,,,,,,#.........#,,,,#","#,,#..BB.tc.c.#,,,,,=,S,S,=,,,,,,#.tc..ec..#,,,,,#","#,,###########,,,,,,=,,,,,=,,,,,,,,###########,,,#","#,,,,,,,,,,,,,,,,,,,=,L,L,=,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,=,S,S,=,,,,,,###########,,,,,#","#,,#..CC.BB..#+,,,,,,=====,,,,,,,#bbb.tc...#+,,,,#","#,,#..........#,,,,,,,,=,,,,,,,,,#..........#,,,,#","#,,#..BB.CC.tc#,,,,,,,,=,,,,,,,,,#.tc..ec..b#,,,,#","#,,###########,,,,,,,,=====,,,,,,###########,,,,,#","#================================================#","#,,###########,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,#","#,,#..ec.bbb..#+,,,,=,,,,,=,,,,############,,,,,,#","#,,#...........#,,,,,=====,,,,,#ssssssssss.#+,,,,#","#,,#..tc..ec...#,,,,,,,,,,,,,,,,#s.rrrrrr.s#,,,,,#","#,,############,,,,,,,,,,,,,,,,,#s.r....r.s#,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#s.r....r.s#,,,,#","#,,###########,,,,,,,,T,,,,,,,,,#s.rrrrrr.s#,,,,,#","#,,#nnn..tc..#+,,,,,,,,,,,,,,,,,#ssssssssss#,,,,,#","#,,#..........#,,,,,,,,,,,,,,,,,,############,,,,#","#,,#..BB..tc..#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,T,,,,,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#","#,,,,,,,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#","#,,,,,,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#","#,,T,,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#","##################################################"]},"ambientNPCs":[{"name":"Sailor","char":"S","color":"#5599BB","dialogue":["The sea's been rough lately.","I've sailed to the far islands and back!","Ahoy, landlubber!"]},{"name":"Fisherman","char":"F","color":"#6699AA","dialogue":["Caught a big one this morning!","The fish ain't bitin' today.","Nothing like the smell of salt air."]},{"name":"Dockworker","char":"D","color":"#AA8866","dialogue":["Heavy cargo today.","Ships come and go, but the work never ends.","Watch your step on the docks."]},{"name":"Arena Fighter","char":"A","color":"#DD5533","dialogue":["Think you can last in the arena?","I've won twelve bouts in a row!","Strength is everything!"]},{"name":"Guard","char":"G","color":"#7799DD","dialogue":["The port is well-guarded.","No smuggling on my watch.","Welcome to Tidereach, traveler."]},{"name":"Merchant","char":"M","color":"#DDA877","dialogue":["Imported goods, finest quality!","Prices from across the sea!","The port trade keeps us fed."]},{"name":"Pirate","char":"P","color":"#884422","dialogue":["Yarr... I mean, hello, officer.","I'm a perfectly legitimate trader.","The sea holds treasures, if ye know where to look."]},{"name":"Child","char":"k","color":"#FFB86C","dialogue":["I wanna be a pirate!","Look at all the big ships!","Mama sells fish at the market."]}]},"archgate": {"id":"archgate","name":"Archgate","type":"town","x":72,"y":26,"description":"City of arcane study, home to the Mage Guild and great libraries.","danger":0,"layout":{"width":50,"height":38,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","o":"rock","t":"table","c":"chair","b":"bookshelf","B":"barrel","C":"crate","n":"counter","L":"lamp","v":"oven","e":"bedTile","s":"stoneFloor","F":"fountain","S":"statue","r":"rugRed","R":"rugBlue","a":"banner"},"rows":["##################################################","#,,,,,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,,,,,#","#,,T,,,,,################,,,,,################,,,#","#,,,,,,,,#bbbb..tc..bbb.#+,,,,#bbbb..tc..bbb.#+,,#","#,,,,,,,,#..............#,,,,,#..............#,,,#","#,,,,,,,,#.tc..bbb..tc..#,,,,,#.tc..bbb..tc..#,,,#","#,,,,,,,,#..............#,,,,,#..............#,,,#","#,,,T,,,,#bbbb..tc..bbb.#,,,,,#bbbb..tc..bbb.#,,,#","#,,,,,,,,################,,,,,################,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,F,,,,,,,,,,###########,,,,,#","#,,#nnn..BB..#+,,,,,,,,,,,,,,,,,,#..tc..ec..#+,,,#","#,,#..........#,,,,,,=====,,,,,,,,#..........#,,,#","#,,#..BB..tc..#,,,,,=,S,S,=,,,,,,#..ec..bb..#,,,,#","#,,###########,,,,,,=,,,,,=,,,,,,###########,,,,,#","#,,,,,,,,,,,,,,,,,,,=,L,L,=,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=,S,S,=,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,=====,,,,,,,,###########,,,,#","#,,#..tc.nnn.#+,,,,,,,,=,,,,,,,,,,#..ec.bbb.#+,,,#","#================================================#","#,,#..BB..tc..#,,,,,,,,=,,,,,,,,,,#..tc..ec..#,,,#","#,,###########,,,,,,,=====,,,,,,,,###########,,,,#","#,,,,,,,,,,,,,,,,,,,=,,,,,=,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,=,F,F,=,,,,,,###########,,,,T#","#,,#vn...tc..#+,,,,,=,,,,,=,,,,,,#..tc..tc..#+,,,#","#,,#..........#,,,,,,=====,,,,,,,,#..........#,,,#","#,,#..BB.tc.c.#,,,,,,,,,,,,,,,,,,,,#.tc..tc.c.#,,#","#,,###########,,,,,,,,,,,,,,,,,,,,###########,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,#","#,,###########,,,,,,,,T,,,,,,,T,,###########,,,,,#","#,,#..ec.bbb..#+,,,,,,,,,,,,,,,,,#..ec.tc..#+,,,,#","#,,#...........#,,,,,,,,,,,,,,,,,,#..........#,,,#","#,,#..tc..ec...#,,,,,,,,T,,,,,,,,#..ec..bb..#,,,,#","#,,############,,,,,,,,,,,,,,,,,,###########,,T,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,T,,,,,,T,,,,,,T,,,,,,,,,,,,,T,,,,,,,T,,,,,,,,T#","##################################################"]},"ambientNPCs":[{"name":"Apprentice","char":"a","color":"#7788CC","dialogue":["I'm studying transmutation this semester.","The library here is immense!","Don't touch that, it's enchanted!"]},{"name":"Wizard","char":"W","color":"#AA77FF","dialogue":["The arcane arts require patience.","Interesting... very interesting.","I sense magical potential in you."]},{"name":"Librarian","char":"L","color":"#998877","dialogue":["Shh! This is a library!","The restricted section is off-limits.","Knowledge must be preserved."]},{"name":"Scholar","char":"S","color":"#88AADD","dialogue":["I've been researching ancient Nefia.","The magical ley lines converge here.","Archgate was built on a nexus of power."]},{"name":"Guard","char":"G","color":"#7799DD","dialogue":["The Mage Guild keeps us busy.","No unauthorized spellcasting in the streets!","Archgate is a place of learning."]},{"name":"Alchemist","char":"A","color":"#44AA88","dialogue":["Need a potion? I might have extras.","The reaction is almost complete...","Careful with those reagents!"]},{"name":"Student","char":"s","color":"#AABB99","dialogue":["I failed my teleportation exam...","Professor says I have talent!","Do you know any good spells?"]},{"name":"Enchanter","char":"E","color":"#CC88DD","dialogue":["Every object has hidden potential.","I can feel the magic in the air.","The enchanting halls are below the library."]}]},"frostbell": {"id":"frostbell","name":"Frostbell","type":"town","x":100,"y":10,"description":"A quiet northern town where bells echo through the snow.","danger":0,"layout":{"width":44,"height":34,"legend":{"#":"wall",".":"floor",",":"grass","=":"road","+":"door","T":"tree","~":"water","o":"rock","t":"table","c":"chair","b":"bookshelf","B":"barrel","n":"counter","L":"lamp","v":"oven","e":"bedTile","s":"stoneFloor","w":"well","S":"statue"},"rows":["############################################","#,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,,,,T#","#,,,,###########,,,,,,,,,,###########,,,,,,#","#,,,,#bbb..tc..#+,,,,,,,,,#nnn..BB..#+,,,,,#","#,,,,#..........#,,,,,,,,,#..........#,,,,,#","#,,,,#..tc..ec..#,,,,,,,,,#..BB..tc..#,,,T,#","#,,,,############,,,,,,,,,###########,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,w,,,,,,###########,,,,#","#,,#vn...tc..#+,,,,,,,,,,,,,,#..tc.tc..#+,,#","#,,#..........#,,,,,,,,,,,,,,#..........#,,#","#,,#..BB.tc.c.#,,,,,,,,,T,,,#.tc..tc.c.#,,,#","#,,###########,,,,,,,,,,,,,,###########,,,,#","#,,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,T,,,,,,,,,=,,,,,,,,T,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,=====,,,,,,,,,,,,,,,,,,#","#==========================================#","#,,,,,,,,,,,,,,,,,,,=====,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,=,,,,,,,,,,,,,,,,,,T,,#","#,,###########,,,,,,,,=,,,,,,,###########,,#","#,,#..ec.bbb..#+,,,,,,,,,,,,,,#..ec.tc..#+,#","#,,#...........#,,,,,,,,,,,,,,#..........#,#","#,,#..tc..ec...#,,,,,,,,,,,,,,#..ec..bb.#,,#","#,,############,,,,,,,,,,,,,,,,###########,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,T,,,,,,,,,,,,,,,,,,T,#","#,,#..tc..ec..#+,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,#..........#,,,,,,,,,,,,T,,,,,,,,T,,,,,,#","#,,#..ec..bb..#,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,###########,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,T,,,,,,,,T,,,,,,,,T,,,,,,,,,T,,,#","#,,T,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#","#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,T,,,#","############################################"]},"ambientNPCs":[{"name":"Trapper","char":"T","color":"#AA8866","dialogue":["The pelts fetch a good price this winter.","Wolves roam the northern wilds.","Best furs come from these mountains."]},{"name":"Elder","char":"E","color":"#CCBBAA","dialogue":["The bells have rung for centuries.","Frostbell endures through every winter.","Listen... can you hear them?"]},{"name":"Guard","char":"G","color":"#7799DD","dialogue":["Bundle up, traveler.","The cold keeps most trouble away.","Quiet day in Frostbell."]},{"name":"Woodcutter","char":"W","color":"#886644","dialogue":["Timber! ...Oh, sorry.","The pines here make good lumber.","Keeps the fires burning all winter."]},{"name":"Innkeeper","char":"I","color":"#DDAA77","dialogue":["Come in from the cold!","Hot soup and warm beds!","The fire's always burning here."]},{"name":"Child","char":"k","color":"#FFB86C","dialogue":["I love the snow!","Let's have a snowball fight!","The bells sound so pretty!"]}]},"homestead": {"id":"homestead","name":"Homestead","type":"home","x":40,"y":40,"description":"Your home base. Build and develop it!","danger":0},"underkeep": {"id":"underkeep","name":"The Underkeep","type":"nefia","x":56,"y":40,"description":"A vast dungeon beneath the hills. Deep and dangerous.","danger":5,"floors":45},"glimmerGrotto": {"id":"glimmerGrotto","name":"Glimmer Grotto","type":"nefia","x":44,"y":28,"description":"A small cavern with glowing moss. Easy introductory dungeon.","danger":1,"floors":3}};
  BIOMES = {"plains":{"id":"plains","name":"Plains","tileChar":".","color":"#5a8a3c","dangerMod":0,"nativeMonsters":["putit","rat","wolf","goblin","wildBoar","plainsStalker","hawkRider","centaur","griffin"]},"forest":{"id":"forest","name":"Forest","tileChar":"T","color":"#2d5a1e","dangerMod":2,"nativeMonsters":["putit","rat","goblin","wolf","bat","zombie","orc","troll","forestSpider","treant","willOWisp","bear","mushMan","wildBoar"]},"mountain":{"id":"mountain","name":"Mountain","tileChar":"^","color":"#8a7a5a","dangerMod":5,"nativeMonsters":["kobold","bat","skeleton","orc","imp","minotaur","drake","troll","snowHarpy","stoneGolem","rockWorm","griffin","mountainOgre","bear"]},"snow":{"id":"snow","name":"Snow","tileChar":"*","color":"#d0d8e0","dangerMod":3,"nativeMonsters":["wolf","zombie","frostWolf","iceElemental","snowHarpy","yeti"]},"sea":{"id":"sea","name":"Sea","tileChar":"~","color":"#2a5aaa","dangerMod":1,"nativeMonsters":["crab","siren","seaSerpent","jellyfish"]},"road":{"id":"road","name":"Road","tileChar":"=","color":"#b8a878","dangerMod":-2},"beach":{"id":"beach","name":"Beach","tileChar":",","color":"#e8d8a0","dangerMod":0,"nativeMonsters":["rat","sandViper","crab","jellyfish","siren","willOWisp"]},"desert":{"id":"desert","name":"Desert","tileChar":":","color":"#d8c878","dangerMod":4,"nativeMonsters":["skeleton","imp","drake","sandViper","scorpion","mummy","dustWraith","cactoid"]}};
  TILE_TYPES = {"floor":{"id":"floor","char":".","color":"#555","walkable":true,"transparent":true},"wall":{"id":"wall","char":"#","color":"#888","walkable":false,"transparent":false},"grass":{"id":"grass","char":".","color":"#4a7a2c","walkable":true,"transparent":true},"water":{"id":"water","char":"~","color":"#2a5aaa","walkable":false,"transparent":true},"tree":{"id":"tree","char":"T","color":"#2d5a1e","walkable":false,"transparent":false},"oakTree":{"id":"oakTree","char":"T","color":"#3a6a20","walkable":false,"transparent":false},"pineTree":{"id":"pineTree","char":"T","color":"#1a4a18","walkable":false,"transparent":false},"birchTree":{"id":"birchTree","char":"T","color":"#6a9a5a","walkable":false,"transparent":false},"mapleTree":{"id":"mapleTree","char":"T","color":"#aa4422","walkable":false,"transparent":false},"yewTree":{"id":"yewTree","char":"T","color":"#2a3a1a","walkable":false,"transparent":false},"door":{"id":"door","char":"+","color":"#a57030","walkable":true,"transparent":false},"stairsDown":{"id":"stairsDown","char":">","color":"#fff","walkable":true,"transparent":true},"stairsUp":{"id":"stairsUp","char":"<","color":"#fff","walkable":true,"transparent":true},"road":{"id":"road","char":"=","color":"#b8a878","walkable":true,"transparent":true},"rock":{"id":"rock","char":"o","color":"#777","walkable":false,"transparent":false},"ore":{"id":"ore","char":"â™¦","color":"#c8a020","walkable":false,"transparent":false},"copperOre":{"id":"copperOre","char":"â™¦","color":"#b87333","walkable":false,"transparent":false},"ironOre":{"id":"ironOre","char":"â™¦","color":"#8a8a8a","walkable":false,"transparent":false},"silverOre":{"id":"silverOre","char":"â™¦","color":"#c0c0d0","walkable":false,"transparent":false},"goldOre":{"id":"goldOre","char":"â™¦","color":"#ffd700","walkable":false,"transparent":false},"mythrilOre":{"id":"mythrilOre","char":"â™¦","color":"#66ccff","walkable":false,"transparent":false},"shrine":{"id":"shrine","char":"â€ ","color":"#d0d050","walkable":true,"transparent":true},"chest":{"id":"chest","char":"â–¡","color":"#daa520","walkable":true,"transparent":true},"trap":{"id":"trap","char":"^","color":"#cc3333","walkable":true,"transparent":true,"hidden":true},"townTile":{"id":"townTile","char":"â– ","color":"#aa8855","walkable":true,"transparent":true},"farmSoil":{"id":"farmSoil","char":"â‰ˆ","color":"#654","walkable":true,"transparent":true},"herbPatch":{"id":"herbPatch","char":"â™£","color":"#2a8a2a","walkable":false,"transparent":true},"oreVein":{"id":"oreVein","char":"â™¦","color":"#c8a020","walkable":false,"transparent":false},"fishingSpot":{"id":"fishingSpot","char":"â‰ˆ","color":"#4a8aee","walkable":false,"transparent":true},"stump":{"id":"stump","char":".","color":"#5a4a2a","walkable":true,"transparent":true},"snowGround":{"id":"snowGround","char":".","color":"#c8d0d8","walkable":true,"transparent":true},"sand":{"id":"sand","char":".","color":"#d8c878","walkable":true,"transparent":true},"dirt":{"id":"dirt","char":".","color":"#7a6a4a","walkable":true,"transparent":true},"rockyGround":{"id":"rockyGround","char":".","color":"#6a6a50","walkable":true,"transparent":true},"forestFloor":{"id":"forestFloor","char":".","color":"#2a4a1a","walkable":true,"transparent":true},"shallowWater":{"id":"shallowWater","char":"~","color":"#3a6abb","walkable":false,"transparent":true},"deadTree":{"id":"deadTree","char":"T","color":"#5a4a3a","walkable":false,"transparent":false},"cactus":{"id":"cactus","char":"Â¥","color":"#4a8a2a","walkable":false,"transparent":true},"snowTree":{"id":"snowTree","char":"T","color":"#6a8a7a","walkable":false,"transparent":false},"bush":{"id":"bush","char":"â™£","color":"#3a7a2a","walkable":false,"transparent":true},"berryBush":{"id":"berryBush","char":"â™£","color":"#8a3a6a","walkable":false,"transparent":true},"mushroomPatch":{"id":"mushroomPatch","char":"â™ ","color":"#aa7744","walkable":false,"transparent":true},"clayDeposit":{"id":"clayDeposit","char":"â—Š","color":"#b07050","walkable":false,"transparent":true},"sandDeposit":{"id":"sandDeposit","char":"â—Š","color":"#d8c878","walkable":false,"transparent":true},"flintNode":{"id":"flintNode","char":"â—","color":"#555544","walkable":false,"transparent":true},"reedPatch":{"id":"reedPatch","char":"â€–","color":"#8aaa5a","walkable":false,"transparent":true},"table":{"id":"table","char":"Ï€","color":"#8B5E3C","walkable":false,"transparent":true},"chair":{"id":"chair","char":"h","color":"#A0784C","walkable":true,"transparent":true},"bookshelf":{"id":"bookshelf","char":"â–","color":"#5C3A1E","walkable":false,"transparent":false},"barrel":{"id":"barrel","char":"â—‹","color":"#9B7E4F","walkable":false,"transparent":true},"crate":{"id":"crate","char":"â–¡","color":"#8B7340","walkable":false,"transparent":true},"carpet":{"id":"carpet","char":"Â·","color":"#8B2020","walkable":true,"transparent":true},"well":{"id":"well","char":"O","color":"#4A6A9A","walkable":false,"transparent":true},"fountain":{"id":"fountain","char":"â—Š","color":"#5A8AD0","walkable":false,"transparent":true},"counter":{"id":"counter","char":"â”€","color":"#7A5A3A","walkable":false,"transparent":true},"lamp":{"id":"lamp","char":"â˜¼","color":"#FFD700","walkable":false,"transparent":true},"fenceH":{"id":"fenceH","char":"â”€","color":"#8B6A3F","walkable":false,"transparent":true},"fenceV":{"id":"fenceV","char":"â”‚","color":"#8B6A3F","walkable":false,"transparent":true},"oven":{"id":"oven","char":"â–“","color":"#AA4422","walkable":false,"transparent":false},"bedTile":{"id":"bedTile","char":"â‰¡","color":"#6A4A8A","walkable":true,"transparent":true},"rugRed":{"id":"rugRed","char":"Â·","color":"#AA3030","walkable":true,"transparent":true},"rugBlue":{"id":"rugBlue","char":"Â·","color":"#3030AA","walkable":true,"transparent":true},"statue":{"id":"statue","char":"â™ ","color":"#C0C0C0","walkable":false,"transparent":true},"banner":{"id":"banner","char":"Â¶","color":"#CC2222","walkable":false,"transparent":true},"stoneFloor":{"id":"stoneFloor","char":".","color":"#7A7A7A","walkable":true,"transparent":true},"woodFloor":{"id":"woodFloor","char":".","color":"#9B7A50","walkable":true,"transparent":true}};
  SPELL_DEFS = {"magicArrow":{"id":"magicArrow","name":"Magic Arrow","type":"bolt","domain":"magic","attr":"MAG","baseCost":4,"basePower":8,"dice":"1d6","range":6,"difficulty":1,"description":"Fires a bolt of pure mana at a single target.","char":"*","color":"#c8f"},"iceBolt":{"id":"iceBolt","name":"Ice Bolt","type":"bolt","domain":"cold","attr":"MAG","baseCost":6,"basePower":12,"dice":"2d5","range":5,"difficulty":3,"description":"Hurls a bolt of freezing ice at a target.","char":"â—†","color":"#6cf"},"fireBolt":{"id":"fireBolt","name":"Fire Bolt","type":"bolt","domain":"fire","attr":"MAG","baseCost":7,"basePower":14,"dice":"2d6","range":5,"difficulty":4,"description":"Launches a searing bolt of fire.","char":"â—†","color":"#f64"},"lightningBolt":{"id":"lightningBolt","name":"Lightning Bolt","type":"bolt","domain":"lightning","attr":"MAG","baseCost":10,"basePower":18,"dice":"2d8","range":7,"difficulty":8,"description":"Strikes a target with a bolt of lightning.","char":"â†¯","color":"#ff4"},"darkBolt":{"id":"darkBolt","name":"Dark Bolt","type":"bolt","domain":"darkness","attr":"MAG","baseCost":9,"basePower":16,"dice":"2d7","range":5,"difficulty":7,"description":"Sends a bolt of dark energy at a target.","char":"â—†","color":"#a4f"},"fireBall":{"id":"fireBall","name":"Fire Ball","type":"ball","domain":"fire","attr":"MAG","baseCost":14,"basePower":20,"dice":"3d6","range":4,"radius":2,"difficulty":10,"description":"Conjures an explosive ball of fire. Hits all in the area!","char":"â˜¼","color":"#f84"},"iceBall":{"id":"iceBall","name":"Ice Ball","type":"ball","domain":"cold","attr":"MAG","baseCost":12,"basePower":16,"dice":"2d8","range":4,"radius":2,"difficulty":8,"description":"Creates a freezing explosion. Hits all in the area!","char":"â˜¼","color":"#8ef"},"chaosBall":{"id":"chaosBall","name":"Chaos Ball","type":"ball","domain":"chaos","attr":"MAG","baseCost":18,"basePower":25,"dice":"3d8","range":4,"radius":2,"difficulty":15,"description":"Unleashes chaotic energy in an area. Devastating!","char":"â˜¼","color":"#f0f"},"heal":{"id":"heal","name":"Heal","type":"heal","domain":"holy","attr":"WIL","baseCost":5,"basePower":15,"dice":"2d6","difficulty":1,"description":"Restores your health with divine energy.","char":"+","color":"#4f4"},"healCritical":{"id":"healCritical","name":"Heal Critical","type":"heal","domain":"holy","attr":"WIL","baseCost":12,"basePower":35,"dice":"4d8","difficulty":8,"description":"Powerful healing magic. Restores a large amount of HP.","char":"+","color":"#2f2"},"holyLight":{"id":"holyLight","name":"Holy Light","type":"bolt","domain":"holy","attr":"WIL","baseCost":8,"basePower":14,"dice":"2d6","range":6,"difficulty":5,"description":"A beam of holy light that smites the unholy.","char":"âœ¦","color":"#ffa"},"holyVeil":{"id":"holyVeil","name":"Holy Veil","type":"buff","domain":"holy","attr":"WIL","baseCost":10,"basePower":0,"difficulty":6,"duration":20,"buffType":"holyVeil","description":"Surrounds you with a protective holy aura. +PV for a time.","char":"â—‹","color":"#ffa"},"mist":{"id":"mist","name":"Mist of Silence","type":"buff","domain":"mind","attr":"WIL","baseCost":8,"basePower":0,"difficulty":5,"duration":15,"buffType":"mistSilence","description":"Wraps you in mist, boosting evasion. +DV for a time.","char":"~","color":"#aaf"},"speed":{"id":"speed","name":"Speed","type":"buff","domain":"magic","attr":"MAG","baseCost":12,"basePower":0,"difficulty":7,"duration":25,"buffType":"speed","description":"Hastens your movements. +Speed for a time.","char":"Â»","color":"#4ff"},"teleport":{"id":"teleport","name":"Teleport","type":"teleport","domain":"chaos","attr":"MAG","baseCost":8,"basePower":0,"difficulty":4,"description":"Randomly teleports you to another location on the map.","char":"Â¤","color":"#f8f"},"shortTeleport":{"id":"shortTeleport","name":"Short Teleport","type":"teleport","domain":"magic","attr":"MAG","baseCost":4,"basePower":0,"difficulty":2,"description":"Teleports you a short distance away.","char":"Â¤","color":"#88f"},"touchOfWeakness":{"id":"touchOfWeakness","name":"Touch of Weakness","type":"bolt","domain":"nerve","attr":"MAG","baseCost":5,"basePower":6,"dice":"1d8","range":1,"difficulty":3,"description":"A touch that saps the target's strength.","char":"â˜ ","color":"#a6a"},"acidGround":{"id":"acidGround","name":"Acid Ground","type":"ball","domain":"poison","attr":"MAG","baseCost":10,"basePower":10,"dice":"2d5","range":4,"radius":2,"difficulty":6,"description":"Spreads corrosive acid across an area.","char":"â˜¼","color":"#6f0"},"magicStorm":{"id":"magicStorm","name":"Magic Storm","type":"ball","domain":"magic","attr":"MAG","baseCost":22,"basePower":30,"dice":"4d8","range":5,"radius":3,"difficulty":18,"description":"Calls down a devastating storm of pure magic.","char":"â˜¼","color":"#f4f"}};
  CROP_DEFS = {"turnip":{"id":"turnip","name":"Turnip","seedId":"seedTurnip","harvestId":"cropTurnip","growthTime":80,"stages":4,"seasons":["spring","autumn"],"baseYield":2,"difficulty":1,"chars":[".","Â·","â™£","â™£","Î¨"],"colors":["#654","#6a4","#4a2","#3a3","#2d2"],"description":"A hardy root vegetable. Grows fast and easy."},"potato":{"id":"potato","name":"Potato","seedId":"seedPotato","harvestId":"cropPotato","growthTime":120,"stages":4,"seasons":["spring","summer"],"baseYield":3,"difficulty":2,"chars":[".","Â·","â™£","â™£","Î¨"],"colors":["#654","#6a4","#5a3","#4a3","#4c2"],"description":"A filling tuber that grows underground."},"strawberry":{"id":"strawberry","name":"Strawberry","seedId":"seedStrawberry","harvestId":"cropStrawberry","growthTime":100,"stages":4,"seasons":["spring","summer"],"baseYield":2,"difficulty":3,"chars":[".","Â·","â™£","â€","â‚"],"colors":["#654","#6a4","#4a2","#a44","#d44"],"description":"Sweet red berries. Loved by all."},"corn":{"id":"corn","name":"Corn","seedId":"seedCorn","harvestId":"cropCorn","growthTime":150,"stages":4,"seasons":["summer"],"baseYield":3,"difficulty":3,"chars":[".","Â·","â€ ","â€¡","Î¨"],"colors":["#654","#6a4","#5a2","#6a3","#cc4"],"description":"Tall stalks of golden corn. Best in summer."},"tomato":{"id":"tomato","name":"Tomato","seedId":"seedTomato","harvestId":"cropTomato","growthTime":110,"stages":4,"seasons":["summer","autumn"],"baseYield":2,"difficulty":2,"chars":[".","Â·","â™£","â™£","â—"],"colors":["#654","#6a4","#4a2","#5a3","#e32"],"description":"Juicy red fruit. Versatile and nutritious."},"carrot":{"id":"carrot","name":"Carrot","seedId":"seedCarrot","harvestId":"cropCarrot","growthTime":90,"stages":4,"seasons":["spring","autumn"],"baseYield":2,"difficulty":1,"chars":[".","Â·","â™£","â™£","â†‘"],"colors":["#654","#6a4","#4a2","#3a3","#e82"],"description":"An orange root vegetable full of vitamins."},"herb":{"id":"herb","name":"Medicinal Herb","seedId":"seedHerb","harvestId":"cropHerb","growthTime":60,"stages":4,"seasons":["spring","summer","autumn"],"baseYield":1,"difficulty":2,"chars":[".","Â·","â™£","â™ ","â™ "],"colors":["#654","#6a4","#4a2","#2a4","#0c0"],"description":"A healing herb. Restores HP when eaten."},"pumpkin":{"id":"pumpkin","name":"Pumpkin","seedId":"seedPumpkin","harvestId":"cropPumpkin","growthTime":180,"stages":4,"seasons":["autumn"],"baseYield":1,"difficulty":4,"chars":[".","Â·","â™£","â™£","â—‰"],"colors":["#654","#6a4","#4a2","#6a3","#e80"],"description":"A large gourd. Takes long to grow but very filling."},"wheat":{"id":"wheat","name":"Wheat","seedId":"seedWheat","harvestId":"cropWheat","growthTime":140,"stages":4,"seasons":["summer","autumn"],"baseYield":4,"difficulty":2,"chars":[".","Â·","â€ ","â€¡","Î¨"],"colors":["#654","#6a4","#5a2","#8a3","#da4"],"description":"Golden grain for making bread."}};
  SHOP_DEFS = {"generalStore":{"id":"generalStore","name":"General Store","char":"$","color":"#ffd700","npcName":"Shopkeeper","buyMarkup":1.5,"sellMarkdown":0.3,"inventory":[{"itemId":"ration","stock":10,"restockRate":5},{"itemId":"bread","stock":8,"restockRate":4},{"itemId":"potionHeal","stock":5,"restockRate":2},{"itemId":"potionMana","stock":3,"restockRate":1},{"itemId":"herbGreen","stock":6,"restockRate":3},{"itemId":"woodenShield","stock":2,"restockRate":1},{"itemId":"leatherBoots","stock":2,"restockRate":1},{"itemId":"seedTurnip","stock":5,"restockRate":3},{"itemId":"seedPotato","stock":4,"restockRate":2},{"itemId":"seedCarrot","stock":3,"restockRate":2},{"itemId":"torch","stock":5,"restockRate":3},{"itemId":"lantern","stock":2,"restockRate":1}]},"blacksmith":{"id":"blacksmith","name":"Blacksmith","char":"&","color":"#ff8844","npcName":"Smith","buyMarkup":1.3,"sellMarkdown":0.4,"inventory":[{"itemId":"dagger","stock":3,"restockRate":1},{"itemId":"longSword","stock":2,"restockRate":1},{"itemId":"battleAxe","stock":1,"restockRate":1},{"itemId":"woodenMace","stock":2,"restockRate":1},{"itemId":"shortBow","stock":2,"restockRate":1},{"itemId":"oakStaff","stock":2,"restockRate":1},{"itemId":"leatherArmor","stock":2,"restockRate":1},{"itemId":"chainMail","stock":1,"restockRate":0},{"itemId":"ironHelm","stock":2,"restockRate":1},{"itemId":"oreIron","stock":6,"restockRate":3},{"itemId":"oreCopper","stock":8,"restockRate":4},{"itemId":"hatchet","stock":2,"restockRate":1},{"itemId":"ironAxeTool","stock":1,"restockRate":1},{"itemId":"stonePickaxe","stock":2,"restockRate":1},{"itemId":"ironPickaxe","stock":1,"restockRate":1}]},"magicShop":{"id":"magicShop","name":"Magic Shop","char":"â˜…","color":"#c8f","npcName":"Mage","buyMarkup":1.8,"sellMarkdown":0.35,"inventory":[{"itemId":"spellbookMagicArrow","stock":2,"restockRate":1},{"itemId":"spellbookIceBolt","stock":1,"restockRate":0},{"itemId":"spellbookFireBolt","stock":1,"restockRate":0},{"itemId":"spellbookHeal","stock":2,"restockRate":1},{"itemId":"spellbookShortTeleport","stock":1,"restockRate":1},{"itemId":"spellbookHolyLight","stock":1,"restockRate":0},{"itemId":"spellbookSpeed","stock":1,"restockRate":0},{"itemId":"potionMana","stock":5,"restockRate":3},{"itemId":"potionHeal","stock":3,"restockRate":2},{"itemId":"scrollEnchant","stock":2,"restockRate":1},{"itemId":"scrollEnchantArmor","stock":2,"restockRate":1},{"itemId":"scrollGreaterEnchant","stock":1,"restockRate":0},{"itemId":"scrollFireEnchant","stock":1,"restockRate":0},{"itemId":"scrollIceEnchant","stock":1,"restockRate":0},{"itemId":"magicLight","stock":1,"restockRate":0}]},"farmSupply":{"id":"farmSupply","name":"Farm Supply","char":"â™£","color":"#4a4","npcName":"Farmer","buyMarkup":1.2,"sellMarkdown":0.5,"inventory":[{"itemId":"seedTurnip","stock":10,"restockRate":5},{"itemId":"seedPotato","stock":8,"restockRate":4},{"itemId":"seedCarrot","stock":6,"restockRate":3},{"itemId":"seedCorn","stock":5,"restockRate":2},{"itemId":"seedTomato","stock":5,"restockRate":2},{"itemId":"seedStrawberry","stock":3,"restockRate":1},{"itemId":"seedHerb","stock":4,"restockRate":2},{"itemId":"seedPumpkin","stock":3,"restockRate":1},{"itemId":"seedWheat","stock":6,"restockRate":3},{"itemId":"bread","stock":5,"restockRate":3},{"itemId":"ration","stock":5,"restockRate":3}]},"tavern":{"id":"tavern","name":"Tavern","char":"â™ª","color":"#da4","npcName":"Barkeep","buyMarkup":1.6,"sellMarkdown":0.25,"inventory":[{"itemId":"ration","stock":15,"restockRate":8},{"itemId":"bread","stock":10,"restockRate":5},{"itemId":"herbGreen","stock":5,"restockRate":3},{"itemId":"potionHeal","stock":3,"restockRate":1}]},"furnitureShop":{"id":"furnitureShop","name":"Furniture Shop","char":"â‰¡","color":"#a07040","npcName":"Carpenter","buyMarkup":1.4,"sellMarkdown":0.3,"inventory":[{"itemId":"bedroll","stock":3,"restockRate":2},{"itemId":"strawMat","stock":2,"restockRate":1},{"itemId":"woodenBed","stock":2,"restockRate":1},{"itemId":"comfortableBed","stock":1,"restockRate":0},{"itemId":"royalBed","stock":1,"restockRate":0},{"itemId":"workshopCrudeWorkbench","stock":2,"restockRate":1},{"itemId":"workshopCampfire","stock":2,"restockRate":1},{"itemId":"workshopCarpentryBench","stock":1,"restockRate":0},{"itemId":"workshopAnvil","stock":1,"restockRate":0}]}};
  RECIPE_DEFS = {"craftCrudeWorkbench":{"id":"craftCrudeWorkbench","name":"Build Crude Workbench","skill":"crafting","skillReq":1,"level":1,"difficulty":1,"workshop":null,"defaultKnown":true,"ingredients":[{"itemId":"woodLog","count":3},{"itemId":"flint","count":2}],"result":{"itemId":"workshopCrudeWorkbench","count":1},"xpGain":10},"craftCampfire":{"id":"craftCampfire","name":"Build Campfire","skill":"crafting","skillReq":1,"level":1,"difficulty":1,"workshop":null,"defaultKnown":true,"ingredients":[{"itemId":"woodLog","count":3},{"itemId":"flint","count":2}],"result":{"itemId":"workshopCampfire","count":1},"xpGain":10},"craftString":{"id":"craftString","name":"Craft String from Reeds","skill":"crafting","skillReq":1,"level":1,"difficulty":1,"workshop":"crudeWorkbench","defaultKnown":true,"ingredients":[{"itemId":"reeds","count":2}],"result":{"itemId":"string","count":2},"xpGain":5},"craftStonePickaxe":{"id":"craftStonePickaxe","name":"Craft Stone Pickaxe","skill":"crafting","skillReq":1,"level":1,"difficulty":1,"workshop":"crudeWorkbench","defaultKnown":true,"ingredients":[{"itemId":"flint","count":2},{"itemId":"woodLog","count":1}],"result":{"itemId":"stonePickaxe","count":1},"xpGain":8},"craftTorch":{"id":"craftTorch","name":"Craft Torch","skill":"crafting","skillReq":1,"level":1,"difficulty":1,"workshop":"crudeWorkbench","defaultKnown":true,"ingredients":[{"itemId":"woodLog","count":1},{"itemId":"reeds","count":1}],"result":{"itemId":"torch","count":2},"xpGain":5},"craftGlass":{"id":"craftGlass","name":"Craft Empty Bottles","skill":"crafting","skillReq":2,"level":2,"difficulty":3,"workshop":"crudeWorkbench","ingredients":[{"itemId":"sand","count":3}],"result":{"itemId":"emptyBottle","count":2},"xpGain":12},"craftLeatherBoots":{"id":"craftLeatherBoots","name":"Craft Leather Boots","skill":"crafting","skillReq":1,"level":1,"difficulty":2,"workshop":"crudeWorkbench","ingredients":[{"itemId":"leather","count":1}],"result":{"itemId":"leatherBoots","count":1},"xpGain":10},"craftLeatherArmor":{"id":"craftLeatherArmor","name":"Craft Leather Armor","skill":"crafting","skillReq":2,"level":2,"difficulty":4,"workshop":"crudeWorkbench","ingredients":[{"itemId":"leather","count":3}],"result":{"itemId":"leatherArmor","count":1},"xpGain":20},"craftBedroll":{"id":"craftBedroll","name":"Craft Bedroll","skill":"crafting","skillReq":1,"level":1,"difficulty":1,"workshop":"crudeWorkbench","ingredients":[{"itemId":"reeds","count":3},{"itemId":"leather","count":1}],"result":{"itemId":"bedroll","count":1},"xpGain":8},"craftCarpentryBench":{"id":"craftCarpentryBench","name":"Build Carpentry Bench","skill":"carpentry","skillReq":2,"level":2,"difficulty":3,"workshop":"crudeWorkbench","ingredients":[{"itemId":"woodLog","count":5},{"itemId":"oreIron","count":2}],"result":{"itemId":"workshopCarpentryBench","count":1},"xpGain":20},"craftAnvil":{"id":"craftAnvil","name":"Build Anvil","skill":"blacksmith","skillReq":2,"level":2,"difficulty":3,"workshop":"crudeWorkbench","ingredients":[{"itemId":"oreIron","count":5},{"itemId":"oreCopper","count":2}],"result":{"itemId":"workshopAnvil","count":1},"xpGain":25},"craftCookingStation":{"id":"craftCookingStation","name":"Build Cooking Station","skill":"cooking","skillReq":2,"level":2,"difficulty":3,"workshop":"crudeWorkbench","ingredients":[{"itemId":"oreIron","count":3},{"itemId":"clay","count":4},{"itemId":"woodLog","count":2}],"result":{"itemId":"workshopCookingStation","count":1},"xpGain":20},"craftAlchemyLab":{"id":"craftAlchemyLab","name":"Build Alchemy Lab","skill":"alchemy","skillReq":2,"level":2,"difficulty":4,"workshop":"crudeWorkbench","ingredients":[{"itemId":"sand","count":3},{"itemId":"crystalBlue","count":2},{"itemId":"woodLog","count":2}],"result":{"itemId":"workshopAlchemyLab","count":1},"xpGain":25},"craftSculptorStation":{"id":"craftSculptorStation","name":"Build Sculptor Station","skill":"sculpting","skillReq":2,"level":2,"difficulty":3,"workshop":"crudeWorkbench","ingredients":[{"itemId":"clay","count":5},{"itemId":"flint","count":3}],"result":{"itemId":"workshopSculptorStation","count":1},"xpGain":15},"craftWoodenShield":{"id":"craftWoodenShield","name":"Craft Wooden Shield","skill":"carpentry","skillReq":2,"level":2,"difficulty":3,"workshop":"carpentryBench","ingredients":[{"itemId":"woodLog","count":3}],"result":{"itemId":"woodenShield","count":1},"xpGain":15},"craftOakStaff":{"id":"craftOakStaff","name":"Carve Oak Staff","skill":"carpentry","skillReq":3,"level":3,"difficulty":4,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2}],"result":{"itemId":"oakStaff","count":1},"xpGain":15},"craftShortBow":{"id":"craftShortBow","name":"Craft Short Bow","skill":"carpentry","skillReq":4,"level":4,"difficulty":5,"workshop":"carpentryBench","ingredients":[{"itemId":"woodLog","count":2},{"itemId":"string","count":1}],"result":{"itemId":"shortBow","count":1},"xpGain":20},"craftStrawMat":{"id":"craftStrawMat","name":"Craft Straw Mat","skill":"carpentry","skillReq":2,"level":2,"difficulty":2,"workshop":"carpentryBench","ingredients":[{"itemId":"reeds","count":4},{"itemId":"string","count":2}],"result":{"itemId":"strawMat","count":1},"xpGain":10},"craftWoodenBed":{"id":"craftWoodenBed","name":"Craft Wooden Bed","skill":"carpentry","skillReq":4,"level":4,"difficulty":5,"workshop":"carpentryBench","ingredients":[{"itemId":"woodLog","count":4},{"itemId":"string","count":2},{"itemId":"leather","count":1}],"result":{"itemId":"woodenBed","count":1},"xpGain":25},"craftComfortableBed":{"id":"craftComfortableBed","name":"Craft Comfortable Bed","skill":"carpentry","skillReq":6,"level":6,"difficulty":8,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":3},{"itemId":"leather","count":3},{"itemId":"string","count":3}],"result":{"itemId":"comfortableBed","count":1},"xpGain":40},"craftRoyalBed":{"id":"craftRoyalBed","name":"Craft Royal Bed","skill":"carpentry","skillReq":10,"level":10,"difficulty":14,"workshop":"carpentryBench","ingredients":[{"itemId":"mapleLog","count":4},{"itemId":"oreSilver","count":3},{"itemId":"leather","count":4},{"itemId":"string","count":3}],"result":{"itemId":"royalBed","count":1},"xpGain":80},"craftLoom":{"id":"craftLoom","name":"Build Loom","skill":"carpentry","skillReq":3,"level":3,"difficulty":4,"workshop":"carpentryBench","ingredients":[{"itemId":"woodLog","count":4},{"itemId":"string","count":4}],"result":{"itemId":"workshopLoom","count":1},"xpGain":20},"craftJewelerTable":{"id":"craftJewelerTable","name":"Build Jeweler Table","skill":"carpentry","skillReq":3,"level":3,"difficulty":5,"workshop":"carpentryBench","ingredients":[{"itemId":"woodLog","count":3},{"itemId":"oreSilver","count":2},{"itemId":"crystalBlue","count":1}],"result":{"itemId":"workshopJewelerTable","count":1},"xpGain":25},"craftDagger":{"id":"craftDagger","name":"Forge Dagger","skill":"blacksmith","skillReq":1,"level":1,"difficulty":2,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":1}],"result":{"itemId":"dagger","count":1},"xpGain":10},"craftSword":{"id":"craftSword","name":"Forge Long Sword","skill":"blacksmith","skillReq":3,"level":3,"difficulty":5,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":3},{"itemId":"woodLog","count":1}],"result":{"itemId":"longSword","count":1},"xpGain":25},"craftAxe":{"id":"craftAxe","name":"Forge Battle Axe","skill":"blacksmith","skillReq":5,"level":5,"difficulty":8,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":4},{"itemId":"woodLog","count":2}],"result":{"itemId":"battleAxe","count":1},"xpGain":40},"craftMace":{"id":"craftMace","name":"Forge Wooden Mace","skill":"blacksmith","skillReq":2,"level":2,"difficulty":3,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":1},{"itemId":"woodLog","count":2}],"result":{"itemId":"woodenMace","count":1},"xpGain":15},"craftIronHelm":{"id":"craftIronHelm","name":"Forge Iron Helm","skill":"blacksmith","skillReq":4,"level":4,"difficulty":6,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":2}],"result":{"itemId":"ironHelm","count":1},"xpGain":20},"craftChainMail":{"id":"craftChainMail","name":"Forge Chain Mail","skill":"blacksmith","skillReq":8,"level":8,"difficulty":12,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":6}],"result":{"itemId":"chainMail","count":1},"xpGain":60},"craftHatchet":{"id":"craftHatchet","name":"Forge Hatchet","skill":"blacksmith","skillReq":1,"level":1,"difficulty":2,"workshop":"anvil","ingredients":[{"itemId":"oreCopper","count":2},{"itemId":"woodLog","count":1}],"result":{"itemId":"hatchet","count":1},"xpGain":10},"craftIronAxeTool":{"id":"craftIronAxeTool","name":"Forge Iron Axe","skill":"blacksmith","skillReq":3,"level":3,"difficulty":5,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":3},{"itemId":"oakLog","count":1}],"result":{"itemId":"ironAxeTool","count":1},"xpGain":20},"craftIronPickaxe":{"id":"craftIronPickaxe","name":"Forge Iron Pickaxe","skill":"blacksmith","skillReq":3,"level":3,"difficulty":5,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":3},{"itemId":"oakLog","count":1}],"result":{"itemId":"ironPickaxe","count":1},"xpGain":20},"craftSteelAxeTool":{"id":"craftSteelAxeTool","name":"Forge Steel Axe","skill":"blacksmith","skillReq":6,"level":6,"difficulty":10,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":4},{"itemId":"oreCopper","count":2},{"itemId":"mapleLog","count":1}],"result":{"itemId":"steelAxeTool","count":1},"xpGain":40},"craftSteelPickaxe":{"id":"craftSteelPickaxe","name":"Forge Steel Pickaxe","skill":"blacksmith","skillReq":6,"level":6,"difficulty":10,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":4},{"itemId":"oreCopper","count":2},{"itemId":"mapleLog","count":1}],"result":{"itemId":"steelPickaxe","count":1},"xpGain":40},"craftLantern":{"id":"craftLantern","name":"Forge Lantern","skill":"blacksmith","skillReq":3,"level":3,"difficulty":4,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":2},{"itemId":"emptyBottle","count":1}],"result":{"itemId":"lantern","count":1},"xpGain":15},"craftForge":{"id":"craftForge","name":"Build Forge","skill":"blacksmith","skillReq":6,"level":6,"difficulty":10,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":8},{"itemId":"oreSilver","count":3},{"itemId":"clay","count":5}],"result":{"itemId":"workshopForge","count":1},"xpGain":60},"craftMythrilAxeTool":{"id":"craftMythrilAxeTool","name":"Forge Mythril Axe","skill":"blacksmith","skillReq":10,"level":10,"difficulty":16,"workshop":"forge","ingredients":[{"itemId":"oreMythril","count":3},{"itemId":"yewLog","count":1}],"result":{"itemId":"mythrilAxeTool","count":1},"xpGain":80},"craftMythrilPickaxe":{"id":"craftMythrilPickaxe","name":"Forge Mythril Pickaxe","skill":"blacksmith","skillReq":10,"level":10,"difficulty":16,"workshop":"forge","ingredients":[{"itemId":"oreMythril","count":3},{"itemId":"yewLog","count":1}],"result":{"itemId":"mythrilPickaxe","count":1},"xpGain":80},"cookBread":{"id":"cookBread","name":"Bake Bread","skill":"cooking","skillReq":1,"level":1,"difficulty":1,"workshop":"campfire","defaultKnown":true,"ingredients":[{"itemId":"cropWheat","count":2}],"result":{"itemId":"bread","count":2},"xpGain":8},"cookRation":{"id":"cookRation","name":"Prepare Ration","skill":"cooking","skillReq":1,"level":1,"difficulty":1,"workshop":"campfire","ingredients":[{"itemId":"bread","count":1},{"itemId":"cropCarrot","count":1}],"result":{"itemId":"ration","count":2},"xpGain":10},"cookFish":{"id":"cookFish","name":"Cook Fish","skill":"cooking","skillReq":2,"level":2,"difficulty":2,"workshop":"campfire","ingredients":[{"itemId":"rawFish","count":1}],"result":{"itemId":"ration","count":1},"xpGain":8},"cookFeast":{"id":"cookFeast","name":"Cook Grand Feast","skill":"cooking","skillReq":6,"level":6,"difficulty":8,"workshop":"cookingStation","ingredients":[{"itemId":"cropCorn","count":1},{"itemId":"cropTomato","count":1},{"itemId":"cropPotato","count":1}],"result":{"itemId":"grandFeast","count":1},"xpGain":30},"brewBerryPotion":{"id":"brewBerryPotion","name":"Brew Berry Potion","skill":"alchemy","skillReq":1,"level":1,"difficulty":2,"workshop":"alchemyLab","ingredients":[{"itemId":"berryRed","count":3},{"itemId":"emptyBottle","count":1}],"result":{"itemId":"potionHeal","count":1},"xpGain":10},"brewPotionHeal":{"id":"brewPotionHeal","name":"Brew Healing Potion","skill":"alchemy","skillReq":2,"level":2,"difficulty":3,"workshop":"alchemyLab","ingredients":[{"itemId":"herbGreen","count":2},{"itemId":"emptyBottle","count":1}],"result":{"itemId":"potionHeal","count":1},"xpGain":15},"brewPotionMana":{"id":"brewPotionMana","name":"Brew Mana Potion","skill":"alchemy","skillReq":4,"level":4,"difficulty":5,"workshop":"alchemyLab","ingredients":[{"itemId":"crystalBlue","count":1},{"itemId":"emptyBottle","count":1}],"result":{"itemId":"potionMana","count":1},"xpGain":20},"craftCloth":{"id":"craftCloth","name":"Weave Cloth","skill":"weaving","skillReq":1,"level":1,"difficulty":1,"workshop":"loom","defaultKnown":true,"ingredients":[{"itemId":"string","count":3}],"result":{"itemId":"cloth","count":2},"xpGain":8},"craftPlanks":{"id":"craftPlanks","name":"Cut Planks","skill":"carpentry","skillReq":2,"level":2,"difficulty":1,"workshop":"carpentryBench","defaultKnown":true,"ingredients":[{"itemId":"woodLog","count":1}],"result":{"itemId":"plank","count":3},"xpGain":5},"craftOakPlanks":{"id":"craftOakPlanks","name":"Cut Oak Planks","skill":"carpentry","skillReq":3,"level":3,"difficulty":2,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":1}],"result":{"itemId":"plank","count":4},"xpGain":8},"craftWoodenStool":{"id":"craftWoodenStool","name":"Craft Wooden Stool","skill":"carpentry","skillReq":2,"level":2,"difficulty":2,"workshop":"carpentryBench","defaultKnown":true,"ingredients":[{"itemId":"plank","count":3}],"result":{"itemId":"woodenStool","count":1},"xpGain":8},"craftSignpost":{"id":"craftSignpost","name":"Craft Signpost","skill":"carpentry","skillReq":2,"level":2,"difficulty":1,"workshop":"carpentryBench","defaultKnown":true,"ingredients":[{"itemId":"plank","count":2}],"result":{"itemId":"signpost","count":1},"xpGain":5},"craftWoodenFence":{"id":"craftWoodenFence","name":"Craft Wooden Fence","skill":"carpentry","skillReq":2,"level":2,"difficulty":1,"workshop":"carpentryBench","defaultKnown":true,"ingredients":[{"itemId":"plank","count":2}],"result":{"itemId":"woodenFence","count":2},"xpGain":5},"craftSmallTable":{"id":"craftSmallTable","name":"Craft Small Table","skill":"carpentry","skillReq":2,"level":2,"difficulty":2,"workshop":"carpentryBench","defaultKnown":true,"ingredients":[{"itemId":"plank","count":4}],"result":{"itemId":"smallTable","count":1},"xpGain":10},"craftWoodenCrate":{"id":"craftWoodenCrate","name":"Craft Wooden Crate","skill":"carpentry","skillReq":2,"level":2,"difficulty":2,"workshop":"carpentryBench","defaultKnown":true,"ingredients":[{"itemId":"plank","count":4}],"result":{"itemId":"woodenCrate","count":1},"xpGain":8},"craftWoodenChair":{"id":"craftWoodenChair","name":"Craft Wooden Chair","skill":"carpentry","skillReq":3,"level":3,"difficulty":3,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":4},{"itemId":"woodLog","count":1}],"result":{"itemId":"woodenChair","count":1},"xpGain":12},"craftBarrel":{"id":"craftBarrel","name":"Craft Barrel","skill":"carpentry","skillReq":3,"level":3,"difficulty":3,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":5},{"itemId":"oreIron","count":1}],"result":{"itemId":"barrel","count":1},"xpGain":12},"craftWoodenShelfUnit":{"id":"craftWoodenShelfUnit","name":"Craft Wooden Shelf","skill":"carpentry","skillReq":3,"level":3,"difficulty":3,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":5},{"itemId":"oreIron","count":1}],"result":{"itemId":"woodenShelfUnit","count":1},"xpGain":12},"craftWoodenBench":{"id":"craftWoodenBench","name":"Craft Wooden Bench","skill":"carpentry","skillReq":3,"level":3,"difficulty":3,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":5},{"itemId":"woodLog","count":1}],"result":{"itemId":"woodenBench","count":1},"xpGain":12},"craftFlowerPot":{"id":"craftFlowerPot","name":"Craft Flower Pot","skill":"sculpting","skillReq":2,"level":2,"difficulty":2,"workshop":"sculptorStation","ingredients":[{"itemId":"clay","count":2}],"result":{"itemId":"flowerPot","count":1},"xpGain":10},"craftPlantPot":{"id":"craftPlantPot","name":"Craft Potted Fern","skill":"sculpting","skillReq":2,"level":2,"difficulty":2,"workshop":"sculptorStation","ingredients":[{"itemId":"clay","count":2},{"itemId":"reeds","count":1}],"result":{"itemId":"plantPot","count":1},"xpGain":10},"craftWovenRug":{"id":"craftWovenRug","name":"Weave Rug","skill":"weaving","skillReq":2,"level":2,"difficulty":3,"workshop":"loom","ingredients":[{"itemId":"cloth","count":3},{"itemId":"string","count":2}],"result":{"itemId":"wovenRug","count":1},"xpGain":15},"craftDiningTable":{"id":"craftDiningTable","name":"Craft Dining Table","skill":"carpentry","skillReq":4,"level":4,"difficulty":5,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":6},{"itemId":"woodLog","count":2}],"result":{"itemId":"diningTable","count":1},"xpGain":20},"craftBookshelf":{"id":"craftBookshelf","name":"Craft Bookshelf","skill":"carpentry","skillReq":4,"level":4,"difficulty":5,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":6},{"itemId":"oreIron","count":2}],"result":{"itemId":"bookshelf","count":1},"xpGain":20},"craftWoodenChest":{"id":"craftWoodenChest","name":"Craft Wooden Chest","skill":"carpentry","skillReq":4,"level":4,"difficulty":4,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":5},{"itemId":"oreIron","count":2}],"result":{"itemId":"woodenChest","count":1},"xpGain":18},"craftPaintingFrame":{"id":"craftPaintingFrame","name":"Craft Painting","skill":"carpentry","skillReq":4,"level":4,"difficulty":4,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":3},{"itemId":"cloth","count":2}],"result":{"itemId":"paintingFrame","count":1},"xpGain":18},"craftDiningChairSet":{"id":"craftDiningChairSet","name":"Craft Dining Chair Set","skill":"carpentry","skillReq":4,"level":4,"difficulty":5,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":8},{"itemId":"oakLog","count":2}],"result":{"itemId":"diningChairSet","count":1},"xpGain":22},"craftOakChair":{"id":"craftOakChair","name":"Craft Oak Chair","skill":"carpentry","skillReq":5,"level":5,"difficulty":6,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"plank","count":3}],"result":{"itemId":"oakChair","count":1},"xpGain":25},"craftWeaponRack":{"id":"craftWeaponRack","name":"Craft Weapon Rack","skill":"carpentry","skillReq":5,"level":5,"difficulty":6,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"oreIron","count":3}],"result":{"itemId":"weaponRack","count":1},"xpGain":25},"craftArmorStand":{"id":"craftArmorStand","name":"Craft Armor Stand","skill":"carpentry","skillReq":5,"level":5,"difficulty":6,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"oreIron","count":2}],"result":{"itemId":"armorStand","count":1},"xpGain":25},"craftDresser":{"id":"craftDresser","name":"Craft Dresser","skill":"carpentry","skillReq":5,"level":5,"difficulty":6,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"plank","count":4},{"itemId":"oreIron","count":1}],"result":{"itemId":"dresser","count":1},"xpGain":25},"craftWritingDesk":{"id":"craftWritingDesk","name":"Craft Writing Desk","skill":"carpentry","skillReq":5,"level":5,"difficulty":6,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"plank","count":4},{"itemId":"leather","count":1}],"result":{"itemId":"writingDesk","count":1},"xpGain":25},"craftKitchenCounter":{"id":"craftKitchenCounter","name":"Craft Kitchen Counter","skill":"carpentry","skillReq":5,"level":5,"difficulty":6,"workshop":"carpentryBench","ingredients":[{"itemId":"plank","count":4},{"itemId":"clay","count":3}],"result":{"itemId":"kitchenCounter","count":1},"xpGain":22},"craftMapTable":{"id":"craftMapTable","name":"Craft Map Table","skill":"carpentry","skillReq":5,"level":5,"difficulty":7,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"plank","count":4},{"itemId":"leather","count":2}],"result":{"itemId":"mapTable","count":1},"xpGain":28},"craftOakDiningTable":{"id":"craftOakDiningTable","name":"Craft Oak Dining Table","skill":"carpentry","skillReq":6,"level":6,"difficulty":8,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":3},{"itemId":"plank","count":6}],"result":{"itemId":"oakDiningTable","count":1},"xpGain":35},"craftCandelabra":{"id":"craftCandelabra","name":"Forge Candelabra","skill":"blacksmith","skillReq":4,"level":4,"difficulty":6,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":3},{"itemId":"oreCopper","count":2}],"result":{"itemId":"candelabra","count":1},"xpGain":20},"craftIronChandelier":{"id":"craftIronChandelier","name":"Forge Iron Chandelier","skill":"blacksmith","skillReq":5,"level":5,"difficulty":8,"workshop":"anvil","ingredients":[{"itemId":"oreIron","count":5},{"itemId":"oreCopper","count":2}],"result":{"itemId":"ironChandelier","count":1},"xpGain":30},"craftWineRack":{"id":"craftWineRack","name":"Craft Wine Rack","skill":"carpentry","skillReq":6,"level":6,"difficulty":7,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"plank","count":5}],"result":{"itemId":"wineRack","count":1},"xpGain":30},"craftCushionedChair":{"id":"craftCushionedChair","name":"Craft Cushioned Chair","skill":"carpentry","skillReq":7,"level":7,"difficulty":9,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":2},{"itemId":"cloth","count":3},{"itemId":"leather","count":1}],"result":{"itemId":"cushionedChair","count":1},"xpGain":35},"craftWardrobe":{"id":"craftWardrobe","name":"Craft Wardrobe","skill":"carpentry","skillReq":7,"level":7,"difficulty":9,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":3},{"itemId":"plank","count":5},{"itemId":"oreIron","count":2}],"result":{"itemId":"wardrobe","count":1},"xpGain":35},"craftWallTapestry":{"id":"craftWallTapestry","name":"Weave Wall Tapestry","skill":"weaving","skillReq":5,"level":5,"difficulty":7,"workshop":"loom","ingredients":[{"itemId":"cloth","count":5},{"itemId":"string","count":4}],"result":{"itemId":"wallTapestry","count":1},"xpGain":30},"craftBearskinRug":{"id":"craftBearskinRug","name":"Craft Bearskin Rug","skill":"crafting","skillReq":5,"level":5,"difficulty":6,"workshop":"crudeWorkbench","ingredients":[{"itemId":"leather","count":5},{"itemId":"string","count":3}],"result":{"itemId":"bearskinRug","count":1},"xpGain":25},"craftStonePillar":{"id":"craftStonePillar","name":"Carve Stone Pillar","skill":"sculpting","skillReq":4,"level":4,"difficulty":6,"workshop":"sculptorStation","ingredients":[{"itemId":"clay","count":6},{"itemId":"flint","count":2}],"result":{"itemId":"stonePillar","count":1},"xpGain":25},"craftStoneStatue":{"id":"craftStoneStatue","name":"Sculpt Stone Statue","skill":"sculpting","skillReq":6,"level":6,"difficulty":9,"workshop":"sculptorStation","ingredients":[{"itemId":"clay","count":8},{"itemId":"flint","count":3}],"result":{"itemId":"stoneStatue","count":1},"xpGain":40},"craftDisplayCase":{"id":"craftDisplayCase","name":"Craft Display Case","skill":"carpentry","skillReq":8,"level":8,"difficulty":11,"workshop":"carpentryBench","ingredients":[{"itemId":"oakLog","count":3},{"itemId":"sand","count":4},{"itemId":"oreIron","count":2}],"result":{"itemId":"displayCase","count":1},"xpGain":45},"craftGrandfatherClock":{"id":"craftGrandfatherClock","name":"Craft Grandfather Clock","skill":"carpentry","skillReq":8,"level":8,"difficulty":12,"workshop":"carpentryBench","ingredients":[{"itemId":"mapleLog","count":3},{"itemId":"oreIron","count":3},{"itemId":"oreCopper","count":2}],"result":{"itemId":"grandfatherClock","count":1},"xpGain":50},"craftOrnateMirror":{"id":"craftOrnateMirror","name":"Craft Ornate Mirror","skill":"carpentry","skillReq":9,"level":9,"difficulty":13,"workshop":"carpentryBench","ingredients":[{"itemId":"mapleLog","count":2},{"itemId":"oreSilver","count":3},{"itemId":"sand","count":3}],"result":{"itemId":"ornateMirror","count":1},"xpGain":55},"craftFountainBasin":{"id":"craftFountainBasin","name":"Build Fountain","skill":"sculpting","skillReq":8,"level":8,"difficulty":12,"workshop":"sculptorStation","ingredients":[{"itemId":"clay","count":10},{"itemId":"oreCopper","count":3},{"itemId":"flint","count":4}],"result":{"itemId":"fountainBasin","count":1},"xpGain":50},"craftPianoBench":{"id":"craftPianoBench","name":"Craft Piano","skill":"carpentry","skillReq":10,"level":10,"difficulty":14,"workshop":"carpentryBench","ingredients":[{"itemId":"mapleLog","count":4},{"itemId":"oreIron","count":4},{"itemId":"string","count":8}],"result":{"itemId":"pianoBench","count":1},"xpGain":70},"craftGrandDiningTable":{"id":"craftGrandDiningTable","name":"Craft Grand Dining Table","skill":"carpentry","skillReq":10,"level":10,"difficulty":14,"workshop":"carpentryBench","ingredients":[{"itemId":"mapleLog","count":4},{"itemId":"plank","count":8},{"itemId":"oreSilver","count":2}],"result":{"itemId":"grandDiningTable","count":1},"xpGain":70},"craftTrophyCase":{"id":"craftTrophyCase","name":"Craft Trophy Case","skill":"carpentry","skillReq":10,"level":10,"difficulty":14,"workshop":"carpentryBench","ingredients":[{"itemId":"mapleLog","count":3},{"itemId":"sand","count":4},{"itemId":"oreSilver","count":2}],"result":{"itemId":"trophyCase","count":1},"xpGain":65},"craftOrnateThrone":{"id":"craftOrnateThrone","name":"Craft Ornate Throne","skill":"carpentry","skillReq":11,"level":11,"difficulty":16,"workshop":"carpentryBench","ingredients":[{"itemId":"yewLog","count":3},{"itemId":"oreGold","count":3},{"itemId":"leather","count":3},{"itemId":"cloth","count":4}],"result":{"itemId":"ornateThrone","count":1},"xpGain":90},"craftCrystalChandelier":{"id":"craftCrystalChandelier","name":"Craft Crystal Chandelier","skill":"carpentry","skillReq":12,"level":12,"difficulty":18,"workshop":"carpentryBench","ingredients":[{"itemId":"oreSilver","count":4},{"itemId":"crystalBlue","count":4},{"itemId":"oreGold","count":2}],"result":{"itemId":"crystalChandelier","count":1},"xpGain":100}};
  QUEST_DEFS = {"types":{"hunt":{"id":"hunt","name":"Monster Hunt","description":"Slay a number of monsters.","icon":"âš”","color":"#e44"},"bounty":{"id":"bounty","name":"Bounty","description":"Slay a specific powerful creature.","icon":"â˜ ","color":"#f84"},"delivery":{"id":"delivery","name":"Delivery","description":"Deliver an item to another town.","icon":"ğŸ“¦","color":"#4af"},"gather":{"id":"gather","name":"Gathering","description":"Collect resources and bring them back.","icon":"ğŸŒ¿","color":"#4c4"},"explore":{"id":"explore","name":"Exploration","description":"Reach a certain floor of a dungeon.","icon":"ğŸ—º","color":"#ca4"}},"boards":{"stonehaven":{"maxQuests":3,"dangerRange":[1,5],"levelRange":[1,5]},"millfield":{"maxQuests":3,"dangerRange":[1,5],"levelRange":[1,5]},"crownhold":{"maxQuests":5,"dangerRange":[3,15],"levelRange":[3,12]},"duskmarket":{"maxQuests":4,"dangerRange":[3,10],"levelRange":[2,8]},"tidereach":{"maxQuests":4,"dangerRange":[5,15],"levelRange":[4,12]},"archgate":{"maxQuests":4,"dangerRange":[5,20],"levelRange":[5,15]},"frostbell":{"maxQuests":3,"dangerRange":[5,15],"levelRange":[4,10]}},"rewards":{"goldPerDanger":50,"xpPerDanger":15,"famePerQuest":10,"karmaPerQuest":2,"bonusItemChance":0.3},"bonusItems":["potionHeal","potionMana","herbGreen","ration","bread","leatherArmor","leatherBoots","ironHelm","woodenShield","dagger","longSword","oakStaff"],"deliveryItems":[{"id":"parcel","name":"Sealed Parcel","char":"âœ‰","color":"#ca8"},{"id":"letter","name":"Important Letter","char":"âœ‰","color":"#8af"},{"id":"crate","name":"Supply Crate","char":"â–¡","color":"#a86"},{"id":"pouch","name":"Coin Pouch","char":"$","color":"#ffd700"},{"id":"vial","name":"Rare Reagent","char":"!","color":"#c4f"},{"id":"tome","name":"Ancient Tome","char":"â‰¡","color":"#8cf"}],"gatherTargets":[{"itemId":"oreIron","name":"Iron Ore","counts":[3,5,8]},{"itemId":"woodLog","name":"Wood Log","counts":[3,5,8]},{"itemId":"leather","name":"Leather","counts":[2,4,6]},{"itemId":"herbGreen","name":"Green Herb","counts":[3,5,8]}],"flavorText":{"hunt":["The roads are unsafe. Thin their numbers.","Monsters have been spotted near town.","The guard captain needs help clearing the area.","Travelers report dangerous creatures along the road.","The townsfolk are afraid to leave their homes."],"bounty":["A fearsome creature terrorizes the region.","A bounty has been posted for a dangerous beast.","Slay this menace and claim the reward.","The guild has marked this creature for elimination."],"delivery":["Urgent supplies needed in another settlement.","A merchant needs a package delivered safely.","Time-sensitive documents must reach their destination.","The guild needs a courier for important cargo."],"gather":["The town needs raw materials for repairs.","A craftsman is running low on supplies.","Stockpiles are dangerously low â€” gather resources.","The workshop needs materials. Can you help?"],"explore":["Map the depths of the dungeon below.","Scouts report unusual activity in the dungeon.","Prove your strength by reaching the lower floors.","The guild needs intelligence on the dungeon layout."]}};
  const weatherData = {"types":["sunny","cloudy","rain","heavyRain","snow","heavySnow","ether"],"effects":{"sunny":{"travelMod":0,"status":null},"cloudy":{"travelMod":0,"status":null},"rain":{"travelMod":30,"status":"wet"},"heavyRain":{"travelMod":60,"status":"wet"},"snow":{"travelMod":60,"status":"cold"},"heavySnow":{"travelMod":90,"status":"cold"},"ether":{"travelMod":0,"status":"ether"}},"icons":{"sunny":"â˜€ï¸","cloudy":"â˜ï¸","rain":"ğŸŒ§ï¸","heavyRain":"â›ˆï¸","snow":"ğŸŒ¨ï¸","heavySnow":"â„ï¸","ether":"âœ¨"}};
  WEATHER_TYPES = weatherData.types;
  WEATHER_EFFECTS = weatherData.effects;
  GOD_DEFS = {"opatos":{"id":"opatos","name":"Opatos of Earth","title":"The Immovable","domain":"earth","icon":"ğŸ—¿","color":"#c8a060","description":"God of strength, endurance, and the unshakeable earth. Favors warriors and miners.","favoredActions":["mining","meleeKill","heavyArmor"],"blessings":{"minor":{"threshold":200,"name":"Stone Skin","effect":{"pv":3},"description":"PV +3"},"moderate":{"threshold":600,"name":"Earth's Might","effect":{"pv":6,"STR":2},"description":"PV +6, STR +2"},"major":{"threshold":1200,"name":"Mountain's Heart","effect":{"pv":10,"STR":4,"END":3},"description":"PV +10, STR +4, END +3"}},"gifts":[{"favor":400,"type":"item","itemId":"chainMail","message":"Opatos grants you armor forged in the earth's core!"},{"favor":900,"type":"item","itemId":"battleAxe","message":"Opatos bestows a mighty axe upon you!"},{"favor":1500,"type":"attribute","attr":"STR","amount":3,"message":"Opatos fills your muscles with the power of mountains!"}],"prayerCost":0,"wrathEffects":{"STR":-2,"END":-2,"message":"Opatos trembles the earth beneath you in anger!"}},"lulwy":{"id":"lulwy","name":"Lulwy of Wind","title":"The Swift","domain":"wind","icon":"ğŸŒªï¸","color":"#88ddff","description":"Goddess of speed, archery, and the sky. Favors archers and travelers.","favoredActions":["rangedKill","travel","evasion"],"blessings":{"minor":{"threshold":200,"name":"Tailwind","effect":{"speed":8},"description":"Speed +8"},"moderate":{"threshold":600,"name":"Windwalker","effect":{"speed":15,"dv":5},"description":"Speed +15, DV +5"},"major":{"threshold":1200,"name":"Storm's Grace","effect":{"speed":25,"dv":10,"PER":3},"description":"Speed +25, DV +10, PER +3"}},"gifts":[{"favor":400,"type":"item","itemId":"shortBow","message":"Lulwy sends a bow carried on the wind!"},{"favor":900,"type":"attribute","attr":"DEX","amount":3,"message":"Lulwy blesses your hands with wind's precision!"},{"favor":1500,"type":"attribute","attr":"PER","amount":3,"message":"Your eyes see as far as the hawk's!"}],"prayerCost":0,"wrathEffects":{"DEX":-2,"PER":-2,"message":"Lulwy's gale tears at your balance!"}},"itzpalt":{"id":"itzpalt","name":"Itzpalt of Element","title":"The Archmage","domain":"magic","icon":"ğŸ”®","color":"#cc88ff","description":"God of magic, elements, and arcane knowledge. Favors wizards and spellcasters.","favoredActions":["casting","spellKill","readSpellbook"],"blessings":{"minor":{"threshold":200,"name":"Mana Pulse","effect":{"mpRegen":1},"description":"MP regen +1"},"moderate":{"threshold":600,"name":"Arcane Flow","effect":{"mpRegen":2,"MAG":2},"description":"MP regen +2, MAG +2"},"major":{"threshold":1200,"name":"Elemental Mastery","effect":{"mpRegen":3,"MAG":4,"spellPower":15},"description":"MP regen +3, MAG +4, spell power +15%"}},"gifts":[{"favor":400,"type":"spellStock","spellId":"fireBolt","amount":8,"message":"Itzpalt imparts fire magic into your mind!"},{"favor":900,"type":"spellStock","spellId":"lightningBolt","amount":6,"message":"Itzpalt channels lightning through you!"},{"favor":1500,"type":"attribute","attr":"MAG","amount":4,"message":"The arcane power of the cosmos flows through your veins!"}],"prayerCost":0,"wrathEffects":{"MAG":-3,"WIL":-1,"message":"Itzpalt scrambles the mana in your body!"}},"ehekatl":{"id":"ehekatl","name":"Ehekatl of Luck","title":"The Lucky Cat","domain":"luck","icon":"ğŸ±","color":"#ffcc44","description":"Goddess of luck, fortune, and cats. Favors thieves and gamblers.","favoredActions":["goldPickup","chestOpen","criticalHit"],"blessings":{"minor":{"threshold":200,"name":"Cat's Luck","effect":{"critBonus":5},"description":"Crit chance +5%"},"moderate":{"threshold":600,"name":"Fortune's Smile","effect":{"critBonus":10,"goldBonus":20},"description":"Crit +10%, gold drops +20%"},"major":{"threshold":1200,"name":"Nine Lives","effect":{"critBonus":15,"goldBonus":40,"deathSave":true},"description":"Crit +15%, gold +40%, cheat death once"}},"gifts":[{"favor":400,"type":"gold","amount":500,"message":"Gold coins rain from the sky! Ehekatl purrs with delight!"},{"favor":900,"type":"gold","amount":1500,"message":"A shower of riches! Ehekatl's luck fills your pockets!"},{"favor":1500,"type":"attribute","attr":"CHA","amount":4,"message":"Ehekatl's charm makes you irresistible!"}],"prayerCost":0,"wrathEffects":{"CHA":-2,"DEX":-1,"message":"Ehekatl hisses! Your luck turns sour!"}},"jure":{"id":"jure","name":"Jure of Healing","title":"The Merciful","domain":"healing","icon":"ğŸ’š","color":"#44dd88","description":"Goddess of healing, mercy, and life. Favors priests and healers.","favoredActions":["castHeal","eatFood","farming"],"blessings":{"minor":{"threshold":200,"name":"Gentle Touch","effect":{"hpRegen":2},"description":"HP regen +2"},"moderate":{"threshold":600,"name":"Healing Aura","effect":{"hpRegen":4,"WIL":2},"description":"HP regen +4, WIL +2"},"major":{"threshold":1200,"name":"Gift of Life","effect":{"hpRegen":6,"WIL":3,"healBoost":30},"description":"HP regen +6, WIL +3, healing +30%"}},"gifts":[{"favor":400,"type":"item","itemId":"potionHealing","count":5,"message":"Jure's mercy takes form as healing potions!"},{"favor":900,"type":"spellStock","spellId":"heal","amount":10,"message":"Jure fills your mind with healing light!"},{"favor":1500,"type":"attribute","attr":"WIL","amount":4,"message":"Jure's love strengthens your spirit beyond measure!"}],"prayerCost":0,"wrathEffects":{"WIL":-2,"MAG":-1,"message":"Jure turns away from you. Your spirit weakens."}},"kumiromi":{"id":"kumiromi","name":"Kumiromi of Harvest","title":"The Verdant","domain":"nature","icon":"ğŸŒ¿","color":"#55bb44","description":"God of nature, harvest, and growth. Favors farmers and gatherers.","favoredActions":["farming","gathering","cooking"],"blessings":{"minor":{"threshold":200,"name":"Green Thumb","effect":{"harvestBonus":1},"description":"Harvest yield +1"},"moderate":{"threshold":600,"name":"Nature's Bounty","effect":{"harvestBonus":2,"LRN":2},"description":"Harvest +2, LRN +2"},"major":{"threshold":1200,"name":"Eternal Spring","effect":{"harvestBonus":3,"LRN":3,"nutritionBonus":30},"description":"Harvest +3, LRN +3, food value +30%"}},"gifts":[{"favor":400,"type":"item","itemId":"seedStrawberry","count":3,"message":"Kumiromi blesses you with rare seeds!"},{"favor":900,"type":"item","itemId":"grandFeast","count":2,"message":"A bountiful feast materializes before you!"},{"favor":1500,"type":"attribute","attr":"LRN","amount":4,"message":"Kumiromi opens your mind to nature's wisdom!"}],"prayerCost":0,"wrathEffects":{"LRN":-2,"END":-1,"message":"Plants wither at your touch. Kumiromi is displeased."}},"mani":{"id":"mani","name":"Mani of Machine","title":"The Tinkerer","domain":"craft","icon":"âš™ï¸","color":"#aabbcc","description":"God of crafting, devices, and invention. Favors artisans and enchanters.","favoredActions":["crafting","enchanting","blacksmith"],"blessings":{"minor":{"threshold":200,"name":"Steady Hands","effect":{"craftBonus":10},"description":"Crafting success +10%"},"moderate":{"threshold":600,"name":"Artisan's Eye","effect":{"craftBonus":20,"DEX":2},"description":"Crafting +20%, DEX +2"},"major":{"threshold":1200,"name":"Master Forger","effect":{"craftBonus":30,"DEX":3,"enchantBonus":10},"description":"Crafting +30%, DEX +3, enchant success +10%"}},"gifts":[{"favor":400,"type":"item","itemId":"ironOre","count":10,"message":"Mani sends rare metals from the forge dimension!"},{"favor":900,"type":"item","itemId":"scrollEnchantWeapon","count":3,"message":"Mani bestows enchantment scrolls upon you!"},{"favor":1500,"type":"attribute","attr":"DEX","amount":4,"message":"Mani perfects your hands for the finest craftsmanship!"}],"prayerCost":0,"wrathEffects":{"DEX":-2,"LRN":-1,"message":"Mani's gears grind against you. Your hands tremble."}}};
}

</script>
  <script>
// ============================================================
// UUID generator â€” Simple browser-compatible UUID v4
// ============================================================
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

</script>
  <script>
// ============================================================
// CharacterSystem â€” Create & level characters (browser version)
// ============================================================

class CharacterSystem {
  static createPlayer(name, race, cls) {
    const attributes = {};
    ATTRIBUTES.forEach(attr => {
      const raceVal = race.attributes[attr] || 7;
      const classVal = cls.attributes[attr] || 0;
      attributes[attr] = raceVal + classVal;
    });

    // Derived stats
    const maxHp = Math.floor(
      (attributes.STR * 2 + attributes.END * 3 + attributes.WIL) * (race.baseLife / 100) + 20
    );
    const maxMp = Math.floor(
      (attributes.MAG * 3 + attributes.WIL * 2 + attributes.LRN) * (race.baseMana / 100) + 10
    );
    const maxSp = Math.floor(attributes.END * 2 + 20);
    const speed = Math.floor(race.baseSpeed + attributes.PER * 0.5 + attributes.DEX * 0.3);

    // Skills â€“ start with base + race + class bonuses
    const skills = {};
    const baseSkills = [
      'mining', 'lumberjacking', 'gathering', 'fishing', 'meditation', 'faith',
      'carpentry', 'crafting', 'blacksmith', 'heavyArmor', 'shield', 'throwing',
      'lightArmor', 'evasion', 'strategy', 'travel',
      'martialArt', 'longSword', 'axe', 'scythe', 'staff',
      'polearm', 'mace', 'bow', 'shortSword', 'crossbow',
      'farming', 'cooking', 'literacy', 'memorization', 'casting', 'controlMagic',
      'magicDevice', 'taming', 'negotiation', 'music',
      'alchemy', 'sculpting', 'weaving', 'jewelry'
    ];
    baseSkills.forEach(s => { skills[s] = 1; });
    race.bonusSkills.forEach(s => { skills[s] = (skills[s] || 0) + 3; });
    cls.bonusSkills.forEach(s => { skills[s] = (skills[s] || 0) + 4; });

    // Potential â€“ base 80 for every attribute
    const potential = {};
    ATTRIBUTES.forEach(attr => { potential[attr] = 80; });

    return {
      id: uuidv4(),
      name,
      race,
      cls,
      level: 1,
      xp: 0,
      xpNext: 100,
      hp: maxHp,
      maxHp,
      mp: maxMp,
      maxMp,
      sp: maxSp,
      maxSp,
      speed,
      attributes,
      potential,
      skills,
      inventory: [],
      equipment: {},
      gold: 500,
      nutrition: 8000,
      x: 0,
      y: 0,
      feat: `${race.feat} / ${cls.feat}`,
      domains: cls.domains || []
    };
  }

  static gainExp(player, amount) {
    player.xp += amount;
    while (player.xp >= player.xpNext) {
      player.xp -= player.xpNext;
      player.level++;
      player.xpNext = Math.floor(player.xpNext * 1.5);
      ATTRIBUTES.forEach(attr => {
        player.attributes[attr] += 1;
      });
      CharacterSystem.recalcDerived(player);
      player.hp = player.maxHp;
      player.mp = player.maxMp;
    }
  }

  static recalcDerived(player) {
    const a = player.attributes;
    player.maxHp = Math.floor(
      (a.STR * 2 + a.END * 3 + a.WIL) * (player.race.baseLife / 100) + 20 + player.level * 5
    );
    player.maxMp = Math.floor(
      (a.MAG * 3 + a.WIL * 2 + a.LRN) * (player.race.baseMana / 100) + 10 + player.level * 3
    );
    player.maxSp = Math.floor(a.END * 2 + 20 + player.level * 2);
    player.speed = Math.floor(player.race.baseSpeed + a.PER * 0.5 + a.DEX * 0.3);
  }

  static gainSkillExp(player, skillId, amount) {
    if (player.skills[skillId] === undefined) return;
    if (!player._skillExp) player._skillExp = {};
    if (!player._skillXpGainedThisTurn) player._skillXpGainedThisTurn = [];
    player._skillXpGainedThisTurn.push(skillId);
    player._skillExp[skillId] = (player._skillExp[skillId] || 0) + amount;
    const needed = player.skills[skillId] * 50 + 50;
    while (player._skillExp[skillId] >= needed) {
      player._skillExp[skillId] -= needed;
      player.skills[skillId]++;
      const def = SKILL_DEFS[skillId];
      if (def && def.attr && player.attributes[def.attr] !== undefined) {
        player.attributes[def.attr] += 0.1;
        player.attributes[def.attr] = Math.round(player.attributes[def.attr] * 10) / 10;
      }
    }
  }
}

</script>
  <script>
// ============================================================
// CombatSystem â€” Melee, ranged, damage, criticals (browser)
// ============================================================

class CombatSystem {
  static rollDice(diceStr) {
    if (!diceStr) return 0;
    const [n, m] = diceStr.split('d').map(Number);
    let total = 0;
    for (let i = 0; i < n; i++) {
      total += Math.floor(Math.random() * m) + 1;
    }
    return total;
  }

  static meleeAttack(attacker, defender) {
    const isPlayer = !!attacker.cls;
    const attackerName = attacker.name;
    const defenderName = defender.name;

    const attackerDex = attacker.attributes ? (attacker.attributes.DEX || 7) : 7;
    const attackerStr = attacker.attributes ? (attacker.attributes.STR || 7) : 7;
    const defenderSpeed = defender.speed || 100;
    const hitChance = 70 + attackerDex * 2 - defenderSpeed * 0.1;
    const hitRoll = Math.random() * 100;

    if (hitRoll > hitChance) {
      return {
        hit: false,
        damage: 0,
        message: `${attackerName} attacks ${defenderName} but misses!`
      };
    }

    let weaponDice = '1d3';
    if (isPlayer && attacker.equipment && attacker.equipment.weapon) {
      weaponDice = attacker.equipment.weapon.dice || '1d4';
    } else if (attacker.attack) {
      weaponDice = attacker.attack;
    }
    let damage = CombatSystem.rollDice(weaponDice);

    damage += Math.floor(attackerStr / 3);

    const tacticsSkill = attacker.skills ? (attacker.skills.tactics || 0) : 0;
    damage += Math.floor(tacticsSkill / 5);

    // Enchantment bonus damage
    if (isPlayer && attacker.equipment && attacker.equipment.weapon) {
      damage += EnchantSystem.getEnchantDamage(attacker.equipment.weapon);
    }

    let critical = false;
    let critChance = 5 + (attacker.skills ? (attacker.skills.eyeOfMind || 0) : 0);
    // Faith blessing crit bonus
    if (isPlayer) {
      const faithBonuses = FaithSystem.getBlessingBonuses(attacker);
      critChance += faithBonuses.critBonus || 0;
    }
    if (Math.random() * 100 < critChance) {
      critical = true;
      damage = Math.floor(damage * 1.5);
    }

    let pv = 0;
    if (defender.equipment) {
      Object.values(defender.equipment).forEach(item => {
        if (item && item.PV) pv += item.PV;
        pv += EnchantSystem.getEnchantPV(item);
      });
    }
    if (defender.skills && defender.skills.heavyArmor) {
      pv += Math.floor(defender.skills.heavyArmor / 3);
    }
    damage = Math.max(1, damage - Math.floor(pv * 0.5));

    defender.hp -= damage;

    // Elemental enchant bonus damage
    let elementalMsg = '';
    if (isPlayer && attacker.equipment && attacker.equipment.weapon) {
      const elemental = EnchantSystem.getElementalBonus(attacker.equipment.weapon);
      if (elemental) {
        const eleDmg = CombatSystem.rollDice('1d' + (elemental.bonusDamage + 2));
        defender.hp -= eleDmg;
        damage += eleDmg;
        elementalMsg = ` ${elemental.name} burns for ${eleDmg}!`;
        // Vampiric heals attacker
        if (elemental.type === 'vampiric') {
          attacker.hp = Math.min(attacker.maxHp, attacker.hp + Math.floor(eleDmg / 2));
          elementalMsg = ` Drains ${Math.floor(eleDmg / 2)} life!`;
        }
      }
    }

    const critMsg = critical ? ' Critical hit!' : '';
    return {
      hit: true,
      damage,
      critical,
      message: `${attackerName} hits ${defenderName} for ${damage} damage.${critMsg}${elementalMsg}`
    };
  }

  static rangedAttack(attacker, defender, weapon) {
    const attackerPer = attacker.attributes ? (attacker.attributes.PER || 7) : 7;
    const hitChance = 60 + attackerPer * 2 + (attacker.skills ? (attacker.skills.marksman || 0) * 2 : 0);
    const hitRoll = Math.random() * 100;

    if (hitRoll > hitChance) {
      return { hit: false, damage: 0, message: `${attacker.name}'s shot misses ${defender.name}!` };
    }

    let damage = CombatSystem.rollDice(weapon.dice || '1d4');
    damage += Math.floor(attackerPer / 3);
    damage = Math.max(1, damage);
    defender.hp -= damage;

    return { hit: true, damage, message: `${attacker.name} shoots ${defender.name} for ${damage} damage.` };
  }
}

</script>
  <script>
// ============================================================
// ItemSystem â€” Creation, use, drops, starting inventory (browser)
// ============================================================

class ItemSystem {
  static createItem(templateId) {
    const template = ITEM_TEMPLATES[templateId];
    if (!template) return null;
    return { ...template, id: uuidv4(), templateId: templateId, quantity: 1 };
  }

  static giveStartingItems(player) {
    ItemSystem.addToInventory(player, ItemSystem.createItem('ration'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('ration'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('ration'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('bread'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('bread'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('potionHeal'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('potionHeal'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('torch'));
    ItemSystem.addToInventory(player, ItemSystem.createItem('bedroll'));

    const cls = player.cls.id;
    let weaponId = 'dagger';
    if (cls === 'warrior' || cls === 'paladin') weaponId = 'longSword';
    else if (cls === 'wizard' || cls === 'priest' || cls === 'farmer') weaponId = 'oakStaff';
    else if (cls === 'archer') weaponId = 'shortBow';
    else if (cls === 'thief') weaponId = 'dagger';

    const weapon = ItemSystem.createItem(weaponId);
    ItemSystem.addToInventory(player, weapon);
    player.equipment.weapon = weapon;

    const armor = ItemSystem.createItem('raggedCloth');
    ItemSystem.addToInventory(player, armor);
    player.equipment.body = armor;

    const cls2 = player.cls.id;
    if (cls2 === 'wizard') {
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookMagicArrow'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookIceBolt'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookShortTeleport'));
    } else if (cls2 === 'priest') {
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookHeal'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookHolyLight'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookHolyVeil'));
    } else if (cls2 === 'farmer') {
      ItemSystem.addToInventory(player, ItemSystem.createItem('spellbookHeal'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedTurnip'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedTurnip'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedTurnip'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedPotato'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedPotato'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedCarrot'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedHerb'));
    }

    if (cls2 !== 'farmer') {
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedTurnip'));
      ItemSystem.addToInventory(player, ItemSystem.createItem('seedTurnip'));
    }
  }

  static useItem(player, item) {
    if (item.type === 'potion') {
      if (item.healHP) {
        player.hp = Math.min(player.maxHp, player.hp + item.healHP);
      }
      if (item.healMP) {
        player.mp = Math.min(player.maxMp, player.mp + item.healMP);
      }
      return { consumed: true, message: `You drink the ${item.name}. ` +
        (item.healHP ? `HP +${item.healHP}. ` : '') +
        (item.healMP ? `MP +${item.healMP}. ` : '')
      };
    }
    if (item.type === 'food') {
      player.nutrition = Math.min(10000, player.nutrition + (item.nutrition || 1000));
      if (item.healHP) player.hp = Math.min(player.maxHp, player.hp + item.healHP);
      return { consumed: true, message: `You eat the ${item.name}. Nutrition restored.` };
    }
    if (item.type === 'spellbook') {
      return { consumed: false, message: `You need to read this spellbook carefully. (Use the Read action)` };
    }
    return { consumed: false, message: `You can't use that.` };
  }

  static generateDrops(monster) {
    const drops = [];
    const template = MONSTER_TEMPLATES[monster.id] || monster;
    const dropList = template.drops || [];

    dropList.forEach(dropId => {
      if (Math.random() < 0.4) {
        const item = ItemSystem.createItem(dropId);
        if (item) {
          item.char = item.type === 'weapon' ? '/' : item.type === 'armor' ? '[' : '!';
          item.color = item.type === 'weapon' ? '#aaa' : item.type === 'armor' ? '#88f' : '#dd0';
          drops.push(item);
        }
      }
    });

    if (Math.random() < 0.6) {
      const gold = ItemSystem.createItem('goldCoin');
      if (gold) {
        gold.value = Math.floor(Math.random() * monster.level * 10) + 1;
        gold.name = `${gold.value} Gold`;
        gold.char = '
  <script>
// ============================================================
// TimeWeather â€” Day/night, seasons, weather cycle (browser)
// ============================================================

class TimeWeather {
  constructor(state) {
    if (state) {
      this.minute = state.minute || 0;
      this.hour = state.hour || 8;
      this.day = state.day || 1;
      this.month = state.month || 3;
      this.year = state.year || 517;
      this.weather = state.weather || 'sunny';
      this.weatherTimer = state.weatherTimer || 0;
    } else {
      this.minute = 0;
      this.hour = 8;
      this.day = 1;
      this.month = 3;
      this.year = 517;
      this.weather = 'sunny';
      this.weatherTimer = 0;
    }
  }

  advanceTurn() {
    this.minute += 1;
    this._normalize();
    this.weatherTimer--;
    if (this.weatherTimer <= 0) {
      this._changeWeather();
    }
  }

  advanceMinutes(mins) {
    this.minute += mins;
    this._normalize();
  }

  _normalize() {
    while (this.minute >= 60) {
      this.minute -= 60;
      this.hour++;
    }
    while (this.hour >= 24) {
      this.hour -= 24;
      this.day++;
    }
    while (this.day > 30) {
      this.day -= 30;
      this.month++;
    }
    while (this.month > 12) {
      this.month -= 12;
      this.year++;
    }
  }

  _changeWeather() {
    const season = this.getSeason();
    let pool;
    if (season === 'winter') {
      pool = ['sunny', 'cloudy', 'snow', 'heavySnow', 'cloudy'];
    } else if (season === 'spring') {
      pool = ['sunny', 'sunny', 'cloudy', 'rain', 'sunny'];
    } else if (season === 'summer') {
      pool = ['sunny', 'sunny', 'sunny', 'cloudy', 'rain'];
    } else {
      pool = ['sunny', 'cloudy', 'rain', 'heavyRain', 'cloudy'];
    }
    this.weather = pool[Math.floor(Math.random() * pool.length)];
    this.weatherTimer = Math.floor(Math.random() * 200) + 50;
  }

  getSeason() {
    if (this.month >= 3 && this.month <= 5) return 'spring';
    if (this.month >= 6 && this.month <= 8) return 'summer';
    if (this.month >= 9 && this.month <= 11) return 'autumn';
    return 'winter';
  }

  isNight() {
    return this.hour >= 20 || this.hour < 6;
  }

  getTimeString() {
    const hh = String(this.hour).padStart(2, '0');
    const mm = String(this.minute).padStart(2, '0');
    return `Year ${this.year}, Month ${this.month}, Day ${this.day} ${hh}:${mm}`;
  }

  getState() {
    return {
      minute: this.minute,
      hour: this.hour,
      day: this.day,
      month: this.month,
      year: this.year,
      weather: this.weather,
      weatherTimer: this.weatherTimer,
      season: this.getSeason(),
      isNight: this.isNight(),
      timeString: this.getTimeString()
    };
  }
}

</script>
  <script>
// ============================================================
// MapGenerator â€” World, Town, Outdoor, Dungeon maps (browser)
// ============================================================

class MapGenerator {
  // â”€â”€ World Map constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static WORLD_WIDTH = 128;
  static WORLD_HEIGHT = 96;

  // â”€â”€ World Map (biome grid) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateWorldMap(width, height) {
    width = width || MapGenerator.WORLD_WIDTH;
    height = height || MapGenerator.WORLD_HEIGHT;
    const map = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        row.push(MapGenerator._worldTileBiome(x, y, width, height));
      }
      map.push(row);
    }
    // Build road network connecting nearby towns
    const towns = Object.values(WORLD_LOCATIONS).filter(l => l.type === 'town');
    MapGenerator._buildRoadNetwork(map, towns);
    return map;
  }

  // Deterministic biome for any (x,y) world coordinate.
  // The noise functions are purely hash-based, so the same coordinates
  // always produce the same terrain â€” the world is always identical.
  static _worldTileBiome(x, y, w, h) {
    const nx = x / w; // 0..1
    const ny = y / h; // 0..1

    // â”€â”€ Hard ocean border â”€â”€
    const edgeDist = Math.min(x, y, w - 1 - x, h - 1 - y);
    if (edgeDist <= 1) return { ...BIOMES.sea };

    // â”€â”€ Continental shelf: irregular coastline â”€â”€
    const maxEdge = Math.min(w, h) * 0.5;
    const edgeFactor = Math.min(edgeDist / maxEdge, 1.0);
    const coastNoise = MapGenerator._fbmNoise(x * 0.06 + 500, y * 0.06 + 500, 5);
    const landValue = edgeFactor * 0.65 + coastNoise * 0.35;

    if (landValue < 0.12) return { ...BIOMES.sea };
    if (landValue < 0.18) return { ...BIOMES.beach };

    // â”€â”€ Elevation (mountains, highlands) â”€â”€
    const elevation = MapGenerator._fbmNoise(x * 0.05, y * 0.05, 6);

    // â”€â”€ Moisture (forests, swamps) â”€â”€
    const moisture = MapGenerator._fbmNoise(x * 0.04 + 100, y * 0.04 + 100, 5);

    // â”€â”€ Temperature: latitude gradient + noise + altitude â”€â”€
    // coldness is high in the north (y=0), low in the south (y=h)
    const latCold = 1.0 - ny;
    const coldNoise = MapGenerator._fbmNoise(x * 0.03 + 200, y * 0.03 + 200, 3);
    const coldness = latCold * 0.50 + coldNoise * 0.20 + elevation * 0.15 + 0.15;

    // â”€â”€ Inland lakes / seas â”€â”€
    if (elevation < 0.22 && moisture > 0.63 && edgeFactor > 0.30) {
      return { ...BIOMES.sea };
    }

    // â”€â”€ Biome selection â”€â”€
    if (coldness > 0.74) return { ...BIOMES.snow };
    if (elevation > 0.64) return { ...BIOMES.mountain };
    if (coldness < 0.34 && moisture < 0.44) return { ...BIOMES.desert };
    if (moisture > 0.55) return { ...BIOMES.forest };

    return { ...BIOMES.plains };
  }

  // â”€â”€ Road network: connect each town to its 2 nearest neighbours â”€â”€
  static _buildRoadNetwork(map, towns) {
    if (towns.length < 2) return;
    const connected = new Set();
    for (const town of towns) {
      const sorted = towns
        .filter(t => t.id !== town.id)
        .map(t => ({ t, d: Math.abs(t.x - town.x) + Math.abs(t.y - town.y) }))
        .sort((a, b) => a.d - b.d);
      const count = Math.min(2, sorted.length);
      for (let i = 0; i < count; i++) {
        const key = [town.id, sorted[i].t.id].sort().join('-');
        if (!connected.has(key)) {
          connected.add(key);
          MapGenerator._drawRoad(map, town, sorted[i].t);
        }
      }
    }
  }

  static _drawRoad(map, a, b) {
    let x = a.x, y = a.y;
    while (x !== b.x || y !== b.y) {
      if (x >= 0 && y >= 0 && y < map.length && x < map[0].length) {
        const tile = map[y][x];
        if (tile.id !== 'sea' && tile.id !== 'beach') {
          map[y][x] = { ...BIOMES.road };
        }
      }
      // Diagonal-aware pathfinding with slight noise for organic feel
      const dx = b.x - x, dy = b.y - y;
      if (Math.abs(dx) > Math.abs(dy)) {
        x += dx > 0 ? 1 : -1;
      } else if (Math.abs(dy) > Math.abs(dx)) {
        y += dy > 0 ? 1 : -1;
      } else {
        // Equal â€” alternate to create diagonal road
        const bias = MapGenerator._hash2d(x + 1000, y + 1000);
        if (bias > 0.5) x += dx > 0 ? 1 : -1;
        else y += dy > 0 ? 1 : -1;
      }
    }
  }

  // â”€â”€ Improved noise: multi-octave value noise â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _hash2d(x, y) {
    // Integer hash â€” no sin patterns
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >> 13)) * 1274126177;
    h = h ^ (h >> 16);
    return ((h >>> 0) & 0x7fffffff) / 0x7fffffff; // 0..1
  }

  static _smoothNoise(x, y) {
    const ix = Math.floor(x), iy = Math.floor(y);
    const fx = x - ix, fy = y - iy;
    // Smoothstep
    const sx = fx * fx * (3 - 2 * fx);
    const sy = fy * fy * (3 - 2 * fy);
    const n00 = MapGenerator._hash2d(ix, iy);
    const n10 = MapGenerator._hash2d(ix + 1, iy);
    const n01 = MapGenerator._hash2d(ix, iy + 1);
    const n11 = MapGenerator._hash2d(ix + 1, iy + 1);
    const nx0 = n00 + sx * (n10 - n00);
    const nx1 = n01 + sx * (n11 - n01);
    return nx0 + sy * (nx1 - nx0);
  }

  static _fbmNoise(x, y, octaves = 4) {
    let value = 0, amplitude = 0.5, frequency = 1, total = 0;
    for (let i = 0; i < octaves; i++) {
      value += amplitude * MapGenerator._smoothNoise(x * frequency, y * frequency);
      total += amplitude;
      amplitude *= 0.5;
      frequency *= 2.17; // non-integer avoids alignment
    }
    return value / total;
  }

  static _simpleNoise(x, y) {
    return MapGenerator._fbmNoise(x * 0.15, y * 0.15, 4);
  }

  // â”€â”€ Town Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateTownMap(location) {
    if (location.layout) {
      return MapGenerator._buildFromLayout(location.layout);
    }
    return MapGenerator._generateRandomTownMap();
  }

  static _buildFromLayout(layout) {
    const w = layout.width;
    const h = layout.height;
    const legend = layout.legend || {};
    const rows = layout.rows || [];

    const tiles = [];
    for (let y = 0; y < h; y++) {
      const row = [];
      const line = rows[y] || '';
      for (let x = 0; x < w; x++) {
        const ch = line[x] || ',';
        const tileType = legend[ch] || 'grass';
        row.push(MapGenerator._tile(tileType));
      }
      tiles.push(row);
    }

    return { width: w, height: h, tiles, monsters: [], items: [], type: 'town' };
  }

  static _generateRandomTownMap() {
    const w = 40, h = 30;
    const tiles = MapGenerator._emptyMap(w, h, 'grass');

    const buildings = Math.floor(Math.random() * 4) + 4;
    for (let i = 0; i < buildings; i++) {
      const bx = Math.floor(Math.random() * (w - 8)) + 2;
      const by = Math.floor(Math.random() * (h - 8)) + 2;
      const bw = Math.floor(Math.random() * 4) + 4;
      const bh = Math.floor(Math.random() * 4) + 4;
      for (let yy = by; yy < by + bh && yy < h; yy++) {
        for (let xx = bx; xx < bx + bw && xx < w; xx++) {
          if (yy === by || yy === by + bh - 1 || xx === bx || xx === bx + bw - 1) {
            tiles[yy][xx] = MapGenerator._tile('wall');
          } else {
            tiles[yy][xx] = MapGenerator._tile('floor');
          }
        }
      }
      const doorX = bx + Math.floor(bw / 2);
      tiles[by + bh - 1][doorX] = MapGenerator._tile('door');
    }

    for (let x = 2; x < w - 2; x++) {
      if (tiles[Math.floor(h / 2)][x].walkable || tiles[Math.floor(h / 2)][x].type === 'grass') {
        tiles[Math.floor(h / 2)][x] = MapGenerator._tile('road');
      }
    }

    return { width: w, height: h, tiles, monsters: [], items: [], type: 'town' };
  }

  // â”€â”€ Outdoor Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateOutdoorMap(biome, danger) {
    const w = 50, h = 40;

    // Pick biome-specific ground tile and features
    const biomeConfig = MapGenerator._getBiomeConfig(biome.id);
    const tiles = MapGenerator._emptyMap(w, h, biomeConfig.ground);

    // Generate varied ground using noise â€” mix in alternate ground tiles
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const n = MapGenerator._fbmNoise(x * 0.2 + 50, y * 0.2 + 50, 3);
        if (biomeConfig.altGround && n > 0.55) {
          tiles[y][x] = MapGenerator._tile(biomeConfig.altGround);
        } else if (biomeConfig.altGround2 && n < 0.25) {
          tiles[y][x] = MapGenerator._tile(biomeConfig.altGround2);
        }
      }
    }

    // Scatter biome features using noise for natural clustering
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const featureNoise = MapGenerator._fbmNoise(x * 0.3 + 300, y * 0.3 + 300, 3);
        const scatter = MapGenerator._hash2d(x + 500, y + 500);

        for (const feat of biomeConfig.features) {
          // Combine noise clusters with random scatter for natural look
          const threshold = feat.cluster
            ? feat.density * (featureNoise > feat.clusterMin ? 2.5 : 0.3)
            : feat.density;
          if (scatter < threshold) {
            tiles[y][x] = MapGenerator._tile(feat.tile);
            break; // Only one feature per tile
          }
        }
      }
    }

    // Scatter herb patches in forests and plains
    if (biome.id === 'forest' || biome.id === 'plains') {
      const herbCount = 2 + Math.floor(Math.random() * 4);
      for (let i = 0; i < herbCount; i++) {
        const pos = MapGenerator._randOpen(w, h, tiles);
        tiles[pos.y][pos.x] = MapGenerator._tile('herbPatch');
      }
    }

    // Scatter mushroom patches in forests
    if (biome.id === 'forest') {
      const mushCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < mushCount; i++) {
        const pos = MapGenerator._randOpen(w, h, tiles);
        tiles[pos.y][pos.x] = MapGenerator._tile('mushroomPatch');
      }
    }

    // Add fishing spots near water tiles (beach biome)
    if (biome.id === 'beach' || biome.id === 'sea') {
      const fishCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < fishCount; i++) {
        const pos = MapGenerator._randWater(w, h, tiles);
        if (pos) {
          tiles[pos.y][pos.x] = MapGenerator._tile('fishingSpot');
        }
      }
    }

    // Scatter reed patches near water in beach and plains
    if (biome.id === 'beach' || biome.id === 'plains') {
      const reedCount = Math.floor(Math.random() * 3);
      for (let i = 0; i < reedCount; i++) {
        const pos = MapGenerator._randOpen(w, h, tiles);
        tiles[pos.y][pos.x] = MapGenerator._tile('reedPatch');
      }
    }

    // Assign node subtypes to all gatherable tiles
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        GatheringSystem.assignNodeSubtype(tiles[y][x]);
      }
    }

    const monsters = MapGenerator._spawnMonsters(w, h, tiles, danger, 5 + Math.floor(danger / 2), biome.id);

    const items = [];
    if (Math.random() < 0.3) {
      const ix = MapGenerator._randOpen(w, h, tiles);
      items.push({ ...ITEM_TEMPLATES.herbGreen, id: uuidv4(), x: ix.x, y: ix.y, char: '!', color: '#0c0' });
    }

    return { width: w, height: h, tiles, monsters, items, type: 'outdoor' };
  }

  /** Returns ground tile, alternate ground, and feature config per biome */
  static _getBiomeConfig(biomeId) {
    const configs = {
      plains: {
        ground: 'grass',
        altGround: 'dirt',
        altGround2: null,
        features: [
          { tile: 'berryBush', density: 0.01 },
          { tile: 'bush', density: 0.03, cluster: true, clusterMin: 0.6 },
          { tile: 'oakTree', density: 0.015, cluster: true, clusterMin: 0.65 },
          { tile: 'birchTree', density: 0.005 },
          { tile: 'rock', density: 0.005 },
          { tile: 'flintNode', density: 0.003 },
        ]
      },
      forest: {
        ground: 'forestFloor',
        altGround: 'grass',
        altGround2: 'dirt',
        features: [
          { tile: 'oakTree', density: 0.10, cluster: true, clusterMin: 0.4 },
          { tile: 'pineTree', density: 0.04, cluster: true, clusterMin: 0.45 },
          { tile: 'birchTree', density: 0.03, cluster: true, clusterMin: 0.5 },
          { tile: 'mapleTree', density: 0.01 },
          { tile: 'bush', density: 0.04, cluster: true, clusterMin: 0.5 },
          { tile: 'berryBush', density: 0.015 },
          { tile: 'mushroomPatch', density: 0.008 },
          { tile: 'stump', density: 0.01 },
          { tile: 'rock', density: 0.006 },
          { tile: 'copperOre', density: 0.003 },
        ]
      },
      mountain: {
        ground: 'rockyGround',
        altGround: 'dirt',
        altGround2: 'rockyGround',
        features: [
          { tile: 'rock', density: 0.12, cluster: true, clusterMin: 0.45 },
          { tile: 'ironOre', density: 0.02, cluster: true, clusterMin: 0.6 },
          { tile: 'copperOre', density: 0.015, cluster: true, clusterMin: 0.6 },
          { tile: 'silverOre', density: 0.006, cluster: true, clusterMin: 0.7 },
          { tile: 'goldOre', density: 0.003, cluster: true, clusterMin: 0.75 },
          { tile: 'mythrilOre', density: 0.001, cluster: true, clusterMin: 0.8 },
          { tile: 'pineTree', density: 0.015 },
          { tile: 'yewTree', density: 0.005 },
          { tile: 'flintNode', density: 0.006 },
          { tile: 'clayDeposit', density: 0.004 },
        ]
      },
      snow: {
        ground: 'snowGround',
        altGround: 'rockyGround',
        altGround2: null,
        features: [
          { tile: 'pineTree', density: 0.04, cluster: true, clusterMin: 0.5 },
          { tile: 'yewTree', density: 0.01 },
          { tile: 'rock', density: 0.04, cluster: true, clusterMin: 0.55 },
          { tile: 'ironOre', density: 0.008, cluster: true, clusterMin: 0.65 },
          { tile: 'silverOre', density: 0.004 },
        ]
      },
      desert: {
        ground: 'sand',
        altGround: 'dirt',
        altGround2: null,
        features: [
          { tile: 'cactus', density: 0.03, cluster: true, clusterMin: 0.6 },
          { tile: 'rock', density: 0.02 },
          { tile: 'deadTree', density: 0.008 },
          { tile: 'sandDeposit', density: 0.01 },
          { tile: 'copperOre', density: 0.005 },
          { tile: 'goldOre', density: 0.002 },
        ]
      },
      beach: {
        ground: 'sand',
        altGround: 'grass',
        altGround2: null,
        features: [
          { tile: 'water', density: 0.08, cluster: true, clusterMin: 0.5 },
          { tile: 'shallowWater', density: 0.05, cluster: true, clusterMin: 0.45 },
          { tile: 'rock', density: 0.01 },
          { tile: 'sandDeposit', density: 0.008 },
          { tile: 'reedPatch', density: 0.006 },
          { tile: 'clayDeposit', density: 0.004 },
        ]
      },
      sea: {
        ground: 'sand',
        altGround: null,
        altGround2: null,
        features: [
          { tile: 'water', density: 0.55, cluster: true, clusterMin: 0.3 },
          { tile: 'shallowWater', density: 0.15, cluster: true, clusterMin: 0.4 },
          { tile: 'rock', density: 0.005 },
        ]
      }
    };
    return configs[biomeId] || configs.plains;
  }

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _emptyMap(w, h, fillType) {
    const tiles = [];
    for (let y = 0; y < h; y++) {
      const row = [];
      for (let x = 0; x < w; x++) {
        if (x === 0 || y === 0 || x === w - 1 || y === h - 1) {
          row.push(MapGenerator._tile('wall'));
        } else {
          row.push(MapGenerator._tile(fillType));
        }
      }
      tiles.push(row);
    }
    return tiles;
  }

  static _tile(type) {
    const t = TILE_TYPES[type] || TILE_TYPES.floor;
    return { type: t.id, char: t.char, color: t.color, walkable: t.walkable, transparent: t.transparent };
  }

  static _spawnMonsters(w, h, tiles, danger, count, biomeId) {
    const pool = [];
    MONSTER_TIERS.forEach(tier => {
      if (danger >= tier.minDanger && danger <= tier.maxDanger) {
        pool.push(...tier.monsters);
      }
    });
    if (pool.length === 0) pool.push('putit');

    // Separate monsters into biome-preferred and generic pools
    let biomePool = [];
    let genericPool = [];
    if (biomeId) {
      for (const mId of pool) {
        const tmpl = MONSTER_TEMPLATES[mId];
        if (tmpl && tmpl.biomes && tmpl.biomes.includes(biomeId)) {
          biomePool.push(mId);
        } else {
          genericPool.push(mId);
        }
      }
    }
    // If no biome matches, fall back to the full pool
    if (biomePool.length === 0) {
      biomePool = pool;
      genericPool = [];
    }

    const monsters = [];
    for (let i = 0; i < count; i++) {
      // 75% chance to pick from biome-affiliated monsters, 25% generic
      let chosenPool;
      if (genericPool.length > 0 && Math.random() < 0.25) {
        chosenPool = genericPool;
      } else {
        chosenPool = biomePool;
      }
      const templateId = chosenPool[Math.floor(Math.random() * chosenPool.length)];
      const template = MONSTER_TEMPLATES[templateId];
      if (!template) continue;
      const pos = MapGenerator._randOpen(w, h, tiles);
      const scaledLevel = Math.max(template.level, Math.floor(danger * 0.8));
      const hpScale = 1 + (scaledLevel - template.level) * 0.15;
      monsters.push({
        id: uuidv4(),
        templateId: templateId,
        ...template,
        level: scaledLevel,
        hp: Math.floor(template.hp * hpScale),
        maxHp: Math.floor(template.hp * hpScale),
        x: pos.x,
        y: pos.y,
        char: template.name[0].toUpperCase(),
        color: '#e44'
      });
    }
    return monsters;
  }

  static _randOpen(w, h, tiles) {
    for (let tries = 0; tries < 200; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].walkable) return { x, y };
    }
    return { x: 1, y: 1 };
  }

  static _randWater(w, h, tiles) {
    for (let tries = 0; tries < 200; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].type === 'water') return { x, y };
    }
    return null;
  }
}

</script>
  <script>
// ============================================================
// NefiaSystem â€” Dungeon floor generation (browser)
// ============================================================

class NefiaSystem {
  constructor() {
    this.cache = {};
  }

  generateFloor(location, floorNum) {
    const key = `${location.id}-${floorNum}`;
    if (this.cache[key]) return this.cache[key];

    const baseDanger = (location.danger || 1) + floorNum;
    const w = 40 + Math.floor(Math.random() * 10);
    const h = 30 + Math.floor(Math.random() * 8);
    const tiles = this._generateDungeonLayout(w, h);

    const stairsUp = this._findOpen(tiles, w, h);
    tiles[stairsUp.y][stairsUp.x] = MapGenerator._tile('stairsUp');

    const maxFloors = location.floors || 10;
    let stairsDown = null;
    if (floorNum < maxFloors) {
      stairsDown = this._findOpen(tiles, w, h);
      while (stairsDown.x === stairsUp.x && stairsDown.y === stairsUp.y) {
        stairsDown = this._findOpen(tiles, w, h);
      }
      tiles[stairsDown.y][stairsDown.x] = MapGenerator._tile('stairsDown');
    }

    const monsterCount = 5 + Math.floor(baseDanger / 2) + Math.floor(Math.random() * 4);
    const monsters = MapGenerator._spawnMonsters(w, h, tiles, baseDanger, monsterCount);

    if (floorNum === maxFloors) {
      const bossPos = this._findOpen(tiles, w, h);
      const bossTemplate = this._pickBoss(baseDanger);
      const boss = {
        id: uuidv4(),
        templateId: bossTemplate.id,
        ...bossTemplate,
        level: baseDanger + 5,
        hp: Math.floor(bossTemplate.hp * 3),
        maxHp: Math.floor(bossTemplate.hp * 3),
        x: bossPos.x,
        y: bossPos.y,
        char: bossTemplate.name[0].toUpperCase(),
        color: '#f0f',
        isBoss: true,
        name: `â˜… ${bossTemplate.name} Boss`
      };
      monsters.push(boss);
    }

    const trapCount = Math.floor(baseDanger / 3) + Math.floor(Math.random() * 3);
    for (let i = 0; i < trapCount; i++) {
      const pos = this._findOpen(tiles, w, h);
      tiles[pos.y][pos.x] = { ...MapGenerator._tile('trap'), hidden: true };
    }

    // Scatter ore veins in dungeon walls
    const oreCount = 1 + Math.floor(Math.random() * 3) + Math.floor(baseDanger / 5);
    for (let i = 0; i < oreCount; i++) {
      const pos = this._findWallNeighboringFloor(tiles, w, h);
      if (pos) {
        tiles[pos.y][pos.x] = MapGenerator._tile('ore');
      }
    }

    const items = [];
    const itemCount = 2 + Math.floor(Math.random() * 3);
    for (let i = 0; i < itemCount; i++) {
      const pos = this._findOpen(tiles, w, h);
      const itemPool = ['herbGreen', 'potionHeal', 'potionMana', 'bread', 'torch'];
      if (baseDanger > 5) itemPool.push('leatherArmor', 'longSword', 'scrollEnchant', 'lantern');
      if (baseDanger > 10) itemPool.push('chainMail', 'battleAxe', 'scrollGreaterEnchant');
      if (baseDanger > 15) itemPool.push('scrollSupremeEnchant', 'scrollFireEnchant', 'scrollIceEnchant', 'scrollLightningEnchant', 'magicLight');
      const templateId = itemPool[Math.floor(Math.random() * itemPool.length)];
      const item = { ...ITEM_TEMPLATES[templateId], id: uuidv4(), x: pos.x, y: pos.y };
      if (!item.char) {
        item.char = item.type === 'weapon' ? '/' : item.type === 'armor' ? '[' : '!';
      }
      if (!item.color) {
        item.color = item.type === 'weapon' ? '#aaa' : item.type === 'armor' ? '#88f' : '#dd0';
      }
      items.push(item);
    }

    if (Math.random() < 0.4 + floorNum * 0.05) {
      const pos = this._findOpen(tiles, w, h);
      tiles[pos.y][pos.x] = MapGenerator._tile('chest');
    }

    const floor = {
      width: w, height: h, tiles, monsters, items, type: 'nefia',
      stairsUpX: stairsUp.x, stairsUpY: stairsUp.y,
      stairsDownX: stairsDown ? stairsDown.x : null,
      stairsDownY: stairsDown ? stairsDown.y : null
    };

    this.cache[key] = floor;
    return floor;
  }

  _generateDungeonLayout(w, h) {
    const tiles = [];
    for (let y = 0; y < h; y++) {
      const row = [];
      for (let x = 0; x < w; x++) {
        row.push(MapGenerator._tile('wall'));
      }
      tiles.push(row);
    }

    const rooms = [];
    const roomCount = 6 + Math.floor(Math.random() * 5);
    for (let i = 0; i < roomCount; i++) {
      const rw = Math.floor(Math.random() * 8) + 4;
      const rh = Math.floor(Math.random() * 6) + 4;
      const rx = Math.floor(Math.random() * (w - rw - 2)) + 1;
      const ry = Math.floor(Math.random() * (h - rh - 2)) + 1;

      for (let yy = ry; yy < ry + rh; yy++) {
        for (let xx = rx; xx < rx + rw; xx++) {
          tiles[yy][xx] = MapGenerator._tile('floor');
        }
      }
      rooms.push({ x: rx + Math.floor(rw / 2), y: ry + Math.floor(rh / 2) });
    }

    for (let i = 0; i < rooms.length - 1; i++) {
      this._carveCorridor(tiles, rooms[i], rooms[i + 1], w, h);
    }

    return tiles;
  }

  _carveCorridor(tiles, a, b, w, h) {
    let x = a.x, y = a.y;
    while (x !== b.x) {
      if (x > 0 && x < w - 1 && y > 0 && y < h - 1) {
        tiles[y][x] = MapGenerator._tile('floor');
      }
      x += x < b.x ? 1 : -1;
    }
    while (y !== b.y) {
      if (x > 0 && x < w - 1 && y > 0 && y < h - 1) {
        tiles[y][x] = MapGenerator._tile('floor');
      }
      y += y < b.y ? 1 : -1;
    }
  }

  _findOpen(tiles, w, h) {
    for (let tries = 0; tries < 300; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].walkable) return { x, y };
    }
    return { x: 2, y: 2 };
  }

  _findWallNeighboringFloor(tiles, w, h) {
    for (let tries = 0; tries < 300; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].type !== 'wall') continue;
      // Check if at least one neighbor is walkable
      const dirs = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];
      const hasFloor = dirs.some(d => {
        const nx = x + d.dx, ny = y + d.dy;
        return nx > 0 && ny > 0 && nx < w - 1 && ny < h - 1 && tiles[ny][nx].walkable;
      });
      if (hasFloor) return { x, y };
    }
    return null;
  }

  _pickBoss(danger) {
    const allMonsters = Object.values(MONSTER_TEMPLATES);
    const eligible = allMonsters.filter(m => m.level <= danger + 5);
    if (eligible.length === 0) return allMonsters[allMonsters.length - 1];
    return eligible[eligible.length - 1];
  }
}

</script>
  <script>
// ============================================================
// MagicSystem â€” Spells, spellbooks, casting (browser)
// ============================================================

class MagicSystem {
  static initSpells(player) {
    if (!player.spells) player.spells = {};
    if (!player.buffs) player.buffs = [];
  }

  static readSpellbook(player, book) {
    if (!book || book.type !== 'spellbook') {
      return { success: false, consumed: false, message: 'That is not a spellbook.' };
    }
    MagicSystem.initSpells(player);

    const spellDef = SPELL_DEFS[book.spellId];
    if (!spellDef) {
      return { success: false, consumed: false, message: 'The spellbook is indecipherable.' };
    }

    const literacy = player.skills.literacy || 0;
    const memorization = player.skills.memorization || 0;
    const difficulty = book.difficulty || spellDef.difficulty || 1;

    const successChance = Math.min(95, Math.max(10,
      50 + literacy * 3 + memorization * 2 - difficulty * 5
    ));
    const roll = Math.random() * 100;

    if (roll > successChance) {
      const destroyChance = 30 + difficulty * 3 - literacy;
      const destroyed = Math.random() * 100 < destroyChance;

      CharacterSystem.gainSkillExp(player, 'literacy', 5);

      if (destroyed) {
        return {
          success: false,
          consumed: true,
          message: `You fail to comprehend the ${book.name}. It crumbles to dust!`
        };
      }
      return {
        success: false,
        consumed: false,
        message: `You fail to understand the ${book.name}. (${Math.floor(successChance)}% chance)`
      };
    }

    const stockGain = book.charges || 3;
    if (!player.spells[book.spellId]) {
      player.spells[book.spellId] = { stock: 0, skillLevel: 1 };
    }
    player.spells[book.spellId].stock += stockGain;

    CharacterSystem.gainSkillExp(player, 'literacy', 10 + difficulty * 2);
    CharacterSystem.gainSkillExp(player, 'memorization', 8 + difficulty * 2);

    return {
      success: true,
      consumed: true,
      message: `You memorize ${spellDef.name} from the ${book.name}! Stock +${stockGain} (total: ${player.spells[book.spellId].stock})`
    };
  }

  static castSpell(player, spellId, context) {
    MagicSystem.initSpells(player);

    const spellDef = SPELL_DEFS[spellId];
    if (!spellDef) return { success: false, message: 'Unknown spell.' };

    const spellData = player.spells[spellId];
    if (!spellData || spellData.stock <= 0) {
      return { success: false, message: `You have no stock of ${spellDef.name}.` };
    }

    const castingSkill = player.skills.casting || 0;
    const controlMagic = player.skills.controlMagic || 0;
    const manaCost = Math.max(1, Math.floor(
      spellDef.baseCost * (1 - castingSkill * 0.02 - controlMagic * 0.01)
    ));

    if (player.mp < manaCost) {
      const overflow = manaCost - player.mp;
      player.mp = 0;
      player.hp -= overflow;
      if (player.race && player.race.id === 'eulderna') {
        player.hp += Math.floor(overflow * 0.3);
      }
    } else {
      player.mp -= manaCost;
    }

    spellData.stock--;

    const govAttr = player.attributes[spellDef.attr] || 10;
    const spellSkillLevel = spellData.skillLevel || 1;
    let power = spellDef.basePower + CombatSystem.rollDice(spellDef.dice || '1d4');
    power = Math.floor(power * (1 + govAttr * 0.03 + spellSkillLevel * 0.05 + castingSkill * 0.02));

    if (player.domains && player.domains.includes(spellDef.domain)) {
      power = Math.floor(power * 1.2);
    }

    CharacterSystem.gainSkillExp(player, 'casting', 5 + spellDef.difficulty);
    CharacterSystem.gainSkillExp(player, 'controlMagic', 3);

    if (!player._spellExp) player._spellExp = {};
    player._spellExp[spellId] = (player._spellExp[spellId] || 0) + 10 + spellDef.difficulty;
    const needed = spellData.skillLevel * 40 + 30;
    if (player._spellExp[spellId] >= needed) {
      player._spellExp[spellId] -= needed;
      spellData.skillLevel++;
    }

    const result = {
      success: true,
      spellId,
      spellName: spellDef.name,
      type: spellDef.type,
      manaCost,
      power,
      domain: spellDef.domain,
      message: ''
    };

    switch (spellDef.type) {
      case 'bolt':
        result.damage = power;
        result.range = spellDef.range || 5;
        result.message = `You cast ${spellDef.name}! (${power} dmg, cost ${manaCost} MP, stock ${spellData.stock})`;
        break;

      case 'ball':
        result.damage = power;
        result.range = spellDef.range || 4;
        result.radius = spellDef.radius || 2;
        result.message = `You cast ${spellDef.name}! (${power} dmg, radius ${result.radius}, cost ${manaCost} MP, stock ${spellData.stock})`;
        break;

      case 'heal': {
        const healAmt = power;
        player.hp = Math.min(player.maxHp, player.hp + healAmt);
        result.heal = healAmt;
        result.message = `You cast ${spellDef.name}! HP +${healAmt} (cost ${manaCost} MP, stock ${spellData.stock})`;
        break;
      }

      case 'buff': {
        const duration = spellDef.duration || 15;
        const scaledDuration = duration + Math.floor(spellSkillLevel * 2);
        if (!player.buffs) player.buffs = [];
        player.buffs = player.buffs.filter(b => b.type !== spellDef.buffType);
        player.buffs.push({
          type: spellDef.buffType,
          name: spellDef.name,
          turnsLeft: scaledDuration,
          power: Math.floor(power * 0.3)
        });
        result.buff = { type: spellDef.buffType, duration: scaledDuration };
        result.message = `You cast ${spellDef.name}! Effect for ${scaledDuration} turns. (cost ${manaCost} MP, stock ${spellData.stock})`;
        break;
      }

      case 'teleport':
        result.teleport = true;
        result.message = `You cast ${spellDef.name}! (cost ${manaCost} MP, stock ${spellData.stock})`;
        break;

      default:
        result.message = `You cast ${spellDef.name}! (cost ${manaCost} MP)`;
    }

    return result;
  }

  static applyBoltToTarget(target, damage) {
    if (!target || target.hp <= 0) return { hit: false, message: 'The spell dissipates.' };
    const actualDmg = Math.max(1, damage);
    target.hp -= actualDmg;
    return {
      hit: true,
      damage: actualDmg,
      killed: target.hp <= 0,
      message: `The spell hits ${target.name} for ${actualDmg} damage!${target.hp <= 0 ? ` ${target.name} is destroyed!` : ''}`
    };
  }

  static applyBallToArea(monsters, cx, cy, radius, damage) {
    const hits = [];
    for (const m of monsters) {
      if (m.hp <= 0) continue;
      const dist = Math.abs(m.x - cx) + Math.abs(m.y - cy);
      if (dist <= radius) {
        const falloff = dist === 0 ? 1.0 : (1 - dist / (radius + 1) * 0.3);
        const dmg = Math.max(1, Math.floor(damage * falloff));
        m.hp -= dmg;
        hits.push({
          name: m.name,
          damage: dmg,
          killed: m.hp <= 0
        });
      }
    }
    return hits;
  }

  static findBoltTarget(player, monsters, dx, dy, range) {
    let best = null;
    let bestDist = Infinity;

    for (const m of monsters) {
      if (m.hp <= 0) continue;
      const mdx = m.x - player.x;
      const mdy = m.y - player.y;
      const dist = Math.abs(mdx) + Math.abs(mdy);
      if (dist > range) continue;

      if (dx !== 0 || dy !== 0) {
        if (dx !== 0 && Math.sign(mdx) !== dx) continue;
        if (dy !== 0 && Math.sign(mdy) !== dy) continue;
      }

      if (dist < bestDist) {
        bestDist = dist;
        best = m;
      }
    }
    return best;
  }

  static findNearestMonster(player, monsters, range) {
    let best = null;
    let bestDist = Infinity;
    for (const m of monsters) {
      if (m.hp <= 0) continue;
      const dist = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
      if (dist <= range && dist < bestDist) {
        bestDist = dist;
        best = m;
      }
    }
    return best;
  }

  static tickBuffs(player) {
    if (!player.buffs) return;
    player.buffs.forEach(b => b.turnsLeft--);
    const expired = player.buffs.filter(b => b.turnsLeft <= 0);
    player.buffs = player.buffs.filter(b => b.turnsLeft > 0);
    return expired;
  }

  static getBuffBonuses(player) {
    const bonuses = { dv: 0, pv: 0, speed: 0 };
    if (!player.buffs) return bonuses;
    for (const b of player.buffs) {
      switch (b.type) {
        case 'holyVeil':
          bonuses.pv += b.power;
          break;
        case 'mistSilence':
          bonuses.dv += b.power;
          break;
        case 'speed':
          bonuses.speed += b.power;
          break;
      }
    }
    return bonuses;
  }

  static getSpellList(player) {
    if (!player.spells) return [];
    return Object.entries(player.spells).map(([id, data]) => {
      const def = SPELL_DEFS[id];
      if (!def) return null;
      const castingSkill = player.skills.casting || 0;
      const controlMagic = player.skills.controlMagic || 0;
      const manaCost = Math.max(1, Math.floor(
        def.baseCost * (1 - castingSkill * 0.02 - controlMagic * 0.01)
      ));
      return {
        id,
        name: def.name,
        type: def.type,
        domain: def.domain,
        description: def.description,
        stock: data.stock,
        skillLevel: data.skillLevel,
        manaCost,
        char: def.char,
        color: def.color
      };
    }).filter(Boolean);
  }
}

</script>
  <script>
// ============================================================
// FarmingSystem â€” Planting, growing, and harvesting (browser)
// ============================================================

class FarmingSystem {
  static plantSeed(player, seedItem, tile, season) {
    if (!seedItem || seedItem.type !== 'seed') {
      return { success: false, consumed: false, message: 'That is not a seed.' };
    }

    const cropDef = CROP_DEFS[seedItem.cropId];
    if (!cropDef) {
      return { success: false, consumed: false, message: 'Unknown crop type.' };
    }

    if (tile.type !== 'grass' && tile.type !== 'farmSoil') {
      return { success: false, consumed: false, message: 'You can only plant on grass or tilled soil.' };
    }

    if (tile.crop) {
      return { success: false, consumed: false, message: 'Something is already growing here.' };
    }

    const inSeason = cropDef.seasons.includes(season);
    const farmingSkill = player.skills.farming || 0;

    const successChance = Math.min(98, 60 + farmingSkill * 3 - cropDef.difficulty * 5);
    if (Math.random() * 100 > successChance) {
      CharacterSystem.gainSkillExp(player, 'farming', 3);
      return {
        success: false,
        consumed: true,
        message: `You fumble with the ${seedItem.name} and waste them. (${Math.floor(successChance)}% chance)`
      };
    }

    tile.crop = {
      id: uuidv4(),
      cropId: cropDef.id,
      stage: 0,
      growth: 0,
      growthNeeded: cropDef.growthTime,
      inSeason,
      plantedTurn: 0,
      quality: Math.floor(50 + farmingSkill * 2 + (inSeason ? 20 : -10))
    };

    if (tile.type === 'grass') {
      tile.type = 'farmSoil';
      tile.char = 'â‰ˆ';
      tile.color = '#654';
    }

    CharacterSystem.gainSkillExp(player, 'farming', 5 + cropDef.difficulty);

    const seasonMsg = inSeason ? '' : ' (Out of season â€” growth will be slow!)';
    return {
      success: true,
      consumed: true,
      message: `You plant ${cropDef.name} seeds.${seasonMsg}`
    };
  }

  static harvestCrop(player, tile) {
    if (!tile.crop) {
      return { success: false, message: 'Nothing to harvest here.' };
    }

    const crop = tile.crop;
    const cropDef = CROP_DEFS[crop.cropId];
    if (!cropDef) {
      tile.crop = null;
      return { success: false, message: 'The crop has withered away.' };
    }

    if (crop.stage < cropDef.stages) {
      const stageNames = ['Seed', 'Sprout', 'Growing', 'Mature', 'Harvestable'];
      return {
        success: false,
        message: `The ${cropDef.name} is still ${stageNames[crop.stage] || 'growing'}. (${Math.floor(crop.growth / crop.growthNeeded * 100)}% grown)`
      };
    }

    const farmingSkill = player.skills.farming || 0;
    const qualityBonus = Math.floor(crop.quality / 25);
    const yieldCount = cropDef.baseYield + Math.floor(farmingSkill / 10) + (Math.random() < 0.3 ? 1 : 0);

    const items = [];
    const harvestTemplate = ITEM_TEMPLATES[cropDef.harvestId];
    if (harvestTemplate) {
      for (let i = 0; i < yieldCount; i++) {
        const item = {
          ...harvestTemplate,
          id: uuidv4(),
          char: harvestTemplate.char || cropDef.chars[cropDef.stages] || 'â—',
          color: harvestTemplate.color || cropDef.colors[cropDef.stages] || '#4a4'
        };
        if (item.nutrition) {
          item.nutrition = Math.floor(item.nutrition * (1 + qualityBonus * 0.1));
        }
        if (item.healHP) {
          item.healHP = Math.floor(item.healHP * (1 + qualityBonus * 0.1));
        }
        items.push(item);
      }
    }

    if (Math.random() < 0.3 + farmingSkill * 0.01) {
      const seedTemplate = ITEM_TEMPLATES[cropDef.seedId];
      if (seedTemplate) {
        items.push({
          ...seedTemplate,
          id: uuidv4()
        });
      }
    }

    tile.crop = null;
    tile.char = 'â‰ˆ';
    tile.color = '#654';

    CharacterSystem.gainSkillExp(player, 'farming', 10 + cropDef.difficulty * 3);

    return {
      success: true,
      message: `You harvest ${yieldCount} ${cropDef.name}!`,
      items
    };
  }

  static tickCrops(map, season, weather) {
    if (!map || !map.tiles) return [];
    const messages = [];

    for (let y = 0; y < map.height; y++) {
      for (let x = 0; x < map.width; x++) {
        const tile = map.tiles[y][x];
        if (!tile.crop) continue;

        const crop = tile.crop;
        const cropDef = CROP_DEFS[crop.cropId];
        if (!cropDef) continue;

        if (crop.stage >= cropDef.stages) continue;

        let growthRate = 1;

        crop.inSeason = cropDef.seasons.includes(season);
        if (crop.inSeason) {
          growthRate *= 1.5;
        } else {
          growthRate *= 0.4;
        }

        if (weather === 'rain' || weather === 'heavyRain') {
          growthRate *= 1.5;
        } else if (weather === 'snow' || weather === 'heavySnow') {
          growthRate *= 0.2;
        } else if (weather === 'sunny') {
          growthRate *= 1.2;
        }

        if (season === 'winter' && !crop.inSeason && Math.random() < 0.005) {
          tile.crop = null;
          tile.char = 'â‰ˆ';
          tile.color = '#654';
          messages.push({ x, y, text: `A ${cropDef.name} plant has withered in the cold!` });
          continue;
        }

        crop.growth += growthRate;

        const stageThreshold = crop.growthNeeded / cropDef.stages;
        const newStage = Math.min(cropDef.stages, Math.floor(crop.growth / stageThreshold));

        if (newStage > crop.stage) {
          crop.stage = newStage;

          if (cropDef.chars[crop.stage]) {
            tile.char = cropDef.chars[crop.stage];
          }
          if (cropDef.colors[crop.stage]) {
            tile.color = cropDef.colors[crop.stage];
          }

          if (crop.stage >= cropDef.stages) {
            messages.push({ x, y, text: `Your ${cropDef.name} is ready to harvest!` });
          }
        }
      }
    }

    return messages;
  }

  static getCropInfo(tile) {
    if (!tile || !tile.crop) return null;
    const crop = tile.crop;
    const cropDef = CROP_DEFS[crop.cropId];
    if (!cropDef) return null;

    const stageNames = ['Seed', 'Sprout', 'Growing', 'Mature', 'Harvestable'];
    const progress = Math.min(100, Math.floor(crop.growth / crop.growthNeeded * 100));

    return {
      name: cropDef.name,
      stage: crop.stage,
      stageName: stageNames[crop.stage] || 'Unknown',
      progress,
      inSeason: crop.inSeason,
      quality: crop.quality,
      harvestable: crop.stage >= cropDef.stages
    };
  }
}

</script>
  <script>
// ============================================================
// ShopSystem â€” NPC shops: buying, selling, restocking (browser)
// ============================================================

class ShopSystem {
  static generateTownShops(location) {
    const shops = [];
    const townShopMap = {
      stonehaven: ['generalStore', 'blacksmith'],
      millfield: ['generalStore', 'farmSupply'],
      crownhold: ['generalStore', 'blacksmith', 'magicShop', 'tavern'],
      duskmarket: ['generalStore', 'tavern'],
      tidereach: ['generalStore', 'blacksmith', 'tavern'],
      archgate: ['magicShop', 'generalStore'],
      frostbell: ['generalStore', 'tavern'],
      homestead: []
    };

    const shopIds = townShopMap[location.id] || ['generalStore'];
    shopIds.forEach(shopId => {
      const def = SHOP_DEFS[shopId];
      if (!def) return;
      const inventory = def.inventory.map(slot => ({
        itemId: slot.itemId,
        stock: slot.stock,
        maxStock: slot.stock,
        restockRate: slot.restockRate
      }));
      shops.push({
        id: uuidv4(),
        shopDefId: shopId,
        name: def.name,
        npcName: def.npcName,
        char: def.char,
        color: def.color,
        buyMarkup: def.buyMarkup,
        sellMarkdown: def.sellMarkdown,
        inventory,
        x: 0, y: 0
      });
    });
    return shops;
  }

  static getShopDisplay(shop) {
    if (!shop) return null;
    return {
      id: shop.id,
      name: shop.name,
      npcName: shop.npcName,
      char: shop.char,
      color: shop.color,
      items: shop.inventory.map(slot => {
        const template = ITEM_TEMPLATES[slot.itemId];
        if (!template) return null;
        const buyPrice = Math.ceil(template.value * shop.buyMarkup);
        return {
          itemId: slot.itemId,
          id: template.id,
          name: template.name,
          type: template.type,
          subtype: template.subtype || '',
          slot: template.slot || '',
          char: template.char || '?',
          color: template.color || '#ccc',
          healMP: template.healMP || 0,
          buyPrice,
          stock: slot.stock,
          value: template.value
        };
      }).filter(Boolean)
    };
  }

  static buyItem(player, shop, itemId) {
    if (!shop || !player) return { success: false, message: 'No shop available.' };

    const slot = shop.inventory.find(s => s.itemId === itemId);
    if (!slot || slot.stock <= 0) {
      return { success: false, message: 'That item is out of stock.' };
    }

    const template = ITEM_TEMPLATES[itemId];
    if (!template) return { success: false, message: 'Unknown item.' };

    const price = Math.ceil(template.value * shop.buyMarkup);

    const negotiation = player.skills ? (player.skills.negotiation || 0) : 0;
    const discount = Math.floor(price * negotiation * 0.02);
    const finalPrice = Math.max(1, price - discount);

    if (player.gold < finalPrice) {
      return { success: false, message: `Not enough gold. Need ${finalPrice}gp, have ${player.gold}gp.` };
    }

    player.gold -= finalPrice;
    slot.stock--;

    const item = { ...template, id: uuidv4(), templateId: itemId, quantity: 1 };
    ItemSystem.addToInventory(player, item);

    if (player.skills) {
      CharacterSystem.gainSkillExp(player, 'negotiation', 3);
    }

    return {
      success: true,
      message: `Bought ${template.name} for ${finalPrice}gp.${discount > 0 ? ` (Saved ${discount}gp!)` : ''}`,
      price: finalPrice
    };
  }

  static sellItem(player, shop, itemIndex) {
    if (!shop || !player) return { success: false, message: 'No shop available.' };

    if (itemIndex < 0 || itemIndex >= player.inventory.length) {
      return { success: false, message: 'Invalid item.' };
    }

    const item = player.inventory[itemIndex];
    if (!item) return { success: false, message: 'No item selected.' };

    if (player.equipment) {
      const equipped = Object.values(player.equipment).some(e => e && e.id === item.id);
      if (equipped) return { success: false, message: 'Unequip the item first.' };
    }

    const baseValue = item.value || 1;
    const sellPrice = Math.max(1, Math.floor(baseValue * shop.sellMarkdown));

    const negotiation = player.skills ? (player.skills.negotiation || 0) : 0;
    const bonus = Math.floor(sellPrice * negotiation * 0.02);
    const finalPrice = sellPrice + bonus;

    player.gold += finalPrice;
    ItemSystem.removeFromInventory(player, itemIndex, 1);

    if (player.skills) {
      CharacterSystem.gainSkillExp(player, 'negotiation', 2);
    }

    return {
      success: true,
      message: `Sold ${item.name} for ${finalPrice}gp.${bonus > 0 ? ` (Bonus +${bonus}gp!)` : ''}`,
      price: finalPrice
    };
  }

  static restockShops(shops) {
    if (!shops) return;
    shops.forEach(shop => {
      shop.inventory.forEach(slot => {
        if (slot.stock < slot.maxStock && slot.restockRate > 0) {
          slot.stock = Math.min(slot.maxStock, slot.stock + slot.restockRate);
        }
      });
    });
  }
}

</script>
  <script>
// ============================================================
// CraftingSystem â€” Workshop-based crafting with recipe learning
// ============================================================

class CraftingSystem {

  // â”€â”€ Workshop detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getNearbyWorkshops(player, map) {
    const workshops = new Set();
    if (!map || !map.tiles) return workshops;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const tx = player.x + dx;
        const ty = player.y + dy;
        if (ty >= 0 && ty < map.height && tx >= 0 && tx < map.width) {
          const tile = map.tiles[ty][tx];
          if (tile && tile.workshop) {
            workshops.add(tile.workshop.workshopType);
          }
        }
      }
    }
    return workshops;
  }

  // â”€â”€ Recipe Knowledge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static initRecipes(player) {
    if (!player.knownRecipes) {
      player.knownRecipes = [];
      Object.values(RECIPE_DEFS).forEach(r => {
        if (r.defaultKnown) player.knownRecipes.push(r.id);
      });
    }
  }

  static knowsRecipe(player, recipeId) {
    CraftingSystem.initRecipes(player);
    return player.knownRecipes.includes(recipeId);
  }

  static learnRecipe(player, recipeId) {
    CraftingSystem.initRecipes(player);
    if (!player.knownRecipes.includes(recipeId)) {
      player.knownRecipes.push(recipeId);
      return true;
    }
    return false;
  }

  // â”€â”€ Recipe Learning: Dreaming (sleep) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static tryLearnRecipeFromSleep(player) {
    CraftingSystem.initRecipes(player);
    // 25% base chance to dream of a recipe
    if (Math.random() > 0.25) return null;

    const candidates = Object.values(RECIPE_DEFS).filter(r => {
      if (player.knownRecipes.includes(r.id)) return false;
      if (r.defaultKnown) return false;
      const skillLevel = player.skills ? (player.skills[r.skill] || 0) : 0;
      return skillLevel >= r.skillReq;
    });
    if (candidates.length === 0) return null;

    // Weighted random: lower-level recipes more likely
    candidates.sort((a, b) => a.level - b.level);
    const weights = candidates.map((r, i) => Math.max(1, candidates.length - i));
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let roll = Math.random() * totalWeight;
    let picked = candidates[0];
    for (let i = 0; i < candidates.length; i++) {
      roll -= weights[i];
      if (roll <= 0) { picked = candidates[i]; break; }
    }

    CraftingSystem.learnRecipe(player, picked.id);
    return picked;
  }

  // â”€â”€ Recipe Learning: Skill Practice â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static tryLearnRecipeFromSkill(player, skillId) {
    CraftingSystem.initRecipes(player);
    // ~3% + perception bonus chance
    const luckBonus = ((player.attributes && player.attributes.PER) || 10) * 0.002;
    if (Math.random() > 0.03 + luckBonus) return null;

    const skillLevel = player.skills ? (player.skills[skillId] || 0) : 0;
    const candidates = Object.values(RECIPE_DEFS).filter(r => {
      if (player.knownRecipes.includes(r.id)) return false;
      if (r.defaultKnown) return false;
      if (r.skill !== skillId) return false;
      return skillLevel >= r.skillReq;
    });
    if (candidates.length === 0) return null;

    const picked = candidates[Math.floor(Math.random() * candidates.length)];
    CraftingSystem.learnRecipe(player, picked.id);
    return picked;
  }

  // â”€â”€ Recipe Learning: Recipe Paper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static readRecipePaper(player, recipeId) {
    const recipe = RECIPE_DEFS[recipeId];
    if (!recipe) return { success: false, message: 'The recipe paper is illegible.' };
    if (CraftingSystem.knowsRecipe(player, recipeId)) {
      return { success: false, message: `You already know how to make: ${recipe.name}.`, consumed: false };
    }
    CraftingSystem.learnRecipe(player, recipeId);
    return { success: true, message: `You study the recipe paper and learn: ${recipe.name}!`, consumed: true };
  }

  // â”€â”€ Get Available Recipes for UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getAvailableRecipes(player, nearbyWorkshops) {
    if (!player) return [];
    CraftingSystem.initRecipes(player);
    const workshops = nearbyWorkshops || new Set();

    return Object.values(RECIPE_DEFS).map(recipe => {
      const known = player.knownRecipes.includes(recipe.id);
      if (!known) return null;

      const skillLevel = player.skills ? (player.skills[recipe.skill] || 0) : 0;
      const meetsSkill = skillLevel >= recipe.skillReq;

      const workshopNeeded = recipe.workshop || null;
      const hasWorkshop = !workshopNeeded || workshops.has(workshopNeeded);

      const ingredients = recipe.ingredients.map(ing => {
        const template = ITEM_TEMPLATES[ing.itemId];
        const haveCount = CraftingSystem._countItem(player, ing.itemId);
        return {
          itemId: ing.itemId,
          name: template ? template.name : ing.itemId,
          needed: ing.count,
          have: haveCount,
          enough: haveCount >= ing.count
        };
      });

      const resultTemplate = ITEM_TEMPLATES[recipe.result.itemId];
      const canCraft = meetsSkill && hasWorkshop && ingredients.every(i => i.enough);

      const successChance = Math.min(95, Math.max(10,
        50 + skillLevel * 5 - recipe.difficulty * 5
      ));

      let workshopName = null;
      if (workshopNeeded) {
        const wsItem = Object.values(ITEM_TEMPLATES).find(t => t.workshopType === workshopNeeded);
        workshopName = wsItem ? wsItem.name : workshopNeeded;
      }

      return {
        id: recipe.id,
        name: recipe.name,
        skill: recipe.skill,
        skillReq: recipe.skillReq,
        level: recipe.level || recipe.skillReq,
        difficulty: recipe.difficulty,
        meetsSkill,
        hasWorkshop,
        workshopNeeded,
        workshopName,
        canCraft,
        successChance,
        ingredients,
        resultName: resultTemplate ? resultTemplate.name : 'Unknown',
        resultCount: recipe.result.count
      };
    }).filter(r => r !== null);
  }

  static _countItem(player, templateId) {
    if (!player || !player.inventory) return 0;
    const template = ITEM_TEMPLATES[templateId];
    if (!template) return 0;
    let total = 0;
    player.inventory.forEach(i => {
      if ((i.templateId === templateId) || (i.id === templateId) ||
          (i.name === template.name && i.type === template.type)) {
        total += (i.quantity || 1);
      }
    });
    return total;
  }

  static _removeItems(player, templateId, count) {
    const template = ITEM_TEMPLATES[templateId];
    if (!template) return false;
    let removed = 0;
    for (let i = player.inventory.length - 1; i >= 0 && removed < count; i--) {
      const item = player.inventory[i];
      if (item.name === template.name && item.type === template.type) {
        const isEquipped = player.equipment && Object.values(player.equipment).some(
          e => e && e.id === item.id
        );
        if (!isEquipped) {
          const qty = item.quantity || 1;
          const toRemove = Math.min(qty, count - removed);
          ItemSystem.removeFromInventory(player, i, toRemove);
          removed += toRemove;
        }
      }
    }
    return removed >= count;
  }

  static craft(player, recipeId, nearbyWorkshops) {
    const recipe = RECIPE_DEFS[recipeId];
    if (!recipe) return { success: false, message: 'Unknown recipe.' };

    CraftingSystem.initRecipes(player);
    if (!player.knownRecipes.includes(recipeId)) {
      return { success: false, message: "You don't know this recipe." };
    }

    const skillLevel = player.skills ? (player.skills[recipe.skill] || 0) : 0;
    if (skillLevel < recipe.skillReq) {
      return {
        success: false,
        message: `Your ${recipe.skill} skill is too low. Need level ${recipe.skillReq}, have ${skillLevel}.`
      };
    }

    const workshopNeeded = recipe.workshop || null;
    const workshops = nearbyWorkshops || new Set();
    if (workshopNeeded && !workshops.has(workshopNeeded)) {
      const wsItem = Object.values(ITEM_TEMPLATES).find(t => t.workshopType === workshopNeeded);
      const wsName = wsItem ? wsItem.name : workshopNeeded;
      return { success: false, message: `You need to be near a ${wsName} to craft this.` };
    }

    for (const ing of recipe.ingredients) {
      const have = CraftingSystem._countItem(player, ing.itemId);
      const template = ITEM_TEMPLATES[ing.itemId];
      if (have < ing.count) {
        return {
          success: false,
          message: `Not enough ${template ? template.name : ing.itemId}. Need ${ing.count}, have ${have}.`
        };
      }
    }

    for (const ing of recipe.ingredients) {
      CraftingSystem._removeItems(player, ing.itemId, ing.count);
    }

    const successChance = Math.min(95, Math.max(10,
      50 + skillLevel * 5 - recipe.difficulty * 5
    ));
    const roll = Math.random() * 100;

    CharacterSystem.gainSkillExp(player, recipe.skill, recipe.xpGain || 10);

    if (roll > successChance) {
      return {
        success: false,
        consumed: true,
        message: `You failed to craft ${recipe.name}! Materials lost. (${Math.floor(successChance)}% chance)`
      };
    }

    const resultTemplate = ITEM_TEMPLATES[recipe.result.itemId];
    if (!resultTemplate) {
      return { success: false, message: 'Recipe result item not found!' };
    }

    const createdItems = [];
    for (let i = 0; i < recipe.result.count; i++) {
      const item = ItemSystem.createItem(recipe.result.itemId);
      if (item) {
        ItemSystem.addToInventory(player, item);
        createdItems.push(item.name);
      }
    }

    return {
      success: true,
      message: `Successfully crafted ${createdItems.join(', ')}! (${recipe.skill} +exp)`,
      items: createdItems
    };
  }

  // â”€â”€ Create Recipe Paper Item â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static createRecipePaper(recipeId) {
    const recipe = RECIPE_DEFS[recipeId];
    if (!recipe) return null;
    const paper = ItemSystem.createItem('recipePaper');
    if (!paper) return null;
    paper.recipeId = recipeId;
    paper.name = `Recipe: ${recipe.name}`;
    return paper;
  }

  // â”€â”€ Generate random recipe paper for monster drops â”€â”€
  static generateRandomRecipePaper(monsterLevel) {
    const candidates = Object.values(RECIPE_DEFS).filter(r => {
      if (r.defaultKnown) return false;
      return r.level <= Math.max(3, monsterLevel + 2);
    });
    if (candidates.length === 0) return null;
    const picked = candidates[Math.floor(Math.random() * candidates.length)];
    return CraftingSystem.createRecipePaper(picked.id);
  }
}

</script>
  <script>
// ============================================================
// QuestSystem â€” Quest generation, tracking, completion (browser)
// ============================================================

class QuestSystem {
  // â”€â”€ Generate quests for a town's quest board â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateBoardQuests(townId, playerLevel) {
    if (!QUEST_DEFS || !QUEST_DEFS.boards) return [];
    const boardDef = QUEST_DEFS.boards[townId];
    if (!boardDef) return [];

    const quests = [];
    const maxQ = boardDef.maxQuests || 3;
    const [minDanger, maxDanger] = boardDef.dangerRange || [1, 10];
    const [minLevel, maxLevel] = boardDef.levelRange || [1, 10];

    // Effective level for scaling (clamped to board range)
    const effLevel = Math.max(minLevel, Math.min(maxLevel, playerLevel));

    const questTypes = ['hunt', 'bounty', 'delivery', 'gather', 'explore'];

    for (let i = 0; i < maxQ; i++) {
      const type = questTypes[Math.floor(Math.random() * questTypes.length)];
      const quest = QuestSystem._generateQuest(type, townId, effLevel, minDanger, maxDanger);
      if (quest) quests.push(quest);
    }

    return quests;
  }

  static _generateQuest(type, townId, level, minDanger, maxDanger) {
    const typeDef = QUEST_DEFS.types[type];
    if (!typeDef) return null;

    const danger = Math.floor(minDanger + Math.random() * (maxDanger - minDanger + 1));
    const rewards = QUEST_DEFS.rewards;
    const goldReward = Math.floor(rewards.goldPerDanger * danger * (0.8 + Math.random() * 0.4));
    const xpReward = Math.floor(rewards.xpPerDanger * danger * (0.8 + Math.random() * 0.4));
    const fameReward = rewards.famePerQuest + Math.floor(danger / 3);
    const karmaReward = rewards.karmaPerQuest;

    // Bonus item reward
    let bonusItem = null;
    if (Math.random() < rewards.bonusItemChance) {
      const items = QUEST_DEFS.bonusItems;
      bonusItem = items[Math.floor(Math.random() * items.length)];
    }

    const flavorTexts = QUEST_DEFS.flavorText[type] || ['Complete this task.'];
    const flavor = flavorTexts[Math.floor(Math.random() * flavorTexts.length)];

    const base = {
      id: uuidv4(),
      type,
      typeName: typeDef.name,
      icon: typeDef.icon,
      color: typeDef.color,
      townId,
      danger,
      flavor,
      goldReward,
      xpReward,
      fameReward,
      karmaReward,
      bonusItem,
      accepted: false,
      completed: false,
      failed: false,
      turnAccepted: 0,
      progress: 0
    };

    switch (type) {
      case 'hunt':
        return QuestSystem._buildHuntQuest(base, danger);
      case 'bounty':
        return QuestSystem._buildBountyQuest(base, danger);
      case 'delivery':
        return QuestSystem._buildDeliveryQuest(base, townId);
      case 'gather':
        return QuestSystem._buildGatherQuest(base, danger);
      case 'explore':
        return QuestSystem._buildExploreQuest(base, danger);
      default:
        return null;
    }
  }

  static _buildHuntQuest(base, danger) {
    // Pick a monster appropriate for danger
    const eligible = [];
    if (MONSTER_TIERS) {
      MONSTER_TIERS.forEach(tier => {
        if (danger >= tier.minDanger && danger <= tier.maxDanger) {
          tier.monsters.forEach(mId => eligible.push(mId));
        }
      });
    }
    if (eligible.length === 0) eligible.push('putit');
    const monsterId = eligible[Math.floor(Math.random() * eligible.length)];
    const monsterDef = MONSTER_TEMPLATES[monsterId];
    const monsterName = monsterDef ? monsterDef.name : monsterId;
    const count = 3 + Math.floor(Math.random() * 5); // 3-7

    return {
      ...base,
      name: `Hunt: ${count} ${monsterName}s`,
      description: `${base.flavor} Slay ${count} ${monsterName}s and report back.`,
      targetMonsterId: monsterId,
      targetMonsterName: monsterName,
      targetCount: count,
      progress: 0
    };
  }

  static _buildBountyQuest(base, danger) {
    // Pick a strong monster for the danger level
    const eligible = [];
    if (MONSTER_TIERS) {
      MONSTER_TIERS.forEach(tier => {
        if (danger >= tier.minDanger - 2 && danger <= tier.maxDanger) {
          tier.monsters.forEach(mId => eligible.push(mId));
        }
      });
    }
    if (eligible.length === 0) eligible.push('goblin');
    // Pick the strongest
    const monsterId = eligible[eligible.length - 1];
    const monsterDef = MONSTER_TEMPLATES[monsterId];
    const monsterName = monsterDef ? monsterDef.name : monsterId;

    // Bounty gives 2x gold
    base.goldReward = Math.floor(base.goldReward * 2);

    return {
      ...base,
      name: `Bounty: â˜… ${monsterName}`,
      description: `${base.flavor} Slay a â˜… ${monsterName} (any boss variant counts).`,
      targetMonsterId: monsterId,
      targetMonsterName: monsterName,
      targetCount: 1,
      progress: 0,
      requireBoss: false // any of this type counts
    };
  }

  static _buildDeliveryQuest(base, fromTownId) {
    // Pick a random destination town (different from origin)
    const towns = Object.values(WORLD_LOCATIONS).filter(
      l => l.type === 'town' && l.id !== fromTownId
    );
    if (towns.length === 0) return null;
    const destTown = towns[Math.floor(Math.random() * towns.length)];

    // Pick a delivery item
    const deliveryItems = QUEST_DEFS.deliveryItems || [];
    const dItem = deliveryItems[Math.floor(Math.random() * deliveryItems.length)] || { id: 'parcel', name: 'Sealed Parcel' };

    return {
      ...base,
      name: `Deliver: ${dItem.name} â†’ ${destTown.name}`,
      description: `${base.flavor} Deliver the ${dItem.name} to ${destTown.name}.`,
      deliveryItem: dItem,
      destinationTownId: destTown.id,
      destinationTownName: destTown.name,
      progress: 0,
      targetCount: 1
    };
  }

  static _buildGatherQuest(base, danger) {
    const targets = QUEST_DEFS.gatherTargets || [];
    if (targets.length === 0) return null;
    const target = targets[Math.floor(Math.random() * targets.length)];
    const countIdx = Math.min(Math.floor(danger / 5), target.counts.length - 1);
    const count = target.counts[countIdx];

    return {
      ...base,
      name: `Gather: ${count} ${target.name}`,
      description: `${base.flavor} Collect ${count} ${target.name} and bring them back.`,
      targetItemId: target.itemId,
      targetItemName: target.name,
      targetCount: count,
      progress: 0
    };
  }

  static _buildExploreQuest(base, danger) {
    // Pick a nefia
    const nefias = Object.values(WORLD_LOCATIONS).filter(l => l.type === 'nefia');
    if (nefias.length === 0) return null;
    const nefia = nefias[Math.floor(Math.random() * nefias.length)];
    const targetFloor = Math.max(2, Math.floor(danger / 2) + 1);

    return {
      ...base,
      name: `Explore: ${nefia.name} Floor ${targetFloor}`,
      description: `${base.flavor} Reach floor ${targetFloor} of ${nefia.name}.`,
      targetNefiaId: nefia.id,
      targetNefiaName: nefia.name,
      targetFloor,
      progress: 0,
      targetCount: targetFloor
    };
  }

  // â”€â”€ Accept a quest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static acceptQuest(player, quest, turn) {
    if (quest.accepted) return { success: false, message: 'Quest already accepted.' };

    // Max 5 active quests
    const activeQuests = (player.quests || []).filter(q => q.accepted && !q.completed && !q.failed);
    if (activeQuests.length >= 5) {
      return { success: false, message: 'You can only have 5 active quests. Complete or abandon one first.' };
    }

    quest.accepted = true;
    quest.turnAccepted = turn;

    // For delivery quests, add the delivery item to inventory
    if (quest.type === 'delivery' && quest.deliveryItem) {
      const dItem = {
        id: uuidv4(),
        templateId: `quest_${quest.deliveryItem.id}`,
        name: quest.deliveryItem.name,
        type: 'quest',
        char: quest.deliveryItem.char || 'âœ‰',
        color: quest.deliveryItem.color || '#ca8',
        value: 0,
        weight: 1,
        quantity: 1,
        questId: quest.id
      };
      ItemSystem.addToInventory(player, dItem);
    }

    if (!player.quests) player.quests = [];
    player.quests.push(quest);

    return { success: true, message: `Quest accepted: ${quest.name}` };
  }

  // â”€â”€ Abandon a quest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static abandonQuest(player, questId) {
    if (!player.quests) return { success: false, message: 'No quests.' };
    const idx = player.quests.findIndex(q => q.id === questId);
    if (idx === -1) return { success: false, message: 'Quest not found.' };

    const quest = player.quests[idx];
    if (quest.completed) return { success: false, message: 'Quest already completed.' };

    // Remove delivery item if any
    if (quest.type === 'delivery') {
      const dIdx = player.inventory.findIndex(i => i.questId === quest.id);
      if (dIdx >= 0) {
        ItemSystem.removeFromInventory(player, dIdx, 1);
      }
    }

    player.quests.splice(idx, 1);
    return { success: true, message: `Quest abandoned: ${quest.name}` };
  }

  // â”€â”€ Notify: monster killed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onMonsterKilled(player, monster) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;

      if (quest.type === 'hunt' && monster.templateId === quest.targetMonsterId) {
        quest.progress = Math.min(quest.progress + 1, quest.targetCount);
        if (quest.progress >= quest.targetCount) {
          messages.push({ text: `Quest ready to turn in: ${quest.name}`, type: 'important' });
        } else {
          messages.push({
            text: `Quest progress: ${quest.name} (${quest.progress}/${quest.targetCount})`,
            type: 'loot'
          });
        }
      }

      if (quest.type === 'bounty' && monster.templateId === quest.targetMonsterId) {
        quest.progress = Math.min(quest.progress + 1, quest.targetCount);
        if (quest.progress >= quest.targetCount) {
          messages.push({ text: `Bounty target slain! Return to ${quest.townId} to claim reward.`, type: 'important' });
        }
      }
    });

    return messages;
  }

  // â”€â”€ Notify: entered a town â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onEnterTown(player, townId) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;

      if (quest.type === 'delivery' && quest.destinationTownId === townId) {
        quest.progress = 1;
        messages.push({ text: `Delivery arrived! Turn in quest: ${quest.name}`, type: 'important' });
      }
    });

    return messages;
  }

  // â”€â”€ Notify: reached nefia floor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onNefiaFloorReached(player, nefiaId, floor) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;

      if (quest.type === 'explore' && quest.targetNefiaId === nefiaId) {
        if (floor >= quest.targetFloor) {
          quest.progress = quest.targetFloor;
          messages.push({ text: `Exploration complete! Return to ${quest.townId} to claim reward.`, type: 'important' });
        } else if (floor > quest.progress) {
          quest.progress = floor;
          messages.push({
            text: `Exploration progress: Floor ${floor}/${quest.targetFloor}`,
            type: 'loot'
          });
        }
      }
    });

    return messages;
  }

  // â”€â”€ Check if quest is ready to turn in â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static isQuestComplete(quest) {
    if (!quest || quest.completed || quest.failed) return false;
    return quest.progress >= quest.targetCount;
  }

  // â”€â”€ Check gather quests against inventory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static checkGatherQuests(player) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;
      if (quest.type !== 'gather') return;

      const count = QuestSystem._countItem(player, quest.targetItemId);
      const oldProgress = quest.progress;
      quest.progress = Math.min(count, quest.targetCount);

      if (quest.progress >= quest.targetCount && oldProgress < quest.targetCount) {
        messages.push({ text: `You have enough ${quest.targetItemName}! Return to ${quest.townId} to turn in.`, type: 'important' });
      }
    });

    return messages;
  }

  static _countItem(player, itemId) {
    if (!player.inventory) return 0;
    return player.inventory
      .filter(i => i.templateId === itemId)
      .reduce((sum, i) => sum + (i.quantity || 1), 0);
  }

  // â”€â”€ Turn in a quest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static turnInQuest(player, questId, currentTownId) {
    if (!player.quests) return { success: false, message: 'No quests.' };
    const quest = player.quests.find(q => q.id === questId);
    if (!quest) return { success: false, message: 'Quest not found.' };
    if (quest.completed) return { success: false, message: 'Quest already completed.' };

    // Must be in the quest's origin town to turn in
    if (quest.townId !== currentTownId) {
      return { success: false, message: `Return to the quest board in ${quest.townId} to turn in.` };
    }

    // Check if conditions are met
    if (!QuestSystem.isQuestComplete(quest)) {
      return { success: false, message: `Quest not yet complete: ${quest.name}` };
    }

    // For gather quests, consume the items
    if (quest.type === 'gather') {
      let remaining = quest.targetCount;
      for (let i = player.inventory.length - 1; i >= 0 && remaining > 0; i--) {
        if (player.inventory[i].templateId === quest.targetItemId) {
          const qty = player.inventory[i].quantity || 1;
          if (qty <= remaining) {
            remaining -= qty;
            ItemSystem.removeFromInventory(player, i, qty);
          } else {
            player.inventory[i].quantity -= remaining;
            remaining = 0;
          }
        }
      }
    }

    // For delivery quests, remove the delivery item
    if (quest.type === 'delivery') {
      const dIdx = player.inventory.findIndex(i => i.questId === quest.id);
      if (dIdx >= 0) {
        ItemSystem.removeFromInventory(player, dIdx, 1);
      }
    }

    quest.completed = true;

    // Grant rewards
    const rewardMessages = [];
    player.gold = (player.gold || 0) + quest.goldReward;
    rewardMessages.push(`+${quest.goldReward} gold`);

    if (quest.xpReward > 0) {
      CharacterSystem.gainExp(player, quest.xpReward);
      rewardMessages.push(`+${quest.xpReward} XP`);
    }

    // Bonus item
    let bonusItemObj = null;
    if (quest.bonusItem) {
      bonusItemObj = ItemSystem.createItem(quest.bonusItem);
      if (bonusItemObj) {
        ItemSystem.addToInventory(player, bonusItemObj);
        rewardMessages.push(`+${bonusItemObj.name}`);
      }
    }

    const rewardStr = rewardMessages.join(', ');

    return {
      success: true,
      message: `Quest complete: ${quest.name}! Rewards: ${rewardStr}`,
      fame: quest.fameReward,
      karma: quest.karmaReward
    };
  }

  // â”€â”€ Get quests for display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getActiveQuests(player) {
    if (!player.quests) return [];
    return player.quests
      .filter(q => q.accepted && !q.completed && !q.failed)
      .map(q => ({
        ...q,
        isComplete: QuestSystem.isQuestComplete(q),
        progressText: `${q.progress}/${q.targetCount}`
      }));
  }

  static getCompletedQuests(player) {
    if (!player.quests) return [];
    return player.quests.filter(q => q.completed);
  }
}

</script>
  <script>
// ============================================================
// PetSystem â€” Taming, pet AI, pet management (browser)
// ============================================================
// Pets are tamed monsters that follow the player, fight enemies,
// and persist across maps. Uses the Taming skill + CHA attribute.
// ============================================================

class PetSystem {
  /**
   * Initialize pet array on the player if not present.
   */
  static init(player) {
    if (!player.pets) player.pets = [];
  }

  /**
   * Maximum number of pets a player can have.
   * Scales with CHA: base 2 + floor(CHA / 8).
   */
  static getMaxPets(player) {
    const cha = player.attributes ? (player.attributes.CHA || 7) : 7;
    return 2 + Math.floor(cha / 8);
  }

  /**
   * Attempt to tame a monster on an adjacent tile.
   * @param {object} player - The player object
   * @param {object} monster - The target monster (from currentMap.monsters)
   * @returns {{ success: boolean, message: string }}
   */
  static attemptTame(player, monster) {
    PetSystem.init(player);

    if (!monster || monster.hp <= 0) {
      return { success: false, message: 'Nothing to tame here.' };
    }

    if (monster.isBoss) {
      return { success: false, message: `${monster.name} is far too powerful to tame!` };
    }

    if (monster.isPet) {
      return { success: false, message: `${monster.name} is already your ally.` };
    }

    const maxPets = PetSystem.getMaxPets(player);
    if (player.pets.length >= maxPets) {
      return { success: false, message: `You already have ${maxPets} pets. Release one first. (CHA increases max)` };
    }

    const tamingSkill = player.skills.taming || 0;
    const cha = player.attributes ? (player.attributes.CHA || 7) : 7;
    const monsterLevel = monster.level || 1;

    // Taming is easier when the monster is wounded
    const hpRatio = monster.hp / monster.maxHp;
    const woundBonus = Math.floor((1 - hpRatio) * 30); // Up to +30% when near death

    // Success chance: 20 + taming*4 + CHA*2 + woundBonus - monsterLevel*5
    const successChance = Math.min(90, Math.max(5,
      20 + tamingSkill * 4 + cha * 2 + woundBonus - monsterLevel * 5
    ));

    // Always gain skill XP for attempting
    CharacterSystem.gainSkillExp(player, 'taming', 5 + monsterLevel);

    const roll = Math.random() * 100;
    if (roll > successChance) {
      // Failed â€” the monster is angered
      return {
        success: false,
        message: `You try to tame ${monster.name} but fail! (${Math.floor(successChance)}% chance)`
      };
    }

    // Success! Convert monster to pet
    const pet = PetSystem._monsterToPet(monster, player);
    player.pets.push(pet);

    // Mark monster as tamed (will be removed from hostile list)
    monster._tamed = true;

    CharacterSystem.gainSkillExp(player, 'taming', 15 + monsterLevel * 2);

    return {
      success: true,
      message: `You successfully tame ${monster.name}! It joins you as an ally. ğŸ¾`
    };
  }

  /**
   * Convert a monster object into a pet data structure.
   */
  static _monsterToPet(monster, player) {
    return {
      id: uuidv4(),
      templateId: monster.templateId || monster.id,
      name: monster.name,
      level: monster.level || 1,
      hp: monster.hp,
      maxHp: monster.maxHp,
      mp: monster.mp || 0,
      speed: monster.speed || 100,
      attack: monster.attack || '1d3',
      xp: 0,
      xpNext: (monster.level || 1) * 40 + 40,
      loyalty: 50,  // 0â€“100, affects behavior
      x: monster.x,
      y: monster.y,
      char: monster.char || 'p',
      color: monster.color || '#4f4',
      isBoss: false,
      isPet: true
    };
  }

  /**
   * Release a pet back into the wild.
   */
  static releasePet(player, petId) {
    PetSystem.init(player);
    const idx = player.pets.findIndex(p => p.id === petId);
    if (idx === -1) {
      return { success: false, message: 'Pet not found.' };
    }
    const pet = player.pets.splice(idx, 1)[0];
    return { success: true, message: `You release ${pet.name} back into the wild. Farewell! ğŸ¾` };
  }

  /**
   * Rename a pet.
   */
  static renamePet(player, petId, newName) {
    PetSystem.init(player);
    const pet = player.pets.find(p => p.id === petId);
    if (!pet) return { success: false, message: 'Pet not found.' };
    const oldName = pet.name;
    pet.name = newName;
    return { success: true, message: `${oldName} is now known as ${newName}.` };
  }

  /**
   * Place pets on the map near the player when entering a new map.
   */
  static placePetsOnMap(player, map) {
    PetSystem.init(player);
    if (player.pets.length === 0) return;

    const adjacent = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
    ];

    let placed = 0;
    for (const pet of player.pets) {
      let didPlace = false;
      for (const d of adjacent) {
        const nx = player.x + d.dx;
        const ny = player.y + d.dy;
        if (nx < 0 || ny < 0 || nx >= map.width || ny >= map.height) continue;
        const tile = map.tiles[ny][nx];
        if (!tile.walkable) continue;
        const blocked = map.monsters.some(m => m.hp > 0 && m.x === nx && m.y === ny);
        if (blocked) continue;
        // Check no other pet placed here
        const petBlocked = player.pets.some(p => p !== pet && p.x === nx && p.y === ny);
        if (petBlocked) continue;

        pet.x = nx;
        pet.y = ny;
        didPlace = true;
        placed++;
        break;
      }
      // If no adjacent tile found, place further away
      if (!didPlace) {
        for (let radius = 2; radius <= 5; radius++) {
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const nx = player.x + dx;
              const ny = player.y + dy;
              if (nx < 0 || ny < 0 || nx >= map.width || ny >= map.height) continue;
              const tile = map.tiles[ny][nx];
              if (!tile.walkable) continue;
              const bk = map.monsters.some(m => m.hp > 0 && m.x === nx && m.y === ny);
              if (bk) continue;
              pet.x = nx;
              pet.y = ny;
              didPlace = true;
              break;
            }
            if (didPlace) break;
          }
          if (didPlace) break;
        }
      }
    }
  }

  /**
   * Run one turn of pet AI for all pets.
   * Pets attack adjacent enemies, otherwise move toward the nearest enemy
   * (if one is nearby) or follow the player.
   */
  static petTurn(player, map, addMessage) {
    PetSystem.init(player);
    if (player.pets.length === 0) return;

    for (const pet of player.pets) {
      if (pet.hp <= 0) continue;

      // Find nearest hostile monster
      let nearestEnemy = null;
      let nearestDist = Infinity;
      for (const m of map.monsters) {
        if (m.hp <= 0 || m._tamed || m.isPet) continue;
        const dist = Math.abs(m.x - pet.x) + Math.abs(m.y - pet.y);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestEnemy = m;
        }
      }

      // If adjacent to an enemy, attack it
      if (nearestEnemy && nearestDist <= 1) {
        const result = PetSystem._petAttack(pet, nearestEnemy);
        if (addMessage) addMessage(result.message);
        if (nearestEnemy.hp <= 0) {
          if (addMessage) addMessage(`${pet.name} defeats ${nearestEnemy.name}!`);
          // Pet gains XP
          PetSystem.gainPetExp(pet, nearestEnemy.xp || 5);
          // Give player taming XP for the pet's kill
          CharacterSystem.gainSkillExp(player, 'taming', 3);
        }
        continue;
      }

      // If an enemy is within 6 tiles, move toward it
      if (nearestEnemy && nearestDist <= 6) {
        PetSystem._moveToward(pet, nearestEnemy.x, nearestEnemy.y, player, map);
        continue;
      }

      // Otherwise, follow the player if more than 3 tiles away
      const distToPlayer = Math.abs(player.x - pet.x) + Math.abs(player.y - pet.y);
      if (distToPlayer > 3) {
        PetSystem._moveToward(pet, player.x, player.y, player, map);
      }
      // If close to player, idle (or wander slightly)
    }
  }

  /**
   * Pet melee attack against a target.
   */
  static _petAttack(pet, target) {
    const hitChance = 65 + (pet.level || 1) * 2;
    const roll = Math.random() * 100;

    if (roll > hitChance) {
      return {
        hit: false,
        damage: 0,
        message: `${pet.name} attacks ${target.name} but misses!`
      };
    }

    let damage = CombatSystem.rollDice(pet.attack || '1d3');
    damage += Math.floor((pet.level || 1) / 2);

    // Critical chance: 5%
    let critical = false;
    if (Math.random() < 0.05) {
      critical = true;
      damage = Math.floor(damage * 1.5);
    }

    damage = Math.max(1, damage);
    target.hp -= damage;

    const critMsg = critical ? ' Critical hit!' : '';
    return {
      hit: true,
      damage,
      critical,
      message: `${pet.name} hits ${target.name} for ${damage} damage.${critMsg}`
    };
  }

  /**
   * Move a pet one step toward a target coordinate.
   */
  static _moveToward(pet, tx, ty, player, map) {
    const dx = tx - pet.x;
    const dy = ty - pet.y;
    const mx = dx === 0 ? 0 : Math.sign(dx);
    const my = dy === 0 ? 0 : Math.sign(dy);
    const nx = pet.x + mx;
    const ny = pet.y + my;

    if (nx < 0 || ny < 0 || nx >= map.width || ny >= map.height) return;

    const tile = map.tiles[ny][nx];
    if (!tile.walkable) return;

    // Don't step on the player
    if (nx === player.x && ny === player.y) return;

    // Don't step on hostile monsters (they should attack instead)
    const monsterBlocked = map.monsters.some(m => m.hp > 0 && m.x === nx && m.y === ny);
    if (monsterBlocked) return;

    // Don't step on other pets
    const petBlocked = player.pets.some(p => p !== pet && p.hp > 0 && p.x === nx && p.y === ny);
    if (petBlocked) return;

    pet.x = nx;
    pet.y = ny;
  }

  /**
   * Give a pet experience and handle level-ups.
   */
  static gainPetExp(pet, amount) {
    pet.xp = (pet.xp || 0) + amount;
    while (pet.xp >= pet.xpNext) {
      pet.xp -= pet.xpNext;
      pet.level = (pet.level || 1) + 1;
      pet.xpNext = pet.level * 40 + 40;
      // Increase stats on level up
      pet.maxHp = Math.floor(pet.maxHp * 1.12) + 2;
      pet.hp = pet.maxHp; // Full heal on level up
      pet.loyalty = Math.min(100, (pet.loyalty || 50) + 5);
      // Upgrade attack dice every 3 levels
      if (pet.level % 3 === 0) {
        pet.attack = PetSystem._upgradeDice(pet.attack);
      }
    }
  }

  /**
   * Upgrade dice notation (e.g., 1d3 â†’ 1d4, 2d6 â†’ 2d7, max at 4d10).
   */
  static _upgradeDice(diceStr) {
    if (!diceStr) return '1d4';
    const [n, m] = diceStr.split('d').map(Number);
    if (m < 10) return `${n}d${m + 1}`;
    if (n < 4) return `${n + 1}d${m}`;
    return diceStr; // Max
  }

  /**
   * Handle damage dealt to a pet by a monster.
   */
  static damagePet(pet, damage) {
    pet.hp = Math.max(0, pet.hp - damage);
    return pet.hp <= 0;
  }

  /**
   * Heal all pets by a small amount each turn (natural regeneration).
   */
  static regenPets(player) {
    PetSystem.init(player);
    for (const pet of player.pets) {
      if (pet.hp <= 0) continue;
      if (pet.hp < pet.maxHp) {
        pet.hp = Math.min(pet.maxHp, pet.hp + 1);
      }
    }
  }

  /**
   * Revive a dead pet at 25% HP (costs gold).
   */
  static revivePet(player, petId) {
    PetSystem.init(player);
    const pet = player.pets.find(p => p.id === petId);
    if (!pet) return { success: false, message: 'Pet not found.' };
    if (pet.hp > 0) return { success: false, message: `${pet.name} is not dead.` };

    const cost = (pet.level || 1) * 50;
    if ((player.gold || 0) < cost) {
      return { success: false, message: `Not enough gold to revive ${pet.name}. (Need ${cost}gp)` };
    }

    player.gold -= cost;
    pet.hp = Math.floor(pet.maxHp * 0.25);
    pet.loyalty = Math.max(0, (pet.loyalty || 50) - 10);

    return { success: true, message: `${pet.name} has been revived! (Cost: ${cost}gp) ğŸ¾` };
  }

  /**
   * Get pet list for client state display.
   */
  static getPetList(player) {
    PetSystem.init(player);
    return player.pets.map(pet => ({
      id: pet.id,
      templateId: pet.templateId,
      name: pet.name,
      level: pet.level || 1,
      hp: pet.hp,
      maxHp: pet.maxHp,
      attack: pet.attack,
      xp: pet.xp || 0,
      xpNext: pet.xpNext || 80,
      loyalty: pet.loyalty || 50,
      x: pet.x,
      y: pet.y,
      char: pet.char || 'p',
      color: pet.color || '#4f4',
      isDead: pet.hp <= 0,
      isPet: true
    }));
  }

  /**
   * Check if a position is occupied by a live pet.
   */
  static isPetAt(player, x, y) {
    PetSystem.init(player);
    return player.pets.some(p => p.hp > 0 && p.x === x && p.y === y);
  }

  /**
   * Get a pet at a specific position.
   */
  static getPetAt(player, x, y) {
    PetSystem.init(player);
    return player.pets.find(p => p.hp > 0 && p.x === x && p.y === y) || null;
  }
}

</script>
  <script>
// ============================================================
// GatheringSystem â€” Mining, Chopping, Fishing, Herb Gathering,
//                   Berry Picking, Mushroom Foraging, and more
// ============================================================
// Players interact with resource nodes on maps to gather materials.
// Each node type uses a different skill and yields different items.
// Tree and ore nodes come in subtypes with different hardness values.
// Equipping better tools (axes, pickaxes) speeds up gathering.
// Nodes are consumed on use and regenerate when the map is revisited.
// ============================================================

class GatheringSystem {

  /**
   * Attempt to gather from an adjacent or current tile resource node.
   * @param {object} player
   * @param {object} tile - The map tile being gathered from
   * @param {object} map - The current map (to place items)
   * @param {number} tileX - Tile world x
   * @param {number} tileY - Tile world y
   * @returns {{ success: boolean, message: string, items: object[], skillUsed: string }}
   */
  static gather(player, tile, map, tileX, tileY) {
    const nodeType = GatheringSystem.getNodeType(tile);
    if (!nodeType) {
      return { success: false, message: 'Nothing to gather here.', items: [], skillUsed: null };
    }

    const cfg = GatheringSystem.NODE_CONFIG[nodeType];
    if (!cfg) {
      return { success: false, message: 'Nothing to gather here.', items: [], skillUsed: null };
    }

    // Determine subtype config (for trees/ores with variants)
    const subtype = tile._nodeSubtype || null;
    const subCfg = (subtype && cfg.subtypes && cfg.subtypes[subtype]) ? cfg.subtypes[subtype] : null;

    // Merge subtype overrides with base config
    const difficulty = (subCfg && subCfg.difficulty != null) ? subCfg.difficulty : cfg.difficulty;
    const hardness = (subCfg && subCfg.hardness != null) ? subCfg.hardness : (cfg.hardness || 1);
    const drops = (subCfg && subCfg.drops) ? subCfg.drops : cfg.drops;
    const rareDrops = (subCfg && subCfg.rareDrops) ? subCfg.rareDrops : cfg.rareDrops;
    const xpGain = (subCfg && subCfg.xpGain != null) ? subCfg.xpGain : cfg.xpGain;
    const spCostBase = (subCfg && subCfg.spCost != null) ? subCfg.spCost : cfg.spCost;
    const nodeName = (subCfg && subCfg.name) ? subCfg.name : cfg.name;
    const requiredToolPower = (subCfg && subCfg.requiredToolPower != null) ? subCfg.requiredToolPower : (cfg.requiredToolPower || 0);

    const skillLevel = player.skills ? (player.skills[cfg.skill] || 0) : 0;

    // Tool bonus â€” find the best equipped tool of the right type
    const toolBonus = GatheringSystem._getToolBonus(player, cfg.toolType);

    // Check if the player has a strong enough tool for hard nodes
    if (requiredToolPower > 0 && toolBonus.power < requiredToolPower) {
      const toolName = cfg.toolType === 'axeTool' ? 'axe' : cfg.toolType === 'pickaxe' ? 'pickaxe' : 'tool';
      return {
        success: false,
        message: `This ${nodeName} requires a better ${toolName} (power ${requiredToolPower}+) to harvest.`,
        items: [],
        skillUsed: cfg.skill
      };
    }

    // Effective difficulty reduced by tool power
    const effectiveDifficulty = Math.max(1, difficulty - toolBonus.power);
    const successChance = Math.min(95, Math.max(15, 40 + skillLevel * 5 - effectiveDifficulty * 3 + toolBonus.power * 5));
    const roll = Math.random() * 100;

    // Always grant skill XP (scaled by hardness)
    CharacterSystem.gainSkillExp(player, cfg.skill, Math.floor(xpGain * hardness));

    // SP cost â€” reduced by skill and tool
    const spCost = Math.max(1, Math.ceil(spCostBase * hardness) - Math.floor(skillLevel / 5) - toolBonus.power);
    if (player.sp < spCost) {
      return {
        success: false,
        message: `You're too tired to ${cfg.verb}. (Need ${spCost} SP)`,
        items: [],
        skillUsed: cfg.skill
      };
    }
    player.sp = Math.max(0, player.sp - spCost);

    if (roll > successChance) {
      const toolMsg = toolBonus.name ? ` [${toolBonus.name}]` : '';
      return {
        success: false,
        message: `You ${cfg.verb} the ${nodeName} but find nothing useful.${toolMsg} (${cfg.skill} +exp, ${Math.floor(successChance)}%)`,
        items: [],
        skillUsed: cfg.skill
      };
    }

    // Determine yield
    const items = GatheringSystem._rollYield(drops, rareDrops, skillLevel, toolBonus.power);

    // Deplete the node (convert to a depleted version)
    const depletedTile = (subCfg && subCfg.depletedTile) ? subCfg.depletedTile : cfg.depletedTile;
    const depletedChar = (subCfg && subCfg.depletedChar) ? subCfg.depletedChar : cfg.depletedChar;
    const depletedColor = (subCfg && subCfg.depletedColor) ? subCfg.depletedColor : cfg.depletedColor;
    const depletedWalkable = (subCfg && subCfg.depletedWalkable != null) ? subCfg.depletedWalkable : cfg.depletedWalkable;

    tile.type = depletedTile;
    tile.char = depletedChar;
    tile.color = depletedColor;
    tile.walkable = depletedWalkable;
    tile.transparent = true;
    tile._depletedNode = nodeType; // mark for potential regrowth
    tile._depletedTurn = 0; // will be set by caller
    tile._nodeSubtype = null;

    const toolMsg = toolBonus.name ? ` [${toolBonus.name}]` : '';
    return {
      success: true,
      message: `You ${cfg.verb} the ${nodeName} successfully!${toolMsg} (${cfg.skill} +exp)`,
      items,
      skillUsed: cfg.skill
    };
  }

  /**
   * Get the best tool bonus for a given tool type from the player's equipment/inventory.
   * @returns {{ power: number, name: string|null }}
   */
  static _getToolBonus(player, toolType) {
    if (!toolType) return { power: 0, name: null };
    let bestPower = 0;
    let bestName = null;

    // Check equipped weapon first (axes/pickaxes can be used as weapons too)
    const equipped = player.equipment && player.equipment.weapon;
    if (equipped && equipped.subtype === toolType && equipped.toolPower) {
      bestPower = equipped.toolPower;
      bestName = equipped.name;
    }

    // Check inventory for dedicated tools
    if (player.inventory) {
      for (const item of player.inventory) {
        if (item.type === 'tool' && item.subtype === toolType && item.toolPower > bestPower) {
          bestPower = item.toolPower;
          bestName = item.name;
        }
      }
    }
    return { power: bestPower, name: bestName };
  }

  /**
   * Check what kind of resource node a tile is (if any).
   */
  static getNodeType(tile) {
    if (!tile) return null;
    const type = tile.type;

    // Tree variants
    if (type === 'tree' || type === 'oakTree' || type === 'pineTree' ||
        type === 'birchTree' || type === 'mapleTree' || type === 'yewTree' ||
        type === 'snowTree') {
      return 'tree';
    }
    // Ore variants
    if (type === 'ore' || type === 'oreVein' || type === 'copperOre' ||
        type === 'ironOre' || type === 'silverOre' || type === 'goldOre' || type === 'mythrilOre') {
      return 'ore';
    }
    // Other resource nodes
    switch (type) {
      case 'water':
      case 'fishingSpot':
        return 'fish';
      case 'herbPatch':
        return 'herb';
      case 'berryBush':
        return 'berry';
      case 'mushroomPatch':
        return 'mushroom';
      case 'clayDeposit':
        return 'clay';
      case 'sandDeposit':
        return 'sandNode';
      case 'flintNode':
        return 'flintNode';
      case 'reedPatch':
        return 'reed';
      case 'bush':
        return 'bush';
      case 'deadTree':
        return 'deadTree';
      case 'cactus':
        return 'cactus';
      default:
        return null;
    }
  }

  /**
   * Returns info about a gatherable node for UI display.
   */
  static getNodeInfo(tile) {
    const nodeType = GatheringSystem.getNodeType(tile);
    if (!nodeType) return null;
    const cfg = GatheringSystem.NODE_CONFIG[nodeType];
    if (!cfg) return null;

    // Get subtype-specific name if available
    const subtype = tile._nodeSubtype || null;
    const subCfg = (subtype && cfg.subtypes && cfg.subtypes[subtype]) ? cfg.subtypes[subtype] : null;
    const nodeName = (subCfg && subCfg.name) ? subCfg.name : cfg.name;

    return {
      type: nodeType,
      subtype: subtype,
      name: nodeName,
      skill: cfg.skill,
      verb: cfg.verb,
      icon: cfg.icon,
      toolType: cfg.toolType || null
    };
  }

  /**
   * Find the nearest adjacent gatherable node to the player.
   * Returns { tile, x, y, nodeType } or null.
   */
  static findAdjacentNode(player, map) {
    if (!map || !map.tiles) return null;
    const dirs = [
      { dx: 0, dy: 0 },   // current tile
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
      { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      { dx: 1, dy: 1 }, { dx: -1, dy: 1 },
      { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
    ];
    for (const { dx, dy } of dirs) {
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (ny >= 0 && ny < map.height && nx >= 0 && nx < map.width) {
        const tile = map.tiles[ny][nx];
        const nodeType = GatheringSystem.getNodeType(tile);
        if (nodeType) {
          return { tile, x: nx, y: ny, nodeType };
        }
      }
    }
    return null;
  }

  /**
   * Roll items yielded from a successful gather.
   */
  static _rollYield(drops, rareDrops, skillLevel, toolPower) {
    const items = [];
    const bonusChance = Math.min(50, skillLevel * 3 + toolPower * 5); // tool increases bonus yield

    // Primary drop
    const primaryPool = drops || [];
    if (primaryPool.length > 0) {
      const pick = primaryPool[Math.floor(Math.random() * primaryPool.length)];
      const item = ItemSystem.createItem(pick);
      if (item) items.push(item);
    }

    // Bonus yield at higher skill / better tools
    if (primaryPool.length > 0 && Math.random() * 100 < bonusChance) {
      const bonusPick = primaryPool[Math.floor(Math.random() * primaryPool.length)];
      const bonusItem = ItemSystem.createItem(bonusPick);
      if (bonusItem) items.push(bonusItem);
    }

    // Rare drops
    if (rareDrops && rareDrops.length > 0) {
      const rareChance = 5 + skillLevel * 1.5 + toolPower * 2;
      if (Math.random() * 100 < rareChance) {
        const rarePick = rareDrops[Math.floor(Math.random() * rareDrops.length)];
        const rareItem = ItemSystem.createItem(rarePick);
        if (rareItem) items.push(rareItem);
      }
    }

    return items;
  }

  /**
   * Assign a node subtype to a tile based on its tile type.
   * Called by MapGenerator when placing resource tiles.
   */
  static assignNodeSubtype(tile) {
    const type = tile.type;
    // Tree subtypes
    if (type === 'oakTree') { tile._nodeSubtype = 'oak'; }
    else if (type === 'pineTree') { tile._nodeSubtype = 'pine'; }
    else if (type === 'birchTree') { tile._nodeSubtype = 'birch'; }
    else if (type === 'mapleTree') { tile._nodeSubtype = 'maple'; }
    else if (type === 'yewTree') { tile._nodeSubtype = 'yew'; }
    else if (type === 'snowTree') { tile._nodeSubtype = 'pine'; } // snow trees are pine
    else if (type === 'tree') { tile._nodeSubtype = 'oak'; } // default tree = oak
    // Ore subtypes
    else if (type === 'copperOre') { tile._nodeSubtype = 'copper'; }
    else if (type === 'ironOre') { tile._nodeSubtype = 'iron'; }
    else if (type === 'silverOre') { tile._nodeSubtype = 'silver'; }
    else if (type === 'goldOre') { tile._nodeSubtype = 'gold'; }
    else if (type === 'mythrilOre') { tile._nodeSubtype = 'mythril'; }
    else if (type === 'ore' || type === 'oreVein') { tile._nodeSubtype = 'iron'; } // default ore = iron
  }
}

// â”€â”€ Node Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GatheringSystem.NODE_CONFIG = {
  ore: {
    name: 'Ore Vein',
    skill: 'mining',
    verb: 'mine',
    icon: 'â›',
    toolType: 'pickaxe',
    difficulty: 3,
    hardness: 1,
    spCost: 3,
    xpGain: 8,
    drops: ['oreIron', 'oreIron'],
    rareDrops: ['crystalBlue'],
    depletedTile: 'rock',
    depletedChar: 'o',
    depletedColor: '#555',
    depletedWalkable: false,
    subtypes: {
      copper: {
        name: 'Copper Vein',
        difficulty: 1,
        hardness: 0.8,
        spCost: 2,
        xpGain: 5,
        requiredToolPower: 0,
        drops: ['oreCopper', 'oreCopper'],
        rareDrops: ['flint']
      },
      iron: {
        name: 'Iron Vein',
        difficulty: 3,
        hardness: 1.0,
        spCost: 3,
        xpGain: 8,
        requiredToolPower: 1,
        drops: ['oreIron', 'oreIron'],
        rareDrops: ['crystalBlue']
      },
      silver: {
        name: 'Silver Vein',
        difficulty: 5,
        hardness: 1.3,
        spCost: 4,
        xpGain: 12,
        requiredToolPower: 2,
        drops: ['oreSilver'],
        rareDrops: ['crystalBlue', 'amber']
      },
      gold: {
        name: 'Gold Vein',
        difficulty: 7,
        hardness: 1.5,
        spCost: 5,
        xpGain: 18,
        requiredToolPower: 3,
        drops: ['oreGold'],
        rareDrops: ['crystalBlue', 'amber']
      },
      mythril: {
        name: 'Mythril Vein',
        difficulty: 10,
        hardness: 2.0,
        spCost: 6,
        xpGain: 30,
        requiredToolPower: 4,
        drops: ['oreMythril'],
        rareDrops: ['crystalBlue']
      }
    }
  },
  tree: {
    name: 'Tree',
    skill: 'lumberjacking',
    verb: 'chop',
    icon: 'ğŸª“',
    toolType: 'axeTool',
    difficulty: 2,
    hardness: 1,
    spCost: 3,
    xpGain: 6,
    drops: ['woodLog', 'woodLog'],
    rareDrops: ['string'],
    depletedTile: 'stump',
    depletedChar: '.',
    depletedColor: '#5a4a2a',
    depletedWalkable: true,
    subtypes: {
      pine: {
        name: 'Pine Tree',
        difficulty: 1,
        hardness: 0.7,
        spCost: 2,
        xpGain: 4,
        requiredToolPower: 0,
        drops: ['pineLog', 'pineLog'],
        rareDrops: ['sap', 'string']
      },
      oak: {
        name: 'Oak Tree',
        difficulty: 2,
        hardness: 1.0,
        spCost: 3,
        xpGain: 6,
        requiredToolPower: 0,
        drops: ['oakLog', 'oakLog'],
        rareDrops: ['bark', 'string']
      },
      birch: {
        name: 'Birch Tree',
        difficulty: 2,
        hardness: 0.8,
        spCost: 2,
        xpGain: 5,
        requiredToolPower: 0,
        drops: ['birchLog', 'birchLog'],
        rareDrops: ['bark', 'sap']
      },
      maple: {
        name: 'Maple Tree',
        difficulty: 4,
        hardness: 1.3,
        spCost: 4,
        xpGain: 10,
        requiredToolPower: 1,
        drops: ['mapleLog', 'mapleLog'],
        rareDrops: ['sap', 'amber']
      },
      yew: {
        name: 'Yew Tree',
        difficulty: 6,
        hardness: 1.8,
        spCost: 5,
        xpGain: 15,
        requiredToolPower: 2,
        drops: ['yewLog'],
        rareDrops: ['sap', 'amber']
      }
    }
  },
  fish: {
    name: 'Fishing Spot',
    skill: 'fishing',
    verb: 'fish at',
    icon: 'ğŸ£',
    toolType: null,
    difficulty: 4,
    hardness: 1,
    spCost: 2,
    xpGain: 7,
    drops: ['rawFish', 'rawFish'],
    rareDrops: ['rareFish', 'pearl', 'driftwood'],
    depletedTile: 'water',
    depletedChar: '~',
    depletedColor: '#2a5aaa',
    depletedWalkable: false
  },
  herb: {
    name: 'Herb Patch',
    skill: 'gathering',
    verb: 'gather herbs from',
    icon: 'ğŸŒ¿',
    toolType: null,
    difficulty: 1,
    hardness: 1,
    spCost: 1,
    xpGain: 5,
    drops: ['herbGreen', 'herbGreen'],
    rareDrops: ['seedHerb'],
    depletedTile: 'grass',
    depletedChar: '.',
    depletedColor: '#3a6a28',
    depletedWalkable: true
  },
  berry: {
    name: 'Berry Bush',
    skill: 'gathering',
    verb: 'pick berries from',
    icon: 'ğŸ«',
    toolType: null,
    difficulty: 1,
    hardness: 1,
    spCost: 1,
    xpGain: 4,
    drops: ['berryRed', 'berryBlue', 'berryRed'],
    rareDrops: ['berryPoison', 'seedHerb'],
    depletedTile: 'bush',
    depletedChar: 'â™£',
    depletedColor: '#3a7a2a',
    depletedWalkable: false
  },
  mushroom: {
    name: 'Mushroom Patch',
    skill: 'gathering',
    verb: 'forage mushrooms from',
    icon: 'ğŸ„',
    toolType: null,
    difficulty: 2,
    hardness: 1,
    spCost: 1,
    xpGain: 6,
    drops: ['mushroom', 'mushroom'],
    rareDrops: ['mushroomGlow', 'mushroomPoison'],
    depletedTile: 'dirt',
    depletedChar: '.',
    depletedColor: '#7a6a4a',
    depletedWalkable: true
  },
  clay: {
    name: 'Clay Deposit',
    skill: 'mining',
    verb: 'dig clay from',
    icon: 'ğŸº',
    toolType: 'pickaxe',
    difficulty: 1,
    hardness: 0.6,
    spCost: 2,
    xpGain: 4,
    drops: ['clay', 'clay', 'clay'],
    rareDrops: ['flint'],
    depletedTile: 'dirt',
    depletedChar: '.',
    depletedColor: '#7a6a4a',
    depletedWalkable: true
  },
  sandNode: {
    name: 'Sand Deposit',
    skill: 'mining',
    verb: 'dig sand from',
    icon: 'ğŸ–',
    toolType: null,
    difficulty: 0,
    hardness: 0.4,
    spCost: 1,
    xpGain: 2,
    drops: ['sand', 'sand', 'sand'],
    rareDrops: ['flint', 'emptyBottle'],
    depletedTile: 'sand',
    depletedChar: '.',
    depletedColor: '#d8c878',
    depletedWalkable: true
  },
  flintNode: {
    name: 'Flint Node',
    skill: 'mining',
    verb: 'chip flint from',
    icon: 'ğŸª¨',
    toolType: null,
    difficulty: 2,
    hardness: 1,
    spCost: 2,
    xpGain: 5,
    drops: ['flint', 'flint'],
    rareDrops: ['oreCopper'],
    depletedTile: 'rockyGround',
    depletedChar: '.',
    depletedColor: '#6a6a50',
    depletedWalkable: true
  },
  reed: {
    name: 'Reed Patch',
    skill: 'gathering',
    verb: 'harvest reeds from',
    icon: 'ï¿½',
    toolType: null,
    difficulty: 0,
    hardness: 1,
    spCost: 1,
    xpGain: 3,
    drops: ['reeds', 'reeds', 'string'],
    rareDrops: ['seedHerb'],
    depletedTile: 'grass',
    depletedChar: '.',
    depletedColor: '#3a6a28',
    depletedWalkable: true
  },
  bush: {
    name: 'Bush',
    skill: 'gathering',
    verb: 'search',
    icon: 'ğŸŒ³',
    toolType: null,
    difficulty: 0,
    hardness: 1,
    spCost: 1,
    xpGain: 2,
    drops: ['string', 'herbGreen'],
    rareDrops: ['berryRed', 'seedHerb'],
    depletedTile: 'grass',
    depletedChar: '.',
    depletedColor: '#3a6a28',
    depletedWalkable: true
  },
  deadTree: {
    name: 'Dead Tree',
    skill: 'lumberjacking',
    verb: 'break apart',
    icon: 'ğŸªµ',
    toolType: 'axeTool',
    difficulty: 1,
    hardness: 0.5,
    spCost: 2,
    xpGain: 3,
    drops: ['woodLog', 'bark'],
    rareDrops: ['string'],
    depletedTile: 'stump',
    depletedChar: '.',
    depletedColor: '#5a4a2a',
    depletedWalkable: true
  },
  cactus: {
    name: 'Cactus',
    skill: 'gathering',
    verb: 'carefully harvest',
    icon: 'ğŸŒµ',
    toolType: null,
    difficulty: 3,
    hardness: 1,
    spCost: 2,
    xpGain: 6,
    drops: ['herbGreen'],
    rareDrops: ['berryRed'],
    depletedTile: 'sand',
    depletedChar: '.',
    depletedColor: '#d8c878',
    depletedWalkable: true
  }
};

</script>
  <script>
// ============================================================
// EnchantSystem â€” Item Enchanting & Upgrading
// ============================================================
// Players can enchant weapons and armor using enchant scrolls.
// Enchantments add +N bonus to stats and can apply prefixes/suffixes.
// Higher enchant levels have increasing failure (and destruction) risk.
// ============================================================

class EnchantSystem {

  /**
   * Attempt to enchant an item using a scroll.
   * @param {object} player
   * @param {object} targetItem - The weapon or armor to enchant
   * @param {object} scrollItem - The enchant scroll being used
   * @returns {{ success: boolean, consumed: boolean, destroyed: boolean, message: string }}
   */
  static enchant(player, targetItem, scrollItem) {
    if (!targetItem || (targetItem.type !== 'weapon' && targetItem.type !== 'armor')) {
      return { success: false, consumed: false, destroyed: false, message: 'You can only enchant weapons and armor.' };
    }
    if (!scrollItem || scrollItem.type !== 'scroll') {
      return { success: false, consumed: false, destroyed: false, message: 'You need an enchant scroll.' };
    }

    const currentBonus = targetItem.enchantBonus || 0;
    const scrollTier = scrollItem.enchantTier || 1; // 1 = basic, 2 = greater, 3 = supreme
    const scrollType = scrollItem.enchantType || 'enhance'; // enhance, fire, ice, lightning, holy, speed

    // Success chance decreases with current enchant level
    // Better scrolls and higher crafting skill help
    const craftSkill = player.skills ? (player.skills.crafting || 0) : 0;
    const magicDevice = player.skills ? (player.skills.magicDevice || 0) : 0;
    const skillBonus = Math.floor((craftSkill + magicDevice) / 2);

    const baseChance = 90 - currentBonus * 12;
    const tierBonus = (scrollTier - 1) * 15;
    const successChance = Math.min(98, Math.max(5, baseChance + tierBonus + skillBonus * 2));

    const roll = Math.random() * 100;

    // Always gain skill exp
    CharacterSystem.gainSkillExp(player, 'crafting', 5 + scrollTier * 3);

    if (roll > successChance) {
      // Failure â€” check if item is destroyed
      const destroyChance = Math.max(0, (currentBonus - 2) * 8 - scrollTier * 5);
      const destroyed = Math.random() * 100 < destroyChance;

      if (destroyed) {
        return {
          success: false,
          consumed: true,
          destroyed: true,
          message: `The enchantment fails catastrophically! ${targetItem.name} shatters into pieces! (${Math.floor(successChance)}% chance)`
        };
      }
      return {
        success: false,
        consumed: true,
        destroyed: false,
        message: `The enchantment fizzles. The scroll crumbles to dust. (${Math.floor(successChance)}% chance)`
      };
    }

    // â”€â”€ Success! Apply enchantment â”€â”€
    targetItem.enchantBonus = currentBonus + 1;

    if (scrollType === 'enhance') {
      // Generic enhancement â€” boost primary stat
      if (targetItem.type === 'weapon') {
        targetItem.enchantDamageBonus = (targetItem.enchantDamageBonus || 0) + 2;
      } else {
        targetItem.enchantPVBonus = (targetItem.enchantPVBonus || 0) + 1;
        targetItem.enchantDVBonus = (targetItem.enchantDVBonus || 0) + 1;
      }
    } else {
      // Elemental / special enchantment
      if (!targetItem.enchantments) targetItem.enchantments = [];
      const existing = targetItem.enchantments.find(e => e.type === scrollType);
      if (existing) {
        existing.power += scrollTier;
      } else {
        targetItem.enchantments.push({
          type: scrollType,
          power: scrollTier,
          ...EnchantSystem.ENCHANT_EFFECTS[scrollType]
        });
      }
      // Also give a small primary stat boost
      if (targetItem.type === 'weapon') {
        targetItem.enchantDamageBonus = (targetItem.enchantDamageBonus || 0) + 1;
      } else {
        targetItem.enchantPVBonus = (targetItem.enchantPVBonus || 0) + 1;
      }
    }

    // Update the item name with enchant prefix/suffix
    EnchantSystem._updateItemName(targetItem);

    return {
      success: true,
      consumed: true,
      destroyed: false,
      message: `âœ¨ ${targetItem.name} glows with power! (+${targetItem.enchantBonus}) (${Math.floor(successChance)}% chance)`
    };
  }

  /**
   * Update the display name of an enchanted item.
   */
  static _updateItemName(item) {
    // Strip any previous enchant prefixes/suffixes
    let baseName = item._baseName || item.name;
    item._baseName = baseName;

    // Build prefix from elemental enchantments
    let prefix = '';
    if (item.enchantments && item.enchantments.length > 0) {
      const primary = item.enchantments[0];
      const prefixMap = {
        fire: 'Flaming',
        ice: 'Freezing',
        lightning: 'Shocking',
        holy: 'Holy',
        speed: 'Swift',
        poison: 'Venomous',
        vampiric: 'Vampiric'
      };
      prefix = prefixMap[primary.type] || '';
    }

    // Build the name
    const bonus = item.enchantBonus || 0;
    if (prefix) {
      item.name = `${prefix} ${baseName} +${bonus}`;
    } else if (bonus > 0) {
      item.name = `${baseName} +${bonus}`;
    }
  }

  /**
   * Get effective PV bonus from enchantments on an armor piece.
   */
  static getEnchantPV(item) {
    if (!item) return 0;
    return (item.enchantPVBonus || 0);
  }

  /**
   * Get effective DV bonus from enchantments on an armor piece.
   */
  static getEnchantDV(item) {
    if (!item) return 0;
    let dv = item.enchantDVBonus || 0;
    if (item.enchantments) {
      const speed = item.enchantments.find(e => e.type === 'speed');
      if (speed) dv += speed.power;
    }
    return dv;
  }

  /**
   * Get effective bonus damage from enchantments on a weapon.
   */
  static getEnchantDamage(item) {
    if (!item) return 0;
    return (item.enchantDamageBonus || 0);
  }

  /**
   * Get any elemental bonus damage for combat messages.
   * Returns { type, bonusDamage } or null.
   */
  static getElementalBonus(item) {
    if (!item || !item.enchantments || item.enchantments.length === 0) return null;
    // Pick the strongest elemental enchantment
    let best = null;
    for (const ench of item.enchantments) {
      if (ench.type !== 'speed' && (!best || ench.power > best.power)) {
        best = ench;
      }
    }
    if (!best) return null;
    return {
      type: best.type,
      bonusDamage: best.power * 2,
      name: best.name || best.type
    };
  }

  /**
   * Get display info for an item's enchantments (for UI tooltip).
   */
  static getEnchantInfo(item) {
    if (!item) return null;
    const bonus = item.enchantBonus || 0;
    if (bonus === 0 && (!item.enchantments || item.enchantments.length === 0)) return null;

    const info = { bonus, effects: [] };

    if (item.enchantDamageBonus) info.effects.push(`Damage +${item.enchantDamageBonus}`);
    if (item.enchantPVBonus) info.effects.push(`PV +${item.enchantPVBonus}`);
    if (item.enchantDVBonus) info.effects.push(`DV +${item.enchantDVBonus}`);

    if (item.enchantments) {
      for (const ench of item.enchantments) {
        const label = EnchantSystem.ENCHANT_EFFECTS[ench.type];
        if (label) {
          info.effects.push(`${label.name} +${ench.power}`);
        }
      }
    }

    return info;
  }
}

// â”€â”€ Enchantment Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EnchantSystem.ENCHANT_EFFECTS = {
  fire: { name: 'Fire', color: '#f64', description: 'Burns enemies on hit' },
  ice: { name: 'Ice', color: '#6cf', description: 'Chills enemies on hit' },
  lightning: { name: 'Lightning', color: '#ff4', description: 'Shocks enemies on hit' },
  holy: { name: 'Holy', color: '#ffa', description: 'Smites undead' },
  speed: { name: 'Speed', color: '#4ff', description: 'Increases evasion' },
  poison: { name: 'Poison', color: '#4f4', description: 'Poisons enemies on hit' },
  vampiric: { name: 'Vampiric', color: '#f4f', description: 'Steals life on hit' }
};

</script>
  <script>
// ============================================================
// FaithSystem â€” God worship, prayer, favor, blessings, gifts
// ============================================================

class FaithSystem {

  // â”€â”€ Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static init(player) {
    if (!player.faith) {
      player.faith = {
        godId: null,        // currently worshipped god id
        favor: 0,           // favor with current god (0â€“2000+)
        prayerCooldown: 0,  // turns until next prayer allowed
        giftsReceived: [],   // list of gift favor thresholds already received
        deathSaveUsed: false // Ehekatl's "Nine Lives" one-time save
      };
    }
    return player.faith;
  }

  // â”€â”€ Worship a God at an Altar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static worship(player, godId) {
    FaithSystem.init(player);
    const god = GOD_DEFS[godId];
    if (!god) return { success: false, message: 'Unknown deity.' };

    const oldGodId = player.faith.godId;

    // Already worshipping this god
    if (oldGodId === godId) {
      return { success: false, message: `You already worship ${god.name}.` };
    }

    const messages = [];

    // Switching gods â€” incur wrath from old god
    if (oldGodId && GOD_DEFS[oldGodId]) {
      const oldGod = GOD_DEFS[oldGodId];
      const wrath = oldGod.wrathEffects || {};
      // Apply attribute penalties
      for (const [attr, amount] of Object.entries(wrath)) {
        if (attr === 'message') continue;
        if (player.attributes && player.attributes[attr] !== undefined) {
          player.attributes[attr] = Math.max(1, player.attributes[attr] + amount);
        }
      }
      messages.push(wrath.message || `${oldGod.name} is angered by your betrayal!`);
      // Lose half of old favor
      player.faith.favor = Math.floor(player.faith.favor * 0.3);
    } else {
      player.faith.favor = 0;
    }

    player.faith.godId = godId;
    player.faith.giftsReceived = [];
    player.faith.deathSaveUsed = false;

    messages.push(`You begin to worship ${god.name}. ${god.icon}`);
    messages.push(`"${FaithSystem._getWorshipQuote(god)}"`);

    return { success: true, messages };
  }

  // â”€â”€ Prayer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static pray(player) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) {
      return { success: false, message: 'You have no god to pray to. Visit an altar in town to worship a deity.' };
    }

    const god = GOD_DEFS[godId];
    if (!god) return { success: false, message: 'Your god has vanished from the world.' };

    // Cooldown check
    if (player.faith.prayerCooldown > 0) {
      return { success: false, message: `You must wait before praying again. (${player.faith.prayerCooldown} turns)` };
    }

    const faithSkill = player.skills.faith || 1;
    const favorGain = 10 + Math.floor(faithSkill * 2) + Math.floor(Math.random() * 5);
    player.faith.favor += favorGain;
    player.faith.prayerCooldown = Math.max(30, 80 - faithSkill * 2);

    // Gain faith skill experience
    CharacterSystem.gainSkillExp(player, 'faith', 8);

    // Small immediate effect based on god
    const result = {
      success: true,
      favorGain,
      messages: [`You pray to ${god.name}. ${god.icon} (+${favorGain} favor)`]
    };

    // Prayer healing (minor)
    const healAmt = Math.floor(faithSkill * 0.5) + 2;
    player.hp = Math.min(player.maxHp, player.hp + healAmt);
    player.mp = Math.min(player.maxMp, player.mp + Math.floor(healAmt * 0.5));
    result.messages.push(`A warm light surrounds you. HP +${healAmt}`);

    // Check for divine gifts at favor thresholds
    const giftMessages = FaithSystem._checkGifts(player, god);
    result.messages.push(...giftMessages);

    return result;
  }

  // â”€â”€ Offer an Item at an Altar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static offerItem(player, item) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) {
      return { success: false, consumed: false, message: 'You have no god to offer to.' };
    }

    const god = GOD_DEFS[godId];
    if (!god) return { success: false, consumed: false, message: 'Unknown god.' };

    // Calculate offering value based on item value
    const baseValue = item.value || 10;
    const favorGain = Math.max(5, Math.floor(baseValue * 0.3) + 3);

    player.faith.favor += favorGain;
    CharacterSystem.gainSkillExp(player, 'faith', 5 + Math.floor(baseValue * 0.05));

    const result = {
      success: true,
      consumed: true,
      favorGain,
      messages: [
        `You offer ${item.name} to ${god.name}. ${god.icon}`,
        `${god.name} accepts your offering! (+${favorGain} favor)`
      ]
    };

    // Check for divine gifts
    const giftMessages = FaithSystem._checkGifts(player, god);
    result.messages.push(...giftMessages);

    return result;
  }

  // â”€â”€ Gain Favor from In-Game Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onAction(player, actionType, context) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) return [];

    const god = GOD_DEFS[godId];
    if (!god || !god.favoredActions) return [];

    if (!god.favoredActions.includes(actionType)) return [];

    // Gain favor passively from favored actions
    const gain = Math.floor(Math.random() * 3) + 1;
    player.faith.favor += gain;

    // Occasionally notify (10% of the time to avoid spam)
    if (Math.random() < 0.1) {
      return [`${god.icon} ${god.name} is pleased. (+${gain} favor)`];
    }
    return [];
  }

  // â”€â”€ Tick (per turn) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static tick(player) {
    FaithSystem.init(player);
    if (player.faith.prayerCooldown > 0) {
      player.faith.prayerCooldown--;
    }
  }

  // â”€â”€ Get Blessing Bonuses (applied to stats) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getBlessingBonuses(player) {
    const bonuses = {
      pv: 0, dv: 0, speed: 0, hpRegen: 0, mpRegen: 0,
      critBonus: 0, goldBonus: 0, craftBonus: 0, enchantBonus: 0,
      harvestBonus: 0, nutritionBonus: 0, healBoost: 0, spellPower: 0,
      deathSave: false,
      attrBonuses: {}
    };

    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) return bonuses;

    const god = GOD_DEFS[godId];
    if (!god || !god.blessings) return bonuses;

    const favor = player.faith.favor;

    // Determine the highest blessing tier the player qualifies for
    let activeBlessingKey = null;
    if (favor >= god.blessings.major.threshold) activeBlessingKey = 'major';
    else if (favor >= god.blessings.moderate.threshold) activeBlessingKey = 'moderate';
    else if (favor >= god.blessings.minor.threshold) activeBlessingKey = 'minor';

    if (!activeBlessingKey) return bonuses;

    const blessing = god.blessings[activeBlessingKey];
    const effect = blessing.effect;

    // Apply effects
    for (const [key, value] of Object.entries(effect)) {
      if (key === 'deathSave') {
        bonuses.deathSave = value && !player.faith.deathSaveUsed;
      } else if (['STR', 'END', 'DEX', 'PER', 'LRN', 'WIL', 'MAG', 'CHA'].includes(key)) {
        bonuses.attrBonuses[key] = (bonuses.attrBonuses[key] || 0) + value;
      } else if (bonuses[key] !== undefined) {
        bonuses[key] += value;
      }
    }

    return bonuses;
  }

  // â”€â”€ Get Active Blessing Info (for UI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getActiveBlessingInfo(player) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) return null;

    const god = GOD_DEFS[godId];
    if (!god || !god.blessings) return null;

    const favor = player.faith.favor;
    let activeKey = null;
    let nextKey = null;
    let nextThreshold = 0;

    if (favor >= god.blessings.major.threshold) {
      activeKey = 'major';
    } else if (favor >= god.blessings.moderate.threshold) {
      activeKey = 'moderate';
      nextKey = 'major';
      nextThreshold = god.blessings.major.threshold;
    } else if (favor >= god.blessings.minor.threshold) {
      activeKey = 'minor';
      nextKey = 'moderate';
      nextThreshold = god.blessings.moderate.threshold;
    } else {
      nextKey = 'minor';
      nextThreshold = god.blessings.minor.threshold;
    }

    return {
      active: activeKey ? god.blessings[activeKey] : null,
      activeKey,
      nextBlessing: nextKey ? god.blessings[nextKey] : null,
      nextKey,
      nextThreshold
    };
  }

  // â”€â”€ Death Save (Ehekatl's Nine Lives) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static checkDeathSave(player) {
    FaithSystem.init(player);
    const bonuses = FaithSystem.getBlessingBonuses(player);
    if (bonuses.deathSave && player.hp <= 0) {
      player.hp = Math.floor(player.maxHp * 0.25);
      player.faith.deathSaveUsed = true;
      return {
        saved: true,
        message: 'ğŸ± Ehekatl winks! You miraculously survive with a sliver of life!'
      };
    }
    return { saved: false };
  }

  // â”€â”€ Get State for Client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getState(player) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    const god = godId ? GOD_DEFS[godId] : null;
    const blessingInfo = FaithSystem.getActiveBlessingInfo(player);

    return {
      godId,
      godName: god ? god.name : null,
      godTitle: god ? god.title : null,
      godIcon: god ? god.icon : null,
      godColor: god ? god.color : null,
      godDescription: god ? god.description : null,
      favor: player.faith.favor,
      prayerCooldown: player.faith.prayerCooldown,
      activeBlessing: blessingInfo ? blessingInfo.active : null,
      activeBlessingKey: blessingInfo ? blessingInfo.activeKey : null,
      nextBlessing: blessingInfo ? blessingInfo.nextBlessing : null,
      nextBlessingKey: blessingInfo ? blessingInfo.nextKey : null,
      nextThreshold: blessingInfo ? blessingInfo.nextThreshold : 0,
      allGods: Object.values(GOD_DEFS).map(g => ({
        id: g.id,
        name: g.name,
        title: g.title,
        icon: g.icon,
        color: g.color,
        description: g.description
      }))
    };
  }

  // â”€â”€ Internal: Check & Deliver Gifts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _checkGifts(player, god) {
    const messages = [];
    if (!god.gifts) return messages;

    for (const gift of god.gifts) {
      if (player.faith.favor >= gift.favor && !player.faith.giftsReceived.includes(gift.favor)) {
        player.faith.giftsReceived.push(gift.favor);

        switch (gift.type) {
          case 'item': {
            const template = ITEM_TEMPLATES[gift.itemId];
            if (template) {
              const count = gift.count || 1;
              for (let i = 0; i < count; i++) {
                const item = ItemSystem.createItem(gift.itemId);
                if (item) ItemSystem.addToInventory(player, item);
              }
            }
            break;
          }
          case 'gold': {
            player.gold = (player.gold || 0) + (gift.amount || 100);
            break;
          }
          case 'attribute': {
            if (player.attributes && player.attributes[gift.attr] !== undefined) {
              player.attributes[gift.attr] += gift.amount || 1;
              CharacterSystem.recalcDerived(player);
            }
            break;
          }
          case 'spellStock': {
            MagicSystem.initSpells(player);
            if (!player.spells[gift.spellId]) {
              player.spells[gift.spellId] = { stock: 0, skillLevel: 1 };
            }
            player.spells[gift.spellId].stock += (gift.amount || 5);
            break;
          }
        }

        messages.push(`âœ¦ ${gift.message || 'A divine gift appears!'}`);
      }
    }

    return messages;
  }

  // â”€â”€ Internal: Flavor Quotes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _getWorshipQuote(god) {
    const quotes = {
      opatos: 'Stand firm, mortal. The earth shall be your shield.',
      lulwy: 'Let the wind carry you. Speed is life.',
      itzpalt: 'Knowledge is the greatest power. Cast wisely.',
      ehekatl: 'Meow! Luck favors the bold... and the generous!',
      jure: 'All life is precious. I shall mend what is broken.',
      kumiromi: 'The seed you plant today becomes tomorrow\'s forest.',
      mani: 'Every problem has a mechanical solution. Build it.'
    };
    return quotes[god.id] || 'I acknowledge your devotion.';
  }
}

</script>
  <script>
// ============================================================
// FogOfWarSystem â€” Fog of war with line-of-sight visibility
// Tiles can be: 0 = unseen (black), 1 = seen/remembered (dim),
//               2 = currently visible (full)
// ============================================================

class FogOfWarSystem {
  constructor() {
    this.fogMap = null;       // 2D array of visibility state per tile
    this.width = 0;
    this.height = 0;
    this._mapKey = null;      // Track which map we're on
  }

  // â”€â”€ Initialize / Reset fog for a new map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  init(mapWidth, mapHeight, mapKey) {
    // If same map, keep existing fog (for returning to floors, etc.)
    if (this._mapKey === mapKey && this.fogMap) return;

    this.width = mapWidth;
    this.height = mapHeight;
    this._mapKey = mapKey;
    this.fogMap = [];
    for (let y = 0; y < mapHeight; y++) {
      const row = new Uint8Array(mapWidth); // All zeros = unseen
      this.fogMap.push(row);
    }
  }

  // â”€â”€ Compute the player's current visibility range â”€â”€â”€â”€
  static computeVisibilityRange(player, timeState, locationType) {
    // Base range depends on PER attribute
    const per = (player.attributes && player.attributes.PER) || 8;
    let baseRange = 4 + Math.floor(per / 3);

    // Spot Hidden skill bonus
    const spotHidden = (player.skills && player.skills.spotHidden) || 0;
    baseRange += Math.floor(spotHidden / 5);

    // Eye of Mind skill bonus
    const eyeOfMind = (player.skills && player.skills.eyeOfMind) || 0;
    baseRange += Math.floor(eyeOfMind / 4);

    // Night penalty (only applies to non-underground areas)
    const isUnderground = locationType === 'nefia';
    const isNight = timeState && timeState.isNight;
    if (!isUnderground && isNight) {
      baseRange = Math.max(3, baseRange - 3);
    }

    // Underground base penalty
    if (isUnderground) {
      baseRange = Math.max(3, baseRange - 2);
    }

    // Light source bonuses (check inventory and equipment)
    const lightBonus = FogOfWarSystem.getLightBonus(player);
    baseRange += lightBonus;

    // Clamp to reasonable range
    return Math.min(Math.max(baseRange, 2), 20);
  }

  // â”€â”€ Calculate light bonus from carried/equipped items â”€
  static getLightBonus(player) {
    let bonus = 0;
    if (!player) return bonus;

    // Check equipment first (wielded torch gives more light)
    if (player.equipment) {
      Object.values(player.equipment).forEach(item => {
        if (item && item.lightRadius) {
          bonus += item.lightRadius;
        }
      });
    }

    // Check inventory for passive light sources (reduced effect)
    if (player.inventory) {
      for (const item of player.inventory) {
        if (item && item.lightRadius) {
          // Items in inventory give half their light radius
          bonus += Math.floor(item.lightRadius / 2);
        }
      }
    }

    // Buff-based light (e.g., from a Light spell)
    if (player.buffs) {
      for (const buff of player.buffs) {
        if (buff.lightRadius) {
          bonus += buff.lightRadius;
        }
      }
    }

    return bonus;
  }

  // â”€â”€ Should fog be active for this context? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static shouldUseFog(locationType, timeState) {
    // No fog on the world map
    // Towns during daytime: no fog (reveal everything)
    // Nefias, outdoor encounters, towns at night: fog active
    if (locationType === 'nefia') return true;
    if (locationType === 'outdoor') return true;
    // Towns: fog only at night
    if (locationType === 'town' || locationType === 'home') {
      return timeState && timeState.isNight;
    }
    return false;
  }

  // â”€â”€ Should all tiles be revealed as "seen" (daytime outdoors)? â”€
  static shouldRevealAll(locationType, timeState) {
    // During day and not underground, reveal all tiles as seen
    const isUnderground = locationType === 'nefia';
    const isDay = !timeState || !timeState.isNight;
    if (!isUnderground && isDay) return true;
    return false;
  }

  // â”€â”€ Update visibility based on player position â”€â”€â”€â”€â”€â”€â”€
  update(playerX, playerY, visRange, tiles) {
    if (!this.fogMap) return;

    // First, downgrade all currently visible (2) tiles to seen (1)
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.fogMap[y][x] === 2) {
          this.fogMap[y][x] = 1;
        }
      }
    }

    // Cast rays in 360 degrees from the player to determine visible tiles
    this._castVisibility(playerX, playerY, visRange, tiles);
  }

  // â”€â”€ Reveal all tiles as "seen" (for daytime outdoor) â”€
  revealAllAsSeen() {
    if (!this.fogMap) return;
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.fogMap[y][x] === 0) {
          this.fogMap[y][x] = 1;
        }
      }
    }
  }

  // â”€â”€ Shadowcasting-based visibility (recursive) â”€â”€â”€â”€â”€â”€â”€
  // Uses the "symmetric recursive shadowcasting" algorithm for
  // accurate FOV in roguelikes.
  _castVisibility(ox, oy, range, tiles) {
    // Player's own tile is always visible
    if (oy >= 0 && oy < this.height && ox >= 0 && ox < this.width) {
      this.fogMap[oy][ox] = 2;
    }

    // 8 octants for full 360Â° field of view
    for (let octant = 0; octant < 8; octant++) {
      this._castOctant(ox, oy, range, 1, 1.0, 0.0, octant, tiles);
    }
  }

  _castOctant(ox, oy, range, row, startSlope, endSlope, octant, tiles) {
    if (startSlope < endSlope) return;

    let nextStartSlope = startSlope;

    for (let i = row; i <= range; i++) {
      let blocked = false;

      for (let dx = -i; dx <= 0; dx++) {
        const dy = -i;
        const leftSlope = (dx - 0.5) / (dy + 0.5);
        const rightSlope = (dx + 0.5) / (dy - 0.5);

        if (startSlope < rightSlope) continue;
        if (endSlope > leftSlope) break;

        // Transform coordinates based on octant
        const { tx, ty } = this._transformOctant(dx, dy, octant);
        const ax = ox + tx;
        const ay = oy + ty;

        // Check distance (circular FOV)
        const dist2 = tx * tx + ty * ty;
        if (dist2 > range * range) continue;

        if (ax >= 0 && ax < this.width && ay >= 0 && ay < this.height) {
          this.fogMap[ay][ax] = 2;
        }

        // Check if this tile blocks light
        const isBlocking = this._isOpaque(ax, ay, tiles);

        if (blocked) {
          if (isBlocking) {
            nextStartSlope = rightSlope;
            continue;
          } else {
            blocked = false;
            startSlope = nextStartSlope;
          }
        } else if (isBlocking && i < range) {
          blocked = true;
          this._castOctant(ox, oy, range, i + 1, startSlope, leftSlope, octant, tiles);
          nextStartSlope = rightSlope;
        }
      }

      if (blocked) break;
    }
  }

  _transformOctant(col, row, octant) {
    switch (octant) {
      case 0: return { tx: col, ty: row };
      case 1: return { tx: row, ty: col };
      case 2: return { tx: row, ty: -col };
      case 3: return { tx: col, ty: -row };
      case 4: return { tx: -col, ty: -row };
      case 5: return { tx: -row, ty: -col };
      case 6: return { tx: -row, ty: col };
      case 7: return { tx: -col, ty: row };
      default: return { tx: col, ty: row };
    }
  }

  _isOpaque(x, y, tiles) {
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return true;
    const tile = tiles[y][x];
    // Walls and other non-walkable solid tiles block vision
    if (!tile) return true;
    if (tile.type === 'wall') return true;
    if (tile.type === 'tree' && !tile.walkable) return true;
    // Default: walkable tiles don't block vision
    if (!tile.walkable && tile.type !== 'ore') return true;
    return false;
  }

  // â”€â”€ Check if a specific position is currently visible â”€
  isVisible(x, y) {
    if (!this.fogMap) return true;
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return false;
    return this.fogMap[y][x] === 2;
  }

  // â”€â”€ Check if a specific position has been seen â”€â”€â”€â”€â”€â”€â”€â”€
  isSeen(x, y) {
    if (!this.fogMap) return true;
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return false;
    return this.fogMap[y][x] >= 1;
  }

  // â”€â”€ Get fog state at position: 0=unseen, 1=seen, 2=visible â”€
  getState(x, y) {
    if (!this.fogMap) return 2;
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return 0;
    return this.fogMap[y][x];
  }

  // â”€â”€ Serialize fog state for saving â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  serialize() {
    if (!this.fogMap) return null;
    return {
      width: this.width,
      height: this.height,
      mapKey: this._mapKey,
      data: this.fogMap.map(row => Array.from(row))
    };
  }

  // â”€â”€ Load fog state from save data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  loadFromSave(data) {
    if (!data) return;
    this.width = data.width;
    this.height = data.height;
    this._mapKey = data.mapKey;
    this.fogMap = data.data.map(row => new Uint8Array(row));
  }

  // â”€â”€ Cache for nefia floors (so revisiting a floor keeps fog) â”€
  static _fogCache = {};

  static saveFogToCache(mapKey, fogSystem) {
    if (!fogSystem.fogMap) return;
    FogOfWarSystem._fogCache[mapKey] = fogSystem.serialize();
  }

  static loadFogFromCache(mapKey, fogSystem) {
    const cached = FogOfWarSystem._fogCache[mapKey];
    if (cached && cached.mapKey === mapKey) {
      fogSystem.loadFromSave(cached);
      return true;
    }
    return false;
  }

  static clearCache() {
    FogOfWarSystem._fogCache = {};
  }
}

</script>
  <script>
// ============================================================
// ActionTimingSystem â€” Timed actions with skill-based speed
// ============================================================
// Each action has a base tick cost. Proficiency in the relevant
// skill reduces the time needed. Some actions (like moving) are
// always instant (1 tick). Others require holding the action key
// while a progress bar fills up.
// ============================================================

class ActionTimingSystem {

  // â”€â”€ Action Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Returns { ticks, skill, label, icon } for a given action.
  // `ticks` is the BASE cost before skill reduction.
  // `skill` is the skill id used to reduce the time.
  // If ticks === 1 the action is instant (no progress bar).

  static getActionTiming(action, player, context) {
    const type = action.type;

    switch (type) {
      // â”€â”€ Instant actions (1 tick) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      case 'move':
      case 'wait':
      case 'pickup':
      case 'drop':
      case 'equip':
      case 'enterLocation':
      case 'exitToWorldMap':
      case 'descend':
      case 'ascend':
      case 'shopBuy':
      case 'shopSell':
      case 'closeShop':
      case 'acceptQuest':
      case 'turnInQuest':
      case 'abandonQuest':
      case 'releasePet':
      case 'renamePet':
      case 'worship':
        return { ticks: 1, skill: null, label: null, icon: null, instant: true };

      // â”€â”€ Melee attack: 2-4 ticks, reduced by weapon skill + tactics â”€â”€
      case 'attack':
        return ActionTimingSystem._meleeAttackTiming(player);

      // â”€â”€ Ranged attack: 3-5 ticks, reduced by marksman â”€â”€
      case 'rangedAttack':
        return {
          ticks: ActionTimingSystem._reduceTicks(4, player, 'marksman', 1),
          skill: 'marksman',
          label: 'Aiming...',
          icon: 'ğŸ¹',
          instant: false
        };

      // â”€â”€ Spellcasting: 3-8 ticks, reduced by casting + spell level â”€â”€
      case 'castSpell':
        return ActionTimingSystem._spellCastTiming(action, player);

      // â”€â”€ Reading spellbook: 5-12 ticks, reduced by literacy â”€â”€
      case 'readSpellbook':
        return {
          ticks: ActionTimingSystem._reduceTicks(8, player, 'literacy', 1),
          skill: 'literacy',
          label: 'Studying...',
          icon: 'ğŸ“–',
          instant: false
        };

      // â”€â”€ Eating: 2-3 ticks â”€â”€
      case 'eat':
        return {
          ticks: 2,
          skill: null,
          label: 'Eating...',
          icon: 'ğŸ–',
          instant: false
        };

      // â”€â”€ Crafting: 4-10 ticks, reduced by crafting skill â”€â”€
      case 'craft':
        return ActionTimingSystem._craftTiming(action, player);

      // â”€â”€ Gathering (mine/chop/fish/herb): 4-8 ticks â”€â”€
      case 'gather':
        return ActionTimingSystem._gatherTiming(player, context);

      // â”€â”€ Planting: 3-5 ticks, reduced by farming â”€â”€
      case 'plant':
        return {
          ticks: ActionTimingSystem._reduceTicks(4, player, 'farming', 1),
          skill: 'farming',
          label: 'Planting...',
          icon: 'ğŸŒ±',
          instant: false
        };

      // â”€â”€ Harvesting: 2-4 ticks, reduced by farming â”€â”€
      case 'harvest':
        return {
          ticks: ActionTimingSystem._reduceTicks(3, player, 'farming', 1),
          skill: 'farming',
          label: 'Harvesting...',
          icon: 'ğŸŒ¾',
          instant: false
        };

      // â”€â”€ Taming: 4-8 ticks, reduced by taming â”€â”€
      case 'tame':
        return {
          ticks: ActionTimingSystem._reduceTicks(6, player, 'taming', 2),
          skill: 'taming',
          label: 'Taming...',
          icon: 'ğŸ¾',
          instant: false
        };

      // â”€â”€ Enchanting: 4-6 ticks â”€â”€
      case 'enchant':
        return {
          ticks: ActionTimingSystem._reduceTicks(5, player, 'magicDevice', 1),
          skill: 'magicDevice',
          label: 'Enchanting...',
          icon: 'âœ¨',
          instant: false
        };

      // â”€â”€ Praying: 3-5 ticks, reduced by faith â”€â”€
      case 'pray':
        return {
          ticks: ActionTimingSystem._reduceTicks(4, player, 'faith', 1),
          skill: 'faith',
          label: 'Praying...',
          icon: 'ğŸ™',
          instant: false
        };

      // â”€â”€ Offering: 2 ticks â”€â”€
      case 'offerItem':
        return {
          ticks: 2,
          skill: null,
          label: 'Offering...',
          icon: 'ğŸ™',
          instant: false
        };

      // â”€â”€ Sleeping: 8 ticks (long action) â”€â”€
      case 'sleep':
        return {
          ticks: 8,
          skill: null,
          label: 'Sleeping...',
          icon: 'ğŸ’¤',
          instant: false
        };

      // â”€â”€ Placing bed: 3 ticks â”€â”€
      case 'placeBed':
        return {
          ticks: 3,
          skill: null,
          label: 'Placing...',
          icon: 'ğŸ›',
          instant: false
        };

      // â”€â”€ Reviving pet: 3 ticks â”€â”€
      case 'revivePet':
        return {
          ticks: 3,
          skill: null,
          label: 'Reviving...',
          icon: 'ğŸ’«',
          instant: false
        };

      // â”€â”€ Use item: 2 ticks â”€â”€
      case 'use':
        return {
          ticks: 2,
          skill: null,
          label: 'Using...',
          icon: 'ğŸ’',
          instant: false
        };

      default:
        return { ticks: 1, skill: null, label: null, icon: null, instant: true };
    }
  }

  // â”€â”€ Internal: Reduce ticks based on skill level â”€â”€â”€â”€â”€
  // formula: max(minTicks, baseTicks - floor(skillLevel / divisor))
  static _reduceTicks(baseTicks, player, skillId, minTicks) {
    const skillLevel = player && player.skills ? (player.skills[skillId] || 0) : 0;
    const reduction = Math.floor(skillLevel / 5);
    return Math.max(minTicks, baseTicks - reduction);
  }

  // â”€â”€ Melee attack timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _meleeAttackTiming(player) {
    // Weapon-type skill (longSword, axe, etc.) reduces attack time
    let weaponSkill = 0;
    if (player && player.equipment && player.equipment.weapon) {
      const w = player.equipment.weapon;
      const skillMap = {
        'sword': 'longSword', 'axe': 'axe', 'scythe': 'scythe',
        'staff': 'staff', 'polearm': 'polearm', 'mace': 'mace',
        'shortSword': 'shortSword', 'dagger': 'shortSword'
      };
      const wSkillId = skillMap[w.subtype] || 'martialArt';
      weaponSkill = player.skills ? (player.skills[wSkillId] || 0) : 0;
    } else {
      weaponSkill = player && player.skills ? (player.skills.martialArt || 0) : 0;
    }
    const baseTicks = 3;
    const reduction = Math.floor(weaponSkill / 6);
    return {
      ticks: Math.max(1, baseTicks - reduction),
      skill: 'combat',
      label: 'Attacking...',
      icon: 'âš”',
      instant: Math.max(1, baseTicks - reduction) <= 1
    };
  }

  // â”€â”€ Spell cast timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _spellCastTiming(action, player) {
    const castingSkill = player && player.skills ? (player.skills.casting || 0) : 0;
    let spellLevel = 1;
    let spellName = 'spell';
    if (action.spellId && player && player.spells && player.spells[action.spellId]) {
      spellLevel = player.spells[action.spellId].skillLevel || 1;
      const def = typeof SPELL_DEFS !== 'undefined' ? SPELL_DEFS[action.spellId] : null;
      if (def) spellName = def.name;
    }
    // Higher spell difficulty = more base ticks, higher casting + spell level = fewer
    const baseTicks = 4 + Math.floor(spellLevel * 0.3);
    const reduction = Math.floor(castingSkill / 4) + Math.floor(spellLevel / 3);
    const ticks = Math.max(2, baseTicks - reduction);
    return {
      ticks,
      skill: 'casting',
      label: `Casting ${spellName}...`,
      icon: 'âœ¨',
      instant: false
    };
  }

  // â”€â”€ Craft timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _craftTiming(action, player) {
    let skill = 'crafting';
    if (action.recipeId && typeof RECIPE_DEFS !== 'undefined') {
      const recipe = RECIPE_DEFS[action.recipeId];
      if (recipe && recipe.skill) skill = recipe.skill;
    }
    return {
      ticks: ActionTimingSystem._reduceTicks(6, player, skill, 2),
      skill,
      label: 'Crafting...',
      icon: 'ğŸ”¨',
      instant: false
    };
  }

  // â”€â”€ Gather timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _gatherTiming(player, context) {
    // Context can contain nodeType to pick the right skill
    const nodeSkillMap = {
      'ore': 'mining',
      'tree': 'lumberjacking',
      'fish': 'fishing',
      'herb': 'gathering'
    };
    const nodeType = context && context.nodeType ? context.nodeType : 'ore';
    const skill = nodeSkillMap[nodeType] || 'mining';
    const verbMap = {
      'ore': 'Mining...',
      'tree': 'Chopping...',
      'fish': 'Fishing...',
      'herb': 'Gathering...'
    };
    const iconMap = {
      'ore': 'â›',
      'tree': 'ğŸª“',
      'fish': 'ğŸ£',
      'herb': 'ğŸŒ¿'
    };
    return {
      ticks: ActionTimingSystem._reduceTicks(5, player, skill, 2),
      skill,
      label: verbMap[nodeType] || 'Gathering...',
      icon: iconMap[nodeType] || 'â›',
      instant: false
    };
  }
}

</script>
  <script>
// ============================================================
// CardSystem â€” Monster Card Collection (browser version)
// ============================================================

class CardSystem {
  // Card rarity tiers
  static RARITY = {
    NORMAL: 'normal',
    RARE: 'rare',
    SUPER_FOIL: 'superFoil'
  };

  static RARITY_INFO = {
    normal:    { name: 'Normal',     color: '#ccc',    border: '#666',    emoji: 'ğŸƒ', multiplier: 1 },
    rare:      { name: 'Rare',       color: '#ffd740', border: '#ffa000', emoji: 'âœ¨', multiplier: 3 },
    superFoil: { name: 'Super Foil', color: '#e040fb', border: '#aa00ff', emoji: 'ğŸŒŸ', multiplier: 10 }
  };

  // â”€â”€ Initialize player card collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static init(player) {
    if (!player.cardCollection) player.cardCollection = [];
    if (!player.cardStats) player.cardStats = { totalCollected: 0, totalSold: 0 };
  }

  // â”€â”€ Roll for card drop when a monster dies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static rollCardDrop(monster) {
    // 50% chance of dropping a card
    if (Math.random() > 0.50) return null;

    // Determine rarity
    const roll = Math.random();
    let rarity;
    if (roll < 0.005) {
      rarity = CardSystem.RARITY.SUPER_FOIL;  // 0.5% chance
    } else if (roll < 0.055) {
      rarity = CardSystem.RARITY.RARE;          // 5% chance
    } else {
      rarity = CardSystem.RARITY.NORMAL;         // 94.5% chance
    }

    return CardSystem.createCard(monster.templateId || monster.id, rarity);
  }

  // â”€â”€ Create a card object â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static createCard(monsterId, rarity) {
    const monsterDef = typeof MONSTER_TEMPLATES !== 'undefined' ? MONSTER_TEMPLATES[monsterId] : null;
    const name = monsterDef ? monsterDef.name : monsterId;
    const level = monsterDef ? monsterDef.level : 1;
    const race = monsterDef ? monsterDef.race : 'unknown';

    // Card value scales with monster level and rarity
    const rarityInfo = CardSystem.RARITY_INFO[rarity];
    const baseValue = 5 + (level * 3);
    const value = baseValue * rarityInfo.multiplier;

    return {
      id: typeof uuidv4 === 'function' ? uuidv4() : Math.random().toString(36).slice(2),
      type: 'monsterCard',
      monsterId: monsterId,
      monsterName: name,
      monsterLevel: level,
      monsterRace: race,
      rarity: rarity,
      rarityName: rarityInfo.name,
      value: value,
      char: monsterDef ? (monsterDef.char || 'M') : 'M',
      color: monsterDef ? (monsterDef.color || '#c33') : '#c33'
    };
  }

  // â”€â”€ Add card to player's collection (stacks duplicates) â”€â”€
  static addCard(player, card) {
    CardSystem.init(player);

    // Find existing stack (same monsterId + same rarity)
    const existing = player.cardCollection.find(
      c => c.monsterId === card.monsterId && c.rarity === card.rarity
    );

    if (existing) {
      existing.quantity = (existing.quantity || 1) + 1;
    } else {
      card.quantity = 1;
      player.cardCollection.push(card);
    }

    player.cardStats.totalCollected++;
    return card;
  }

  // â”€â”€ Remove cards from collection (for selling) â”€â”€â”€â”€â”€â”€
  static removeCard(player, cardIndex, count) {
    CardSystem.init(player);
    if (cardIndex < 0 || cardIndex >= player.cardCollection.length) return false;

    const card = player.cardCollection[cardIndex];
    const qty = card.quantity || 1;
    const removeCount = Math.min(count || 1, qty);

    if (removeCount >= qty) {
      player.cardCollection.splice(cardIndex, 1);
    } else {
      card.quantity = qty - removeCount;
    }
    return true;
  }

  // â”€â”€ Get collection display data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getCollectionDisplay(player) {
    CardSystem.init(player);

    // Get all known monster IDs for completion tracking
    const allMonsterIds = typeof MONSTER_TEMPLATES !== 'undefined' ? Object.keys(MONSTER_TEMPLATES) : [];
    const collectedMonsterIds = new Set(player.cardCollection.map(c => c.monsterId));

    // Sort cards: by monster level, then rarity
    const rarityOrder = { superFoil: 0, rare: 1, normal: 2 };
    const sortedCards = [...player.cardCollection].sort((a, b) => {
      const levelDiff = (b.monsterLevel || 0) - (a.monsterLevel || 0);
      if (levelDiff !== 0) return levelDiff;
      return (rarityOrder[a.rarity] || 99) - (rarityOrder[b.rarity] || 99);
    });

    return {
      cards: sortedCards.map(c => ({
        ...c,
        rarityInfo: CardSystem.RARITY_INFO[c.rarity] || CardSystem.RARITY_INFO.normal
      })),
      totalUnique: collectedMonsterIds.size,
      totalMonsters: allMonsterIds.length,
      totalCards: player.cardCollection.reduce((sum, c) => sum + (c.quantity || 1), 0),
      stats: player.cardStats
    };
  }

  // â”€â”€ Card Shop: generate card merchant inventory â”€â”€â”€â”€â”€
  static generateCardShopInventory(player) {
    CardSystem.init(player);

    // Card merchant sells random cards the player might not have
    const allMonsterIds = typeof MONSTER_TEMPLATES !== 'undefined' ? Object.keys(MONSTER_TEMPLATES) : [];
    const collectedNormalIds = new Set(
      player.cardCollection
        .filter(c => c.rarity === CardSystem.RARITY.NORMAL)
        .map(c => c.monsterId)
    );

    // Offer 6-10 random cards, biased toward ones the player doesn't have
    const uncollected = allMonsterIds.filter(id => !collectedNormalIds.has(id));
    const collected = allMonsterIds.filter(id => collectedNormalIds.has(id));

    const shopCards = [];
    const shopSize = 6 + Math.floor(Math.random() * 5); // 6-10 cards

    for (let i = 0; i < shopSize; i++) {
      // 70% chance to offer uncollected cards if available
      let pool = (Math.random() < 0.7 && uncollected.length > 0) ? uncollected : allMonsterIds;
      const monsterId = pool[Math.floor(Math.random() * pool.length)];

      // 10% chance the shop sells a rare variant
      const rarity = Math.random() < 0.10 ? CardSystem.RARITY.RARE : CardSystem.RARITY.NORMAL;
      const card = CardSystem.createCard(monsterId, rarity);
      card.stock = 1;
      card.buyPrice = Math.ceil(card.value * 1.5); // Shop markup
      shopCards.push(card);
    }

    return shopCards;
  }

  // â”€â”€ Card Shop: buy a card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static buyCard(player, shopInventory, cardIndex) {
    if (cardIndex < 0 || cardIndex >= shopInventory.length) {
      return { success: false, message: 'Invalid card.' };
    }
    const shopCard = shopInventory[cardIndex];
    if (shopCard.stock <= 0) {
      return { success: false, message: 'That card is sold out.' };
    }

    const price = shopCard.buyPrice || Math.ceil(shopCard.value * 1.5);
    if (player.gold < price) {
      return { success: false, message: `Not enough gold. Need ${price}gp, have ${player.gold}gp.` };
    }

    player.gold -= price;
    shopCard.stock--;

    const newCard = CardSystem.createCard(shopCard.monsterId, shopCard.rarity);
    CardSystem.addCard(player, newCard);

    const rarityInfo = CardSystem.RARITY_INFO[shopCard.rarity];
    return {
      success: true,
      message: `Bought ${rarityInfo.emoji} ${shopCard.monsterName} (${rarityInfo.name}) card for ${price}gp!`
    };
  }

  // â”€â”€ Card Shop: sell a card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static sellCard(player, cardIndex) {
    CardSystem.init(player);
    if (cardIndex < 0 || cardIndex >= player.cardCollection.length) {
      return { success: false, message: 'Invalid card.' };
    }

    const card = player.cardCollection[cardIndex];
    const sellPrice = Math.max(1, Math.floor(card.value * 0.6));

    // Negotiation bonus
    const negotiation = player.skills ? (player.skills.negotiation || 0) : 0;
    const bonus = Math.floor(sellPrice * negotiation * 0.02);
    const finalPrice = sellPrice + bonus;

    player.gold += finalPrice;
    CardSystem.removeCard(player, cardIndex, 1);
    player.cardStats.totalSold++;

    const rarityInfo = CardSystem.RARITY_INFO[card.rarity];
    return {
      success: true,
      message: `Sold ${rarityInfo.emoji} ${card.monsterName} (${rarityInfo.name}) card for ${finalPrice}gp.${bonus > 0 ? ` (Bonus +${bonus}gp!)` : ''}`,
      price: finalPrice
    };
  }

  // â”€â”€ Death recap: get card collection summary â”€â”€â”€â”€â”€â”€â”€â”€
  static getDeathSummary(player) {
    CardSystem.init(player);
    const allMonsterIds = typeof MONSTER_TEMPLATES !== 'undefined' ? Object.keys(MONSTER_TEMPLATES) : [];
    const uniqueCollected = new Set(player.cardCollection.map(c => c.monsterId)).size;
    const totalCards = player.cardCollection.reduce((sum, c) => sum + (c.quantity || 1), 0);
    const rareCount = player.cardCollection.filter(c => c.rarity === 'rare').reduce((s, c) => s + (c.quantity || 1), 0);
    const foilCount = player.cardCollection.filter(c => c.rarity === 'superFoil').reduce((s, c) => s + (c.quantity || 1), 0);

    // Get top 3 rarest cards
    const rarityValue = { superFoil: 3, rare: 2, normal: 1 };
    const topCards = [...player.cardCollection]
      .sort((a, b) => (rarityValue[b.rarity] || 0) - (rarityValue[a.rarity] || 0) || (b.monsterLevel || 0) - (a.monsterLevel || 0))
      .slice(0, 5);

    return {
      uniqueCollected,
      totalMonsters: allMonsterIds.length,
      totalCards,
      rareCount,
      foilCount,
      topCards,
      completionPct: allMonsterIds.length > 0 ? Math.round((uniqueCollected / allMonsterIds.length) * 100) : 0,
      stats: player.cardStats
    };
  }
}

</script>
  <script>
// ============================================================
// SaveManager â€” LocalStorage-based save/load (browser)
// ============================================================

class SaveManager {
  static _storageKey(id) {
    return `elinclone_save_${id}`;
  }

  static _indexKey() {
    return 'elinclone_saves_index';
  }

  static _getIndex() {
    try {
      const raw = localStorage.getItem(SaveManager._indexKey());
      return raw ? JSON.parse(raw) : [];
    } catch {
      return [];
    }
  }

  static _setIndex(index) {
    localStorage.setItem(SaveManager._indexKey(), JSON.stringify(index));
  }

  static save(data) {
    const id = data.id || uuidv4();
    const saveData = {
      ...data,
      savedAt: new Date().toISOString()
    };
    localStorage.setItem(SaveManager._storageKey(id), JSON.stringify(saveData));

    // Update index
    const index = SaveManager._getIndex();
    const existing = index.findIndex(e => e.id === id);
    const entry = {
      id,
      playerName: data.player ? data.player.name : 'Unknown',
      level: data.player ? data.player.level : 0,
      turn: data.turn || 0,
      savedAt: saveData.savedAt
    };
    if (existing >= 0) {
      index[existing] = entry;
    } else {
      index.push(entry);
    }
    SaveManager._setIndex(index);

    return id;
  }

  static load(id) {
    try {
      const raw = localStorage.getItem(SaveManager._storageKey(id));
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  static listSaves() {
    return SaveManager._getIndex();
  }

  static deleteSave(id) {
    localStorage.removeItem(SaveManager._storageKey(id));
    const index = SaveManager._getIndex().filter(e => e.id !== id);
    SaveManager._setIndex(index);
  }
}

</script>
  <script>
// ============================================================
// GameEngine â€” Master orchestrator (browser version)
// ============================================================

class GameEngine {
  constructor() {
    this.id = uuidv4();
    this.player = null;
    this.worldMap = null;
    this.currentMap = null;
    this.currentLocation = null;
    this.worldX = 10;
    this.worldY = 10;
    this.turn = 0;
    this.messages = [];
    this.mode = 'worldMap';
    this.timeWeather = new TimeWeather();
    this.nefiaSystem = new NefiaSystem();
    this.fogSystem = new FogOfWarSystem();
    this.nefiaFloor = 0;
    this.gameOver = false;
    this.fame = 0;
    this.karma = 0;
    this.townShops = [];
    this.activeShop = null;
    this.activeCardShop = null; // card merchant inventory when visiting card shop
    this.questBoard = [];  // quests available at current town's quest board
    this.homesteadMap = null; // persisted homestead map

    // Death recap tracking
    this.damageLog = [];       // recent damage events: { source, damage, turn }
    this.killCount = 0;        // total monsters killed
    this.deepestFloor = 0;     // deepest nefia floor reached
    this.locationsVisited = new Set(); // unique locations entered
  }

  // â”€â”€ Death Recap Tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _logDamage(source, damage) {
    this.damageLog.push({ source, damage, turn: this.turn });
    // Keep only the last 50 entries
    if (this.damageLog.length > 50) this.damageLog.shift();
  }

  _buildDeathRecap() {
    const recap = {
      killedBy: 'Unknown',
      lastHits: [],
      totalDamageTaken: 0,
      topDamageSources: [],
      turn: this.turn,
      floor: this.nefiaFloor || 0,
      location: this.currentLocation ? this.currentLocation.name : 'the Wilderness',
      locationType: this.currentLocation ? this.currentLocation.type : 'outdoor',
      killCount: this.killCount,
      deepestFloor: this.deepestFloor,
      locationsVisited: this.locationsVisited.size,
      playerLevel: this.player.level,
      playerRace: this.player.race.name,
      playerClass: this.player.cls.name,
      fame: this.fame,
      karma: this.karma,
      gold: this.player.gold || 0,
      timeAlive: this.timeWeather.getState().timeString || '',
      cardSummary: CardSystem.getDeathSummary(this.player)
    };

    if (this.damageLog.length > 0) {
      // Last hit is the killer
      const lastHit = this.damageLog[this.damageLog.length - 1];
      recap.killedBy = lastHit.source;

      // Show last 5 damage events (most recent first)
      recap.lastHits = this.damageLog.slice(-5).reverse().map(e => ({
        source: e.source,
        damage: e.damage,
        turn: e.turn
      }));

      // Aggregate damage by source
      const sourceMap = {};
      for (const entry of this.damageLog) {
        if (!sourceMap[entry.source]) sourceMap[entry.source] = 0;
        sourceMap[entry.source] += entry.damage;
        recap.totalDamageTaken += entry.damage;
      }
      recap.topDamageSources = Object.entries(sourceMap)
        .map(([source, total]) => ({ source, total }))
        .sort((a, b) => b.total - a.total)
        .slice(0, 5);
    }

    return recap;
  }

  // â”€â”€ Create New Game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  createNewGame(data) {
    const raceId = data.raceId || data.race || 'yerles';
    const classId = data.classId || data.class || 'warrior';
    const name = data.name || 'Adventurer';
    const race = RACES[raceId];
    const cls = CLASSES[classId];
    if (!race || !cls) throw new Error('Invalid race or class');

    this.player = CharacterSystem.createPlayer(name, race, cls);
    this.worldMap = MapGenerator.generateWorldMap();
    const home = WORLD_LOCATIONS.homestead;
    this.worldX = home.x;
    this.worldY = home.y;
    this.mode = 'worldMap';
    this.karma = 0;
    this.fame = 0;
    ItemSystem.giveStartingItems(this.player);
    MagicSystem.initSpells(this.player);
    PetSystem.init(this.player);
    FaithSystem.init(this.player);
    this.player.quests = [];
    this.addMessage(`Welcome to the Ashen Reaches, ${name}! Your adventure begins.`);
  }

  // â”€â”€ Process Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  processAction(action) {
    if (this.gameOver) return { ok: false, msg: 'Game Over' };
    const result = { ok: true, events: [] };

    switch (action.type) {
      case 'move':
        this._handleMove(action, result);
        break;
      case 'attack':
        this._handleAttack(action, result);
        break;
      case 'use':
        this._handleUseItem(action, result);
        break;
      case 'pickup':
        this._handlePickup(action, result);
        break;
      case 'drop':
        this._handleDrop(action, result);
        break;
      case 'wait':
        this._advanceTurn(result);
        break;
      case 'enterLocation':
        this._handleEnterLocation(action, result);
        break;
      case 'exitToWorldMap':
        this._handleExitToWorldMap(result);
        break;
      case 'descend':
        this._handleDescend(result);
        break;
      case 'ascend':
        this._handleAscend(result);
        break;
      case 'eat':
        this._handleEat(action, result);
        break;
      case 'equip':
        this._handleEquip(action, result);
        break;
      case 'castSpell':
        this._handleCastSpell(action, result);
        break;
      case 'readSpellbook':
        this._handleReadSpellbook(action, result);
        break;
      case 'plant':
        this._handlePlant(action, result);
        break;
      case 'harvest':
        this._handleHarvest(action, result);
        break;
      case 'shopBuy':
        this._handleShopBuy(action, result);
        break;
      case 'shopSell':
        this._handleShopSell(action, result);
        break;
      case 'closeShop':
        this._handleCloseShop(action, result);
        break;
      case 'craft':
        this._handleCraft(action, result);
        break;
      case 'rangedAttack':
        this._handleRangedAttack(action, result);
        break;
      case 'acceptQuest':
        this._handleAcceptQuest(action, result);
        break;
      case 'turnInQuest':
        this._handleTurnInQuest(action, result);
        break;
      case 'abandonQuest':
        this._handleAbandonQuest(action, result);
        break;
      case 'tame':
        this._handleTame(action, result);
        break;
      case 'releasePet':
        this._handleReleasePet(action, result);
        break;
      case 'renamePet':
        this._handleRenamePet(action, result);
        break;
      case 'revivePet':
        this._handleRevivePet(action, result);
        break;
      case 'gather':
        this._handleGather(action, result);
        break;
      case 'enchant':
        this._handleEnchant(action, result);
        break;
      case 'pray':
        this._handlePray(action, result);
        break;
      case 'worship':
        this._handleWorship(action, result);
        break;
      case 'offerItem':
        this._handleOfferItem(action, result);
        break;
      case 'cardShopBuy':
        this._handleCardShopBuy(action, result);
        break;
      case 'cardShopSell':
        this._handleCardShopSell(action, result);
        break;
      case 'sleep':
        this._handleSleep(action, result);
        break;
      case 'placeBed':
        this._handlePlaceBed(action, result);
        break;
      case 'placeWorkshop':
        this._handlePlaceWorkshop(action, result);
        break;
      case 'placeFurniture':
        this._handlePlaceFurniture(action, result);
        break;
      case 'pickupFurniture':
        this._handlePickupFurniture(action, result);
        break;
      case 'readRecipe':
        this._handleReadRecipe(action, result);
        break;
      default:
        result.ok = false;
        result.msg = 'Unknown action';
    }
    return result;
  }

  // â”€â”€ Movement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleMove(action, result) {
    const { dx, dy } = action;
    if (this.mode === 'worldMap') {
      const nx = this.worldX + dx;
      const ny = this.worldY + dy;
      if (nx < 0 || ny < 0 || nx >= this.worldMap[0].length || ny >= this.worldMap.length) {
        result.ok = false;
        result.msg = 'Edge of the world';
        return;
      }
      this.worldX = nx;
      this.worldY = ny;
      // 3 hours per tile, reduced by Travel skill (min 30 min)
      const travelTime = Math.max(30, 180 - (this.player.skills.travel || 0) * 3);
      this.timeWeather.advanceMinutes(travelTime);
      this._advanceTurn(result);

      const loc = Object.values(WORLD_LOCATIONS).find(l => l.x === nx && l.y === ny);
      if (loc) {
        this.addMessage(`You see ${loc.name} nearby. (Press Enter to enter)`);
        result.events.push({ type: 'nearLocation', location: loc });
      }

      if (!loc && Math.random() < 0.08) {
        this.addMessage('Robbers block your path!');
        this._enterOutdoorMap(result);
      }
    } else {
      const px = this.player.x + dx;
      const py = this.player.y + dy;
      if (!this.currentMap) return;
      const outOfBounds = px < 0 || py < 0 || px >= this.currentMap.width || py >= this.currentMap.height;
      const onEdge = !outOfBounds && (px === 0 || py === 0 || px === this.currentMap.width - 1 || py === this.currentMap.height - 1);

      // Non-dungeon maps: exit by reaching the map border
      if ((outOfBounds || onEdge) && this.currentLocation && this.currentLocation.type !== 'nefia') {
        this.addMessage('You leave the area.');
        this._handleExitToWorldMap(result);
        return;
      }
      if (outOfBounds) {
        result.ok = false;
        return;
      }
      const tile = this.currentMap.tiles[py][px];
      if (!tile.walkable) {
        result.ok = false;
        result.msg = 'Blocked';
        return;
      }
      const monster = this.currentMap.monsters.find(m => m.x === px && m.y === py && m.hp > 0);
      if (monster) {
        const combatResult = CombatSystem.meleeAttack(this.player, monster);
        this.addMessage(combatResult.message);
        if (monster.hp <= 0) {
          monster._processed = true;
          this.addMessage(`You defeated ${monster.name}!`);
          const xpGain = monster.xp || 10;
          CharacterSystem.gainExp(this.player, xpGain);
          this.fame += Math.floor(xpGain / 5);
          result.events.push({ type: 'kill', monster: monster.name, xp: xpGain });
          const drops = ItemSystem.generateDrops(monster);
          drops.forEach(item => {
            this.currentMap.items.push({ ...item, x: monster.x, y: monster.y });
          });
          this._onMonsterKilled(monster);
        }
        this._advanceTurn(result);
        return;
      }

      // Don't walk onto your own pet â€” swap positions instead
      const petOnTile = PetSystem.getPetAt(this.player, px, py);
      if (petOnTile) {
        // Swap positions with the pet
        const oldPx = this.player.x;
        const oldPy = this.player.y;
        this.player.x = px;
        this.player.y = py;
        petOnTile.x = oldPx;
        petOnTile.y = oldPy;
        this._advanceTurn(result);
        return;
      }

      this.player.x = px;
      this.player.y = py;

      const groundItems = this.currentMap.items.filter(i => i.x === px && i.y === py);
      if (groundItems.length > 0) {
        this.addMessage(`You see: ${groundItems.map(i => i.name).join(', ')}`);
      }
      const currentTile = this.currentMap.tiles[py][px];
      if (currentTile.npc) {
        if (currentTile.npc.questBoard) {
          this.addMessage('You see the Quest Board. (Press Q to browse quests)');
          result.events.push({ type: 'openQuestBoard' });
        } else if (currentTile.npc.cardMerchant) {
          // Open card shop
          this.activeCardShop = CardSystem.generateCardShopInventory(this.player);
          this.addMessage('Card Merchant: "Greetings, collector! Browse my cards or sell your duplicates."');
          result.events.push({ type: 'openCardShop' });
        } else {
          const shop = this.townShops.find(s => s.id === currentTile.npc.shopId);
          if (shop) {
            this.activeShop = shop;
            this.addMessage(`${currentTile.npc.name}: "Welcome to the ${currentTile.npc.shopName}! Browse my wares."`);
            result.events.push({ type: 'openShop', shopId: shop.id });
          } else if (currentTile.npc.dialogue) {
            // Ambient NPC with random dialogue
            const lines = currentTile.npc.dialogue;
            const line = lines[Math.floor(Math.random() * lines.length)];
            this.addMessage(`${currentTile.npc.name}: "${line}"`);
          }
        }
      } else {
        if (this.activeShop) {
          this.activeShop = null;
        }
        if (this.activeCardShop) {
          this.activeCardShop = null;
        }
      }
      if (tile.type === 'stairsDown') {
        this.addMessage('You see stairs leading down. (Press > to descend)');
      } else if (tile.type === 'stairsUp') {
        this.addMessage('You see stairs leading up. (Press < to ascend)');
      }

      // Altar detection
      if (tile.altar || tile.type === 'shrine') {
        const godName = this.player.faith && this.player.faith.godId
          ? (GOD_DEFS[this.player.faith.godId] ? GOD_DEFS[this.player.faith.godId].name : 'your god')
          : null;
        if (godName) {
          this.addMessage(`You stand at the altar. Press R to pray to ${godName}, or open the Faith tab to worship a different god.`);
        } else {
          this.addMessage('You stand at a sacred altar. Open the Faith tab to choose a god to worship.');
        }
        result.events.push({ type: 'onAltar' });
      }

      this._advanceTurn(result);
    }
  }

  _handleAttack(action, result) {
    const { targetId } = action;
    const monster = this.currentMap && this.currentMap.monsters.find(m => m.id === targetId && m.hp > 0);
    if (!monster) { result.ok = false; return; }
    const combatResult = CombatSystem.meleeAttack(this.player, monster);
    this.addMessage(combatResult.message);
    if (monster.hp <= 0) {
      monster._processed = true;
      this.addMessage(`You defeated ${monster.name}!`);
      const xpGain = monster.xp || 10;
      CharacterSystem.gainExp(this.player, xpGain);
      this.fame += Math.floor(xpGain / 5);
      const drops = ItemSystem.generateDrops(monster);
      drops.forEach(item => {
        this.currentMap.items.push({ ...item, x: monster.x, y: monster.y });
      });
      this._onMonsterKilled(monster);
    }
    this._advanceTurn(result);
  }

  _handleUseItem(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : this.player.inventory.findIndex(i => i.id === action.itemId);
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    const useResult = ItemSystem.useItem(this.player, item);
    this.addMessage(useResult.message);
    if (useResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    this._advanceTurn(result);
  }

  _handleEat(action, result) {
    let idx = -1;
    if (action.itemIndex != null) {
      idx = action.itemIndex;
    } else if (action.itemId) {
      idx = this.player.inventory.findIndex(i => i.id === action.itemId && (i.type === 'food'));
    } else {
      idx = this.player.inventory.findIndex(i => i.type === 'food');
    }
    if (idx === -1 || idx >= this.player.inventory.length) { result.ok = false; result.msg = 'No food to eat'; return; }
    const item = this.player.inventory[idx];
    if (item.type !== 'food') { result.ok = false; result.msg = 'That is not food'; return; }
    this.player.nutrition = Math.min(10000, this.player.nutrition + (item.nutrition || 1000));
    if (item.healHP) this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.healHP);
    ItemSystem.removeFromInventory(this.player, idx, 1);
    this.addMessage(`You eat the ${item.name}. Nutrition restored.`);
    this._advanceTurn(result);
  }

  _handlePickup(action, result) {
    if (!this.currentMap) return;
    const { x, y } = this.player;
    const idx = this.currentMap.items.findIndex(i => i.x === x && i.y === y);
    if (idx === -1) { result.ok = false; result.msg = 'Nothing here'; return; }
    const item = this.currentMap.items.splice(idx, 1)[0];
    delete item.x;
    delete item.y;
    // Convert gold coins directly to player gold
    if (item.type === 'currency') {
      this.player.gold = (this.player.gold || 0) + (item.value || 1);
      this.addMessage(`Picked up ${item.name}.`);
      return;
    }
    ItemSystem.addToInventory(this.player, item);
    this.addMessage(`Picked up ${item.name}.`);
    // Check gather quests
    const gatherMsgs = QuestSystem.checkGatherQuests(this.player);
    gatherMsgs.forEach(m => this.addMessage(m.text));
  }

  _handleDrop(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : this.player.inventory.findIndex(i => i.id === action.itemId);
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = ItemSystem.removeFromInventory(this.player, idx, 1);
    if (!item) { result.ok = false; return; }
    if (this.currentMap) {
      item.x = this.player.x;
      item.y = this.player.y;
      this.currentMap.items.push(item);
    }
    this.addMessage(`Dropped ${item.name}.`);
  }

  _handleEquip(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    const equipResult = ItemSystem.equipItem(this.player, item);
    this.addMessage(equipResult.message);
  }

  _handleReadSpellbook(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    if (item.type !== 'spellbook') {
      this.addMessage('That is not a spellbook.');
      result.ok = false;
      return;
    }
    MagicSystem.initSpells(this.player);
    const readResult = MagicSystem.readSpellbook(this.player, item);
    this.addMessage(readResult.message);
    if (readResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    this._advanceTurn(result);
  }

  _handleCastSpell(action, result) {
    const spellId = action.spellId;
    if (!spellId) { result.ok = false; return; }
    MagicSystem.initSpells(this.player);

    const hpBefore = this.player.hp;
    const castResult = MagicSystem.castSpell(this.player, spellId, {});
    if (!castResult.success) {
      this.addMessage(castResult.message);
      result.ok = false;
      return;
    }
    // Track mana overflow damage
    if (this.player.hp < hpBefore) {
      this._logDamage('Mana Overflow', hpBefore - this.player.hp);
    }
    this.addMessage(castResult.message);

    if (castResult.type === 'bolt' && this.currentMap) {
      const target = MagicSystem.findNearestMonster(
        this.player, this.currentMap.monsters, castResult.range
      );
      if (target) {
        const hitResult = MagicSystem.applyBoltToTarget(target, castResult.damage);
        this.addMessage(hitResult.message);
        if (hitResult.killed) {
          target._processed = true;
          const xpGain = target.xp || 10;
          CharacterSystem.gainExp(this.player, xpGain);
          this.fame += Math.floor(xpGain / 5);
          const drops = ItemSystem.generateDrops(target);
          drops.forEach(item => {
            this.currentMap.items.push({ ...item, x: target.x, y: target.y });
          });
          this._onMonsterKilled(target);
        }
      } else {
        this.addMessage('The spell finds no target.');
      }
    } else if (castResult.type === 'ball' && this.currentMap) {
      const target = MagicSystem.findNearestMonster(
        this.player, this.currentMap.monsters, castResult.range
      );
      const cx = target ? target.x : this.player.x;
      const cy = target ? target.y : this.player.y;
      const hits = MagicSystem.applyBallToArea(
        this.currentMap.monsters, cx, cy, castResult.radius, castResult.damage
      );
      if (hits.length > 0) {
        hits.forEach(h => {
          this.addMessage(`${h.name} takes ${h.damage} damage!${h.killed ? ' Destroyed!' : ''}`);
          if (h.killed) {
            const m = this.currentMap.monsters.find(m2 => m2.name === h.name && m2.hp <= 0 && !m2._processed);
            if (m) {
              m._processed = true;
              const xpGain = m.xp || 10;
              CharacterSystem.gainExp(this.player, xpGain);
              this.fame += Math.floor(xpGain / 5);
              const drops = ItemSystem.generateDrops(m);
              drops.forEach(item => {
                this.currentMap.items.push({ ...item, x: m.x, y: m.y });
              });
              this._onMonsterKilled(m);
            }
          }
        });
      } else {
        this.addMessage('The spell explodes harmlessly.');
      }
    } else if (castResult.type === 'teleport' && this.currentMap) {
      const walkable = [];
      for (let y = 0; y < this.currentMap.height; y++) {
        for (let x = 0; x < this.currentMap.width; x++) {
          if (this.currentMap.tiles[y][x].walkable) {
            const blocked = this.currentMap.monsters.some(m => m.hp > 0 && m.x === x && m.y === y);
            if (!blocked) walkable.push({ x, y });
          }
        }
      }
      if (walkable.length > 0) {
        const dest = walkable[Math.floor(Math.random() * walkable.length)];
        this.player.x = dest.x;
        this.player.y = dest.y;
        this.addMessage(`You teleport to a new location!`);
      }
    }

    if (this.player.hp <= 0) {
      this.addMessage('The mana overflow kills you...');
      this.gameOver = true;
      result.events.push({ type: 'death' });
      return;
    }

    // Faith favor for spell casting
    const castFaithMsgs = FaithSystem.onAction(this.player, 'casting', {});
    castFaithMsgs.forEach(m => this.addMessage(m));
    if (castResult.type === 'heal') {
      const healFaithMsgs = FaithSystem.onAction(this.player, 'castHeal', {});
      healFaithMsgs.forEach(m => this.addMessage(m));
    }

    this._advanceTurn(result);
  }

  _handlePlant(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot plant here'; return; }
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    if (item.type !== 'seed') {
      this.addMessage('That is not a seed.');
      result.ok = false;
      return;
    }
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    const season = this.timeWeather.getSeason();
    const plantResult = FarmingSystem.plantSeed(this.player, item, tile, season);
    this.addMessage(plantResult.message);
    if (plantResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    if (plantResult.success) {
      tile.crop.plantedTurn = this.turn;
    }
    this._advanceTurn(result);
  }

  _handleHarvest(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot harvest here'; return; }
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    const harvestResult = FarmingSystem.harvestCrop(this.player, tile);
    this.addMessage(harvestResult.message);
    if (harvestResult.success && harvestResult.items) {
      harvestResult.items.forEach(item => {
        ItemSystem.addToInventory(this.player, item);
      });
      this.addMessage(`Collected: ${harvestResult.items.map(i => i.name).join(', ')}`);
    }
    this._advanceTurn(result);
  }

  _handleShopBuy(action, result) {
    if (!this.activeShop) { result.ok = false; result.msg = 'No shop open'; return; }
    const buyResult = ShopSystem.buyItem(this.player, this.activeShop, action.itemId);
    this.addMessage(buyResult.message);
    if (!buyResult.success) result.ok = false;
  }

  _handleShopSell(action, result) {
    if (!this.activeShop) { result.ok = false; result.msg = 'No shop open'; return; }
    const sellResult = ShopSystem.sellItem(this.player, this.activeShop, action.itemIndex);
    this.addMessage(sellResult.message);
    if (!sellResult.success) result.ok = false;
  }

  _handleCloseShop(action, result) {
    this.activeShop = null;
    this.addMessage('You leave the shop.');
  }

  _handleCardShopBuy(action, result) {
    if (!this.activeCardShop) { result.ok = false; result.msg = 'No card shop open'; return; }
    const buyResult = CardSystem.buyCard(this.player, this.activeCardShop, action.cardIndex);
    this.addMessage(buyResult.message);
    if (!buyResult.success) result.ok = false;
  }

  _handleCardShopSell(action, result) {
    if (!this.activeCardShop) { result.ok = false; result.msg = 'No card shop open'; return; }
    const sellResult = CardSystem.sellCard(this.player, action.cardIndex);
    this.addMessage(sellResult.message);
    if (!sellResult.success) result.ok = false;
  }

  _handleCraft(action, result) {
    const nearbyWorkshops = CraftingSystem.getNearbyWorkshops(this.player, this.currentMap);
    const craftResult = CraftingSystem.craft(this.player, action.recipeId, nearbyWorkshops);
    this.addMessage(craftResult.message);
    if (!craftResult.success) result.ok = false;
    else {
      // Faith favor for crafting
      const craftFaithMsgs = FaithSystem.onAction(this.player, 'crafting', {});
      craftFaithMsgs.forEach(m => this.addMessage(m));
    }
    this._advanceTurn(result);
  }

  // â”€â”€ Place Workshop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePlaceWorkshop(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const invIdx = action.invIndex;
    const item = this.player.inventory[invIdx];
    if (!item || item.subtype !== 'workshop') {
      this.addMessage('That is not a workshop.');
      result.ok = false;
      return;
    }
    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
    if (!tile || !tile.walkable) {
      this.addMessage('You cannot place a workshop here.');
      result.ok = false;
      return;
    }
    if (tile.workshop) {
      this.player.inventory.push({ ...tile.workshop, x: undefined, y: undefined });
      this.addMessage(`You pick up the ${tile.workshop.name}.`);
    }
    tile.workshop = {
      id: item.id,
      templateId: item.templateId || item.id,
      name: item.name,
      workshopType: item.workshopType,
      char: item.char || 'Ï€',
      color: item.color || '#8a6a3a'
    };
    this.player.inventory.splice(invIdx, 1);
    this.addMessage(`You place the ${item.name}.`);
    this._advanceTurn(result);
  }

  // â”€â”€ Read Recipe Paper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleReadRecipe(action, result) {
    const idx = action.itemIndex;
    const item = this.player.inventory[idx];
    if (!item || item.type !== 'recipePaper') {
      this.addMessage('That is not a recipe paper.');
      result.ok = false;
      return;
    }
    const readResult = CraftingSystem.readRecipePaper(this.player, item.recipeId);
    this.addMessage(readResult.message);
    if (readResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    this._advanceTurn(result);
  }

  _handleRangedAttack(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const weapon = this.player.equipment ? this.player.equipment.weapon : null;
    if (!weapon || !weapon.ranged) {
      this.addMessage('You need a ranged weapon equipped to shoot.');
      result.ok = false;
      return;
    }
    const range = 8;
    let target = null;
    if (action.targetId) {
      target = this.currentMap.monsters.find(m => m.id === action.targetId && m.hp > 0);
    } else if (action.dx !== undefined && action.dy !== undefined) {
      target = MagicSystem.findBoltTarget(this.player, this.currentMap.monsters, action.dx, action.dy, range);
    } else {
      target = MagicSystem.findNearestMonster(this.player, this.currentMap.monsters, range);
    }
    if (!target) {
      this.addMessage('No target in range.');
      result.ok = false;
      return;
    }
    const combatResult = CombatSystem.rangedAttack(this.player, target, weapon);
    this.addMessage(combatResult.message);
    if (target.hp <= 0) {
      target._processed = true;
      this.addMessage(`You defeated ${target.name}!`);
      const xpGain = target.xp || 10;
      CharacterSystem.gainExp(this.player, xpGain);
      this.fame += Math.floor(xpGain / 5);
      const drops = ItemSystem.generateDrops(target);
      drops.forEach(item => {
        this.currentMap.items.push({ ...item, x: target.x, y: target.y });
      });
      this._onMonsterKilled(target);
    }
    CharacterSystem.gainSkillExp(this.player, 'marksman', 5);
    this._advanceTurn(result);
  }

  // â”€â”€ Location Entry / Exit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleEnterLocation(action, result) {
    const locId = action.locationId;
    const loc = WORLD_LOCATIONS[locId];
    const atLoc = loc || Object.values(WORLD_LOCATIONS).find(l => l.x === this.worldX && l.y === this.worldY);
    if (!atLoc) {
      // No named location â€” enter the wilderness / outdoor tile
      this._enterOutdoorMap(result);
      return;
    }

    this.currentLocation = atLoc;
    if (atLoc.type === 'home') {
      // Homestead: use persisted map if available
      if (this.homesteadMap) {
        this.currentMap = this.homesteadMap;
      } else {
        this.currentMap = MapGenerator.generateTownMap(atLoc);
        this.homesteadMap = this.currentMap;
      }
      this.townShops = [];
    } else if (atLoc.type === 'town') {
      this.currentMap = MapGenerator.generateTownMap(atLoc);
      this.townShops = ShopSystem.generateTownShops(atLoc);
      ShopSystem.restockShops(this.townShops);
      this._placeShopNPCs();
      // Place card merchant
      this._placeCardMerchant();
      // Generate quest board for this town
      this.questBoard = QuestSystem.generateBoardQuests(atLoc.id, this.player.level);
      this._placeQuestBoard();
      // Place altar for god worship
      this._placeAltar();
      // Place ambient NPCs (guards, townsfolk, etc.)
      this._placeAmbientNPCs(atLoc);
      // Check delivery quests
      const deliveryMsgs = QuestSystem.onEnterTown(this.player, atLoc.id);
      deliveryMsgs.forEach(m => this.addMessage(m.text));
    } else if (atLoc.type === 'nefia') {
      this.nefiaFloor = 1;
      this.currentMap = this.nefiaSystem.generateFloor(atLoc, 1);
    }
    // Spawn on the appropriate stair tile when entering a nefia to avoid walls
    if (atLoc.type === 'nefia' && this.currentMap.stairsUpX != null && this.currentMap.stairsUpY != null) {
      this.player.x = this.currentMap.stairsUpX;
      this.player.y = this.currentMap.stairsUpY;
    } else {
      this.player.x = Math.floor(this.currentMap.width / 2);
      this.player.y = this.currentMap.height - 2;
    }
    this.mode = 'localMap';
    this.addMessage(`You enter ${atLoc.name}.`);
    this.locationsVisited.add(atLoc.id);
    // Place pets near the player
    PetSystem.placePetsOnMap(this.player, this.currentMap);
    // Initialize fog of war for this map
    this._updateFog();
  }

  _enterOutdoorMap(result) {
    const biome = this.worldMap[this.worldY][this.worldX];
    this.currentLocation = { id: 'outdoor', type: 'outdoor', name: `${biome.name} wilderness`, danger: biome.dangerMod + 3 };
    this.currentMap = MapGenerator.generateOutdoorMap(biome, this.currentLocation.danger);
    this.player.x = Math.floor(this.currentMap.width / 2);
    this.player.y = Math.floor(this.currentMap.height / 2);
    this.mode = 'localMap';
    this.addMessage(`You enter the ${biome.name} wilderness.`);
    PetSystem.placePetsOnMap(this.player, this.currentMap);
    // Initialize fog of war for outdoor encounter
    this._updateFog();
  }

  _handleExitToWorldMap(result) {
    // Save fog state before leaving
    if (this.currentMap && this.fogSystem.fogMap) {
      FogOfWarSystem.saveFogToCache(this._getFogMapKey(), this.fogSystem);
    }
    // Persist homestead map
    if (this.currentLocation && this.currentLocation.type === 'home' && this.currentMap) {
      this.homesteadMap = this.currentMap;
    }
    this.currentMap = null;
    this.currentLocation = null;
    this.nefiaFloor = 0;
    this.mode = 'worldMap';
    this.townShops = [];
    this.activeShop = null;
    this.activeCardShop = null;
    this.cardMerchantPos = null;
    this.questBoard = [];
    this.questBoardPos = null;
    this.ambientNPCs = [];
    this.addMessage('You return to the world map.');
  }

  _placeShopNPCs() {
    if (!this.currentMap || !this.townShops || this.townShops.length === 0) return;
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        if (this.currentMap.tiles[y][x].type === 'floor') {
          floorTiles.push({ x, y });
        }
      }
    }
    const used = new Set();
    this.townShops.forEach(shop => {
      for (const tile of floorTiles) {
        const key = `${tile.x},${tile.y}`;
        if (!used.has(key)) {
          shop.x = tile.x;
          shop.y = tile.y;
          used.add(key);
          this.currentMap.tiles[tile.y][tile.x].npc = {
            shopId: shop.id,
            name: shop.npcName,
            char: shop.char,
            color: shop.color,
            shopName: shop.name
          };
          break;
        }
      }
    });
  }

  _placeQuestBoard() {
    if (!this.currentMap || !this.questBoard || this.questBoard.length === 0) return;
    // Find a floor tile that isn't occupied by an NPC
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }
    if (floorTiles.length === 0) return;
    const spot = floorTiles[Math.floor(Math.random() * floorTiles.length)];
    this.currentMap.tiles[spot.y][spot.x].npc = {
      questBoard: true,
      name: 'Quest Board',
      char: 'ğŸ“œ',
      color: '#ffa',
      shopName: 'Quest Board'
    };
    this.questBoardPos = { x: spot.x, y: spot.y };
  }

  _placeCardMerchant() {
    if (!this.currentMap) return;
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }
    if (floorTiles.length === 0) return;
    const spot = floorTiles[Math.floor(Math.random() * floorTiles.length)];
    this.currentMap.tiles[spot.y][spot.x].npc = {
      cardMerchant: true,
      name: 'Card Merchant',
      char: '\uD83C\uDCCF',
      color: '#e040fb',
      shopName: 'Card Shop'
    };
    this.cardMerchantPos = { x: spot.x, y: spot.y };
  }

  _placeAltar() {
    if (!this.currentMap) return;
    // Find a floor tile that isn't occupied by an NPC or quest board
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }
    if (floorTiles.length === 0) return;
    const spot = floorTiles[Math.floor(Math.random() * floorTiles.length)];
    const tile = this.currentMap.tiles[spot.y][spot.x];
    tile.type = 'shrine';
    tile.altar = true;
    tile.walkable = true;
    tile.char = 'â€ ';
    tile.color = '#d0d050';
    this.altarPos = { x: spot.x, y: spot.y };
  }

  _placeAmbientNPCs(location) {
    if (!this.currentMap || !location.ambientNPCs || location.ambientNPCs.length === 0) return;
    this.ambientNPCs = [];

    // Collect walkable tiles that aren't occupied (grass or road, not inside buildings)
    const openTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.walkable && !tile.npc && (tile.type === 'grass' || tile.type === 'road' || tile.type === 'stoneFloor')) {
          openTiles.push({ x, y });
        }
      }
    }
    if (openTiles.length === 0) return;

    // Also collect floor tiles inside buildings for indoor NPCs
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }

    const used = new Set();
    // Place each ambient NPC definition
    for (const npcDef of location.ambientNPCs) {
      // 60% chance outdoor, 40% chance indoor (if floor tiles exist)
      const useIndoor = floorTiles.length > 0 && Math.random() < 0.4;
      const pool = useIndoor ? floorTiles : openTiles;
      if (pool.length === 0) continue;

      // Try to find an unused spot
      let spot = null;
      for (let tries = 0; tries < 50; tries++) {
        const candidate = pool[Math.floor(Math.random() * pool.length)];
        const key = `${candidate.x},${candidate.y}`;
        if (!used.has(key)) {
          spot = candidate;
          used.add(key);
          break;
        }
      }
      if (!spot) continue;

      const npcData = {
        name: npcDef.name,
        char: npcDef.char,
        color: npcDef.color,
        dialogue: npcDef.dialogue
      };

      this.currentMap.tiles[spot.y][spot.x].npc = npcData;
      this.ambientNPCs.push({ x: spot.x, y: spot.y, ...npcData });
    }
  }

  _handleDescend(result) {
    if (!this.currentMap) return;
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    if (tile.type !== 'stairsDown') { result.ok = false; result.msg = 'No stairs here'; return; }
    if (this.currentLocation && this.currentLocation.type === 'nefia') {
      // Save fog state before changing floors
      if (this.fogSystem.fogMap) {
        FogOfWarSystem.saveFogToCache(this._getFogMapKey(), this.fogSystem);
      }
      this.nefiaFloor++;
      const maxFloors = this.currentLocation.floors || 10;
      if (this.nefiaFloor > maxFloors) {
        this.addMessage('You have conquered this Nefia!');
        this.fame += 50;
        this.karma += 5;
        this._handleExitToWorldMap(result);
        return;
      }
      this.currentMap = this.nefiaSystem.generateFloor(this.currentLocation, this.nefiaFloor);
      this.player.x = this.currentMap.stairsUpX || 1;
      this.player.y = this.currentMap.stairsUpY || 1;
      this.addMessage(`You descend to floor ${this.nefiaFloor}.`);
      if (this.nefiaFloor > this.deepestFloor) this.deepestFloor = this.nefiaFloor;
      // Notify explore quests
      const exploreMsgs = QuestSystem.onNefiaFloorReached(this.player, this.currentLocation.id, this.nefiaFloor);
      exploreMsgs.forEach(m => this.addMessage(m.text));
      PetSystem.placePetsOnMap(this.player, this.currentMap);
      // Reset fog for new floor (try loading from cache)
      const fogKey = this._getFogMapKey();
      if (!FogOfWarSystem.loadFogFromCache(fogKey, this.fogSystem)) {
        this.fogSystem.init(this.currentMap.width, this.currentMap.height, fogKey);
      }
      this._updateFog();
    }
  }

  _handleAscend(result) {
    if (!this.currentMap) return;
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    if (tile.type !== 'stairsUp') { result.ok = false; result.msg = 'No stairs here'; return; }
    if (this.nefiaFloor <= 1) {
      this._handleExitToWorldMap(result);
      return;
    }
    // Save fog state before changing floors
    if (this.fogSystem.fogMap) {
      FogOfWarSystem.saveFogToCache(this._getFogMapKey(), this.fogSystem);
    }
    this.nefiaFloor--;
    this.currentMap = this.nefiaSystem.generateFloor(this.currentLocation, this.nefiaFloor);
    this.player.x = this.currentMap.stairsDownX || this.currentMap.width - 2;
    this.player.y = this.currentMap.stairsDownY || this.currentMap.height - 2;
    this.addMessage(`You ascend to floor ${this.nefiaFloor}.`);
    PetSystem.placePetsOnMap(this.player, this.currentMap);
    // Reset fog for this floor (try loading from cache)
    const fogKey = this._getFogMapKey();
    if (!FogOfWarSystem.loadFogFromCache(fogKey, this.fogSystem)) {
      this.fogSystem.init(this.currentMap.width, this.currentMap.height, fogKey);
    }
    this._updateFog();
  }

  // â”€â”€ Sleep System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleSleep(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot sleep here.'; return; }

    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];

    // Determine comfort level: check for bed on current tile, then ground sleeping
    let comfort = 5; // 5% = bare ground
    let bedName = 'the bare ground';

    if (tile && tile.bed) {
      comfort = tile.bed.comfort || comfort;
      bedName = tile.bed.name || 'a bed';
    }

    // Check if there are hostile monsters nearby (within 5 tiles)
    const nearbyHostile = this.currentMap.monsters.some(m => {
      if (m.hp <= 0 || m.isPet || m._tamed) return false;
      const dist = Math.abs(m.x - this.player.x) + Math.abs(m.y - this.player.y);
      return dist <= 5;
    });
    if (nearbyHostile) {
      this.addMessage('You cannot sleep with enemies nearby!');
      result.ok = false;
      return;
    }

    // Sleeping advances time by 7 hours (420 minutes = 420 turns)
    const sleepTurns = 420;
    for (let i = 0; i < sleepTurns; i++) {
      this.turn++;
      this.timeWeather.advanceTurn();
      // Nutrition still drains while sleeping (at half rate)
      if (i % 2 === 0) {
        this.player.nutrition = Math.max(0, this.player.nutrition - 1);
      }
      // Farming still ticks
      if (this.currentMap && i % 10 === 0) {
        const season = this.timeWeather.getSeason();
        FarmingSystem.tickCrops(this.currentMap, season, this.timeWeather.weather);
      }
    }

    // HP and MP fully restored
    this.player.hp = this.player.maxHp;
    this.player.mp = this.player.maxMp;

    // SP restored based on comfort level (0-100%)
    const spRecovery = Math.floor(this.player.maxSp * (comfort / 100));
    this.player.sp = Math.min(this.player.maxSp, this.player.sp + spRecovery);

    // Messages
    this.addMessage(`You sleep on ${bedName} for 7 hours.`);
    this.addMessage('You feel well rested. HP and MP fully restored!');
    if (comfort > 0) {
      this.addMessage(`Sleep comfort: ${comfort}%. SP restored by ${spRecovery}.`);
    } else {
      this.addMessage('Sleeping on the ground provides no SP recovery.');
    }

    // Recipe dreaming â€” chance to learn a recipe while sleeping (max 1 per sleep)
    const dreamedRecipe = CraftingSystem.tryLearnRecipeFromSleep(this.player);
    if (dreamedRecipe) {
      this.addMessage(`ğŸ’­ In your dreams, you envision how to make: ${dreamedRecipe.name}!`);
    }
  }

  // â”€â”€ Place Bed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePlaceBed(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const invIdx = action.invIndex;
    const item = this.player.inventory[invIdx];
    if (!item || item.type !== 'furniture' || item.subtype !== 'bed') {
      this.addMessage('That is not a bed.');
      result.ok = false;
      return;
    }

    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
    if (!tile || !tile.walkable) {
      this.addMessage('You cannot place a bed here.');
      result.ok = false;
      return;
    }

    // Remove any existing bed on this tile
    if (tile.bed) {
      // Return old bed to inventory
      this.player.inventory.push({
        ...tile.bed,
        x: undefined, y: undefined
      });
      this.addMessage(`You pick up the ${tile.bed.name}.`);
    }

    // Place the bed
    tile.bed = {
      id: item.id,
      templateId: item.templateId || item.id,
      name: item.name,
      comfort: item.comfort || 0,
      char: item.char || '\u2261',
      color: item.color || '#a07040'
    };

    // Remove from inventory
    this.player.inventory.splice(invIdx, 1);
    this.addMessage(`You place the ${item.name}. (Comfort: ${item.comfort}%)`);
    this._advanceTurn(result);
  }

  // â”€â”€ Place Decoration Furniture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePlaceFurniture(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const invIdx = action.invIndex;
    const item = this.player.inventory[invIdx];
    if (!item || item.type !== 'furniture' || item.subtype !== 'decoration') {
      this.addMessage('That is not a placeable furniture item.');
      result.ok = false;
      return;
    }

    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
    if (!tile || !tile.walkable) {
      this.addMessage('You cannot place furniture here.');
      result.ok = false;
      return;
    }

    // Remove any existing furniture on this tile
    if (tile.furniture) {
      this.player.inventory.push({
        ...tile.furniture,
        x: undefined, y: undefined
      });
      this.addMessage(`You pick up the ${tile.furniture.name}.`);
    }

    // Place the furniture
    tile.furniture = {
      id: item.id,
      templateId: item.templateId || item.id,
      name: item.name,
      beauty: item.beauty || 0,
      char: item.char || 'â–¡',
      color: item.color || '#a07040',
      lightRadius: item.lightRadius || 0,
      type: item.type,
      subtype: item.subtype,
      description: item.description || ''
    };

    this.player.inventory.splice(invIdx, 1);
    const beautyText = item.beauty ? ` (Beauty: ${item.beauty})` : '';
    this.addMessage(`You place the ${item.name}.${beautyText}`);
    this._advanceTurn(result);
  }

  // â”€â”€ Pick Up Furniture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePickupFurniture(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];

    if (tile && tile.furniture) {
      const furn = tile.furniture;
      const newItem = ItemSystem.createItem(furn.templateId || furn.id);
      if (newItem) {
        ItemSystem.addToInventory(this.player, newItem);
      } else {
        this.player.inventory.push({ ...furn, x: undefined, y: undefined });
      }
      this.addMessage(`You pick up the ${furn.name}.`);
      tile.furniture = null;
      this._advanceTurn(result);
      return;
    }

    this.addMessage('There is no furniture here to pick up.');
    result.ok = false;
  }

  // â”€â”€ Turn Advancement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _advanceTurn(result) {
    this.turn++;
    this.timeWeather.advanceTurn();

    this.player.nutrition = Math.max(0, this.player.nutrition - 2);
    if (this.player.nutrition <= 0) {
      this.player.hp -= 2;
      this._logDamage('Starvation', 2);
      if (this.turn % 10 === 0) this.addMessage('You are starving!');
    }

    if (this.player.skills.regeneration > 0 && this.turn % 5 === 0) {
      this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.floor(this.player.skills.regeneration / 3) + 1);
    }
    if (this.player.skills.meditation > 0 && this.turn % 5 === 0) {
      this.player.mp = Math.min(this.player.maxMp, this.player.mp + Math.floor(this.player.skills.meditation / 3) + 1);
    }
    // SP no longer regenerates passively â€” only through sleeping

    const expired = MagicSystem.tickBuffs(this.player);
    if (expired && expired.length > 0) {
      expired.forEach(b => this.addMessage(`The effect of ${b.name} wears off.`));
    }

    // Recipe learning from skill practice
    if (this.player._skillXpGainedThisTurn && this.player._skillXpGainedThisTurn.length > 0) {
      const uniqueSkills = [...new Set(this.player._skillXpGainedThisTurn)];
      for (const sid of uniqueSkills) {
        const learned = CraftingSystem.tryLearnRecipeFromSkill(this.player, sid);
        if (learned) {
          const sdef = SKILL_DEFS[sid];
          this.addMessage(`While practicing ${sdef ? sdef.name : sid}, you figure out: ${learned.name}!`);
        }
      }
      this.player._skillXpGainedThisTurn = [];
    }

    // Faith system tick (prayer cooldown)
    FaithSystem.tick(this.player);

    // Faith regen bonuses
    const faithBonuses = FaithSystem.getBlessingBonuses(this.player);
    if (faithBonuses.hpRegen > 0 && this.turn % 5 === 0) {
      this.player.hp = Math.min(this.player.maxHp, this.player.hp + faithBonuses.hpRegen);
    }
    if (faithBonuses.mpRegen > 0 && this.turn % 5 === 0) {
      this.player.mp = Math.min(this.player.maxMp, this.player.mp + faithBonuses.mpRegen);
    }

    if (this.currentMap) {
      const season = this.timeWeather.getSeason();
      const cropMsgs = FarmingSystem.tickCrops(this.currentMap, season, this.timeWeather.weather);
      cropMsgs.forEach(m => this.addMessage(m.text));
    }

    if (this.currentMap && this.currentMap.monsters) {
      for (const m of this.currentMap.monsters) {
        if (m.hp <= 0) continue;
        this._monsterTurn(m, result);
      }
    }

    // Pet turns: pets attack enemies and follow the player
    if (this.currentMap) {
      PetSystem.petTurn(this.player, this.currentMap, (msg) => this.addMessage(msg));
      // Check for pet kills (monsters killed by pets generate drops)
      if (this.currentMap.monsters) {
        for (const m of this.currentMap.monsters) {
          if (m.hp <= 0 && !m._processed) {
            m._processed = true;
            const drops = ItemSystem.generateDrops(m);
            drops.forEach(item => {
              this.currentMap.items.push({ ...item, x: m.x, y: m.y });
            });
            this._onMonsterKilled(m);
          }
        }
      }
    }

    // Pet regen (1 HP every turn)
    if (this.turn % 3 === 0) {
      PetSystem.regenPets(this.player);
    }

    // Check for dead pets
    PetSystem.init(this.player);
    for (const pet of this.player.pets) {
      if (pet.hp <= 0 && !pet._deathNotified) {
        pet._deathNotified = true;
        this.addMessage(`${pet.name} has fallen! Visit a town to revive them. ğŸ’€`);
      }
    }

    if (this.player.hp <= 0) {
      // Check for divine death save (Ehekatl's Nine Lives)
      const deathSave = FaithSystem.checkDeathSave(this.player);
      if (deathSave.saved) {
        this.addMessage(deathSave.message);
      } else {
        this.addMessage('You have died...');
        this.gameOver = true;
        result.events.push({ type: 'death' });
      }
    }

    // Update fog of war after all entities have moved
    this._updateFog();
  }

  _monsterTurn(monster, result) {
    // Find the closest target: player or a living pet
    let targetX = this.player.x;
    let targetY = this.player.y;
    let targetObj = this.player;
    let distToPlayer = Math.abs(this.player.x - monster.x) + Math.abs(this.player.y - monster.y);
    let bestDist = distToPlayer;

    // Check if any pet is closer
    PetSystem.init(this.player);
    for (const pet of this.player.pets) {
      if (pet.hp <= 0) continue;
      const petDist = Math.abs(pet.x - monster.x) + Math.abs(pet.y - monster.y);
      if (petDist < bestDist) {
        bestDist = petDist;
        targetX = pet.x;
        targetY = pet.y;
        targetObj = pet;
      }
    }

    const dx = targetX - monster.x;
    const dy = targetY - monster.y;
    const dist = Math.abs(dx) + Math.abs(dy);

    if (dist <= 1) {
      if (targetObj === this.player) {
        const combatResult = CombatSystem.meleeAttack(monster, this.player);
        this.addMessage(combatResult.message);
        if (combatResult.hit && combatResult.damage > 0) {
          this._logDamage(monster.name, combatResult.damage);
        }
      } else {
        // Monster attacks a pet
        let damage = CombatSystem.rollDice(monster.attack || '1d3');
        damage = Math.max(1, damage);
        const killed = PetSystem.damagePet(targetObj, damage);
        this.addMessage(`${monster.name} hits ${targetObj.name} for ${damage} damage.`);
      }
    } else if (dist < 8) {
      const mx = dx === 0 ? 0 : dx / Math.abs(dx);
      const my = dy === 0 ? 0 : dy / Math.abs(dy);
      const nx = monster.x + mx;
      const ny = monster.y + my;
      if (nx >= 0 && ny >= 0 && nx < this.currentMap.width && ny < this.currentMap.height) {
        const tile = this.currentMap.tiles[ny][nx];
        const blocked = this.currentMap.monsters.some(m2 => m2 !== monster && m2.hp > 0 && m2.x === nx && m2.y === ny);
        if (tile.walkable && !blocked && !(nx === this.player.x && ny === this.player.y)) {
          // Also don't step on pets
          const petBlocked = PetSystem.isPetAt(this.player, nx, ny);
          if (!petBlocked) {
            monster.x = nx;
            monster.y = ny;
          }
        }
      }
    }
  }

  // â”€â”€ Quest Hooks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onMonsterKilled(monster) {
    this.killCount++;
    const questMsgs = QuestSystem.onMonsterKilled(this.player, monster);
    questMsgs.forEach(m => this.addMessage(m.text));
    // Also check gather quests (monster drops may complete them)
    const gatherMsgs = QuestSystem.checkGatherQuests(this.player);
    gatherMsgs.forEach(m => this.addMessage(m.text));
    // Faith favor for kills
    const faithMsgs = FaithSystem.onAction(this.player, 'meleeKill', { monster });
    faithMsgs.forEach(m => this.addMessage(m));
    // Card drop
    const card = CardSystem.rollCardDrop(monster);
    if (card) {
      CardSystem.addCard(this.player, card);
      const ri = CardSystem.RARITY_INFO[card.rarity];
      this.addMessage(`${ri.emoji} Obtained card: ${card.monsterName} (${ri.name})!`);
    }
  }

  _handleAcceptQuest(action, result) {
    const quest = this.questBoard.find(q => q.id === action.questId);
    if (!quest) { result.ok = false; result.msg = 'Quest not found on board'; return; }
    const acceptResult = QuestSystem.acceptQuest(this.player, quest, this.turn);
    this.addMessage(acceptResult.message);
    if (!acceptResult.success) result.ok = false;
    // Remove from board
    if (acceptResult.success) {
      this.questBoard = this.questBoard.filter(q => q.id !== action.questId);
    }
  }

  _handleTurnInQuest(action, result) {
    const townId = this.currentLocation ? this.currentLocation.id : null;
    const turnInResult = QuestSystem.turnInQuest(this.player, action.questId, townId);
    this.addMessage(turnInResult.message);
    if (turnInResult.success) {
      if (turnInResult.fame) this.fame += turnInResult.fame;
      if (turnInResult.karma) this.karma += turnInResult.karma;
    } else {
      result.ok = false;
    }
  }

  _handleAbandonQuest(action, result) {
    const abandonResult = QuestSystem.abandonQuest(this.player, action.questId);
    this.addMessage(abandonResult.message);
    if (!abandonResult.success) result.ok = false;
  }

  // â”€â”€ Gathering / Mining â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleGather(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot gather here'; return; }

    const node = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
    if (!node) {
      this.addMessage('No resource node nearby. (Stand next to a tree, ore vein, herb patch, bush, or other resource)');
      result.ok = false;
      return;
    }

    const gatherResult = GatheringSystem.gather(
      this.player, node.tile, this.currentMap, node.x, node.y
    );
    if (gatherResult.skillUsed) {
      node.tile._depletedTurn = this.turn;
    }
    this.addMessage(gatherResult.message);

    if (gatherResult.success && gatherResult.items.length > 0) {
      gatherResult.items.forEach(item => {
        ItemSystem.addToInventory(this.player, item);
      });
      const names = gatherResult.items.map(i => i.name).join(', ');
      this.addMessage(`Obtained: ${names}`);
      // Check gather quests
      try {
        const gatherMsgs = QuestSystem.checkGatherQuests(this.player);
        gatherMsgs.forEach(m => this.addMessage(m.text));
      } catch (e) { /* quest system may not be active */ }
      // Faith favor for gathering
      const gatherFaithMsgs = FaithSystem.onAction(this.player, 'gathering', {});
      gatherFaithMsgs.forEach(m => this.addMessage(m));
    }

    this._advanceTurn(result);
  }

  // â”€â”€ Enchanting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleEnchant(action, result) {
    const scrollIdx = action.scrollIndex;
    const targetIdx = action.targetIndex;
    if (scrollIdx == null || targetIdx == null) { result.ok = false; result.msg = 'Missing enchant parameters'; return; }
    if (scrollIdx < 0 || scrollIdx >= this.player.inventory.length) { result.ok = false; return; }
    if (targetIdx < 0 || targetIdx >= this.player.inventory.length) { result.ok = false; return; }

    const scroll = this.player.inventory[scrollIdx];
    const target = this.player.inventory[targetIdx];

    const enchantResult = EnchantSystem.enchant(this.player, target, scroll);
    this.addMessage(enchantResult.message);

    if (enchantResult.consumed) {
      // Remove the scroll (adjust targetIdx if scroll was before target)
      ItemSystem.removeFromInventory(this.player, scrollIdx, 1);
    }

    if (enchantResult.destroyed) {
      // Find the target item again (index may have shifted)
      const newTargetIdx = this.player.inventory.findIndex(i => i.id === target.id);
      if (newTargetIdx >= 0) {
        // Unequip if equipped
        if (this.player.equipment) {
          Object.keys(this.player.equipment).forEach(slot => {
            if (this.player.equipment[slot] && this.player.equipment[slot].id === target.id) {
              this.player.equipment[slot] = null;
            }
          });
        }
        ItemSystem.removeFromInventory(this.player, newTargetIdx, 1);
      }
    }

    this._advanceTurn(result);
  }

  // â”€â”€ Faith / God Worship â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePray(action, result) {
    FaithSystem.init(this.player);
    const prayResult = FaithSystem.pray(this.player);
    if (prayResult.messages) {
      prayResult.messages.forEach(m => this.addMessage(m));
    } else {
      this.addMessage(prayResult.message);
    }
    if (prayResult.success) {
      this._advanceTurn(result);
    } else {
      result.ok = false;
    }
  }

  _handleWorship(action, result) {
    const godId = action.godId;
    if (!godId) { result.ok = false; result.msg = 'No god selected'; return; }

    // Must be standing on an altar tile
    if (this.currentMap) {
      const tile = this.currentMap.tiles[this.player.y][this.player.x];
      if (!tile.altar && tile.type !== 'shrine') {
        this.addMessage('You must stand at an altar to worship a god.');
        result.ok = false;
        return;
      }
    }

    const worshipResult = FaithSystem.worship(this.player, godId);
    if (worshipResult.messages) {
      worshipResult.messages.forEach(m => this.addMessage(m));
    } else {
      this.addMessage(worshipResult.message);
    }
    if (!worshipResult.success) result.ok = false;
  }

  _handleOfferItem(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }

    // Must be on an altar
    if (this.currentMap) {
      const tile = this.currentMap.tiles[this.player.y][this.player.x];
      if (!tile.altar && tile.type !== 'shrine') {
        this.addMessage('You must stand at an altar to make an offering.');
        result.ok = false;
        return;
      }
    }

    const item = this.player.inventory[idx];
    const offerResult = FaithSystem.offerItem(this.player, item);
    if (offerResult.messages) {
      offerResult.messages.forEach(m => this.addMessage(m));
    } else {
      this.addMessage(offerResult.message);
    }
    if (offerResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    if (offerResult.success) {
      this._advanceTurn(result);
    } else {
      result.ok = false;
    }
  }

  // â”€â”€ Pet Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleTame(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot tame here'; return; }
    PetSystem.init(this.player);

    // Find an adjacent hostile monster to tame
    let target = null;
    if (action.targetId) {
      target = this.currentMap.monsters.find(m => m.id === action.targetId && m.hp > 0 && !m._tamed);
    } else {
      // Auto-target nearest adjacent hostile monster
      const adj = [
        { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
        { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
      ];
      let bestDist = Infinity;
      for (const m of this.currentMap.monsters) {
        if (m.hp <= 0 || m._tamed || m.isPet) continue;
        const dist = Math.abs(m.x - this.player.x) + Math.abs(m.y - this.player.y);
        if (dist <= 1 && dist < bestDist) {
          bestDist = dist;
          target = m;
        }
      }
    }

    if (!target) {
      this.addMessage('No creature nearby to tame. (Stand adjacent to a monster)');
      result.ok = false;
      return;
    }

    const tameResult = PetSystem.attemptTame(this.player, target);
    this.addMessage(tameResult.message);

    if (tameResult.success) {
      // Remove tamed monster from the hostile monster list
      this.currentMap.monsters = this.currentMap.monsters.filter(m => !m._tamed);
      result.events.push({ type: 'petTamed', name: target.name });
    }

    this._advanceTurn(result);
  }

  _handleReleasePet(action, result) {
    const releaseResult = PetSystem.releasePet(this.player, action.petId);
    this.addMessage(releaseResult.message);
    if (!releaseResult.success) result.ok = false;
  }

  _handleRenamePet(action, result) {
    const renameResult = PetSystem.renamePet(this.player, action.petId, action.newName || 'Pet');
    this.addMessage(renameResult.message);
    if (!renameResult.success) result.ok = false;
  }

  _handleRevivePet(action, result) {
    const reviveResult = PetSystem.revivePet(this.player, action.petId);
    this.addMessage(reviveResult.message);
    if (!reviveResult.success) result.ok = false;
  }

  // â”€â”€ Messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addMessage(msg) {
    this.messages.push({ turn: this.turn, text: msg, time: this.timeWeather.getTimeString() });
    if (this.messages.length > 100) this.messages.shift();
  }

  // â”€â”€ Fog of War â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _updateFog() {
    if (!this.currentMap || this.mode !== 'localMap') return;

    const locType = this.currentLocation ? this.currentLocation.type : 'outdoor';
    const timeState = this.timeWeather.getState();
    const mapKey = this._getFogMapKey();

    // Initialize fog for this map if needed
    this.fogSystem.init(this.currentMap.width, this.currentMap.height, mapKey);

    // If daytime and not underground, reveal everything as seen
    if (FogOfWarSystem.shouldRevealAll(locType, timeState)) {
      this.fogSystem.revealAllAsSeen();
    }

    // Calculate visibility range and update visible tiles
    const visRange = FogOfWarSystem.computeVisibilityRange(
      this.player, timeState, locType
    );
    this.fogSystem.update(
      this.player.x, this.player.y, visRange, this.currentMap.tiles
    );
  }

  _getFogMapKey() {
    const locId = this.currentLocation ? this.currentLocation.id : 'outdoor';
    return this.nefiaFloor > 0 ? `${locId}-${this.nefiaFloor}` : locId;
  }

  // â”€â”€ Client State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getClientState() {
    let dv = 0, pv = 0;
    if (this.player.equipment) {
      Object.values(this.player.equipment).forEach(item => {
        if (item && item.DV) dv += item.DV;
        if (item && item.PV) pv += item.PV;
        // Add enchantment bonuses
        dv += EnchantSystem.getEnchantDV(item);
        pv += EnchantSystem.getEnchantPV(item);
      });
    }
    if (this.player.skills && this.player.skills.evasion) {
      dv += Math.floor(this.player.skills.evasion / 3);
    }

    MagicSystem.initSpells(this.player);
    const buffBonuses = MagicSystem.getBuffBonuses(this.player);
    dv += buffBonuses.dv;
    pv += buffBonuses.pv;

    // Faith blessing bonuses
    FaithSystem.init(this.player);
    const faithBonuses = FaithSystem.getBlessingBonuses(this.player);
    dv += faithBonuses.dv;
    pv += faithBonuses.pv;

    const weaponItem = this.player.equipment ? this.player.equipment.weapon : null;
    const bodyItem = this.player.equipment ? this.player.equipment.body : null;

    const state = {
      id: this.id,
      mode: this.mode,
      turn: this.turn,
      gameOver: this.gameOver,
      dead: this.gameOver,
      deathRecap: this.gameOver ? this._buildDeathRecap() : null,
      fame: this.fame,
      karma: this.karma,
      time: this.timeWeather.getState(),
      weather: this.timeWeather.weather,
      messages: this.messages.slice(-20),
      player: {
        name: this.player.name,
        raceName: this.player.race.name,
        className: this.player.cls.name,
        level: this.player.level,
        exp: this.player.xp,
        expNext: this.player.xpNext,
        hp: this.player.hp,
        maxHp: this.player.maxHp,
        mp: this.player.mp,
        maxMp: this.player.maxMp,
        sp: this.player.sp,
        maxSp: this.player.maxSp,
        nutrition: this.player.nutrition,
        attributes: this.player.attributes,
        skills: this.player.skills,
        inventory: this.player.inventory,
        equipment: {
          weapon: weaponItem ? weaponItem.id : null,
          weaponName: weaponItem ? weaponItem.name : null,
          armor: bodyItem ? bodyItem.id : null,
          armorName: bodyItem ? bodyItem.name : null
        },
        x: this.player.x,
        y: this.player.y,
        gold: this.player.gold,
        feat: this.player.feat,
        speed: this.player.speed + buffBonuses.speed + faithBonuses.speed,
        dv,
        pv,
        spells: MagicSystem.getSpellList(this.player),
        buffs: (this.player.buffs || []).map(b => ({ type: b.type, name: b.name, turnsLeft: b.turnsLeft }))
      }
    };

    if (this.mode === 'worldMap') {
      state.worldMap = this.worldMap;
      state.worldX = this.worldX;
      state.worldY = this.worldY;
      state.locations = WORLD_LOCATIONS;
    } else if (this.mode === 'localMap' && this.currentMap) {
      // Include world map data for minimap rendering
      state.worldMap = this.worldMap;
      state.worldX = this.worldX;
      state.worldY = this.worldY;
      state.locations = WORLD_LOCATIONS;
      const locType = this.currentLocation ? this.currentLocation.type : 'outdoor';
      const timeState = this.timeWeather.getState();
      const fogActive = FogOfWarSystem.shouldUseFog(locType, timeState);

      state.localMap = {
        width: this.currentMap.width,
        height: this.currentMap.height,
        tiles: this.currentMap.tiles,
        monsters: this.currentMap.monsters.filter(m => m.hp > 0).map(m => ({
          id: m.id, templateId: m.templateId, name: m.name, x: m.x, y: m.y, hp: m.hp, maxHp: m.maxHp, level: m.level, char: m.char || 'M', color: m.color || '#c33', isBoss: m.isBoss || false
        })),
        items: this.currentMap.items.map(i => ({ id: i.id, templateId: i.templateId, name: i.name, type: i.type, subtype: i.subtype, slot: i.slot, x: i.x, y: i.y, char: i.char || '!', color: i.color || '#dd0', healMP: i.healMP })),
        locationName: this.currentLocation ? this.currentLocation.name : 'Wilderness',
        locationType: locType,
        fogActive: fogActive,
        fogMap: fogActive ? this.fogSystem.fogMap : null,
        visRange: fogActive ? FogOfWarSystem.computeVisibilityRange(this.player, timeState, locType) : 0
      };
      state.nefiaFloor = this.nefiaFloor;
      const playerTile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
      if (playerTile && playerTile.crop) {
        state.cropInfo = FarmingSystem.getCropInfo(playerTile);
      }
      if (playerTile && playerTile.furniture) {
        state.furnitureInfo = {
          name: playerTile.furniture.name,
          beauty: playerTile.furniture.beauty || 0,
          description: playerTile.furniture.description || ''
        };
      }
      // Check for nearby gatherable nodes
      const nearbyNode = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
      if (nearbyNode) {
        state.gatherNode = GatheringSystem.getNodeInfo(nearbyNode.tile);
      }
    }

    if (this.activeShop) {
      state.shop = ShopSystem.getShopDisplay(this.activeShop);
    }

    // Card collection & card shop
    CardSystem.init(this.player);
    state.cardCollection = CardSystem.getCollectionDisplay(this.player);
    if (this.activeCardShop) {
      state.cardShop = this.activeCardShop;
    }

    if (this.mode === 'localMap') {
      state.npcs = [];
      // Add shop NPCs
      if (this.townShops && this.townShops.length > 0) {
        for (const s of this.townShops) {
          state.npcs.push({
            x: s.x, y: s.y, char: s.char, color: s.color, name: s.npcName, npcName: s.npcName, shopName: s.name
          });
        }
      }
      // Add card merchant NPC
      if (this.cardMerchantPos) {
        state.npcs.push({
          x: this.cardMerchantPos.x, y: this.cardMerchantPos.y,
          char: 'ğŸƒ', color: '#e040fb', name: 'Card Merchant', npcName: 'Card Merchant', shopName: 'Card Shop'
        });
      }
      // Add quest board NPC to the npcs list
      if (this.questBoardPos) {
        state.npcs.push({
          x: this.questBoardPos.x, y: this.questBoardPos.y,
          char: 'ğŸ“œ', color: '#ffa', name: 'Quest Board', npcName: 'Quest Board', shopName: 'Quest Board'
        });
      }
      // Add altar to the npcs list for rendering
      if (this.altarPos) {
        state.npcs.push({
          x: this.altarPos.x, y: this.altarPos.y,
          char: 'â€ ', color: '#d0d050', name: 'Altar', npcName: 'Altar', shopName: 'Altar'
        });
      }
      // Add ambient NPCs to the npcs list for rendering
      if (this.ambientNPCs && this.ambientNPCs.length > 0) {
        for (const npc of this.ambientNPCs) {
          state.npcs.push({
            x: npc.x, y: npc.y,
            char: npc.char, color: npc.color,
            name: npc.name, npcName: npc.name, shopName: ''
          });
        }
      }
    }

    const nearbyWorkshops = this.currentMap ? CraftingSystem.getNearbyWorkshops(this.player, this.currentMap) : new Set();
    state.recipes = CraftingSystem.getAvailableRecipes(this.player, nearbyWorkshops);
    state.nearbyWorkshops = Array.from(nearbyWorkshops);
    state.knownRecipeCount = this.player.knownRecipes ? this.player.knownRecipes.length : 0;
    state.totalRecipeCount = Object.keys(RECIPE_DEFS).length;

    // Quest data
    state.activeQuests = QuestSystem.getActiveQuests(this.player);
    state.completedQuestCount = QuestSystem.getCompletedQuests(this.player).length;
    state.questBoard = this.questBoard || [];
    state.currentTownId = this.currentLocation ? this.currentLocation.id : null;
    // Check if player is standing on quest board
    if (this.questBoardPos && this.player.x === this.questBoardPos.x && this.player.y === this.questBoardPos.y) {
      state.onQuestBoard = true;
    }

    const rangedWeapon = this.player.equipment ? this.player.equipment.weapon : null;
    if (rangedWeapon && rangedWeapon.ranged) {
      state.player.hasRangedWeapon = true;
    }

    // Pet data
    PetSystem.init(this.player);
    state.pets = PetSystem.getPetList(this.player);
    state.maxPets = PetSystem.getMaxPets(this.player);

    // Faith data
    state.faith = FaithSystem.getState(this.player);
    // Check if player is standing on an altar
    if (this.currentMap && this.player.y < this.currentMap.height && this.player.x < this.currentMap.width) {
      const playerTile2 = this.currentMap.tiles[this.player.y][this.player.x];
      if (playerTile2 && (playerTile2.altar || playerTile2.type === 'shrine')) {
        state.onAltar = true;
        state.altarGodId = playerTile2.altarGodId || null;
      }
    }

    // â”€â”€ Context Actions â€” what the player can do right now â”€â”€
    state.contextActions = this._getContextActions();

    return state;
  }

  // â”€â”€ Context Action Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _getContextActions() {
    const actions = [];

    // â”€ Always available â”€
    actions.push({ key: '.', label: 'Wait', action: 'wait', icon: 'â³', always: true });

    if (this.mode === 'worldMap') {
      // World-map specific
      const loc = Object.values(WORLD_LOCATIONS).find(l => l.x === this.worldX && l.y === this.worldY);
      if (loc) {
        actions.push({ key: 'Enter', label: `Enter ${loc.name}`, action: 'enterLocation', icon: 'ğŸšª', highlight: true });
      } else {
        const biome = this.worldMap && this.worldMap[this.worldY] && this.worldMap[this.worldY][this.worldX];
        const biomeName = biome ? biome.name : 'Wilderness';
        actions.push({ key: 'Enter', label: `Enter ${biomeName}`, action: 'enterLocation', icon: 'ğŸŒ¿', highlight: false });
      }
      actions.push({ key: 'Ctrl+S', label: 'Save', action: 'save', icon: 'ğŸ’¾', always: true });
      return actions;
    }

    // â”€ Local map actions â”€
    if (!this.currentMap) return actions;

    const px = this.player.x;
    const py = this.player.y;
    const tile = this.currentMap.tiles[py] && this.currentMap.tiles[py][px];

    // Pickup: items on ground
    const groundItems = this.currentMap.items.filter(i => i.x === px && i.y === py);
    if (groundItems.length > 0) {
      const itemName = groundItems.length === 1 ? groundItems[0].name : `${groundItems.length} items`;
      actions.push({ key: 'G', label: `Get (${itemName})`, action: 'pickup', icon: 'ğŸ“¦', highlight: true });
    }

    // Eat: have food in inventory
    const hasFood = this.player.inventory.some(i => i.type === 'food');
    if (hasFood) {
      actions.push({ key: 'E', label: 'Eat', action: 'eat', icon: 'ğŸ–' });
    }

    // Descend / Ascend stairs
    if (tile) {
      if (tile.type === 'stairsDown') {
        actions.push({ key: '>', label: 'Descend', action: 'descend', icon: 'â¬‡', highlight: true });
      }
      if (tile.type === 'stairsUp') {
        actions.push({ key: '<', label: 'Ascend', action: 'ascend', icon: 'â¬†', highlight: true });
      }
    }

    // Tame: adjacent monster
    const adjDirs = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
    ];
    const adjacentMonster = this.currentMap.monsters.find(m => {
      if (m.hp <= 0 || m._tamed || m.isPet) return false;
      return Math.abs(m.x - px) <= 1 && Math.abs(m.y - py) <= 1 && !(m.x === px && m.y === py);
    });
    if (adjacentMonster) {
      actions.push({ key: 'T', label: `Tame (${adjacentMonster.name})`, action: 'tame', icon: 'ğŸ¾', highlight: true });
    }

    // Gather: adjacent resource node
    const nearbyNode = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
    if (nearbyNode) {
      const nodeInfo = GatheringSystem.getNodeInfo(nearbyNode.tile);
      actions.push({ key: 'M', label: `${nodeInfo.verb} (${nodeInfo.name})`, action: 'gather', icon: nodeInfo.icon || 'â›', highlight: true });
    }

    // Harvest: standing on harvestable crop
    if (tile && tile.crop) {
      const cropInfo = FarmingSystem.getCropInfo(tile);
      if (cropInfo && cropInfo.harvestable) {
        actions.push({ key: 'H', label: `Harvest (${cropInfo.name})`, action: 'harvest', icon: 'ğŸŒ¾', highlight: true });
      }
    }

    // Plant: have seeds and on farmable tile
    const hasSeed = this.player.inventory.some(i => i.type === 'seed');
    if (hasSeed && tile && (tile.type === 'farmland' || tile.type === 'soil' || tile.type === 'grass' || tile.type === 'floor')) {
      actions.push({ key: 'P', label: 'Plant', action: 'openPlant', icon: 'ğŸŒ±' });
    }

    // Pick up placed furniture
    if (tile && tile.furniture) {
      actions.push({ key: 'Shift+U', label: `Pick up ${tile.furniture.name}`, action: 'pickupFurniture', icon: 'ğŸ ' });
    }

    // Sleep: always available on local map (comfort depends on bed)
    if (tile && tile.bed) {
      actions.push({ key: 'S', label: `Sleep (${tile.bed.name} ${tile.bed.comfort}%)`, action: 'sleep', icon: 'ğŸ’¤', highlight: true });
    } else {
      actions.push({ key: 'S', label: 'Sleep (ground 5%)', action: 'sleep', icon: 'ğŸ’¤' });
    }

    // Ranged attack: have ranged weapon and visible monster
    const rangedWeapon = this.player.equipment ? this.player.equipment.weapon : null;
    if (rangedWeapon && rangedWeapon.ranged) {
      const visibleMonster = this.currentMap.monsters.some(m => m.hp > 0);
      if (visibleMonster) {
        actions.push({ key: 'F', label: 'Shoot', action: 'rangedAttack', icon: 'ğŸ¹', highlight: true });
      }
    }

    // Pray: have a god
    if (this.player.faith && this.player.faith.godId) {
      // On altar â€” extra highlight
      const onAltar = tile && (tile.altar || tile.type === 'shrine');
      if (onAltar) {
        actions.push({ key: 'R', label: 'Pray', action: 'pray', icon: 'ğŸ™', highlight: true });
      } else {
        actions.push({ key: 'R', label: 'Pray', action: 'pray', icon: 'ğŸ™' });
      }
    }

    // On altar without a god
    if (tile && (tile.altar || tile.type === 'shrine') && !(this.player.faith && this.player.faith.godId)) {
      actions.push({ key: 'ğŸ™', label: 'Worship (open Faith tab)', action: 'openFaith', icon: 'ğŸ™', highlight: true });
    }

    // Shop: standing on NPC shop tile
    if (tile && tile.npc && tile.npc.shopId) {
      actions.push({ key: 'ğŸª', label: `Shop (${tile.npc.shopName})`, action: 'openShop', icon: 'ğŸª', highlight: true });
    }

    // Quest Board
    if (tile && tile.npc && tile.npc.questBoard) {
      actions.push({ key: 'Q', label: 'Quests', action: 'openQuests', icon: 'ğŸ“œ', highlight: true });
    }

    // Always-available panel shortcuts
    actions.push({ key: 'Z', label: 'Spells', action: 'openSpells', icon: 'âœ¨' });
    // Show nearby workshops in craft action
    const ctxWorkshops = CraftingSystem.getNearbyWorkshops(this.player, this.currentMap);
    if (ctxWorkshops.size > 0) {
      actions.push({ key: 'C', label: `Craft (${ctxWorkshops.size} workshop${ctxWorkshops.size > 1 ? 's' : ''})`, action: 'openCraft', icon: 'ğŸ”¨', highlight: true });
    } else {
      actions.push({ key: 'C', label: 'Craft (hand only)', action: 'openCraft', icon: 'ğŸ”¨' });
    }
    actions.push({ key: 'Q', label: 'Quests', action: 'openQuests', icon: 'ğŸ“œ' });

    // Exit to world map â€” walk to the map edge to leave

    // Save
    actions.push({ key: 'Ctrl+S', label: 'Save', action: 'save', icon: 'ğŸ’¾', always: true });

    return actions;
  }

  // â”€â”€ Action Timing Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getActionContext(action) {
    const context = {};
    if (action.type === 'gather' && this.currentMap) {
      const node = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
      if (node) {
        context.nodeType = GatheringSystem.getNodeType(node.tile);
      }
    }
    return context;
  }

  // â”€â”€ Save / Load â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  serialize() {
    return {
      id: this.id,
      player: this.player,
      // worldMap is deterministic â€” regenerated on load to save storage
      worldX: this.worldX,
      worldY: this.worldY,
      turn: this.turn,
      mode: this.mode,
      fame: this.fame,
      karma: this.karma,
      time: this.timeWeather.getState(),
      messages: this.messages,
      damageLog: this.damageLog,
      killCount: this.killCount,
      deepestFloor: this.deepestFloor,
      locationsVisited: Array.from(this.locationsVisited),
      homesteadMap: this.homesteadMap,
      cardCollection: this.player.cardCollection || [],
      cardStats: this.player.cardStats || { totalCollected: 0, totalSold: 0 }
    };
  }

  loadFromSave(data) {
    Object.assign(this, data);
    // Regenerate deterministic world map (not saved to reduce storage)
    this.worldMap = MapGenerator.generateWorldMap();
    // Migrate old saves: if worldX/worldY out of bounds, reset to homestead
    if (this.worldX >= MapGenerator.WORLD_WIDTH || this.worldY >= MapGenerator.WORLD_HEIGHT) {
      const home = WORLD_LOCATIONS.homestead;
      this.worldX = home.x;
      this.worldY = home.y;
    }
    this.timeWeather = new TimeWeather(data.time);
    this.nefiaSystem = new NefiaSystem();
    this.fogSystem = new FogOfWarSystem();
    this.gameOver = false;
    if (!this.player.quests) this.player.quests = [];
    if (!this.player.pets) this.player.pets = [];
    FaithSystem.init(this.player);
    this.questBoard = [];
    this.questBoardPos = null;
    // Restore death recap tracking
    this.damageLog = data.damageLog || [];
    this.killCount = data.killCount || 0;
    this.deepestFloor = data.deepestFloor || 0;
    this.locationsVisited = new Set(data.locationsVisited || []);
    this.homesteadMap = data.homesteadMap || null;
    // Initialize recipe system
    CraftingSystem.initRecipes(this.player);
    // Restore card collection
    if (data.cardCollection) this.player.cardCollection = data.cardCollection;
    if (data.cardStats) this.player.cardStats = data.cardStats;
    CardSystem.init(this.player);
  }
}

</script>

  <script>
// ============================================================
// Client-side Game Data â€” Loaded from static JSON files
// ============================================================

// These will be populated by loadGameData() before the game starts
let CLIENT_RACES = [];
let CLIENT_CLASSES = [];
let GAME_DATA = {};
let SHOP_DATA = {};
let RECIPE_DATA = {};

const ATTR_NAMES = {
  STR: 'Strength', END: 'Endurance', DEX: 'Dexterity', PER: 'Perception',
  LRN: 'Learning', WIL: 'Willpower', MAG: 'Magic', CHA: 'Charisma'
};

let WEATHER_ICONS = {
  sunny: 'â˜€ï¸', cloudy: 'â˜ï¸', rain: 'ğŸŒ§ï¸', heavyRain: 'â›ˆï¸',
  snow: 'ğŸŒ¨ï¸', heavySnow: 'â„ï¸', ether: 'âœ¨'
};

/**
 * Fetches all game data from static JSON files and populates globals.
 * Also loads the engine's global data (RACES, CLASSES, etc.).
 * Must be called (and awaited) before showing any UI that uses game data.
 */
async function loadGameData() {
  // Load engine-side globals first
  await loadAllGameData();

  // Build the GAME_DATA bundle from the engine globals
  const data = {
    races: RACES,
    classes: CLASSES,
    skills: SKILL_DEFS,
    items: ITEM_TEMPLATES,
    monsters: MONSTER_TEMPLATES,
    monsterTiers: MONSTER_TIERS,
    locations: WORLD_LOCATIONS,
    biomes: BIOMES,
    tiles: TILE_TYPES,
    weather: { types: WEATHER_TYPES, effects: WEATHER_EFFECTS },
    spells: SPELL_DEFS,
    crops: CROP_DEFS,
    shops: SHOP_DEFS,
    recipes: RECIPE_DEFS
  };
  GAME_DATA = data;

  // Build CLIENT_RACES array (format expected by UI)
  CLIENT_RACES = Object.values(data.races).map(r => ({
    id: r.id,
    name: r.name,
    desc: r.description,
    attrs: Object.entries(r.attributes).map(([id, mod]) => ({ id, mod })),
    feat: r.feat,
    featDesc: r.featDesc,
    baseLife: r.baseLife,
    baseMana: r.baseMana,
    baseSpeed: r.baseSpeed
  }));

  // Build CLIENT_CLASSES array (format expected by UI)
  CLIENT_CLASSES = Object.values(data.classes).map(c => ({
    id: c.id,
    name: c.name,
    desc: c.description,
    attrs: Object.entries(c.attributes).map(([id, mod]) => ({ id, mod })),
    feat: c.feat,
    featDesc: c.featDesc,
    domains: c.domains || []
  }));

  // Load weather icons from data if available
  if (data.weather && data.weather.icons) {
    WEATHER_ICONS = data.weather.icons;
  }

  // Store shop and recipe data
  if (data.shops) SHOP_DATA = data.shops;
  if (data.recipes) RECIPE_DATA = data.recipes;

  return data;
}

</script>

  <!-- Tile system: core manager + modular tile definitions -->
  <script>
// ============================================================
// SVGTileManager â€” Registry & loader for modular SVG tile files
// ============================================================
// Each tile category is defined in its own file under js/tiles/.
// Tile files register themselves via SVGTileManager.register().
// This allows the game to scale to thousands of tiles without
// touching a single monolithic file.
//
// PNG Override: After SVG tiles are loaded, the manager fetches
// assets/sprites/manifest.json.  For every key listed there the
// SVG tile is replaced by the PNG sprite.  SVG remains as fallback.
// ============================================================

class SVGTileManager {
  constructor(tileSize) {
    this.tileSize = tileSize || 32;
    this.cache = {};
    this.variants = {};   // key -> [Image, Image, ...]
    this.pngOverrides = {}; // key -> { img, gridWidth, gridHeight }
    this._applyRegistered();
    this._loadPNGOverrides();
  }

  // â”€â”€ PNG Override system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Fetch manifest and load PNG sprites to override SVG tiles */
  _loadPNGOverrides() {
    Promise.resolve({"_comment":"Maps tile keys to their PNG sprite filenames. Managed by the Sprite Tool.","sprites":{}})
      .then(manifest => {
        if (!manifest || !manifest.sprites) return;
        const entries = Object.entries(manifest.sprites);
        let loaded = 0;
        entries.forEach(([key, info]) => {
          const img = new Image();
          img.onload = () => {
            this.pngOverrides[key] = {
              img,
              gridWidth: info.gridWidth || 1,
              gridHeight: info.gridHeight || 1
            };
            // Also replace in the main cache so existing code works
            this.cache[key] = img;
            // Replace in variants array first entry too
            if (this.variants[key]) {
              this.variants[key][0] = img;
            }
            loaded++;
            if (loaded === entries.length) {
              console.log(`[SVGTileManager] Loaded ${loaded} PNG overrides`);
            }
          };
          img.onerror = () => {
            console.warn(`[SVGTileManager] Failed to load PNG override for "${key}": ${info.file}`);
          };
          img.src = `/assets/sprites/${info.file}`;
        });
      })
      .catch(() => {
        // No manifest or fetch error â€” SVG fallback is fine
      });
  }

  /** Check if a key has a PNG override with multi-tile size info */
  getPNGOverride(key) {
    return this.pngOverrides[key] || null;
  }

  /** Check if a tile is multi-grid (bigger than 1x1) */
  getGridSize(key) {
    const ov = this.pngOverrides[key];
    if (ov) return { w: ov.gridWidth, h: ov.gridHeight };
    return { w: 1, h: 1 };
  }

  // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Get a cached Image for any tile key */
  get(key) {
    return this.cache[key] || null;
  }

  /**
   * Register multiple variants for a single tile key.
   * The first variant is also stored in this.cache as the default.
   */
  addVariants(key, images) {
    if (!images || images.length === 0) return;
    this.cache[key] = images[0];
    this.variants[key] = images;
  }

  /**
   * Pick a deterministic variant based on (x, y) coordinates.
   * Uses a multi-step hash to eliminate visible patterns.
   */
  getVariant(key, x, y) {
    const arr = this.variants[key];
    if (!arr || arr.length === 0) return this.cache[key] || null;
    // Multi-step integer hash â€” breaks linear patterns
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >>> 13)) * 1274126177;
    h = (h ^ (h >>> 16)) * 2654435769;
    h = h ^ (h >>> 13);
    return arr[(h >>> 0) % arr.length];
  }

  /** Get tile image for a terrain tile type (with variant support) */
  getTile(tileId, x, y) {
    const key = `tile_${tileId}`;
    // PNG override takes priority (already in cache via _loadPNGOverrides)
    if (this.pngOverrides[key]) return this.cache[key];
    if (x !== undefined && y !== undefined && this.variants[key]) {
      return this.getVariant(key, x, y);
    }
    return this.cache[key] || null;
  }

  /** Get tile for a biome (with variant support) */
  getBiome(biomeId, x, y) {
    const key = `biome_${biomeId}`;
    if (this.pngOverrides[key]) return this.cache[key];
    if (x !== undefined && y !== undefined && this.variants[key]) {
      return this.getVariant(key, x, y);
    }
    return this.cache[key] || null;
  }

  /** Get tile for a monster by its template id */
  getMonster(monsterId) {
    return this.cache[`monster_${monsterId}`] || null;
  }

  /** Get tile for an NPC by name */
  getNpc(npcName) {
    const key = npcName ? npcName.toLowerCase().replace(/\s/g, '') : 'generic';
    return this.cache[`npc_${key}`] || this.cache['npc_generic'];
  }

  /** Get tile for a location type */
  getLocation(locationType) {
    return this.cache[`location_${locationType}`] || this.cache['location_town'];
  }

  /**
   * Draw a (possibly multi-grid) sprite onto a canvas context.
   * Multi-tile sprites (2x2, 3x2, etc.) are drawn spanning multiple grid cells.
   * The anchor is the top-left corner of the sprite.
   * Returns the grid size {w, h} so the caller can skip cells already covered.
   */
  drawSprite(ctx, key, dx, dy, ts) {
    const img = this.cache[key];
    if (!img || !img.complete || img.naturalWidth === 0) return null;

    const ov = this.pngOverrides[key];
    const gw = ov ? ov.gridWidth : 1;
    const gh = ov ? ov.gridHeight : 1;

    ctx.drawImage(img, dx, dy, ts * gw, ts * gh);
    return { w: gw, h: gh };
  }

  /** Get tile for an item (delegates to ItemTiles logic) */
  getItem(item) {
    if (!item) return null;
    const tid = item.templateId || item.id || '';

    if (item.type === 'weapon') {
      if (tid === 'brokenSword') return this.cache['item_weapon_brokenSword'] || this.cache['item_weapon_longSword'];
      const sub = item.subtype || '';
      if (sub.includes('Sword') || sub.includes('longSword')) return this.cache['item_weapon_longSword'];
      if (sub.includes('shortSword')) return this.cache['item_weapon_shortSword'];
      if (sub.includes('axe')) return this.cache['item_weapon_axe'];
      if (sub.includes('bow')) return this.cache['item_weapon_bow'];
      if (sub.includes('staff')) return this.cache['item_weapon_staff'];
      if (sub.includes('mace')) return this.cache['item_weapon_mace'];
      return this.cache['item_weapon_longSword'];
    }
    if (item.type === 'armor') {
      if (tid === 'raggedCloth') return this.cache['item_armor_raggedCloth'] || this.cache['item_armor_body'];
      if (tid === 'chainMail') return this.cache['item_armor_chainMail'] || this.cache['item_armor_body'];
      const slot = item.slot || 'body';
      return this.cache[`item_armor_${slot}`] || this.cache['item_armor_body'];
    }
    if (item.type === 'food') {
      if (tid === 'ration') return this.cache['item_food_ration'] || this.cache['item_food'];
      if (tid === 'bread') return this.cache['item_food_bread'] || this.cache['item_food'];
      if (tid === 'grandFeast') return this.cache['item_food_feast'] || this.cache['item_food'];
      if (tid === 'cropTurnip') return this.cache['item_food_turnip'] || this.cache['item_food'];
      if (tid === 'cropPotato') return this.cache['item_food_potato'] || this.cache['item_food'];
      if (tid === 'cropStrawberry') return this.cache['item_food_strawberry'] || this.cache['item_food'];
      if (tid === 'cropCorn') return this.cache['item_food_corn'] || this.cache['item_food'];
      if (tid === 'cropTomato') return this.cache['item_food_tomato'] || this.cache['item_food'];
      if (tid === 'cropCarrot') return this.cache['item_food_carrot'] || this.cache['item_food'];
      if (tid === 'cropHerb') return this.cache['item_food_cropHerb'] || this.cache['item_food_herb'];
      if (tid === 'cropPumpkin') return this.cache['item_food_pumpkin'] || this.cache['item_food'];
      if (tid === 'cropWheat') return this.cache['item_food_wheat'] || this.cache['item_food'];
      if (tid === 'berryRed') return this.cache['item_food_berryRed'] || this.cache['item_food_berry'];
      if (tid === 'berryBlue') return this.cache['item_food_berryBlue'] || this.cache['item_food_berry'];
      if (tid === 'berryPoison') return this.cache['item_food_berryPoison'] || this.cache['item_food_berry'];
      if (tid === 'mushroomPoison') return this.cache['item_food_mushroomPoison'] || this.cache['item_food_mushroom'];
      if (tid === 'rareFish') return this.cache['item_food_rareFish'] || this.cache['item_food_fish'];
      if (tid && tid.includes('herb')) return this.cache['item_food_herb'];
      if (tid && (tid.includes('berry') || tid.includes('Berry'))) return this.cache['item_food_berry'];
      if (tid && (tid.includes('mushroom') || tid.includes('Mushroom'))) return this.cache['item_food_mushroom'];
      if (tid && (tid.includes('Fish') || tid.includes('fish'))) return this.cache['item_food_fish'];
      return this.cache['item_food'];
    }
    if (item.type === 'potion') {
      if (item.healMP) return this.cache['item_potion_mana'];
      return this.cache['item_potion_heal'];
    }
    if (item.type === 'resource') {
      // Specific ores
      if (tid === 'oreIron') return this.cache['item_resource_oreIron'] || this.cache['item_resource_ore'];
      if (tid === 'oreCopper') return this.cache['item_resource_oreCopper'] || this.cache['item_resource_ore'];
      if (tid === 'oreSilver') return this.cache['item_resource_oreSilver'] || this.cache['item_resource_ore'];
      if (tid === 'oreGold') return this.cache['item_resource_oreGold'] || this.cache['item_resource_ore'];
      if (tid === 'oreMythril') return this.cache['item_resource_oreMythril'] || this.cache['item_resource_ore'];
      // Specific logs
      if (tid === 'oakLog') return this.cache['item_resource_oakLog'] || this.cache['item_resource_wood'];
      if (tid === 'pineLog') return this.cache['item_resource_pineLog'] || this.cache['item_resource_wood'];
      if (tid === 'birchLog') return this.cache['item_resource_birchLog'] || this.cache['item_resource_wood'];
      if (tid === 'mapleLog') return this.cache['item_resource_mapleLog'] || this.cache['item_resource_wood'];
      if (tid === 'yewLog') return this.cache['item_resource_yewLog'] || this.cache['item_resource_wood'];
      if (tid === 'mushroomGlow') return this.cache['item_resource_glowMushroom'] || this.cache['item_food_mushroom'];
      // Generic resource matching
      if (tid && (tid.includes('ore') || tid.includes('Ore'))) return this.cache['item_resource_ore'];
      if (tid && (tid.includes('wood') || tid.includes('Wood') || tid.includes('Log') || tid.includes('log'))) return this.cache['item_resource_wood'];
      if (tid && tid.includes('leather')) return this.cache['item_resource_leather'];
      if (tid && tid.includes('string')) return this.cache['item_resource_string'];
      if (tid && (tid.includes('Bottle') || tid.includes('bottle'))) return this.cache['item_resource_bottle'];
      if (tid && tid.includes('crystal')) return this.cache['item_resource_crystal'];
      if (tid && tid.includes('clay')) return this.cache['item_resource_clay'];
      if (tid && tid === 'sand') return this.cache['item_resource_sand'];
      if (tid && tid.includes('flint')) return this.cache['item_resource_flint'];
      if (tid && tid.includes('reeds')) return this.cache['item_resource_reeds'];
      if (tid && tid.includes('bark')) return this.cache['item_resource_bark'];
      if (tid && tid.includes('sap')) return this.cache['item_resource_sap'];
      if (tid && tid.includes('amber')) return this.cache['item_resource_amber'];
      if (tid && tid.includes('pearl')) return this.cache['item_resource_pearl'];
      if (tid && tid.includes('driftwood')) return this.cache['item_resource_driftwood'];
      if (tid && tid.includes('Glow')) return this.cache['item_resource_glowMushroom'] || this.cache['item_food_mushroom'];
      return this.cache['item_resource_ore'];
    }
    if (item.type === 'tool') {
      if (tid === 'ironAxeTool') return this.cache['item_tool_ironAxe'] || this.cache['item_tool_axe'];
      if (tid === 'steelAxeTool') return this.cache['item_tool_steelAxe'] || this.cache['item_tool_axe'];
      if (tid === 'mythrilAxeTool') return this.cache['item_tool_mythrilAxe'] || this.cache['item_tool_axe'];
      if (tid === 'stonePickaxe') return this.cache['item_tool_stonePickaxe'] || this.cache['item_tool_pickaxe'];
      if (tid === 'ironPickaxe') return this.cache['item_tool_ironPickaxe'] || this.cache['item_tool_pickaxe'];
      if (tid === 'steelPickaxe') return this.cache['item_tool_steelPickaxe'] || this.cache['item_tool_pickaxe'];
      if (tid === 'mythrilPickaxe') return this.cache['item_tool_mythrilPickaxe'] || this.cache['item_tool_pickaxe'];
      if (item.subtype === 'axeTool') return this.cache['item_tool_axe'];
      if (item.subtype === 'pickaxe') return this.cache['item_tool_pickaxe'];
      return this.cache['item_tool_pickaxe'];
    }
    if (item.type === 'currency') return this.cache['item_gold'];
    if (item.type === 'seed') {
      const cropId = item.cropId || '';
      if (cropId === 'turnip') return this.cache['item_seed_turnip'] || this.cache['item_seed'];
      if (cropId === 'potato') return this.cache['item_seed_potato'] || this.cache['item_seed'];
      if (cropId === 'strawberry') return this.cache['item_seed_strawberry'] || this.cache['item_seed'];
      if (cropId === 'corn') return this.cache['item_seed_corn'] || this.cache['item_seed'];
      if (cropId === 'tomato') return this.cache['item_seed_tomato'] || this.cache['item_seed'];
      if (cropId === 'carrot') return this.cache['item_seed_carrot'] || this.cache['item_seed'];
      if (cropId === 'herb') return this.cache['item_seed_herb'] || this.cache['item_seed'];
      if (cropId === 'pumpkin') return this.cache['item_seed_pumpkin'] || this.cache['item_seed'];
      if (cropId === 'wheat') return this.cache['item_seed_wheat'] || this.cache['item_seed'];
      return this.cache['item_seed'];
    }
    if (item.type === 'spellbook') {
      const spellId = item.spellId || '';
      const key = `item_spellbook_${spellId}`;
      return this.cache[key] || this.cache['item_spellbook'];
    }
    if (item.type === 'scroll') {
      if (tid === 'scrollEnchant') return this.cache['item_scroll_enchantWeapon'] || this.cache['item_scroll'];
      if (tid === 'scrollEnchantArmor') return this.cache['item_scroll_enchantArmor'] || this.cache['item_scroll'];
      if (tid === 'scrollGreaterEnchant') return this.cache['item_scroll_greaterEnchant'] || this.cache['item_scroll'];
      if (tid === 'scrollSupremeEnchant') return this.cache['item_scroll_supremeEnchant'] || this.cache['item_scroll'];
      if (tid === 'scrollLightningEnchant') return this.cache['item_scroll_lightning'] || this.cache['item_scroll'];
      if (tid === 'scrollHolyEnchant') return this.cache['item_scroll_holy'] || this.cache['item_scroll'];
      if (tid === 'scrollSpeedEnchant') return this.cache['item_scroll_speed'] || this.cache['item_scroll'];
      if (item.enchantType === 'fire') return this.cache['item_scroll_fire'];
      if (item.enchantType === 'ice') return this.cache['item_scroll_ice'];
      return this.cache['item_scroll'];
    }
    if (item.type === 'light') {
      if (tid === 'torch') return this.cache['item_light_torch'];
      if (tid === 'lantern') return this.cache['item_light_lantern'];
      if (tid === 'magicLight') return this.cache['item_light_magicLight'];
      return this.cache['item_light_torch'] || this.cache['item_food'];
    }

    return this.cache['item_food']; // fallback
  }

  /**
   * Returns the cache key string for an item (same logic as getItem).
   * Used by the renderer to query grid size for multi-tile items.
   */
  _getItemKey(item) {
    if (!item) return null;
    const tid = item.templateId || item.id || '';
    if (item.type === 'weapon') {
      if (tid === 'brokenSword') return 'item_weapon_brokenSword';
      const sub = item.subtype || '';
      if (sub.includes('Sword') || sub.includes('longSword')) return 'item_weapon_longSword';
      if (sub.includes('shortSword')) return 'item_weapon_shortSword';
      if (sub.includes('axe')) return 'item_weapon_axe';
      if (sub.includes('bow')) return 'item_weapon_bow';
      if (sub.includes('staff')) return 'item_weapon_staff';
      if (sub.includes('mace')) return 'item_weapon_mace';
      return 'item_weapon_longSword';
    }
    if (item.type === 'armor') {
      if (tid === 'raggedCloth') return this.cache['item_armor_raggedCloth'] ? 'item_armor_raggedCloth' : 'item_armor_body';
      if (tid === 'chainMail') return this.cache['item_armor_chainMail'] ? 'item_armor_chainMail' : 'item_armor_body';
      const slot = item.slot || 'body';
      return this.cache[`item_armor_${slot}`] ? `item_armor_${slot}` : 'item_armor_body';
    }
    if (item.type === 'food') {
      if (tid === 'ration') return 'item_food_ration';
      if (tid === 'bread') return 'item_food_bread';
      if (tid === 'grandFeast') return 'item_food_feast';
      if (tid === 'cropTurnip') return 'item_food_turnip';
      if (tid === 'cropPotato') return 'item_food_potato';
      if (tid === 'cropStrawberry') return 'item_food_strawberry';
      if (tid === 'cropCorn') return 'item_food_corn';
      if (tid === 'cropTomato') return 'item_food_tomato';
      if (tid === 'cropCarrot') return 'item_food_carrot';
      if (tid === 'cropHerb') return 'item_food_cropHerb';
      if (tid === 'cropPumpkin') return 'item_food_pumpkin';
      if (tid === 'cropWheat') return 'item_food_wheat';
      if (tid === 'berryRed') return 'item_food_berryRed';
      if (tid === 'berryBlue') return 'item_food_berryBlue';
      if (tid === 'berryPoison') return 'item_food_berryPoison';
      if (tid === 'mushroomPoison') return 'item_food_mushroomPoison';
      if (tid === 'rareFish') return 'item_food_rareFish';
      if (tid && tid.includes('herb')) return 'item_food_herb';
      if (tid && (tid.includes('berry') || tid.includes('Berry'))) return 'item_food_berry';
      if (tid && (tid.includes('mushroom') || tid.includes('Mushroom'))) return 'item_food_mushroom';
      if (tid && (tid.includes('Fish') || tid.includes('fish'))) return 'item_food_fish';
      return 'item_food';
    }
    if (item.type === 'potion') {
      return item.healMP ? 'item_potion_mana' : 'item_potion_heal';
    }
    if (item.type === 'resource') {
      if (tid === 'oreIron') return 'item_resource_oreIron';
      if (tid === 'oreCopper') return 'item_resource_oreCopper';
      if (tid === 'oreSilver') return 'item_resource_oreSilver';
      if (tid === 'oreGold') return 'item_resource_oreGold';
      if (tid === 'oreMythril') return 'item_resource_oreMythril';
      if (tid === 'oakLog') return 'item_resource_oakLog';
      if (tid === 'pineLog') return 'item_resource_pineLog';
      if (tid === 'birchLog') return 'item_resource_birchLog';
      if (tid === 'mapleLog') return 'item_resource_mapleLog';
      if (tid === 'yewLog') return 'item_resource_yewLog';
      if (tid === 'mushroomGlow') return 'item_resource_glowMushroom';
      if (tid && (tid.includes('ore') || tid.includes('Ore'))) return 'item_resource_ore';
      if (tid && (tid.includes('wood') || tid.includes('Wood') || tid.includes('Log') || tid.includes('log'))) return 'item_resource_wood';
      if (tid && tid.includes('leather')) return 'item_resource_leather';
      if (tid && tid.includes('string')) return 'item_resource_string';
      if (tid && (tid.includes('Bottle') || tid.includes('bottle'))) return 'item_resource_bottle';
      if (tid && tid.includes('crystal')) return 'item_resource_crystal';
      if (tid && tid.includes('clay')) return 'item_resource_clay';
      if (tid && tid === 'sand') return 'item_resource_sand';
      if (tid && tid.includes('flint')) return 'item_resource_flint';
      if (tid && tid.includes('reeds')) return 'item_resource_reeds';
      if (tid && tid.includes('bark')) return 'item_resource_bark';
      if (tid && tid.includes('sap')) return 'item_resource_sap';
      if (tid && tid.includes('amber')) return 'item_resource_amber';
      if (tid && tid.includes('pearl')) return 'item_resource_pearl';
      if (tid && tid.includes('driftwood')) return 'item_resource_driftwood';
      if (tid && tid.includes('Glow')) return 'item_resource_glowMushroom';
      return 'item_resource_ore';
    }
    if (item.type === 'tool') {
      if (tid === 'ironAxeTool') return 'item_tool_ironAxe';
      if (tid === 'steelAxeTool') return 'item_tool_steelAxe';
      if (tid === 'mythrilAxeTool') return 'item_tool_mythrilAxe';
      if (tid === 'stonePickaxe') return 'item_tool_stonePickaxe';
      if (tid === 'ironPickaxe') return 'item_tool_ironPickaxe';
      if (tid === 'steelPickaxe') return 'item_tool_steelPickaxe';
      if (tid === 'mythrilPickaxe') return 'item_tool_mythrilPickaxe';
      if (item.subtype === 'axeTool') return 'item_tool_axe';
      if (item.subtype === 'pickaxe') return 'item_tool_pickaxe';
      return 'item_tool_pickaxe';
    }
    if (item.type === 'currency') return 'item_gold';
    if (item.type === 'seed') {
      const cropId = item.cropId || '';
      if (cropId) return `item_seed_${cropId}`;
      return 'item_seed';
    }
    if (item.type === 'spellbook') {
      const spellId = item.spellId || '';
      return spellId ? `item_spellbook_${spellId}` : 'item_spellbook';
    }
    if (item.type === 'scroll') {
      if (tid === 'scrollEnchant') return 'item_scroll_enchantWeapon';
      if (tid === 'scrollEnchantArmor') return 'item_scroll_enchantArmor';
      if (tid === 'scrollGreaterEnchant') return 'item_scroll_greaterEnchant';
      if (tid === 'scrollSupremeEnchant') return 'item_scroll_supremeEnchant';
      if (tid === 'scrollLightningEnchant') return 'item_scroll_lightning';
      if (tid === 'scrollHolyEnchant') return 'item_scroll_holy';
      if (tid === 'scrollSpeedEnchant') return 'item_scroll_speed';
      if (item.enchantType === 'fire') return 'item_scroll_fire';
      if (item.enchantType === 'ice') return 'item_scroll_ice';
      return 'item_scroll';
    }
    if (item.type === 'light') {
      if (tid === 'torch') return 'item_light_torch';
      if (tid === 'lantern') return 'item_light_lantern';
      if (tid === 'magicLight') return 'item_light_magicLight';
      return 'item_light_torch';
    }
    return 'item_food';
  }

  /** Get a data-URI string for an item sprite (used by UI inventory) */
  getItemSpriteURL(item) {
    const img = this.getItem(item);
    return img ? img.src : null;
  }

  /** Get crop tile for a specific crop at a growth stage */
  getCrop(cropId, stage) {
    return this.cache[`crop_${cropId}_${stage}`] || this.cache[`crop_stage_${stage}`] || null;
  }

  // â”€â”€ SVG helpers (shared by all tile files) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  svgToImage(svgStr) {
    const img = new Image();
    img.src = 'data:image/svg+xml;base64,' + btoa(svgStr);
    return img;
  }

  wrap(inner, bg) {
    const s = this.tileSize;
    return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
      ${bg ? `<rect width="${s}" height="${s}" fill="${bg}"/>` : ''}
      ${inner}
    </svg>`;
  }

  // â”€â”€ Registration system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Register a tile generator function.
   * Each tile file calls this at load time.
   * @param {string}   category - e.g. 'terrain', 'biome', 'monster'
   * @param {function} generatorFn - function(manager) that populates manager.cache
   */
  static register(category, generatorFn) {
    if (!SVGTileManager._registry) SVGTileManager._registry = [];
    SVGTileManager._registry.push({ category, generatorFn });
  }

  /** Run every registered generator to populate the cache */
  _applyRegistered() {
    if (!SVGTileManager._registry) return;
    for (const { generatorFn } of SVGTileManager._registry) {
      generatorFn(this);
    }
  }
}

// Static registry â€” filled before constructor runs
SVGTileManager._registry = [];

</script>
  <script>
// ============================================================
// Terrain Tiles â€” floor, wall, grass, water, tree, door, etc.
// Multiple variants per tile type for visual variety.
// Linked to: data/tiles.json (tile properties like walkable, transparent)
// ============================================================

SVGTileManager.register('terrain', (mgr) => {
  const s = mgr.tileSize;

  // â”€â”€ Helper: tiny seededâ€random decorations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function dot(cx, cy, r, fill, opacity) {
    return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" opacity="${opacity || 1}"/>`;
  }
  function blade(x1, y1, x2, y2, stroke, sw) {
    return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="${sw || 1.5}" stroke-linecap="round"/>`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FLOOR â€” stone tile variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_floor', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/2-2}" fill="#404050" rx="1"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/2-2}" fill="#383848" rx="1"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#383848" rx="1"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#404050" rx="1"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#383848"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/2-2}" fill="#3c3c4c" rx="1"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/2-2}" fill="#424252" rx="1"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#424252" rx="1"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#3c3c4c" rx="1"/>
      ${dot(6, 6, 1, '#4a4a5a', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c3c4c"/>
      <rect x="1" y="1" width="${s/3-1}" height="${s/2-2}" fill="#424252" rx="1"/>
      <rect x="${s/3+1}" y="1" width="${s/3-1}" height="${s/2-2}" fill="#3a3a4a" rx="1"/>
      <rect x="${s*2/3+1}" y="1" width="${s/3-2}" height="${s/2-2}" fill="#404050" rx="1"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#3e3e4e" rx="1"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#444454" rx="1"/>
      ${dot(20, 22, 0.8, '#4e4e5e', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3b3b4b"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/3-1}" fill="#414151" rx="1"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/3-1}" fill="#393949" rx="1"/>
      <rect x="1" y="${s/3+1}" width="${s/3-1}" height="${s/3-1}" fill="#3d3d4d" rx="1"/>
      <rect x="${s/3+1}" y="${s/3+1}" width="${s*2/3-2}" height="${s/3-1}" fill="#434353" rx="1"/>
      <rect x="1" y="${s*2/3+1}" width="${s-2}" height="${s/3-2}" fill="#404050" rx="1"/>
      ${dot(24, 8, 0.6, '#505060', 0.3)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WALL â€” stone brick variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_wall', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#666677"/>
      <rect x="0" y="0" width="${s}" height="${s/2-1}" fill="#707080" rx="2"/>
      <rect x="${s/3}" y="${s/2+1}" width="${s*2/3}" height="${s/2-2}" fill="#606070" rx="2"/>
      <rect x="0" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#585868" rx="2"/>
      <line x1="0" y1="${s/2}" x2="${s}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s/3}" y1="0" x2="${s/3}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s*2/3}" y1="0" x2="${s*2/3}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#626272"/>
      <rect x="0" y="0" width="${s/2-1}" height="${s/2-1}" fill="#6c6c7c" rx="2"/>
      <rect x="${s/2+1}" y="0" width="${s/2-1}" height="${s/2-1}" fill="#727282" rx="2"/>
      <rect x="0" y="${s/2+1}" width="${s}" height="${s/2-2}" fill="#5e5e6e" rx="2"/>
      <line x1="0" y1="${s/2}" x2="${s}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s/2}" y1="0" x2="${s/2}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      ${dot(8, 20, 1, '#757585', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#686878"/>
      <rect x="0" y="0" width="${s*2/3}" height="${s/2-1}" fill="#747484" rx="2"/>
      <rect x="${s*2/3+1}" y="0" width="${s/3-1}" height="${s/2-1}" fill="#6a6a7a" rx="2"/>
      <rect x="0" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#606070" rx="2"/>
      <rect x="${s/3}" y="${s/2+1}" width="${s*2/3}" height="${s/2-2}" fill="#6e6e7e" rx="2"/>
      <line x1="0" y1="${s/2}" x2="${s}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s*2/3}" y1="0" x2="${s*2/3}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s/3}" y1="${s/2}" x2="${s/3}" y2="${s}" stroke="#55556a" stroke-width="1"/>
      ${dot(4, 4, 0.8, '#50506a', 0.25)}
      ${dot(26, 24, 0.6, '#7a7a8a', 0.2)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GRASS â€” lush ground with varied blades & flowers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_grass', [
    // Variant 0 â€” standard blades
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(4, s, 6, s-8, '#5a9a3a')}
      ${blade(12, s, 10, s-7, '#4a8a2e')}
      ${blade(20, s, 22, s-9, '#5a9a3a')}
      ${blade(28, s, 26, s-6, '#4a8a2e')}
      ${blade(8, s-4, 9, s-10, '#6aaa44', 1)}
      ${blade(24, s-2, 23, s-9, '#6aaa44', 1)}
      ${dot(16, s-3, 1, '#4a7a2c')}
      ${dot(7, s-2, 0.8, '#5a8a3a')}
    `)),
    // Variant 1 â€” short dense grass
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c6c2a"/>
      ${blade(3, s, 4, s-5, '#5a9838')}
      ${blade(8, s, 7, s-6, '#4e8e30')}
      ${blade(13, s, 14, s-5, '#58962e')}
      ${blade(18, s, 17, s-7, '#529232')}
      ${blade(23, s, 24, s-5, '#5a9838')}
      ${blade(28, s, 27, s-6, '#4e8e30')}
      ${dot(6, s-8, 0.6, '#6aaa44', 0.5)}
      ${dot(20, s-9, 0.7, '#68a642', 0.5)}
      ${dot(10, s-4, 1, '#3a6228', 0.4)}
    `)),
    // Variant 2 â€” sparse with pebbles
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#396826"/>
      ${blade(5, s, 7, s-9, '#5a9a3a')}
      ${blade(22, s, 20, s-8, '#4a8a2e')}
      ${blade(15, s-3, 16, s-10, '#6aaa44', 1)}
      ${dot(10, s-4, 1.5, '#7a7a6a', 0.35)}
      ${dot(26, s-6, 1, '#8a8a7a', 0.3)}
      ${dot(4, s-2, 0.8, '#3e6e2a', 0.6)}
      ${dot(18, s-2, 0.6, '#3e6e2a', 0.5)}
    `)),
    // Variant 3 â€” with tiny yellow wildflower
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3b6b29"/>
      ${blade(4, s, 5, s-7, '#5a9a3a')}
      ${blade(10, s, 9, s-8, '#4a8a2e')}
      ${blade(20, s, 22, s-7, '#5a9a3a')}
      ${blade(27, s, 26, s-9, '#4e8e30')}
      ${blade(15, s-2, 15, s-12, '#509030', 1)}
      ${dot(15, s-13, 2, '#e8d44a', 0.85)}
      ${dot(15, s-13, 1, '#f0e060', 0.9)}
      ${dot(8, s-3, 0.7, '#4a7a2c')}
    `)),
    // Variant 4 â€” tall wispy grass
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#386826"/>
      ${blade(3, s, 5, s-12, '#5ea03c', 1.2)}
      ${blade(10, s, 8, s-11, '#4c8c2e', 1.2)}
      ${blade(17, s, 19, s-13, '#5ea03c', 1.2)}
      ${blade(24, s, 22, s-10, '#4c8c2e', 1.2)}
      ${blade(7, s-2, 6, s-8, '#6ab046', 0.8)}
      ${blade(21, s-1, 20, s-7, '#6ab046', 0.8)}
      ${dot(14, s-3, 0.6, '#3a6228', 0.4)}
      ${dot(28, s-5, 0.5, '#3a6228', 0.3)}
    `)),
    // Variant 5 â€” clover patch
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(5, s, 6, s-6, '#4a8a2e')}
      ${blade(25, s, 24, s-7, '#4a8a2e')}
      ${dot(10, s-8, 3, '#48883a', 0.5)}
      ${dot(12, s-10, 2.5, '#509040', 0.5)}
      ${dot(8, s-9, 2.5, '#449036', 0.45)}
      ${dot(18, s-6, 2, '#4a8a3a', 0.4)}
      ${dot(16, s-4, 0.8, '#3a6228')}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WATER â€” animated wave patterns
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_water', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a8a"/>
      <path d="M0,${s/3} Q${s/4},${s/3-4} ${s/2},${s/3} Q${s*3/4},${s/3+4} ${s},${s/3}" stroke="#3a7acc" stroke-width="2" fill="none" opacity="0.7"/>
      <path d="M0,${s*2/3} Q${s/4},${s*2/3-4} ${s/2},${s*2/3} Q${s*3/4},${s*2/3+4} ${s},${s*2/3}" stroke="#3a7acc" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M${-s/4},${s/2} Q0,${s/2-3} ${s/4},${s/2} Q${s/2},${s/2+3} ${s*3/4},${s/2}" stroke="#5a9aee" stroke-width="1" fill="none" opacity="0.4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1c4c8c"/>
      <path d="M0,8 Q10,4 20,8 Q30,12 ${s},8" stroke="#3878c8" stroke-width="1.8" fill="none" opacity="0.6"/>
      <path d="M0,18 Q8,14 16,18 Q24,22 ${s},18" stroke="#4a88d8" stroke-width="1.5" fill="none" opacity="0.5"/>
      <path d="M0,26 Q12,22 ${s},26" stroke="#5a9aee" stroke-width="1" fill="none" opacity="0.35"/>
      ${dot(8, 14, 1, '#5a9aee', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#184888"/>
      <path d="M0,6 Q6,2 12,6 Q18,10 24,6 Q30,2 ${s},6" stroke="#3a7acc" stroke-width="1.5" fill="none" opacity="0.65"/>
      <path d="M0,16 Q10,12 20,16 Q30,20 ${s},16" stroke="#4888cc" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M0,24 Q8,20 16,24 Q24,28 ${s},24" stroke="#3a7acc" stroke-width="1.5" fill="none" opacity="0.4"/>
      ${dot(22, 10, 1.2, '#6aadff', 0.25)}
      ${dot(6, 22, 0.8, '#6aadff', 0.2)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1e4e8e"/>
      <path d="M0,10 Q16,6 ${s},10" stroke="#4080cc" stroke-width="2" fill="none" opacity="0.55"/>
      <path d="M0,20 Q8,16 16,20 Q24,24 ${s},20" stroke="#3a78c8" stroke-width="1.8" fill="none" opacity="0.5"/>
      ${dot(14, 6, 1.5, '#5a9aee', 0.2)}
      ${dot(4, 28, 1, '#5a9aee', 0.15)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TREE â€” different tree shapes & tones
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_tree', [
    // Variant 0 â€” round canopy (original improved)
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#2d7a1e"/>
      <circle cx="${s/2-4}" cy="${s/3+4}" r="${s/4}" fill="#3a8a2a"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4}" fill="#258a18"/>
      <circle cx="${s/2}" cy="${s/4}" r="${s/5}" fill="#4a9a3a"/>
    `)),
    // Variant 1 â€” bushy wider canopy
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+4}" width="4" height="${s/2-4}" fill="#5e3e22" rx="1"/>
      <ellipse cx="${s/2}" cy="${s/3+3}" rx="${s/2.5}" ry="${s/3.5}" fill="#307820"/>
      <circle cx="${s/2-5}" cy="${s/3+1}" r="${s/5}" fill="#3c8c2c"/>
      <circle cx="${s/2+5}" cy="${s/3+2}" r="${s/5}" fill="#288a1a"/>
      <circle cx="${s/2}" cy="${s/5}" r="${s/6}" fill="#48983a"/>
      <circle cx="${s/2+2}" cy="${s/3+5}" r="${s/7}" fill="#226e16"/>
    `)),
    // Variant 2 â€” conifer / pine
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},2 ${s/2+10},${s/3+2} ${s/2-10},${s/3+2}" fill="#1e6e14"/>
      <polygon points="${s/2},${s/6} ${s/2+12},${s/2+2} ${s/2-12},${s/2+2}" fill="#267818"/>
      <polygon points="${s/2},${s/3} ${s/2+13},${s*2/3} ${s/2-13},${s*2/3}" fill="#2d7a1e"/>
      ${dot(s/2, 4, 1.2, '#4a9a3a', 0.7)}
    `)),
    // Variant 3 â€” small young tree
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-1}" y="${s/2}" width="2" height="${s/2}" fill="#6a4a2a" rx="0.5"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/4}" fill="#348a24"/>
      <circle cx="${s/2-3}" cy="${s/3+4}" r="${s/5}" fill="#3e9430"/>
      <circle cx="${s/2+3}" cy="${s/3+1}" r="${s/5}" fill="#2c7e1c"/>
      ${dot(s/2, s/4, 2, '#4ca03c', 0.6)}
    `)),
    // Variant 4 â€” autumn-tinted tree
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#3a8a2a"/>
      <circle cx="${s/2-4}" cy="${s/3+3}" r="${s/4.5}" fill="#5a9a3a"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4.5}" fill="#328228"/>
      <circle cx="${s/2+1}" cy="${s/5}" r="${s/6}" fill="#4a9a3a"/>
      ${dot(s/2-6, s/4+2, 1.5, '#8ab040', 0.5)}
      ${dot(s/2+5, s/5, 1.2, '#7aa838', 0.4)}
    `)),
    // Variant 5 â€” dark evergreen
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+3}" width="4" height="${s/2-3}" fill="#4a3018" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+1}" r="${s/3+1}" fill="#1a5e10"/>
      <circle cx="${s/2-3}" cy="${s/3+4}" r="${s/4}" fill="#226a16"/>
      <circle cx="${s/2+3}" cy="${s/3-1}" r="${s/4}" fill="#1a5e10"/>
      <circle cx="${s/2}" cy="${s/5-1}" r="${s/5}" fill="#2a7018"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DOOR â€” wooden door variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_door'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="4" y="2" width="${s-8}" height="${s-4}" fill="#8a6030" rx="3"/>
    <rect x="6" y="4" width="${s-12}" height="${s/2-4}" fill="#a57838" rx="2"/>
    <rect x="6" y="${s/2+2}" width="${s-12}" height="${s/2-6}" fill="#9a6830" rx="2"/>
    <circle cx="${s-10}" cy="${s/2}" r="2" fill="#d4a840"/>
    <line x1="4" y1="${s/2}" x2="${s-4}" y2="${s/2}" stroke="#704820" stroke-width="1"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STAIRS DOWN
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_stairsDown'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="4" y="4" width="${s-8}" height="5" fill="#888" rx="1"/>
    <rect x="7" y="11" width="${s-14}" height="5" fill="#777" rx="1"/>
    <rect x="10" y="18" width="${s-20}" height="5" fill="#666" rx="1"/>
    <polygon points="${s/2-3},${s-6} ${s/2+3},${s-6} ${s/2},${s-2}" fill="#ff0" opacity="0.8"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STAIRS UP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_stairsUp'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="10" y="4" width="${s-20}" height="5" fill="#888" rx="1"/>
    <rect x="7" y="11" width="${s-14}" height="5" fill="#777" rx="1"/>
    <rect x="4" y="18" width="${s-8}" height="5" fill="#666" rx="1"/>
    <polygon points="${s/2-3},8 ${s/2+3},8 ${s/2},3" fill="#0f0" opacity="0.8"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROAD â€” packed dirt with tracks (variants)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_road', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a89868"/>
      <rect x="0" y="${s/3}" width="${s}" height="2" fill="#988858" opacity="0.5"/>
      <rect x="0" y="${s*2/3}" width="${s}" height="2" fill="#988858" opacity="0.5"/>
      ${dot(5, 8, 1, '#b8a878', 0.5)}
      ${dot(20, 20, 1.5, '#b8a878', 0.5)}
      ${dot(14, 14, 1, '#c8b888', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a69466"/>
      <rect x="0" y="${s/4}" width="${s}" height="2" fill="#968454" opacity="0.4"/>
      <rect x="0" y="${s*3/4}" width="${s}" height="2" fill="#968454" opacity="0.4"/>
      ${dot(8, 6, 1.2, '#b8a878', 0.4)}
      ${dot(24, 16, 1, '#c0b080', 0.35)}
      ${dot(12, 26, 1.5, '#b0a070', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#aa9a6a"/>
      <rect x="0" y="${s/3+2}" width="${s}" height="1.5" fill="#9a8a5a" opacity="0.45"/>
      <rect x="0" y="${s*2/3-1}" width="${s}" height="1.5" fill="#9a8a5a" opacity="0.45"/>
      ${dot(3, 12, 0.8, '#bca880', 0.5)}
      ${dot(18, 8, 1.3, '#bca880', 0.4)}
      ${dot(26, 24, 1, '#c4b48c', 0.35)}
      ${dot(10, 22, 0.6, '#a09060', 0.3)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROCK â€” boulder variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_rock', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#777"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#888"/>
      <ellipse cx="${s/2-3}" cy="${s/2-2}" rx="${s/5}" ry="${s/6}" fill="#999" opacity="0.5"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#386828"/>
      <ellipse cx="${s/2+2}" cy="${s/2+3}" rx="${s/3+2}" ry="${s/4+1}" fill="#6e6e6e"/>
      <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/3}" ry="${s/4-1}" fill="#808080"/>
      <ellipse cx="${s/2+3}" cy="${s/2-1}" rx="${s/6}" ry="${s/7}" fill="#929292" opacity="0.45"/>
      ${dot(s/2-6, s/2+5, 1, '#666', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c6c2a"/>
      <ellipse cx="${s/2-3}" cy="${s/2+1}" rx="${s/4}" ry="${s/5}" fill="#747474"/>
      <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="${s/4-1}" ry="${s/5-1}" fill="#6a6a6a"/>
      <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/5}" ry="${s/6}" fill="#8a8a8a" opacity="0.4"/>
      <ellipse cx="${s/2+5}" cy="${s/2+1}" rx="${s/7}" ry="${s/8}" fill="#929292" opacity="0.35"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORE â€” sparkling rock variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_ore', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#666"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#777"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#daa520"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#c8a020"/>
      ${dot(s/2-2, s/2+4, 1.5, '#eab830', 0.8)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c3c4c"/>
      <ellipse cx="${s/2+1}" cy="${s/2+1}" rx="${s/3}" ry="${s/4}" fill="#606060"/>
      <ellipse cx="${s/2-1}" cy="${s/2-1}" rx="${s/3-2}" ry="${s/4-1}" fill="#727272"/>
      <polygon points="${s/2+2},${s/3+2} ${s/2+5},${s/3-2} ${s/2+7},${s/3+3}" fill="#d4a018"/>
      <polygon points="${s/2-5},${s/2+1} ${s/2-2},${s/2-2} ${s/2-1},${s/2+2}" fill="#ccaa20"/>
      ${dot(s/2+4, s/2+5, 1, '#e0b828', 0.7)}
      ${dot(s/2-3, s/3+5, 1.2, '#d8b020', 0.6)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SHRINE â€” stone altar
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_shrine'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="${s/2-6}" y="${s/2}" width="12" height="${s/2-2}" fill="#888" rx="1"/>
    <rect x="${s/2-8}" y="${s/2-2}" width="16" height="4" fill="#999" rx="1"/>
    <line x1="${s/2}" y1="4" x2="${s/2}" y2="${s/2-2}" stroke="#d0d050" stroke-width="2"/>
    <line x1="${s/2-5}" y1="${s/4}" x2="${s/2+5}" y2="${s/4}" stroke="#d0d050" stroke-width="2"/>
    <circle cx="${s/2}" cy="${s/4-2}" r="2" fill="#ff0" opacity="0.6"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CHEST â€” treasure box
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_chest'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="6" y="${s/3}" width="${s-12}" height="${s/2}" fill="#8a6020" rx="3"/>
    <rect x="6" y="${s/3}" width="${s-12}" height="${s/4}" fill="#a87828" rx="3"/>
    <rect x="${s/2-3}" y="${s/3+s/4-3}" width="6" height="6" fill="#daa520" rx="1"/>
    <line x1="6" y1="${s/3+s/4}" x2="${s-6}" y2="${s/3+s/4}" stroke="#704818" stroke-width="1"/>
    <rect x="8" y="${s/3+2}" width="4" height="3" fill="#c89830" rx="1" opacity="0.5"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRAP â€” hidden spikes
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_trap'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <polygon points="8,${s-6} 10,8 12,${s-6}" fill="#cc3333" opacity="0.8"/>
    <polygon points="14,${s-6} 16,6 18,${s-6}" fill="#cc3333" opacity="0.9"/>
    <polygon points="20,${s-6} 22,8 24,${s-6}" fill="#cc3333" opacity="0.8"/>
    <line x1="4" y1="${s-6}" x2="${s-4}" y2="${s-6}" stroke="#993333" stroke-width="1"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TOWN TILE â€” cobblestone variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_townTile', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#8a7a5a"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/3-1}" fill="#9a8a6a" rx="2"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/3-1}" fill="#8a7a5a" rx="2"/>
      <rect x="3" y="${s/3+1}" width="${s/3}" height="${s/3-1}" fill="#8a7a5a" rx="2"/>
      <rect x="${s/3+4}" y="${s/3+1}" width="${s/3}" height="${s/3-1}" fill="#9a8a6a" rx="2"/>
      <rect x="1" y="${s*2/3+1}" width="${s/2-2}" height="${s/3-2}" fill="#9a8a6a" rx="2"/>
      <rect x="${s/2+1}" y="${s*2/3+1}" width="${s/2-2}" height="${s/3-2}" fill="#8a7a5a" rx="2"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#887858"/>
      <rect x="1" y="1" width="${s/3-1}" height="${s/2-2}" fill="#968862" rx="2"/>
      <rect x="${s/3+1}" y="1" width="${s/3-1}" height="${s/2-2}" fill="#8c7c5c" rx="2"/>
      <rect x="${s*2/3+1}" y="1" width="${s/3-2}" height="${s/2-2}" fill="#928460" rx="2"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#8c7c5c" rx="2"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#968862" rx="2"/>
      ${dot(10, 14, 0.5, '#a09270', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#8c7c5c"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/2-2}" fill="#96886a" rx="2"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/2-2}" fill="#887858" rx="2"/>
      <rect x="1" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#8a7a5a" rx="2"/>
      <rect x="${s/3+1}" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#948664" rx="2"/>
      <rect x="${s*2/3+1}" y="${s/2+1}" width="${s/3-2}" height="${s/2-2}" fill="#8a7a5a" rx="2"/>
      ${dot(22, 8, 0.6, '#a09270', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FARM SOIL â€” tilled earth variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_farmSoil', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5a4030"/>
      <line x1="0" y1="5" x2="${s}" y2="5" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="11" x2="${s}" y2="11" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="17" x2="${s}" y2="17" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="23" x2="${s}" y2="23" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="29" x2="${s}" y2="29" stroke="#4a3020" stroke-width="2"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#584030"/>
      <line x1="0" y1="6" x2="${s}" y2="6" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="12" x2="${s}" y2="12" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="18" x2="${s}" y2="18" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="24" x2="${s}" y2="24" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="30" x2="${s}" y2="30" stroke="#4c3222" stroke-width="1.8"/>
      ${dot(8, 9, 0.8, '#6a5040', 0.3)}
      ${dot(22, 21, 0.7, '#6a5040', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HERB PATCH â€” harvestable herb cluster on grass
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_herbPatch', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(6, s-2, 4, 10, '#2a9a2a', 2)}
      ${blade(10, s-2, 12, 8, '#3aaa3a', 2)}
      ${blade(16, s-2, 14, 9, '#2aaa2a', 1.8)}
      ${blade(22, s-2, 24, 11, '#3a9a3a', 2)}
      ${blade(26, s-2, 25, 7, '#2aaa2a', 1.5)}
      ${dot(5, 8, 2, '#4aee4a', 0.6)}
      ${dot(13, 7, 2.5, '#3add3a', 0.7)}
      ${dot(23, 9, 2, '#4aee4a', 0.5)}
      ${dot(9, 14, 1.5, '#6f6', 0.5)}
      <circle cx="${s/2-2}" cy="${s-6}" r="2" fill="#5e5" opacity="0.6"/>
      <circle cx="${s/2+1}" cy="${s-7}" r="1.8" fill="#5e5" opacity="0.5"/>
      <circle cx="${s/2}" cy="${s-9}" r="1.5" fill="#6f6" opacity="0.5"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(8, s-2, 6, 11, '#3aaa3a', 2)}
      ${blade(14, s-2, 16, 7, '#2a9a2a', 2.2)}
      ${blade(20, s-2, 18, 10, '#3aaa3a', 1.8)}
      ${blade(25, s-2, 26, 9, '#2aaa2a', 1.5)}
      ${dot(7, 10, 2.5, '#3add3a', 0.65)}
      ${dot(17, 8, 2, '#4aee4a', 0.55)}
      ${dot(24, 11, 1.8, '#6f6', 0.5)}
      <circle cx="12" cy="6" r="1.5" fill="#ff8" opacity="0.4"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FISHING SPOT â€” shimmering water with fish ripples
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_fishingSpot', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a8a"/>
      <ellipse cx="${s/2}" cy="${s/3}" rx="10" ry="4" fill="#2a6acc" opacity="0.3"/>
      <ellipse cx="${s/2}" cy="${s*2/3}" rx="8" ry="3" fill="#2a6acc" opacity="0.25"/>
      <path d="M10,${s/2} Q14,${s/2-3} 18,${s/2}" stroke="#4a8aee" stroke-width="1" fill="none" opacity="0.5"/>
      <path d="M18,${s/2+4} Q22,${s/2+1} 26,${s/2+4}" stroke="#4a8aee" stroke-width="1" fill="none" opacity="0.4"/>
      ${dot(s/2, s/2-1, 1.5, '#6af', 0.6)}
      ${dot(s/2+5, s/2+3, 1, '#8cf', 0.4)}
      <path d="M${s/2-6},${s-6} Q${s/2-3},${s-9} ${s/2},${s-6}" stroke="#8cf" stroke-width="1" fill="none" opacity="0.5"/>
      <path d="M${s/2},${s-6} Q${s/2+3},${s-9} ${s/2+6},${s-6}" stroke="#8cf" stroke-width="1" fill="none" opacity="0.4"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STUMP â€” depleted tree, walkable
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_stump', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+6}" rx="6" ry="3" fill="#5a4a2a"/>
      <rect x="${s/2-5}" y="${s/2-2}" width="10" height="8" fill="#6a5a3a" rx="2"/>
      <ellipse cx="${s/2}" cy="${s/2-2}" rx="5" ry="3" fill="#7a6a4a"/>
      <circle cx="${s/2}" cy="${s/2-2}" r="2" fill="#5a4a2a" opacity="0.5"/>
      ${dot(s/2-2, s/2-1, 0.5, '#8a7a5a', 0.4)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORE VEIN â€” identical to 'ore' but explicitly named
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_oreVein', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#666677"/>
      <rect x="2" y="2" width="${s-4}" height="${s-4}" fill="#555566" rx="3"/>
      <polygon points="8,8 14,4 18,10 12,14" fill="#c8a020" opacity="0.9"/>
      <polygon points="18,16 24,12 26,20 20,22" fill="#dab030" opacity="0.8"/>
      <polygon points="6,20 10,18 12,24 8,25" fill="#b89020" opacity="0.7"/>
      ${dot(16, 8, 1.5, '#ffe060', 0.5)}
      ${dot(22, 18, 1, '#ffe060', 0.4)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TREE VARIANTS â€” Oak, Pine, Birch, Maple, Yew
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Oak Tree â€” broad canopy, sturdy trunk, warm green
  mgr.addVariants('tile_oakTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2.5}" y="${s/2+2}" width="5" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3+1}" fill="#3a7a20"/>
      <circle cx="${s/2-5}" cy="${s/3+4}" r="${s/4}" fill="#4a8a2a"/>
      <circle cx="${s/2+5}" cy="${s/3}" r="${s/4}" fill="#358a18"/>
      <circle cx="${s/2}" cy="${s/4}" r="${s/5}" fill="#5a9a3a"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+3}" width="4" height="${s/2-3}" fill="#5e3e22" rx="1"/>
      <ellipse cx="${s/2}" cy="${s/3+3}" rx="${s/2.5}" ry="${s/3.5}" fill="#3a7820"/>
      <circle cx="${s/2-5}" cy="${s/3+1}" r="${s/5}" fill="#4c8c2c"/>
      <circle cx="${s/2+5}" cy="${s/3+2}" r="${s/5}" fill="#388a1a"/>
      <circle cx="${s/2+1}" cy="${s/5}" r="${s/6}" fill="#58983a"/>
    `)),
  ]);

  // Pine Tree â€” conical shape, dark green, tall
  mgr.addVariants('tile_pineTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a18"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},2 ${s/2+10},${s/3+2} ${s/2-10},${s/3+2}" fill="#1a5e10"/>
      <polygon points="${s/2},${s/6} ${s/2+12},${s/2+2} ${s/2-12},${s/2+2}" fill="#1e6818"/>
      <polygon points="${s/2},${s/3} ${s/2+13},${s*2/3} ${s/2-13},${s*2/3}" fill="#227018"/>
      ${dot(s/2, 4, 1.2, '#3a8a2a', 0.7)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a18"/>
      <rect x="${s/2-1.5}" y="${s*2/3+2}" width="3" height="${s/3-2}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},3 ${s/2+9},${s/3+1} ${s/2-9},${s/3+1}" fill="#1c6012"/>
      <polygon points="${s/2},${s/6+1} ${s/2+11},${s/2+1} ${s/2-11},${s/2+1}" fill="#206a16"/>
      <polygon points="${s/2},${s/3+1} ${s/2+12},${s*2/3+1} ${s/2-12},${s*2/3+1}" fill="#247218"/>
    `)),
  ]);

  // Birch Tree â€” white trunk, lighter canopy
  mgr.addVariants('tile_birchTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a2a"/>
      <rect x="${s/2-2}" y="${s/2+1}" width="4" height="${s/2-1}" fill="#d8d0c0" rx="1"/>
      <line x1="${s/2-1}" y1="${s/2+4}" x2="${s/2+1}" y2="${s/2+4}" stroke="#8a8070" stroke-width="0.8"/>
      <line x1="${s/2-1}" y1="${s/2+8}" x2="${s/2+1}" y2="${s/2+8}" stroke="#8a8070" stroke-width="0.8"/>
      <line x1="${s/2}" y1="${s/2+12}" x2="${s/2+1}" y2="${s/2+12}" stroke="#8a8070" stroke-width="0.6"/>
      <circle cx="${s/2}" cy="${s/3+1}" r="${s/3}" fill="#6aaa5a"/>
      <circle cx="${s/2-4}" cy="${s/3+3}" r="${s/4.5}" fill="#7aba6a"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4.5}" fill="#5aa04a"/>
      <circle cx="${s/2}" cy="${s/5}" r="${s/6}" fill="#8aca7a"/>
    `)),
  ]);

  // Maple Tree â€” reddish-orange canopy
  mgr.addVariants('tile_mapleTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#aa4422"/>
      <circle cx="${s/2-5}" cy="${s/3+3}" r="${s/4.5}" fill="#cc5533"/>
      <circle cx="${s/2+5}" cy="${s/3}" r="${s/4.5}" fill="#bb3a1a"/>
      <circle cx="${s/2}" cy="${s/5}" r="${s/6}" fill="#dd6644"/>
      ${dot(s/2-3, s/3+5, 1.5, '#ee7755', 0.4)}
      ${dot(s/2+3, s/4, 1.2, '#ff8866', 0.3)}
    `)),
  ]);

  // Yew Tree â€” very dark, ancient-looking
  mgr.addVariants('tile_yewTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a3a14"/>
      <rect x="${s/2-3}" y="${s/2+1}" width="6" height="${s/2-1}" fill="#3a2a10" rx="2"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3+2}" fill="#1a3010"/>
      <circle cx="${s/2-4}" cy="${s/3+4}" r="${s/4}" fill="#223a16"/>
      <circle cx="${s/2+4}" cy="${s/3-1}" r="${s/4}" fill="#1a3010"/>
      <circle cx="${s/2}" cy="${s/5-2}" r="${s/5}" fill="#2a4018"/>
      ${dot(s/2-6, s/3+2, 1, '#3a5028', 0.4)}
      ${dot(s/2+6, s/3, 1.2, '#3a5028', 0.35)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORE VARIANTS â€” Copper, Iron, Silver, Gold, Mythril
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Copper Ore â€” orange-brown metallic specks
  mgr.addVariants('tile_copperOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#666"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#777"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#b87333"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#a06628"/>
      ${dot(s/2-2, s/2+4, 1.5, '#cc8840', 0.8)}
      ${dot(s/2+4, s/3+2, 1, '#d09050', 0.6)}
    `)),
  ]);

  // Iron Ore â€” grey metallic veins
  mgr.addVariants('tile_ironOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#606060"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#727272"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#8a8a8a"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#9a9a9a"/>
      ${dot(s/2-2, s/2+4, 1.5, '#aaaaaa', 0.7)}
      ${dot(s/2+4, s/3+2, 1, '#b0b0b0', 0.5)}
    `)),
  ]);

  // Silver Ore â€” bright silvery sparkles
  mgr.addVariants('tile_silverOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c3c50"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#606068"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#727280"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#c0c0d0"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#d0d0e0"/>
      ${dot(s/2, s/2-2, 2, '#e8e8f8', 0.6)}
      ${dot(s/2-5, s/2+3, 1.5, '#d8d8e8', 0.5)}
      ${dot(s/2+5, s/3, 1, '#f0f0ff', 0.4)}
    `)),
  ]);

  // Gold Ore â€” bright golden specks
  mgr.addVariants('tile_goldOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a48"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#5a5a60"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#6a6a70"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#ffd700"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#e8c000"/>
      <polygon points="${s/2-6},${s/2+3} ${s/2-3},${s/2+1} ${s/2-2},${s/2+5}" fill="#ffc800"/>
      ${dot(s/2, s/3-2, 2, '#ffe840', 0.7)}
      ${dot(s/2+5, s/2+5, 1.5, '#ffe040', 0.5)}
    `)),
  ]);

  // Mythril Ore â€” glowing blue-cyan veins
  mgr.addVariants('tile_mythrilOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a2a40"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#4a4a5a"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#5a5a6a"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#44bbee"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#66ccff"/>
      <polygon points="${s/2-5},${s/2+4} ${s/2-3},${s/2+1} ${s/2-1},${s/2+5}" fill="#55ccee"/>
      ${dot(s/2, s/3-1, 2.5, '#88ddff', 0.7)}
      ${dot(s/2-4, s/2+5, 1.5, '#66ccff', 0.5)}
      ${dot(s/2+6, s/3+3, 1.2, '#aaeeff', 0.4)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEW GATHERABLE NODES â€” Berry Bush, Mushroom, etc.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Berry Bush â€” green bush with colorful berries
  mgr.addVariants('tile_berryBush', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+2}" ry="${s/4+1}" fill="#2a6a1e"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#3a8a2a"/>
      <ellipse cx="${s/2-3}" cy="${s/2-1}" rx="${s/5}" ry="${s/6}" fill="#4a9a38" opacity="0.6"/>
      ${dot(s/2-5, s/2-1, 2, '#cc3344', 0.9)}
      ${dot(s/2+3, s/2+2, 2, '#cc3344', 0.85)}
      ${dot(s/2-1, s/2+4, 1.8, '#4466cc', 0.9)}
      ${dot(s/2+6, s/2-2, 1.5, '#4466cc', 0.8)}
      ${dot(s/2-3, s/2+6, 1.5, '#cc3344', 0.7)}
    `)),
  ]);

  // Mushroom Patch â€” small mushrooms on dirt
  mgr.addVariants('tile_mushroomPatch', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a5a20"/>
      <rect x="${s/2-7}" y="${s/2+4}" width="2" height="5" fill="#c8b090" rx="0.5"/>
      <ellipse cx="${s/2-6}" cy="${s/2+3}" rx="4" ry="3" fill="#aa7744"/>
      <ellipse cx="${s/2-6}" cy="${s/2+2}" rx="3.5" ry="2" fill="#bb8855" opacity="0.6"/>
      ${dot(s/2-7, s/2+2, 1, '#fff', 0.4)}
      <rect x="${s/2+2}" y="${s/2+5}" width="2" height="4" fill="#c8b090" rx="0.5"/>
      <ellipse cx="${s/2+3}" cy="${s/2+4}" rx="3.5" ry="2.5" fill="#aa7744"/>
      <ellipse cx="${s/2+3}" cy="${s/2+3}" rx="3" ry="1.8" fill="#bb8855" opacity="0.6"/>
      ${dot(s/2+2, s/2+3, 0.8, '#fff', 0.35)}
      <rect x="${s/2-1}" y="${s/2+7}" width="1.5" height="3" fill="#c8b090" rx="0.3"/>
      <ellipse cx="${s/2-0.5}" cy="${s/2+6}" rx="2.5" ry="2" fill="#996633"/>
    `)),
  ]);

  // Clay Deposit â€” reddish-brown smooth mound
  mgr.addVariants('tile_clayDeposit', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+1}" ry="${s/4}" fill="#8a5a3a"/>
      <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/3}" ry="${s/4-1}" fill="#b07050"/>
      <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/5}" ry="${s/7}" fill="#c08060" opacity="0.5"/>
      ${dot(s/2+4, s/2+3, 1, '#905838', 0.3)}
    `)),
  ]);

  // Sand Deposit â€” pale sandy mound
  mgr.addVariants('tile_sandDeposit', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c070"/>
      <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+2}" ry="${s/4}" fill="#c8b860"/>
      <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/3}" ry="${s/4-1}" fill="#d8c878"/>
      <ellipse cx="${s/2-3}" cy="${s/2-1}" rx="${s/5}" ry="${s/7}" fill="#e0d088" opacity="0.5"/>
      ${dot(s/2+5, s/2+4, 1, '#c0b060', 0.4)}
      ${dot(s/2-4, s/2+5, 0.8, '#b8a858', 0.3)}
    `)),
  ]);

  // Flint Node â€” dark jagged stone
  mgr.addVariants('tile_flintNode', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <polygon points="${s/2-6},${s/2+4} ${s/2-2},${s/2-5} ${s/2+5},${s/2-3} ${s/2+7},${s/2+5} ${s/2+1},${s/2+7}" fill="#444438"/>
      <polygon points="${s/2-4},${s/2+3} ${s/2-1},${s/2-3} ${s/2+4},${s/2-1} ${s/2+5},${s/2+4} ${s/2},${s/2+5}" fill="#555544"/>
      ${dot(s/2-2, s/2-1, 1.2, '#666655', 0.5)}
      ${dot(s/2+3, s/2+1, 0.8, '#777766', 0.4)}
    `)),
  ]);

  // Reed Patch â€” tall reeds near water
  mgr.addVariants('tile_reedPatch', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(5, s-2, 4, 4, '#7a9a4a', 2)}
      ${blade(9, s-2, 10, 3, '#8aaa5a', 2)}
      ${blade(14, s-2, 13, 5, '#7a9a4a', 1.8)}
      ${blade(19, s-2, 20, 3, '#8aaa5a', 2)}
      ${blade(24, s-2, 23, 4, '#7a9a4a', 1.8)}
      ${blade(28, s-2, 29, 6, '#8aaa5a', 1.5)}
      ${dot(5, 3, 1.5, '#9aba6a', 0.5)}
      ${dot(10, 2, 1.5, '#9aba6a', 0.5)}
      ${dot(20, 2, 1.5, '#9aba6a', 0.5)}
      ${dot(24, 3, 1.5, '#9aba6a', 0.5)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SNOW GROUND â€” white/pale terrain with icy accents
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_snowGround', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8d2dc"/>
      ${dot(5, 8, 2, '#dde6ee', 0.6)}
      ${dot(20, 14, 2.5, '#d8e2ea', 0.5)}
      ${dot(12, 24, 1.8, '#e0eaf2', 0.45)}
      ${dot(26, 6, 1.2, '#e8f0f8', 0.7)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c4cdd6"/>
      <ellipse cx="${s/3}" cy="${s*2/3}" rx="${s/4}" ry="${s/8}" fill="#d0dae4" opacity="0.4"/>
      ${dot(8, 10, 1.5, '#dce6ee', 0.55)}
      ${dot(22, 20, 2, '#d4dee8', 0.5)}
      ${dot(16, 6, 1, '#e4ecf4', 0.6)}
      ${dot(4, 28, 1.2, '#d8e2ea', 0.35)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cad4de"/>
      ${dot(10, 12, 2.2, '#dde8f0', 0.5)}
      ${dot(24, 8, 1.5, '#e2ecf4', 0.55)}
      ${dot(6, 22, 1.8, '#d6e0ea', 0.4)}
      ${dot(18, 28, 1, '#e0eaf2', 0.35)}
      ${dot(28, 22, 1.3, '#d0dae4', 0.45)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c6d0da"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/5}" ry="${s/8}" fill="#d4dee8" opacity="0.35"/>
      ${dot(4, 6, 1.8, '#dce6ee', 0.6)}
      ${dot(14, 18, 2, '#d8e2ea', 0.45)}
      ${dot(26, 26, 1.5, '#e4ecf4', 0.4)}
      ${dot(20, 4, 1, '#e0eaf2', 0.5)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c2ccd6"/>
      ${dot(8, 4, 1.5, '#d8e2ec', 0.5)}
      ${dot(22, 16, 2.2, '#dde8f0', 0.45)}
      ${dot(4, 20, 1.2, '#d4dee8', 0.55)}
      ${dot(16, 28, 1.8, '#e0eaf2', 0.35)}
      ${dot(28, 8, 1, '#e6eef6', 0.6)}
      <line x1="12" y1="14" x2="18" y2="14" stroke="#e0e8f0" stroke-width="0.5" opacity="0.3"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SAND â€” desert / beach ground
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_sand', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d4c478"/>
      ${dot(6, 10, 1.5, '#e0d08a', 0.5)}
      ${dot(22, 6, 1, '#dcc880', 0.4)}
      ${dot(14, 24, 1.3, '#c8b46a', 0.35)}
      ${dot(26, 20, 0.8, '#e0d08a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c074"/>
      <ellipse cx="${s/3}" cy="${s*2/3}" rx="${s/4}" ry="${s/7}" fill="#dcc880" opacity="0.35"/>
      ${dot(10, 8, 1.2, '#dcc880', 0.45)}
      ${dot(24, 18, 1.5, '#e0d08a', 0.4)}
      ${dot(4, 26, 0.8, '#c8b46a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d6c67a"/>
      ${dot(8, 14, 1.8, '#e2d28c', 0.4)}
      ${dot(22, 24, 1, '#e2d28c', 0.35)}
      ${dot(16, 4, 1.2, '#c6b468', 0.3)}
      ${dot(28, 10, 0.8, '#dcc880', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d2c276"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/5}" ry="${s/8}" fill="#dcc880" opacity="0.3"/>
      ${dot(5, 20, 1.5, '#e0d08a', 0.45)}
      ${dot(18, 12, 1, '#c8b46a', 0.35)}
      ${dot(26, 28, 1.3, '#d8c47e', 0.3)}
      ${dot(12, 28, 0.7, '#cab66c', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d8c87c"/>
      ${dot(4, 8, 1, '#e4d48e', 0.5)}
      ${dot(20, 4, 1.5, '#d0c070', 0.4)}
      ${dot(12, 20, 1.2, '#e0d08a', 0.35)}
      ${dot(26, 16, 0.8, '#ccb86e', 0.3)}
      ${dot(8, 28, 1, '#d4c478', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DIRT â€” muddy / brown earth
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_dirt', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6a5a3a"/>
      ${dot(6, 10, 1.5, '#7a6a4a', 0.5)}
      ${dot(22, 8, 1.2, '#5a4a2a', 0.4)}
      ${dot(14, 22, 1, '#7a6a4a', 0.35)}
      ${dot(26, 18, 0.8, '#8a7a5a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#685838"/>
      <ellipse cx="${s/3}" cy="${s/2}" rx="${s/5}" ry="${s/8}" fill="#7a6a4a" opacity="0.3"/>
      ${dot(10, 6, 1.2, '#5e4e2e', 0.45)}
      ${dot(24, 22, 1.5, '#7a6a4a', 0.4)}
      ${dot(4, 26, 0.8, '#584828', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6c5c3c"/>
      ${dot(8, 14, 1.8, '#7e6e4e', 0.4)}
      ${dot(20, 6, 1, '#5a4a2a', 0.35)}
      ${dot(14, 28, 1.3, '#7a6a4a', 0.3)}
      ${dot(28, 20, 0.7, '#8a7a5a', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#665636"/>
      ${dot(4, 4, 1.2, '#7a6a4a', 0.5)}
      ${dot(18, 16, 1.5, '#5e4e2e', 0.4)}
      ${dot(26, 8, 1, '#746444', 0.35)}
      ${dot(10, 24, 0.8, '#7e6e4e', 0.3)}
      ${dot(22, 28, 1.2, '#6a5a3a', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROCKY GROUND â€” mountain / cave floor
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_rockyGround', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5a5a44"/>
      ${dot(6, 8, 2.5, '#6a6a50', 0.5)}
      ${dot(22, 14, 2, '#505038', 0.4)}
      ${dot(14, 24, 1.8, '#6a6a50', 0.35)}
      ${dot(26, 26, 1.2, '#7a7a60', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#585842"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4}" ry="${s/6}" fill="#626248" opacity="0.35"/>
      ${dot(8, 6, 1.5, '#4e4e36', 0.45)}
      ${dot(24, 20, 2, '#6e6e54', 0.4)}
      ${dot(4, 22, 1.2, '#5a5a42', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5c5c46"/>
      ${dot(10, 10, 2.2, '#6c6c52', 0.45)}
      ${dot(20, 22, 1.5, '#4c4c34', 0.4)}
      ${dot(6, 28, 1.8, '#5e5e46', 0.35)}
      ${dot(28, 8, 1, '#7a7a60', 0.3)}
      ${dot(16, 16, 0.8, '#525240', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#565640"/>
      ${dot(4, 14, 2, '#686850', 0.5)}
      ${dot(18, 6, 1.8, '#4a4a34', 0.4)}
      ${dot(26, 18, 1.5, '#6a6a50', 0.35)}
      ${dot(12, 26, 2.2, '#5c5c44', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5e5e48"/>
      <ellipse cx="${s*2/3}" cy="${s*2/3}" rx="${s/5}" ry="${s/7}" fill="#686850" opacity="0.3"/>
      ${dot(6, 6, 1.5, '#505038', 0.45)}
      ${dot(22, 12, 2, '#6e6e54', 0.4)}
      ${dot(10, 20, 1, '#747458', 0.3)}
      ${dot(28, 26, 1.8, '#5a5a42', 0.35)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FOREST FLOOR â€” dark leafy ground with detritus
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_forestFloor', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a4a1a"/>
      ${dot(6, 8, 2, '#34561e', 0.5)}
      ${dot(20, 14, 1.5, '#3e6028', 0.4)}
      ${dot(12, 24, 1.8, '#283e14', 0.35)}
      ${dot(26, 22, 1, '#365a20', 0.3)}
      ${blade(8, s-2, 10, s-8, '#3a6a24', 1)}
      ${blade(22, s-4, 20, s-10, '#346020', 1)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2c4c1c"/>
      <ellipse cx="${s/3}" cy="${s/2}" rx="${s/5}" ry="${s/7}" fill="#34561e" opacity="0.3"/>
      ${dot(10, 6, 1.5, '#223c12', 0.45)}
      ${dot(24, 18, 2, '#3a6224', 0.4)}
      ${dot(4, 26, 1.2, '#2e4e18', 0.3)}
      ${blade(14, s-2, 16, s-7, '#386824', 1)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#284618"/>
      ${dot(8, 12, 2.2, '#365a20', 0.45)}
      ${dot(22, 8, 1.5, '#223c12', 0.4)}
      ${dot(14, 28, 1.8, '#2e4e18', 0.35)}
      ${dot(28, 24, 1, '#3e6228', 0.3)}
      ${dot(4, 4, 0.8, '#4a3a1a', 0.2)}
      ${blade(18, s-2, 20, s-9, '#346020', 1.2)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2e4e1e"/>
      ${dot(6, 18, 2, '#38581e', 0.5)}
      ${dot(20, 4, 1.8, '#243e14', 0.4)}
      ${dot(26, 16, 1.5, '#365a20', 0.35)}
      ${dot(10, 26, 1, '#3c6226', 0.3)}
      ${dot(16, 10, 0.8, '#5a4a2a', 0.15)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#264416"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/6}" ry="${s/8}" fill="#2e4e18" opacity="0.25"/>
      ${dot(4, 10, 1.5, '#345820', 0.5)}
      ${dot(18, 22, 2, '#3a6224', 0.4)}
      ${dot(28, 6, 1.2, '#223a10', 0.35)}
      ${dot(8, 28, 1.8, '#2c4c1a', 0.3)}
      ${blade(24, s-2, 26, s-8, '#3a6a24', 1)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SHALLOW WATER â€” lighter water for beach edges
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_shallowWater', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a9a"/>
      <path d="M0,${s/3} Q${s/4},${s/3-3} ${s/2},${s/3} Q${s*3/4},${s/3+3} ${s},${s/3}" stroke="#4a8acc" stroke-width="1.5" fill="none" opacity="0.6"/>
      <path d="M0,${s*2/3} Q${s/4},${s*2/3-3} ${s/2},${s*2/3} Q${s*3/4},${s*2/3+3} ${s},${s*2/3}" stroke="#4a8acc" stroke-width="1.5" fill="none" opacity="0.4"/>
      ${dot(12, s/2, 1, '#6aaaee', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2c5c9c"/>
      <path d="M0,10 Q10,6 20,10 Q30,14 ${s},10" stroke="#4888cc" stroke-width="1.3" fill="none" opacity="0.5"/>
      <path d="M0,22 Q8,18 16,22 Q24,26 ${s},22" stroke="#5a9add" stroke-width="1" fill="none" opacity="0.35"/>
      ${dot(22, 16, 1.2, '#6aaaee', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#285898"/>
      <path d="M0,8 Q12,4 ${s},8" stroke="#4a88cc" stroke-width="1.5" fill="none" opacity="0.55"/>
      <path d="M0,18 Q6,14 12,18 Q18,22 24,18 Q30,14 ${s},18" stroke="#5090cc" stroke-width="1.2" fill="none" opacity="0.4"/>
      ${dot(8, 26, 0.8, '#6aaaee', 0.2)}
      ${dot(24, 6, 1, '#7ab0ee', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DEAD TREE â€” desert / wasteland tree
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_deadTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d4c478"/>
      <rect x="${s/2-2}" y="${s/3}" width="4" height="${s*2/3}" fill="#5a4a3a" rx="1"/>
      <line x1="${s/2}" y1="${s/3+2}" x2="${s/2-8}" y2="${s/6}" stroke="#5a4a3a" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="${s/2}" y1="${s/3+4}" x2="${s/2+7}" y2="${s/5}" stroke="#5a4a3a" stroke-width="2" stroke-linecap="round"/>
      <line x1="${s/2-8}" y1="${s/6}" x2="${s/2-10}" y2="${s/8}" stroke="#5a4a3a" stroke-width="1.5" stroke-linecap="round"/>
      <line x1="${s/2+7}" y1="${s/5}" x2="${s/2+10}" y2="${s/7}" stroke="#5a4a3a" stroke-width="1.2" stroke-linecap="round"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c074"/>
      <rect x="${s/2-1.5}" y="${s/4}" width="3" height="${s*3/4}" fill="#4e3e2e" rx="1"/>
      <line x1="${s/2}" y1="${s/4+3}" x2="${s/2-6}" y2="${s/8}" stroke="#4e3e2e" stroke-width="2" stroke-linecap="round"/>
      <line x1="${s/2}" y1="${s/3}" x2="${s/2+8}" y2="${s/5}" stroke="#4e3e2e" stroke-width="1.8" stroke-linecap="round"/>
      <line x1="${s/2+8}" y1="${s/5}" x2="${s/2+6}" y2="${s/8}" stroke="#4e3e2e" stroke-width="1" stroke-linecap="round"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CACTUS â€” desert succulent
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_cactus', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d4c478"/>
      <rect x="${s/2-3}" y="${s/4}" width="6" height="${s*3/4-2}" fill="#3a7a28" rx="3"/>
      <rect x="${s/2-9}" y="${s/3}" width="6" height="${s/4}" fill="#3a7a28" rx="3"/>
      <rect x="${s/2+3}" y="${s/4+2}" width="6" height="${s/3}" fill="#3a7a28" rx="3"/>
      <line x1="${s/2-9}" y1="${s/3}" x2="${s/2-6}" y2="${s/3}" stroke="#3a7a28" stroke-width="4"/>
      <line x1="${s/2+3}" y1="${s/4+2+s/6}" x2="${s/2+6}" y2="${s/4+2+s/6}" stroke="#3a7a28" stroke-width="4"/>
      ${dot(s/2, s/3, 1, '#2a6a1a', 0.3)}
      ${dot(s/2, s/2+2, 1, '#2a6a1a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c074"/>
      <rect x="${s/2-2.5}" y="${s/3}" width="5" height="${s*2/3-2}" fill="#348a24" rx="2.5"/>
      <line x1="${s/2}" y1="${s/3+6}" x2="${s/2-7}" y2="${s/3+2}" stroke="#348a24" stroke-width="4" stroke-linecap="round"/>
      <line x1="${s/2}" y1="${s/2}" x2="${s/2+6}" y2="${s/3+4}" stroke="#348a24" stroke-width="3.5" stroke-linecap="round"/>
      ${dot(s/2-1, s/3+4, 0.8, '#2a7a1a', 0.3)}
      ${dot(s/2+1, s/2+4, 0.8, '#2a7a1a', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d6c67a"/>
      <ellipse cx="${s/2}" cy="${s/2+4}" rx="4" ry="${s/3}" fill="#408a30"/>
      <ellipse cx="${s/2}" cy="${s/2+4}" rx="3" ry="${s/3-2}" fill="#4a9a3a" opacity="0.5"/>
      ${dot(s/2, s/3+2, 1, '#60b050', 0.4)}
      ${dot(s/2-1, s/2+6, 0.8, '#308020', 0.3)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SNOW TREE â€” frosted evergreen
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_snowTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8d2dc"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},2 ${s/2+10},${s/3+2} ${s/2-10},${s/3+2}" fill="#2a5a28"/>
      <polygon points="${s/2},${s/6} ${s/2+12},${s/2+2} ${s/2-12},${s/2+2}" fill="#2e6430"/>
      <polygon points="${s/2},${s/3} ${s/2+13},${s*2/3} ${s/2-13},${s*2/3}" fill="#326a34"/>
      ${dot(s/2-5, s/3-2, 2.5, '#dce6ee', 0.7)}
      ${dot(s/2+4, s/3+6, 2, '#d8e2ea', 0.6)}
      ${dot(s/2, s/6+2, 1.5, '#e0eaf2', 0.65)}
      ${dot(s/2-8, s/2, 2, '#dce6ee', 0.5)}
      ${dot(s/2+6, s/2+4, 1.8, '#d8e2ea', 0.55)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c4cdd6"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#5a3a1a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#2a5828"/>
      <circle cx="${s/2-4}" cy="${s/3+4}" r="${s/4}" fill="#306a2e"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4}" fill="#28582a"/>
      ${dot(s/2-2, s/4, 3, '#dce6ee', 0.65)}
      ${dot(s/2+5, s/3+2, 2.5, '#d8e2ea', 0.55)}
      ${dot(s/2-6, s/3+6, 2, '#e0eaf2', 0.5)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cad4de"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#4a3018" rx="1"/>
      <polygon points="${s/2},4 ${s/2+8},${s/3} ${s/2-8},${s/3}" fill="#285a26"/>
      <polygon points="${s/2},${s/5} ${s/2+10},${s/2} ${s/2-10},${s/2}" fill="#2c6230"/>
      <polygon points="${s/2},${s/3+2} ${s/2+11},${s*2/3-2} ${s/2-11},${s*2/3-2}" fill="#306634"/>
      ${dot(s/2, 6, 2, '#e0eaf2', 0.7)}
      ${dot(s/2-6, s/3+4, 2.5, '#dce6ee', 0.6)}
      ${dot(s/2+5, s/2-2, 2, '#d8e2ea', 0.55)}
      ${dot(s/2-3, s/2+6, 1.5, '#e4ecf4', 0.5)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BUSH â€” small shrub on grass
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_bush', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3}" ry="${s/4}" fill="#3a8a2a"/>
      <ellipse cx="${s/2-4}" cy="${s/2+2}" rx="${s/5}" ry="${s/5}" fill="#48983a"/>
      <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="${s/5}" ry="${s/5}" fill="#2e7a1e"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/5}" ry="${s/6}" fill="#50a040" opacity="0.6"/>
      ${dot(s/2-6, s/2+1, 1, '#5aaa4a', 0.4)}
      ${dot(s/2+5, s/2-1, 1, '#2a7a1a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#386828"/>
      <ellipse cx="${s/2+2}" cy="${s/2+5}" rx="${s/3-2}" ry="${s/4-1}" fill="#3c8c2c"/>
      <ellipse cx="${s/2-3}" cy="${s/2+3}" rx="${s/4}" ry="${s/5}" fill="#449436"/>
      <ellipse cx="${s/2+3}" cy="${s/2+1}" rx="${s/5}" ry="${s/6}" fill="#4ca03c" opacity="0.5"/>
      ${dot(s/2-2, s/2+6, 1.5, '#e44a4a', 0.4)}
      ${dot(s/2+4, s/2+4, 1.2, '#e44a4a', 0.35)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c6c2a"/>
      <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/2.8}" ry="${s/3.5}" fill="#388a28"/>
      <ellipse cx="${s/2-3}" cy="${s/2+1}" rx="${s/4}" ry="${s/5}" fill="#42942e"/>
      <ellipse cx="${s/2+5}" cy="${s/2+4}" rx="${s/5}" ry="${s/5}" fill="#2c7c1c"/>
      <ellipse cx="${s/2}" cy="${s/2-1}" rx="${s/6}" ry="${s/7}" fill="#4c9c3c" opacity="0.5"/>
    `)),
  ]);
});


</script>
  <script>
// ============================================================
// Biome Tiles â€” World map terrain (plains, forest, mountain, etc.)
// Multiple variants per biome for visual variety.
// Linked to: data/biomes.json (biome properties like dangerMod, color)
// ============================================================

SVGTileManager.register('biome', (mgr) => {
  const s = mgr.tileSize;

  function dot(cx, cy, r, fill, opacity) {
    return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" opacity="${opacity || 1}"/>`;
  }

  // â”€â”€ Plains â€” rolling green â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_plains', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#4a7a30"/>
      <ellipse cx="${s/4}" cy="${s*3/4}" rx="${s/3}" ry="${s/6}" fill="#5a8a3c" opacity="0.6"/>
      <ellipse cx="${s*3/4}" cy="${s/3}" rx="${s/4}" ry="${s/8}" fill="#5a8a3c" opacity="0.4"/>
      ${dot(6, 8, 1, '#6a9a4c', 0.5)}
      ${dot(22, 24, 1, '#6a9a4c', 0.5)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#4c7c32"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/5}" fill="#568a38" opacity="0.5"/>
      <ellipse cx="${s/5}" cy="${s/4}" rx="${s/5}" ry="${s/8}" fill="#5a8e3c" opacity="0.35"/>
      ${dot(24, 8, 1, '#6a9a4c', 0.4)}
      ${dot(8, 26, 0.8, '#5c8c38', 0.45)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#488028"/>
      <ellipse cx="${s*3/4}" cy="${s*2/3}" rx="${s/3}" ry="${s/6}" fill="#5a8a3c" opacity="0.5"/>
      <ellipse cx="${s/3}" cy="${s/5}" rx="${s/4}" ry="${s/7}" fill="#528634" opacity="0.4"/>
      ${dot(14, 20, 1.2, '#6a9a4c', 0.35)}
      ${dot(4, 14, 0.8, '#5e8e3a', 0.4)}
      ${dot(28, 28, 0.6, '#6a9a4c', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#4e7e34"/>
      <ellipse cx="${s/2}" cy="${s*3/4}" rx="${s/2.5}" ry="${s/7}" fill="#588a38" opacity="0.45"/>
      ${dot(6, 6, 1.5, '#e8d44a', 0.4)}
      ${dot(7, 6, 0.8, '#f0e060', 0.5)}
      ${dot(20, 18, 0.8, '#6a9a4c', 0.35)}
    `)),
  ]);

  // â”€â”€ Forest â€” dense trees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_forest', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a10"/>
      <circle cx="8" cy="10" r="6" fill="#2d6a1e"/>
      <circle cx="22" cy="8" r="7" fill="#256018"/>
      <circle cx="14" cy="20" r="6" fill="#2d7020"/>
      <circle cx="26" cy="22" r="5" fill="#256018"/>
      <rect x="7" y="14" width="2" height="6" fill="#5a3a1a"/>
      <rect x="21" y="13" width="2" height="7" fill="#5a3a1a"/>
      <rect x="13" y="24" width="2" height="5" fill="#5a3a1a"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1c4c12"/>
      <circle cx="6" cy="8" r="5" fill="#2a6a1c"/>
      <circle cx="18" cy="6" r="6" fill="#286418"/>
      <circle cx="28" cy="10" r="5" fill="#2e7020"/>
      <circle cx="10" cy="22" r="7" fill="#246016"/>
      <circle cx="24" cy="24" r="5" fill="#2a6a1c"/>
      <rect x="5" y="12" width="2" height="5" fill="#5a3a1a"/>
      <rect x="17" y="10" width="2" height="6" fill="#5a3a1a"/>
      <rect x="9" y="26" width="2" height="5" fill="#5a3a1a"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#184a0e"/>
      <circle cx="10" cy="12" r="7" fill="#2c6c1e"/>
      <circle cx="24" cy="10" r="6" fill="#226014"/>
      <circle cx="8" cy="6" r="4" fill="#306e20"/>
      <circle cx="20" cy="22" r="6" fill="#286818"/>
      <rect x="9" y="16" width="2" height="7" fill="#5a3a1a"/>
      <rect x="23" y="14" width="2" height="6" fill="#5a3a1a"/>
      <rect x="19" y="26" width="2" height="5" fill="#5a3a1a"/>
      ${dot(4, 28, 1, '#1e5612', 0.4)}
    `)),
    // Pine forest variant
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4810"/>
      <polygon points="8,4 14,18 2,18" fill="#1e6414"/>
      <polygon points="22,2 30,20 14,20" fill="#1c5e12"/>
      <polygon points="14,14 22,28 6,28" fill="#206816"/>
      <rect x="7" y="17" width="2" height="5" fill="#5a3a1a"/>
      <rect x="21" y="19" width="2" height="5" fill="#5a3a1a"/>
      <rect x="13" y="27" width="2" height="4" fill="#5a3a1a"/>
    `)),
  ]);

  // â”€â”€ Mountain â€” rocky peaks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_mountain', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6a6a50"/>
      <polygon points="${s/2},2 ${s-4},${s-2} 4,${s-2}" fill="#8a7a5a"/>
      <polygon points="${s/2},2 ${s/2+2},8 ${s/2-6},${s/2}" fill="#9a8a6a" opacity="0.6"/>
      <polygon points="${s/2-2},4 ${s/2+2},4 ${s/2},0" fill="#ddd" opacity="0.7"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#686848"/>
      <polygon points="${s/2+4},4 ${s-2},${s-2} 8,${s-2}" fill="#887858"/>
      <polygon points="${s/2+4},4 ${s/2+6},10 ${s/2},${s/2+2}" fill="#988868" opacity="0.55"/>
      <polygon points="${s/2+2},6 ${s/2+5},6 ${s/2+3},2" fill="#ccc" opacity="0.6"/>
      ${dot(8, s-4, 1, '#7a7a5a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6c6c4e"/>
      <polygon points="6,6 18,${s-2} 0,${s-2}" fill="#847454"/>
      <polygon points="20,4 ${s},${s-2} 10,${s-2}" fill="#8a7a5a"/>
      <polygon points="6,6 8,10 2,${s/2}" fill="#948462" opacity="0.5"/>
      <polygon points="20,4 22,8 18,${s/2-2}" fill="#9a8a6a" opacity="0.5"/>
      <polygon points="5,8 7,8 6,4" fill="#ddd" opacity="0.6"/>
      <polygon points="19,6 21,6 20,2" fill="#ddd" opacity="0.65"/>
    `)),
  ]);

  // â”€â”€ Snow â€” white terrain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_snow', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8d0d8"/>
      ${dot(5, 8, 2, '#dde4ea', 0.7)}
      ${dot(20, 14, 2.5, '#dde4ea', 0.6)}
      ${dot(12, 24, 2, '#e0e8f0', 0.5)}
      ${dot(26, 6, 1.5, '#e8f0f8', 0.8)}
      ${dot(8, 20, 1, '#f0f4fa', 0.6)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cad2da"/>
      ${dot(10, 6, 2, '#dce2e8', 0.65)}
      ${dot(24, 18, 2, '#dde4ea', 0.55)}
      ${dot(6, 22, 1.5, '#e2eaf0', 0.5)}
      ${dot(18, 28, 1.8, '#e0e8f0', 0.45)}
      ${dot(28, 4, 1, '#e8f0f8', 0.7)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c6ced6"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/5}" fill="#d4dce4" opacity="0.4"/>
      ${dot(4, 10, 1.5, '#dde4ea', 0.5)}
      ${dot(22, 8, 1, '#e8f0f8', 0.6)}
      ${dot(14, 26, 2, '#e0e8f0', 0.4)}
      ${dot(28, 22, 1, '#d8e0e8', 0.5)}
    `)),
  ]);

  // â”€â”€ Sea â€” deep water â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_sea', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a3a7a"/>
      <path d="M0,10 Q8,6 16,10 Q24,14 ${s},10" stroke="#2a5aaa" stroke-width="2" fill="none" opacity="0.6"/>
      <path d="M0,20 Q8,16 16,20 Q24,24 ${s},20" stroke="#2a5aaa" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M0,28 Q8,24 16,28 Q24,32 ${s},28" stroke="#3a6abb" stroke-width="1.5" fill="none" opacity="0.4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1c3c7c"/>
      <path d="M0,8 Q10,4 20,8 Q30,12 ${s},8" stroke="#2858a8" stroke-width="1.8" fill="none" opacity="0.55"/>
      <path d="M0,18 Q6,14 12,18 Q18,22 24,18 Q30,14 ${s},18" stroke="#2a5aaa" stroke-width="2" fill="none" opacity="0.45"/>
      <path d="M0,26 Q12,22 ${s},26" stroke="#3a6abb" stroke-width="1.2" fill="none" opacity="0.35"/>
      ${dot(20, 14, 1, '#4a7acc', 0.2)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#183878"/>
      <path d="M0,12 Q8,8 16,12 Q24,16 ${s},12" stroke="#2c5eae" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M0,22 Q10,18 20,22 Q30,26 ${s},22" stroke="#2a5aaa" stroke-width="1.5" fill="none" opacity="0.45"/>
      ${dot(8, 6, 1.2, '#4a7acc', 0.15)}
      ${dot(26, 26, 0.8, '#4a7acc', 0.15)}
    `)),
  ]);

  // â”€â”€ Road (world map) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_road', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a89868"/>
      <rect x="4" y="0" width="${s-8}" height="${s}" fill="#b8a878"/>
      ${dot(10, 8, 1, '#c8b888', 0.4)}
      ${dot(22, 20, 1, '#c8b888', 0.4)}
      <line x1="8" y1="0" x2="8" y2="${s}" stroke="#a09060" stroke-width="0.5" stroke-dasharray="4 4"/>
      <line x1="24" y1="0" x2="24" y2="${s}" stroke="#a09060" stroke-width="0.5" stroke-dasharray="4 4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a69666"/>
      <rect x="4" y="0" width="${s-8}" height="${s}" fill="#b6a676"/>
      ${dot(12, 12, 1.2, '#c6b686', 0.35)}
      ${dot(20, 26, 0.8, '#c6b686', 0.3)}
      <line x1="8" y1="0" x2="8" y2="${s}" stroke="#9e8e5e" stroke-width="0.5" stroke-dasharray="4 4"/>
      <line x1="24" y1="0" x2="24" y2="${s}" stroke="#9e8e5e" stroke-width="0.5" stroke-dasharray="4 4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#aa9a6a"/>
      <rect x="4" y="0" width="${s-8}" height="${s}" fill="#baaa7a"/>
      ${dot(8, 6, 0.8, '#cabb8a', 0.4)}
      ${dot(24, 16, 1, '#cabb8a', 0.35)}
      ${dot(16, 28, 0.6, '#c0b080', 0.3)}
      <line x1="8" y1="0" x2="8" y2="${s}" stroke="#a29262" stroke-width="0.5" stroke-dasharray="4 4"/>
      <line x1="24" y1="0" x2="24" y2="${s}" stroke="#a29262" stroke-width="0.5" stroke-dasharray="4 4"/>
    `)),
  ]);

  // â”€â”€ Beach â€” sandy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_beach', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d8c888"/>
      ${dot(6, 10, 1.5, '#e8d8a0', 0.6)}
      ${dot(20, 6, 1, '#e8d8a0', 0.5)}
      ${dot(14, 22, 1.5, '#c8b878', 0.4)}
      ${dot(26, 18, 1, '#e8d8a0', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d6c686"/>
      ${dot(10, 8, 1.2, '#e6d69e', 0.55)}
      ${dot(24, 14, 1.5, '#e6d69e', 0.45)}
      ${dot(4, 24, 1, '#c6b676', 0.35)}
      ${dot(18, 28, 0.8, '#e0d098', 0.4)}
      ${dot(28, 6, 1, '#dcc890', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#daca8a"/>
      ${dot(8, 14, 1.8, '#eadaa2', 0.5)}
      ${dot(22, 22, 1, '#eadaa2', 0.4)}
      ${dot(16, 4, 1.2, '#caba7a', 0.35)}
      ${dot(4, 28, 0.8, '#e2d29a', 0.3)}
    `)),
  ]);

  // â”€â”€ Desert â€” arid sand â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_desert', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8b060"/>
      <ellipse cx="${s/3}" cy="${s*2/3}" rx="${s/2}" ry="${s/5}" fill="#d8c070" opacity="0.5"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/3}" ry="${s/6}" fill="#d8c070" opacity="0.4"/>
      ${dot(24, 24, 1, '#b8a050', 0.6)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c6ae5e"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/2.5}" ry="${s/6}" fill="#d6be6e" opacity="0.45"/>
      <ellipse cx="${s/4}" cy="${s*3/4}" rx="${s/4}" ry="${s/8}" fill="#d4bc6c" opacity="0.35"/>
      ${dot(8, 8, 1.2, '#b6a44e', 0.5)}
      ${dot(26, 20, 0.8, '#ccba62', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cab262"/>
      <ellipse cx="${s*2/3}" cy="${s*2/3}" rx="${s/3}" ry="${s/5}" fill="#dac272" opacity="0.4"/>
      ${dot(6, 12, 1, '#b8a654', 0.5)}
      ${dot(20, 4, 1.5, '#d4c06a', 0.35)}
      ${dot(14, 28, 0.8, '#bca858', 0.4)}
    `)),
  ]);
});

</script>
  <script>
// ============================================================
// Item Tiles â€” weapons, armor, food, potions, resources, etc.
// Linked to: data/items.json (item properties like type, subtype, value)
// ============================================================

SVGTileManager.register('items', (mgr) => {
  const s = mgr.tileSize;

  // â”€â”€ Weapons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Long Sword â€” polished steel blade with fuller, leather-wrapped hilt, round pommel
  mgr.cache['item_weapon_longSword'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="2" fill="#000" opacity="0.15"/>
    <line x1="${s/2+6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#8a8a9a" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2+6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#c0c0e0" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="${s/2+5}" y1="${s-7}" x2="${s/2-5}" y2="6" stroke="#e8e8ff" stroke-width="0.8" stroke-linecap="round" opacity="0.6"/>
    <line x1="${s/2-1}" y1="${s/2-3}" x2="${s/2+3}" y2="${s/2+1}" stroke="#d0d0e0" stroke-width="0.5" opacity="0.4"/>
    <rect x="${s/2-5}" y="${s/2}" width="10" height="3" fill="#6a5020" rx="1" transform="rotate(-25 ${s/2} ${s/2+1})"/>
    <rect x="${s/2-5}" y="${s/2}" width="10" height="1.5" fill="#8a7030" rx="1" transform="rotate(-25 ${s/2} ${s/2+1})"/>
    <line x1="${s/2-5}" y1="${s/2+2}" x2="${s/2+5}" y2="${s/2-1}" stroke="#4a3010" stroke-width="0.5" opacity="0.5"/>
    <circle cx="${s/2+7}" cy="${s-5}" r="2.5" fill="#7a6020" stroke="#5a4010" stroke-width="0.5"/>
    <circle cx="${s/2+7}" cy="${s-5}" r="1.2" fill="#a08030" opacity="0.6"/>
    <circle cx="${s/2+6.5}" cy="${s-5.5}" r="0.6" fill="#d0b060" opacity="0.7"/>
  `));

  // Short Sword / Dagger â€” shorter blade, compact crossguard, visible edge bevel
  mgr.cache['item_weapon_shortSword'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-4}" rx="5" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2+4}" y1="${s-8}" x2="${s/2-3}" y2="9" stroke="#909098" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-8}" x2="${s/2-3}" y2="9" stroke="#c0c0d0" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2+3.5}" y1="${s-8.5}" x2="${s/2-2.5}" y2="9.5" stroke="#e0e0f0" stroke-width="0.6" opacity="0.5"/>
    <rect x="${s/2-4}" y="${s/2-1}" width="8" height="3" fill="#6a5020" rx="1" transform="rotate(-20 ${s/2} ${s/2})"/>
    <rect x="${s/2-4}" y="${s/2-1}" width="8" height="1.2" fill="#8a7030" rx="1" transform="rotate(-20 ${s/2} ${s/2})"/>
    <circle cx="${s/2+4.5}" cy="${s-7}" r="1.8" fill="#7a6020" stroke="#5a4010" stroke-width="0.5"/>
    <circle cx="${s/2+4.2}" cy="${s-7.3}" r="0.5" fill="#c0a040" opacity="0.6"/>
    <polygon points="${s/2-3},10 ${s/2-4},8 ${s/2-2},8" fill="#d0d0e0" opacity="0.4"/>
  `));

  // Battle Axe â€” oak shaft, double-headed steel blade with edge detail
  mgr.cache['item_weapon_axe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="3" stroke="#6a4a20" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="3" stroke="#8a6a3a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="${s/2+0.5}" y1="${s-4}" x2="${s/2+0.5}" y2="3" stroke="#a08050" stroke-width="0.5" opacity="0.4"/>
    <path d="M${s/2-2},5 Q${s/2-11},${s/3} ${s/2-2},${s/2-2}" fill="#a0a0b8" stroke="#707080" stroke-width="1"/>
    <path d="M${s/2+2},5 Q${s/2+11},${s/3} ${s/2+2},${s/2-2}" fill="#a0a0b8" stroke="#707080" stroke-width="1"/>
    <path d="M${s/2-2},6 Q${s/2-8},${s/3-1} ${s/2-2},${s/2-3}" fill="#c0c0d0" opacity="0.35"/>
    <path d="M${s/2+2},6 Q${s/2+8},${s/3-1} ${s/2+2},${s/2-3}" fill="#c0c0d0" opacity="0.35"/>
    <line x1="${s/2-9}" y1="${s/3}" x2="${s/2-3}" y2="${s/3}" stroke="#e0e0f0" stroke-width="0.4" opacity="0.5"/>
    <line x1="${s/2+9}" y1="${s/3}" x2="${s/2+3}" y2="${s/3}" stroke="#e0e0f0" stroke-width="0.4" opacity="0.5"/>
    <rect x="${s/2-1}" y="${s-6}" width="2" height="3" fill="#5a3a10" rx="0.5" opacity="0.5"/>
  `));

  // Short Bow â€” carved wood limbs, taut string, feathered arrow nocked
  mgr.cache['item_weapon_bow'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2-2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <path d="M${s/2-6},${s-6} Q${s/2-13},${s/2} ${s/2-6},5" stroke="#6a4a20" stroke-width="3" fill="none"/>
    <path d="M${s/2-6},${s-6} Q${s/2-13},${s/2} ${s/2-6},5" stroke="#8a6a3a" stroke-width="2" fill="none"/>
    <path d="M${s/2-5},${s-7} Q${s/2-11},${s/2} ${s/2-5},6" stroke="#a08050" stroke-width="0.5" fill="none" opacity="0.4"/>
    <line x1="${s/2-6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#ddd" stroke-width="0.8"/>
    <line x1="${s/2-6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#fff" stroke-width="0.3" opacity="0.4"/>
    <line x1="${s/2-4}" y1="${s/2}" x2="${s/2+9}" y2="${s/2-3}" stroke="#a0a0b0" stroke-width="1.8" stroke-linecap="round"/>
    <line x1="${s/2-4}" y1="${s/2}" x2="${s/2+9}" y2="${s/2-3}" stroke="#c0c0d0" stroke-width="0.6" opacity="0.5"/>
    <polygon points="${s/2+9},${s/2-3} ${s/2+7},${s/2-6} ${s/2+11},${s/2-4}" fill="#8a8a98" stroke="#606068" stroke-width="0.5"/>
    <line x1="${s/2+8}" y1="${s/2-3}" x2="${s/2+6}" y2="${s/2-1}" stroke="#c44" stroke-width="1" stroke-linecap="round" opacity="0.7"/>
    <line x1="${s/2+8}" y1="${s/2-4}" x2="${s/2+6}" y2="${s/2-2}" stroke="#e66" stroke-width="0.6" stroke-linecap="round" opacity="0.5"/>
  `));

  // Oak Staff â€” gnarled wood, glowing crystal orb, arcane rings
  mgr.cache['item_weapon_staff'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="8" stroke="#5a3a1a" stroke-width="4" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="8" stroke="#7a5a2a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+0.8}" y1="${s-4}" x2="${s/2+0.8}" y2="8" stroke="#9a7a4a" stroke-width="0.6" opacity="0.4"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="2" ry="0.8" fill="#4a3010" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2-4}" rx="2" ry="0.8" fill="#4a3010" opacity="0.5"/>
    <circle cx="${s/2}" cy="6" r="5" fill="#3344aa" opacity="0.2"/>
    <circle cx="${s/2}" cy="6" r="4" fill="none" stroke="#6688ff" stroke-width="1.8"/>
    <circle cx="${s/2}" cy="6" r="4" fill="none" stroke="#aaccff" stroke-width="0.5" opacity="0.5"/>
    <circle cx="${s/2}" cy="6" r="2.5" fill="#6688ff" opacity="0.6"/>
    <circle cx="${s/2}" cy="6" r="1.5" fill="#aaccff" opacity="0.8"/>
    <circle cx="${s/2-1}" cy="5" r="0.6" fill="#fff" opacity="0.9"/>
    <circle cx="${s/2+2}" cy="4" r="1" fill="#aaf" opacity="0.15"/>
    <circle cx="${s/2-3}" cy="8" r="0.8" fill="#88f" opacity="0.15"/>
  `));

  // Wooden Mace â€” thick handle, spiked iron head with rivets
  mgr.cache['item_weapon_mace'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+1}" stroke="#5a3a1a" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+1}" stroke="#8a6a3a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="${s/2+0.6}" y1="${s-4}" x2="${s/2+0.6}" y2="${s/3+1}" stroke="#a08050" stroke-width="0.5" opacity="0.35"/>
    <circle cx="${s/2}" cy="${s/4+1}" r="${s/5+1}" fill="#666" stroke="#555" stroke-width="1"/>
    <circle cx="${s/2}" cy="${s/4+1}" r="${s/5}" fill="#888" stroke="#6a6a70" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/4+1}" r="${s/7}" fill="#9a9a9a"/>
    <circle cx="${s/2-1}" cy="${s/4-1}" r="1" fill="#bbb" opacity="0.6"/>
    <polygon points="${s/2-7},${s/4+1} ${s/2-5},${s/4-1} ${s/2-5},${s/4+3}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <polygon points="${s/2+7},${s/4+1} ${s/2+5},${s/4-1} ${s/2+5},${s/4+3}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <polygon points="${s/2},${s/4-6} ${s/2-2},${s/4-3} ${s/2+2},${s/4-3}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <polygon points="${s/2},${s/4+8} ${s/2-2},${s/4+5} ${s/2+2},${s/4+5}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <circle cx="${s/2-2}" cy="${s/4}" r="0.7" fill="#aaa"/>
    <circle cx="${s/2+2}" cy="${s/4+2}" r="0.7" fill="#aaa"/>
  `));

  // Broken Sword â€” chipped, shorter blade with rust
  mgr.cache['item_weapon_brokenSword'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="2" fill="#000" opacity="0.15"/>
    <line x1="${s/2+5}" y1="${s-6}" x2="${s/2-2}" y2="${s/3+2}" stroke="#7a7a7a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+5}" y1="${s-6}" x2="${s/2-2}" y2="${s/3+2}" stroke="#999" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2-2}" y1="${s/3+2}" x2="${s/2-4}" y2="${s/3-1}" stroke="#999" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>
    <line x1="${s/2-1}" y1="${s/3+1}" x2="${s/2-5}" y2="${s/3+3}" stroke="#999" stroke-width="1" opacity="0.4"/>
    <circle cx="${s/2+1}" cy="${s/2+2}" r="1" fill="#8a4a20" opacity="0.5"/>
    <circle cx="${s/2-1}" cy="${s/3+4}" r="0.7" fill="#8a4a20" opacity="0.4"/>
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="3" fill="#6a5020" rx="1" transform="rotate(-20 ${s/2} ${s/2+3})"/>
    <circle cx="${s/2+6}" cy="${s-5}" r="2" fill="#6a5020" stroke="#4a3010" stroke-width="0.5"/>
  `));

  // â”€â”€ Armor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Body Armor â€” layered leather cuirass with stitching, buckle, shoulder plates
  mgr.cache['item_armor_body'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.12"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8 L${s/2+4},4 L${s/2},6 L${s/2-4},4 Z" fill="#7a5a30" stroke="#5a3a10" stroke-width="1"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8 L${s/2+4},4 L${s/2},6 L${s/2-4},4 Z" fill="#8a6a40" opacity="0.8"/>
    <path d="M${s/2-4},4 L${s/2},6 L${s/2+4},4 L${s/2+6},6 L${s/2-6},6 Z" fill="#9a7a50" opacity="0.5"/>
    <line x1="${s/2}" y1="6" x2="${s/2}" y2="${s-8}" stroke="#6a4a20" stroke-width="1" opacity="0.4"/>
    <line x1="${s/2-4}" y1="10" x2="${s/2-6}" y2="${s-8}" stroke="#6a4a20" stroke-width="0.5" opacity="0.3" stroke-dasharray="2 2"/>
    <line x1="${s/2+4}" y1="10" x2="${s/2+6}" y2="${s-8}" stroke="#6a4a20" stroke-width="0.5" opacity="0.3" stroke-dasharray="2 2"/>
    <rect x="${s/2-1}" y="${s/2-1}" width="2" height="3" fill="#c8a040" rx="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="0.8" fill="#e8c060"/>
    <rect x="${s/2-7}" y="8" width="3" height="4" fill="#8a6a40" rx="1" opacity="0.6"/>
    <rect x="${s/2+4}" y="8" width="3" height="4" fill="#8a6a40" rx="1" opacity="0.6"/>
    <path d="M${s/2-8},${s-6} L${s/2+10},${s-6}" stroke="#9a7a50" stroke-width="0.5" opacity="0.4"/>
  `));

  // Iron Helm â€” rounded dome, nose guard, cheek plates, rivet detail
  mgr.cache['item_armor_head'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-4}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+1}" ry="${s/4+1}" fill="#707078" stroke="#606068" stroke-width="1"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3}" ry="${s/4}" fill="#888890"/>
    <ellipse cx="${s/2}" cy="${s/2-1}" rx="${s/3+2}" ry="${s/5+1}" fill="#8a8a92" stroke="#707078" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="${s/3}" ry="${s/5}" fill="#9a9aa0" opacity="0.6"/>
    <ellipse cx="${s/2-2}" cy="${s/2-3}" rx="${s/5}" ry="${s/8}" fill="#b0b0b8" opacity="0.35"/>
    <rect x="${s/2-1}" y="${s/4-1}" width="2" height="${s/3+2}" fill="#808088" rx="0.5"/>
    <rect x="${s/2-0.5}" y="${s/4}" width="1" height="${s/3}" fill="#9a9aa0" rx="0.3" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.8" fill="#aaa"/>
    <circle cx="${s/2+5}" cy="${s/2+1}" r="0.8" fill="#aaa"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="0.6" fill="#bbb" opacity="0.5"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="0.6" fill="#bbb" opacity="0.5"/>
  `));

  // Leather Boots â€” tall boots with laces, sole detail, folded cuff
  mgr.cache['item_armor_foot'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <path d="M${s/2-6},7 L${s/2-7},${s-8} L${s/2-2},${s-5} L${s/2+7},${s-5} L${s/2+7},${s-9} L${s/2+4},7 Z" fill="#6a4a20" stroke="#4a2a08" stroke-width="1"/>
    <path d="M${s/2-6},7 L${s/2-7},${s-8} L${s/2-2},${s-5} L${s/2+7},${s-5} L${s/2+7},${s-9} L${s/2+4},7 Z" fill="#7a5a30" opacity="0.7"/>
    <path d="M${s/2-6},7 L${s/2+4},7 L${s/2+3},10 L${s/2-5},10 Z" fill="#8a6a40" opacity="0.5"/>
    <line x1="${s/2-2}" y1="12" x2="${s/2+1}" y2="12" stroke="#5a3a10" stroke-width="0.6"/>
    <line x1="${s/2-2}" y1="15" x2="${s/2+1}" y2="15" stroke="#5a3a10" stroke-width="0.6"/>
    <line x1="${s/2-2}" y1="18" x2="${s/2+1}" y2="18" stroke="#5a3a10" stroke-width="0.6"/>
    <line x1="${s/2-2}" y1="21" x2="${s/2+1}" y2="21" stroke="#5a3a10" stroke-width="0.6"/>
    <path d="M${s/2-7},${s-8} L${s/2-2},${s-5} L${s/2+7},${s-5}" stroke="#4a2a08" stroke-width="1.5" fill="none"/>
    <line x1="${s/2+5}" y1="${s-5}" x2="${s/2+7}" y2="${s-5}" stroke="#8a6a40" stroke-width="2"/>
  `));

  // Wooden Shield â€” round shield with iron rim, boss, wood grain
  mgr.cache['item_armor_hand'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+1}" ry="${s/2.5+1}" fill="#6a5020" stroke="#4a3010" stroke-width="1.2"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/2.5}" fill="#8a7030"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3-1}" ry="${s/2.5-1}" fill="#9a8040" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2}" x2="${s/2+6}" y2="${s/2}" stroke="#7a6020" stroke-width="0.6" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2-8}" x2="${s/2}" y2="${s/2+8}" stroke="#7a6020" stroke-width="0.6" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="3" fill="#8a8090" stroke="#6a6060" stroke-width="0.8"/>
    <circle cx="${s/2}" cy="${s/2}" r="2" fill="#9a9098"/>
    <circle cx="${s/2-0.5}" cy="${s/2-0.5}" r="0.7" fill="#bbb" opacity="0.5"/>
    <ellipse cx="${s/2-3}" cy="${s/2-4}" rx="2" ry="1" fill="#a09040" opacity="0.25" transform="rotate(-20 ${s/2-3} ${s/2-4})"/>
  `));

  // Ragged Cloth â€” tattered body armor
  mgr.cache['item_armor_raggedCloth'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.1"/>
    <path d="M${s/2-7},8 L${s/2-9},${s-6} L${s/2+9},${s-6} L${s/2+7},8 L${s/2+3},5 L${s/2},7 L${s/2-3},5 Z" fill="#6a5030" stroke="#4a3010" stroke-width="0.8"/>
    <path d="M${s/2-7},8 L${s/2-9},${s-6} L${s/2+9},${s-6} L${s/2+7},8" fill="#8a6a40" opacity="0.6"/>
    <line x1="${s/2-4}" y1="12" x2="${s/2-6}" y2="${s-8}" stroke="#5a3a10" stroke-width="0.8" opacity="0.4"/>
    <line x1="${s/2+2}" y1="15" x2="${s/2+4}" y2="${s-10}" stroke="#5a3a10" stroke-width="0.6" opacity="0.3"/>
    <line x1="${s/2-2}" y1="${s/2}" x2="${s/2+3}" y2="${s/2+2}" stroke="#4a2a08" stroke-width="0.5" opacity="0.5"/>
    <line x1="${s/2-5}" y1="${s/2+5}" x2="${s/2}" y2="${s/2+4}" stroke="#4a2a08" stroke-width="0.5" opacity="0.4"/>
  `));

  // Chain Mail â€” heavier metallic armor
  mgr.cache['item_armor_chainMail'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.12"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8 L${s/2+4},4 L${s/2},6 L${s/2-4},4 Z" fill="#707080" stroke="#505060" stroke-width="1"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8" fill="#888898" opacity="0.7"/>
    <circle cx="${s/2-4}" cy="12" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2}" cy="12" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+4}" cy="12" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2-2}" cy="15" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+2}" cy="15" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2-4}" cy="18" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2}" cy="18" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+4}" cy="18" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2-2}" cy="21" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+2}" cy="21" r="0.8" fill="#aaa" opacity="0.3"/>
    <rect x="${s/2-1}" y="${s/2-1}" width="2" height="3" fill="#c8a040" rx="0.5"/>
  `));

  // â”€â”€ Food â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Bread / Ration â€” golden loaf with cross-score, sesame seeds, warm shadow
  mgr.cache['item_food'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+1}" ry="3" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+1}" ry="${s/4+1}" fill="#b08040"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#d0a050"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#dab870" opacity="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2-1}" rx="${s/4}" ry="${s/5}" fill="#e8c880" opacity="0.5"/>
    <ellipse cx="${s/2-2}" cy="${s/2-2}" rx="${s/6}" ry="${s/8}" fill="#f0d890" opacity="0.3"/>
    <line x1="${s/2-4}" y1="${s/2-1}" x2="${s/2+4}" y2="${s/2-1}" stroke="#c09040" stroke-width="0.6" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/2+2}" stroke="#c09040" stroke-width="0.6" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="0.5" fill="#c8a050" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="0.5" fill="#c8a050" opacity="0.6"/>
    <circle cx="${s/2+1}" cy="${s/2-1}" r="0.4" fill="#c8a050" opacity="0.5"/>
  `));

  // Green Herb â€” lush plant with multiple leaf shapes, veins, small flower bud
  mgr.cache['item_food_herb'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="${s/3-2}" stroke="#1a6a1a" stroke-width="2.5"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="${s/3-2}" stroke="#2a8a2a" stroke-width="1.8"/>
    <line x1="${s/2+0.5}" y1="${s-5}" x2="${s/2+0.5}" y2="${s/3-2}" stroke="#3a9a3a" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="${s/2-5}" cy="${s/3+3}" rx="4" ry="6.5" fill="#28882a" transform="rotate(-25 ${s/2-5} ${s/3+3})"/>
    <ellipse cx="${s/2-5}" cy="${s/3+3}" rx="3.5" ry="6" fill="#3aaa3a" transform="rotate(-25 ${s/2-5} ${s/3+3})" opacity="0.8"/>
    <line x1="${s/2-5}" y1="${s/3}" x2="${s/2-5}" y2="${s/3+7}" stroke="#1a7a1a" stroke-width="0.4" opacity="0.5" transform="rotate(-25 ${s/2-5} ${s/3+3})"/>
    <ellipse cx="${s/2+5}" cy="${s/3+1}" rx="4" ry="6.5" fill="#28882a" transform="rotate(25 ${s/2+5} ${s/3+1})"/>
    <ellipse cx="${s/2+5}" cy="${s/3+1}" rx="3.5" ry="6" fill="#3aaa3a" transform="rotate(25 ${s/2+5} ${s/3+1})" opacity="0.8"/>
    <line x1="${s/2+5}" y1="${s/3-2}" x2="${s/2+5}" y2="${s/3+5}" stroke="#1a7a1a" stroke-width="0.4" opacity="0.5" transform="rotate(25 ${s/2+5} ${s/3+1})"/>
    <ellipse cx="${s/2}" cy="${s/4-1}" rx="3.5" ry="5.5" fill="#30a032"/>
    <ellipse cx="${s/2}" cy="${s/4-1}" rx="3" ry="5" fill="#4aba4a" opacity="0.7"/>
    <line x1="${s/2}" y1="${s/4-4}" x2="${s/2}" y2="${s/4+3}" stroke="#1a8a1a" stroke-width="0.3" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/4-5}" r="1.5" fill="#e8e040" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/4-5}" r="0.8" fill="#fff" opacity="0.3"/>
  `));

  // Ration â€” travel pack with wrapping
  mgr.cache['item_food_ration'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <rect x="6" y="7" width="${s-12}" height="${s-14}" fill="#b09060" rx="2"/>
    <rect x="7" y="8" width="${s-14}" height="${s-16}" fill="#c8a870" rx="1.5" opacity="0.8"/>
    <line x1="${s/2-6}" y1="${s/2}" x2="${s/2+6}" y2="${s/2}" stroke="#8a6a40" stroke-width="1.5"/>
    <line x1="${s/2}" y1="8" x2="${s/2}" y2="${s-7}" stroke="#8a6a40" stroke-width="1.5"/>
    <rect x="${s/2-2}" y="${s/2-2}" width="4" height="4" fill="#907040" rx="1"/>
    <circle cx="${s/2}" cy="${s/2}" r="1.5" fill="#6a4a20"/>
  `));

  // Bread â€” golden loaf (keep existing as item_food, add specific)
  mgr.cache['item_food_bread'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+1}" ry="3" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+1}" ry="${s/4+1}" fill="#b08040"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#daa520"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#e8c060" opacity="0.8"/>
    <line x1="${s/2-4}" y1="${s/2-1}" x2="${s/2+4}" y2="${s/2-1}" stroke="#c09040" stroke-width="0.8" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/2+2}" stroke="#c09040" stroke-width="0.6" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="0.6" fill="#d4a840" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="0.5" fill="#d4a840" opacity="0.5"/>
  `));

  // Grand Feast â€” large plate with multiple items
  mgr.cache['item_food_feast'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+5}" rx="${s/3+3}" ry="4" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+3}" ry="${s/4+2}" fill="#ddd" stroke="#bbb" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+2}" ry="${s/4+1}" fill="#eee" opacity="0.6"/>
    <ellipse cx="${s/2-4}" cy="${s/2}" rx="4" ry="3" fill="#b08040"/>
    <ellipse cx="${s/2-4}" cy="${s/2-1}" rx="3.5" ry="2.5" fill="#d0a050" opacity="0.8"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="3" fill="#cc3344"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="2" fill="#dd5566" opacity="0.5"/>
    <ellipse cx="${s/2+1}" cy="${s/2+2}" rx="2" ry="1.5" fill="#daa520"/>
    <circle cx="${s/2-2}" cy="${s/3}" r="1.5" fill="#3a8a3a" opacity="0.6"/>
    <circle cx="${s/2+5}" cy="${s/3+2}" r="0.8" fill="#fa4" opacity="0.7"/>
  `));

  // Generic Berries â€” red berry cluster fallback
  mgr.cache['item_food_berry'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#cc3344"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.5"/>
  `));

  // Generic Mushroom â€” brown cap, pale stem
  mgr.cache['item_food_mushroom'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#c8b090" rx="1"/>
    <rect x="${s/2-1.5}" y="${s/2+2}" width="3" height="${s/3}" fill="#d8c0a0" rx="0.5" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/4}" ry="${s/6}" fill="#aa7744"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4-1}" ry="${s/6-1}" fill="#bb8855" opacity="0.7"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/6}" ry="${s/8}" fill="#cc9966" opacity="0.4"/>
  `));

  // Generic Fish â€” simple silver fish
  mgr.cache['item_food_fish'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+2}" ry="${s/5}" fill="#6a8aaa" stroke="#5a7a9a" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/5-1}" fill="#7a9aba" opacity="0.6"/>
    <ellipse cx="${s/2-1}" cy="${s/2-1}" rx="${s/5}" ry="${s/8}" fill="#8aaacc" opacity="0.4"/>
    <polygon points="${s/2+10},${s/2} ${s/2+14},${s/2-4} ${s/2+14},${s/2+4}" fill="#5a7a9a" opacity="0.8"/>
    <circle cx="${s/2-6}" cy="${s/2-1}" r="1.2" fill="#222" opacity="0.6"/>
    <circle cx="${s/2-6}" cy="${s/2-1}" r="0.5" fill="#fff" opacity="0.5"/>
  `));

  // â”€â”€ Specific Berries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Red Berries â€” red cluster
  mgr.cache['item_food_berryRed'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#cc3344"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.5"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.4"/>
  `));

  // Blue Berries â€” blue cluster
  mgr.cache['item_food_berryBlue'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#4466cc"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#4466cc"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#4466cc"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#6688dd" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#6688dd" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#6688dd" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.5"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.6" fill="#ccf" opacity="0.4"/>
  `));

  // Poison Berries â€” purple/green toxic
  mgr.cache['item_food_berryPoison'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#4a4a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#4a4a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#884488"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#884488"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#884488"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#995599" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#995599" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#995599" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#d8d" opacity="0.4"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.6" fill="#d8d" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/3-1}" r="1.5" fill="#a0f" opacity="0.15"/>
  `));

  // â”€â”€ Specific Mushrooms â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Glowing Mushroom â€” teal glow
  mgr.cache['item_resource_glowMushroom'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#44ddaa" opacity="0.12"/>
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#88ccaa" rx="1"/>
    <rect x="${s/2-1.5}" y="${s/2+2}" width="3" height="${s/3}" fill="#99ddbb" rx="0.5" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/4}" ry="${s/6}" fill="#33bb88"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4-1}" ry="${s/6-1}" fill="#44ddaa" opacity="0.8"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/6}" ry="${s/8}" fill="#66eebb" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3}" fill="#44ddaa" opacity="0.12"/>
    <circle cx="${s/2-3}" cy="${s/2}" r="1" fill="#aaffdd" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="0.8" fill="#aaffdd" opacity="0.4"/>
  `));

  // Poison Mushroom â€” red cap with spots
  mgr.cache['item_food_mushroomPoison'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#c8b090" rx="1"/>
    <rect x="${s/2-1.5}" y="${s/2+2}" width="3" height="${s/3}" fill="#d8c0a0" rx="0.5" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/4}" ry="${s/6}" fill="#cc4444"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4-1}" ry="${s/6-1}" fill="#dd5555" opacity="0.7"/>
    <circle cx="${s/2-3}" cy="${s/2}" r="1.2" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1" fill="#fff" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.8" fill="#fff" opacity="0.4"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.7" fill="#fff" opacity="0.3"/>
  `));

  // â”€â”€ Specific Fish â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Rare Fish â€” larger, more colorful
  mgr.cache['item_food_rareFish'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+3}" ry="${s/5+1}" fill="#44aadd" stroke="#2288bb" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+1}" ry="${s/5}" fill="#55bbee" opacity="0.7"/>
    <ellipse cx="${s/2-2}" cy="${s/2-2}" rx="${s/5}" ry="${s/8}" fill="#66ccff" opacity="0.5"/>
    <polygon points="${s/2+12},${s/2} ${s/2+16},${s/2-5} ${s/2+16},${s/2+5}" fill="#3399cc" opacity="0.8"/>
    <circle cx="${s/2-7}" cy="${s/2-1}" r="1.4" fill="#222" opacity="0.6"/>
    <circle cx="${s/2-7}" cy="${s/2-1}" r="0.6" fill="#fff" opacity="0.6"/>
    <line x1="${s/2-3}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2+1}" stroke="#ffd700" stroke-width="0.8" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2-2}" r="0.5" fill="#fff" opacity="0.4"/>
  `));

  // â”€â”€ Crop Foods (harvested) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Turnip â€” white/purple root vegetable
  mgr.cache['item_food_turnip'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="6" ry="7" fill="#e8e0d0"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="5.5" ry="6" fill="#f0eae0" opacity="0.8"/>
    <ellipse cx="${s/2}" cy="${s/3+1}" rx="5" ry="3" fill="#9944aa" opacity="0.5"/>
    <line x1="${s/2}" y1="4" x2="${s/2-2}" y2="1" stroke="#2a8a2a" stroke-width="1.5"/>
    <line x1="${s/2}" y1="4" x2="${s/2+2}" y2="2" stroke="#3a9a3a" stroke-width="1.2"/>
    <circle cx="${s/2-2}" cy="${s/2+2}" r="0.5" fill="#ddd" opacity="0.4"/>
  `));

  // Potato â€” brown lumpy tuber
  mgr.cache['item_food_potato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="8" ry="6" fill="#a08050"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="7" ry="5" fill="#b89060" opacity="0.8"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="4" ry="3" fill="#c8a070" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2+1}" r="0.8" fill="#8a6a40" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="0.6" fill="#8a6a40" opacity="0.4"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="0.5" fill="#8a6a40" opacity="0.3"/>
  `));

  // Strawberry â€” red heart shape with seeds
  mgr.cache['item_food_strawberry'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2},${s/3} Q${s/2-8},${s/3+2} ${s/2},${s-5} Q${s/2+8},${s/3+2} ${s/2},${s/3}" fill="#dd3344"/>
    <path d="M${s/2},${s/3} Q${s/2-6},${s/3+2} ${s/2-2},${s/2+4}" fill="#ee5566" opacity="0.5"/>
    <circle cx="${s/2-2}" cy="${s/2+1}" r="0.5" fill="#ffa" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.5" fill="#ffa" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+4}" r="0.5" fill="#ffa" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2+4}" r="0.4" fill="#ffa" opacity="0.3"/>
    <ellipse cx="${s/2}" cy="${s/3-1}" rx="4" ry="2" fill="#2a8a2a" opacity="0.6"/>
  `));

  // Corn â€” golden ear with husk
  mgr.cache['item_food_corn'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="5" ry="9" fill="#daa520"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="4.5" ry="8.5" fill="#e8c040" opacity="0.8"/>
    <line x1="${s/2}" y1="${s/3}" x2="${s/2}" y2="${s*2/3}" stroke="#c8a020" stroke-width="0.5" opacity="0.5"/>
    <line x1="${s/2-3}" y1="${s/3+1}" x2="${s/2-3}" y2="${s*2/3-1}" stroke="#c8a020" stroke-width="0.4" opacity="0.3"/>
    <line x1="${s/2+3}" y1="${s/3+1}" x2="${s/2+3}" y2="${s*2/3-1}" stroke="#c8a020" stroke-width="0.4" opacity="0.3"/>
    <path d="M${s/2-5},${s/2} Q${s/2-9},${s/3} ${s/2-4},${s/4}" fill="#5a8a2a" opacity="0.5"/>
    <path d="M${s/2+5},${s/2} Q${s/2+9},${s/3} ${s/2+4},${s/4}" fill="#5a8a2a" opacity="0.4"/>
  `));

  // Tomato â€” round red fruit with star calyx
  mgr.cache['item_food_tomato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="8" fill="#cc3322"/>
    <circle cx="${s/2}" cy="${s/2}" r="7.5" fill="#dd4433" opacity="0.8"/>
    <circle cx="${s/2-2}" cy="${s/2-2}" r="4" fill="#ee5544" opacity="0.3"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#ff8877" opacity="0.3"/>
    <polygon points="${s/2},${s/4-2} ${s/2-3},${s/4+1} ${s/2+3},${s/4+1}" fill="#2a8a2a" opacity="0.7"/>
    <polygon points="${s/2-2},${s/4-1} ${s/2-4},${s/4+2} ${s/2},${s/4+2}" fill="#3a9a3a" opacity="0.5"/>
    <polygon points="${s/2+2},${s/4-1} ${s/2+4},${s/4+2} ${s/2},${s/4+2}" fill="#3a9a3a" opacity="0.5"/>
  `));

  // Carrot â€” orange root with green top
  mgr.cache['item_food_carrot'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-3},${s/3+2} Q${s/2},${s-2} ${s/2+1},${s-4}" fill="#e87020" stroke="#c06018" stroke-width="0.5"/>
    <path d="M${s/2+3},${s/3+2} Q${s/2},${s-2} ${s/2-1},${s-4}" fill="#f08030" opacity="0.6"/>
    <line x1="${s/2}" y1="${s/2}" x2="${s/2}" y2="${s/2+4}" stroke="#c06018" stroke-width="0.3" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/3+2}" x2="${s/2-3}" y2="${s/4-2}" stroke="#2a8a2a" stroke-width="1.5"/>
    <line x1="${s/2}" y1="${s/3+2}" x2="${s/2+2}" y2="${s/4-3}" stroke="#3a9a3a" stroke-width="1.2"/>
    <line x1="${s/2}" y1="${s/3+2}" x2="${s/2+4}" y2="${s/4}" stroke="#2a8a2a" stroke-width="1"/>
  `));

  // Pumpkin â€” large orange round
  mgr.cache['item_food_pumpkin'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="9" ry="8" fill="#e80"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="8.5" ry="7.5" fill="#fa2" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/3}" x2="${s/2}" y2="${s*2/3+2}" stroke="#c60" stroke-width="1" opacity="0.4"/>
    <path d="M${s/2-5},${s/3+1} Q${s/2-5},${s/2+8} ${s/2-3},${s*2/3+2}" stroke="#c60" stroke-width="0.6" opacity="0.3" fill="none"/>
    <path d="M${s/2+5},${s/3+1} Q${s/2+5},${s/2+8} ${s/2+3},${s*2/3+2}" stroke="#c60" stroke-width="0.6" opacity="0.3" fill="none"/>
    <rect x="${s/2-1}" y="${s/3-3}" width="2" height="4" fill="#5a3a1a" rx="0.5"/>
    <ellipse cx="${s/2+2}" cy="${s/3-2}" rx="3" ry="1.5" fill="#3a9a2a" opacity="0.5"/>
  `));

  // Wheat â€” bundle of golden stalks
  mgr.cache['item_food_wheat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2-3}" y1="${s-5}" x2="${s/2-2}" y2="6" stroke="#da4" stroke-width="1.5"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="4" stroke="#da4" stroke-width="1.5"/>
    <line x1="${s/2+3}" y1="${s-5}" x2="${s/2+2}" y2="5" stroke="#da4" stroke-width="1.5"/>
    <ellipse cx="${s/2-2}" cy="5" rx="2" ry="4" fill="#da4"/>
    <ellipse cx="${s/2}" cy="3" rx="2" ry="4" fill="#eb5"/>
    <ellipse cx="${s/2+2}" cy="4" rx="2" ry="4" fill="#da4"/>
    <line x1="${s/2-3}" y1="${s-6}" x2="${s/2+3}" y2="${s-6}" stroke="#a83" stroke-width="1"/>
    <line x1="${s/2-2}" y1="${s-7}" x2="${s/2+2}" y2="${s-7}" stroke="#a83" stroke-width="0.5" opacity="0.5"/>
  `));

  // Medicinal Herb â€” specific crop herb (green, with medicinal look)
  mgr.cache['item_food_cropHerb'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="${s/3}" stroke="#1a7a1a" stroke-width="2"/>
    <ellipse cx="${s/2-5}" cy="${s/3+2}" rx="4" ry="5" fill="#0c0" transform="rotate(-20 ${s/2-5} ${s/3+2})"/>
    <ellipse cx="${s/2+5}" cy="${s/3}" rx="4" ry="5" fill="#0c0" transform="rotate(20 ${s/2+5} ${s/3})"/>
    <ellipse cx="${s/2}" cy="${s/4}" rx="3" ry="5" fill="#0e0" opacity="0.7"/>
    <circle cx="${s/2}" cy="${s/4-4}" r="2" fill="#fff" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/4-4}" r="1" fill="#f44" opacity="0.5"/>
    <line x1="${s/2-5}" y1="${s/3+2}" x2="${s/2-5}" y2="${s/3+6}" stroke="#0a0" stroke-width="0.3" opacity="0.5"/>
    <line x1="${s/2+5}" y1="${s/3}" x2="${s/2+5}" y2="${s/3+4}" stroke="#0a0" stroke-width="0.3" opacity="0.5"/>
  `));

  // â”€â”€ Potions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Potion of Healing â€” red liquid, glass bottle with cork, label, bubbles, glow
  mgr.cache['item_potion_heal'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#a02020" opacity="0.15"/>
    <rect x="${s/2-3}" y="5" width="6" height="4" fill="#999" rx="1.5"/>
    <rect x="${s/2-2.5}" y="5" width="5" height="2" fill="#b5a070" rx="1"/>
    <rect x="${s/2-2}" y="5" width="4" height="1" fill="#c8b080" rx="0.5" opacity="0.6"/>
    <path d="M${s/2-3},9 L${s/2-6},${s/2} L${s/2-6},${s-6} Q${s/2-6},${s-3} ${s/2-3},${s-3} L${s/2+3},${s-3} Q${s/2+6},${s-3} ${s/2+6},${s-6} L${s/2+6},${s/2} L${s/2+3},9 Z" fill="#b83030" stroke="#8a2020" stroke-width="0.8"/>
    <path d="M${s/2-3},9 L${s/2-5},${s/2} L${s/2-5},${s-6} Q${s/2-5},${s-4} ${s/2-3},${s-4} L${s/2-1},${s-4} L${s/2-1},${s/2} L${s/2-2},9 Z" fill="#d04040" opacity="0.4"/>
    <ellipse cx="${s/2}" cy="${s-5}" rx="4" ry="2" fill="#e06060" opacity="0.25"/>
    <circle cx="${s/2-2}" cy="${s/2+3}" r="1" fill="#e88" opacity="0.5"/>
    <circle cx="${s/2+1}" cy="${s/2+5}" r="0.7" fill="#e88" opacity="0.4"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.5" fill="#faa" opacity="0.4"/>
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="3" fill="#c8a860" rx="0.5" opacity="0.3"/>
    <line x1="${s/2-2}" y1="${s/2+3}" x2="${s/2+2}" y2="${s/2+3}" stroke="#a08040" stroke-width="0.3" opacity="0.5"/>
    <line x1="${s/2+4}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2-1}" stroke="#fcc" stroke-width="0.5" opacity="0.4"/>
  `));

  // Potion of Mana â€” blue liquid, glass bottle with cork, sparkles, glow
  mgr.cache['item_potion_mana'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#2040a0" opacity="0.15"/>
    <rect x="${s/2-3}" y="5" width="6" height="4" fill="#999" rx="1.5"/>
    <rect x="${s/2-2.5}" y="5" width="5" height="2" fill="#b5a070" rx="1"/>
    <rect x="${s/2-2}" y="5" width="4" height="1" fill="#c8b080" rx="0.5" opacity="0.6"/>
    <path d="M${s/2-3},9 L${s/2-6},${s/2} L${s/2-6},${s-6} Q${s/2-6},${s/3} ${s/2-3},${s-3} L${s/2+3},${s-3} Q${s/2+6},${s-3} ${s/2+6},${s-6} L${s/2+6},${s/2} L${s/2+3},9 Z" fill="#3050b8" stroke="#203898" stroke-width="0.8"/>
    <path d="M${s/2-3},9 L${s/2-5},${s/2} L${s/2-5},${s-6} Q${s/2-5},${s-4} ${s/2-3},${s-4} L${s/2-1},${s-4} L${s/2-1},${s/2} L${s/2-2},9 Z" fill="#4060d0" opacity="0.4"/>
    <ellipse cx="${s/2}" cy="${s-5}" rx="4" ry="2" fill="#6080e0" opacity="0.25"/>
    <circle cx="${s/2-2}" cy="${s/2+3}" r="1" fill="#88c" opacity="0.5"/>
    <circle cx="${s/2+1}" cy="${s/2+5}" r="0.7" fill="#88c" opacity="0.4"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.5" fill="#aaf" opacity="0.4"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.6" fill="#ccf" opacity="0.3"/>
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="3" fill="#a0a0d0" rx="0.5" opacity="0.2"/>
    <line x1="${s/2+4}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2-1}" stroke="#ccf" stroke-width="0.5" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+6}" r="0.4" fill="#eef" opacity="0.5"/>
  `));

  // â”€â”€ Generic Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Generic Ore â€” grey rock chunk
  mgr.cache['item_resource_ore'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#666" stroke="#444" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#777" opacity="0.5"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#888" opacity="0.4"/>
    <line x1="${s/2-5}" y1="${s/2}" x2="${s/2}" y2="${s/3}" stroke="#999" stroke-width="1" opacity="0.5"/>
  `));

  // Generic Wood Log â€” brown log cross-section
  mgr.cache['item_resource_wood'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#6a3a10" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#8a5a20" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#a07030" rx="3.5" opacity="0.4"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#5a2a08" stroke-width="0.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+5}" x2="${s-7}" y2="${s/3+5}" stroke="#5a2a08" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#5a2a08" stroke="#4a1a05" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#b08040"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#5a2a08"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#5a2a08" stroke="#4a1a05" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#b08040"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#5a2a08"/>
  `));

  // Leather â€” tanned hide piece
  mgr.cache['item_resource_leather'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <path d="M${s/2-7},${s/3} Q${s/2-8},${s/2-4} ${s/2-5},${s/2+5} Q${s/2-2},${s-5} ${s/2+4},${s-5} Q${s/2+8},${s-6} ${s/2+8},${s/2+2} Q${s/2+9},${s/3} ${s/2+5},${s/4} Q${s/2+2},${s/5} ${s/2-4},${s/3-1} Z" fill="#a86" stroke="#865" stroke-width="0.8"/>
    <path d="M${s/2-5},${s/3+1} Q${s/2-3},${s/2} ${s/2+2},${s/2+2}" fill="#c9a" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="0.5" fill="#865" opacity="0.5"/>
  `));

  // String â€” coiled twine
  mgr.cache['item_resource_string'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="5" ry="5" fill="none" stroke="#ccc" stroke-width="1.5"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="3" ry="3" fill="none" stroke="#ccc" stroke-width="1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="1" ry="1" fill="none" stroke="#ccc" stroke-width="0.5"/>
    <circle cx="${s/2+5}" cy="${s/2}" r="0.8" fill="#ddd"/>
  `));

  // Empty Bottle â€” glass bottle
  mgr.cache['item_resource_bottle'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-2}" y="5" width="4" height="4" fill="#999" rx="1"/>
    <rect x="${s/2-1.5}" y="5" width="3" height="2" fill="#b0a070" rx="0.5"/>
    <path d="M${s/2-2},9 L${s/2-4},${s/2} L${s/2-4},${s-6} Q${s/2-4},${s-3} ${s/2},${s-3} Q${s/2+4},${s-3} ${s/2+4},${s-6} L${s/2+4},${s/2} L${s/2+2},9 Z" fill="#aaeeff" stroke="#88ccdd" stroke-width="0.5" opacity="0.5"/>
    <path d="M${s/2-2},9 L${s/2-3},${s/2} L${s/2-3},${s-6} L${s/2-1},${s-6} L${s/2-1},${s/2} Z" fill="#ccf" opacity="0.2"/>
  `));

  // Blue Crystal â€” faceted gem
  mgr.cache['item_resource_crystal'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#48f" opacity="0.15"/>
    <polygon points="${s/2},3 ${s/2+5},${s/2} ${s/2+3},${s-5} ${s/2-3},${s-5} ${s/2-5},${s/2}" fill="#48f" stroke="#36c" stroke-width="0.8"/>
    <polygon points="${s/2},3 ${s/2+5},${s/2} ${s/2},${s/2-2}" fill="#6af" opacity="0.5"/>
    <polygon points="${s/2},3 ${s/2-5},${s/2} ${s/2-2},${s/2-2}" fill="#8cf" opacity="0.3"/>
    <circle cx="${s/2-1}" cy="${s/3}" r="1" fill="#adf" opacity="0.6"/>
  `));

  // Clay â€” brown lump
  mgr.cache['item_resource_clay'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="8" ry="6" fill="#b07050"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="7" ry="5" fill="#c08060" opacity="0.7"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="4" ry="3" fill="#d09070" opacity="0.4"/>
  `));

  // Sand â€” pile of sand
  mgr.cache['item_resource_sand'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="9" ry="6" fill="#c8b868"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="8" ry="5" fill="#d8c878" opacity="0.8"/>
    <ellipse cx="${s/2-2}" cy="${s/2}" rx="5" ry="3" fill="#e8d888" opacity="0.4"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.4" fill="#b8a858" opacity="0.5"/>
  `));

  // Flint â€” dark chipped stone
  mgr.cache['item_resource_flint'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <polygon points="${s/2-3},5 ${s/2+5},${s/3} ${s/2+4},${s-6} ${s/2-4},${s-5} ${s/2-6},${s/2}" fill="#555544" stroke="#444433" stroke-width="0.8"/>
    <polygon points="${s/2-3},5 ${s/2+5},${s/3} ${s/2+1},${s/3+1}" fill="#666655" opacity="0.5"/>
    <line x1="${s/2-2}" y1="7" x2="${s/2+3}" y2="${s/3+2}" stroke="#777766" stroke-width="0.5" opacity="0.6"/>
  `));

  // Reeds â€” bundle of green reeds
  mgr.cache['item_resource_reeds'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2-4}" y1="${s-4}" x2="${s/2-3}" y2="4" stroke="#7a9a4a" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="3" stroke="#8aaa5a" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-4}" x2="${s/2+3}" y2="5" stroke="#7a9a4a" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2-2}" y1="${s-5}" x2="${s/2+2}" y2="${s-5}" stroke="#6a8a3a" stroke-width="1"/>
  `));

  // Bark â€” flat strip of bark
  mgr.cache['item_resource_bark'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-6}" y="${s/3}" width="12" height="${s/3}" fill="#6a4a2a" rx="2"/>
    <rect x="${s/2-5}" y="${s/3+1}" width="10" height="${s/3-2}" fill="#7a5a3a" opacity="0.7" rx="1"/>
    <line x1="${s/2-4}" y1="${s/3+2}" x2="${s/2+4}" y2="${s/3+2}" stroke="#5a3a1a" stroke-width="0.5" opacity="0.4"/>
    <line x1="${s/2-3}" y1="${s/3+5}" x2="${s/2+3}" y2="${s/3+5}" stroke="#5a3a1a" stroke-width="0.4" opacity="0.3"/>
  `));

  // Tree Sap â€” amber droplet
  mgr.cache['item_resource_sap'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#d8a030" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="5" ry="6" fill="#d8a030"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="4" ry="5" fill="#e8b040" opacity="0.7"/>
    <ellipse cx="${s/2-1}" cy="${s/2-2}" rx="2.5" ry="3" fill="#f0c050" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2-3}" r="1" fill="#fff" opacity="0.3"/>
  `));

  // Amber â€” golden gem
  mgr.cache['item_resource_amber'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#cc8800" opacity="0.15"/>
    <polygon points="${s/2},4 ${s/2+5},${s/3} ${s/2+4},${s-5} ${s/2-4},${s-5} ${s/2-5},${s/3}" fill="#cc8800" stroke="#aa6600" stroke-width="0.8"/>
    <polygon points="${s/2},4 ${s/2+5},${s/3} ${s/2},${s/3+1}" fill="#e0a020" opacity="0.5"/>
    <polygon points="${s/2},4 ${s/2-5},${s/3} ${s/2-1},${s/3}" fill="#eebb40" opacity="0.3"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="0.8" fill="#ffd060" opacity="0.6"/>
  `));

  // Pearl â€” lustrous white sphere
  mgr.cache['item_resource_pearl'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.06"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#ddd0ee" stroke="#ccbbdd" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#eeddff" opacity="0.7"/>
    <circle cx="${s/2-2}" cy="${s/2-2}" r="2.5" fill="#fff" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2-2}" r="1" fill="#fff" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.5" fill="#ddc" opacity="0.3"/>
  `));

  // Driftwood â€” pale weathered wood
  mgr.cache['item_resource_driftwood'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M5,${s/2} Q${s/3},${s/3} ${s/2},${s/2-2} Q${s*2/3},${s/2+3} ${s-5},${s/2+1}" stroke="#9a8a6a" stroke-width="3.5" stroke-linecap="round" fill="none"/>
    <path d="M5,${s/2} Q${s/3},${s/3} ${s/2},${s/2-2} Q${s*2/3},${s/2+3} ${s-5},${s/2+1}" stroke="#b0a080" stroke-width="2.5" stroke-linecap="round" fill="none"/>
    <circle cx="${s/3}" cy="${s/3+2}" r="0.5" fill="#a09070" opacity="0.5"/>
  `));

  // Gold Coin â€” shiny gold piece
  mgr.cache['item_gold'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1" fill="#000" opacity="0.1"/>
    <circle cx="${s/2}" cy="${s/2}" r="7" fill="#c8a020" stroke="#a08010" stroke-width="1"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#e8c040" opacity="0.8"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#f0d050" opacity="0.5"/>
    <text x="${s/2}" y="${s/2+3}" text-anchor="middle" font-size="9" font-weight="bold" fill="#a08010" font-family="serif">$</text>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#ffd700" opacity="0.3"/>
    <circle cx="${s/2-1}" cy="${s/2-2}" r="0.7" fill="#fff" opacity="0.3"/>
  `));

  // â”€â”€ Individual Ore Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Iron Ore â€” grey rock with silver veins
  mgr.cache['item_resource_oreIron'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#666" stroke="#444" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#777" opacity="0.7"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#8a8a90" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#aaa" stroke-width="1" opacity="0.7"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#999" stroke-width="0.8" opacity="0.6"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="0.8" fill="#ddd" opacity="0.6"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.6" fill="#ccc" opacity="0.4"/>
  `));

  // Copper Ore â€” brownish-orange rock with green patina
  mgr.cache['item_resource_oreCopper'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#6a5040" stroke="#4a3020" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#7a6050" opacity="0.7"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#8a7060" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#b87333" stroke-width="1.2" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#b87333" stroke-width="1" opacity="0.7"/>
    <line x1="${s/2-3}" y1="${s-8}" x2="${s/2+1}" y2="${s/2+2}" stroke="#d08840" stroke-width="0.6" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2+1}" r="1.2" fill="#5a8a5a" opacity="0.35"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="0.8" fill="#e8a060" opacity="0.6"/>
  `));

  // Silver Ore â€” pale bluish-grey rock with bright veins
  mgr.cache['item_resource_oreSilver'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#7a7a8a" stroke="#5a5a6a" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#9090a0" opacity="0.6"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#a0a0b8" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#c0c0d0" stroke-width="1.2" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#c0c0e0" stroke-width="1" opacity="0.7"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="1" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.8" fill="#eef" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2+3}" r="0.5" fill="#ddf" opacity="0.4"/>
  `));

  // Gold Ore â€” dark rock with gold veins and sparkle
  mgr.cache['item_resource_oreGold'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#5a5040" stroke="#3a3020" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#6a6050" opacity="0.7"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#7a7060" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#ffd700" stroke-width="1.5" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#ffd700" stroke-width="1.2" opacity="0.7"/>
    <line x1="${s/2-3}" y1="${s-8}" x2="${s/2+1}" y2="${s/2+2}" stroke="#e8c020" stroke-width="0.8" opacity="0.6"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="1" fill="#ffd700" opacity="0.7"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.8" fill="#ffe040" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2+3}" r="0.6" fill="#fff" opacity="0.5"/>
  `));

  // Mythril Ore â€” blue-silver rock with ethereal glow
  mgr.cache['item_resource_oreMythril'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#66ccff" opacity="0.1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#556678" stroke="#445568" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#667788" opacity="0.6"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#7788aa" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#66ccff" stroke-width="1.5" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#66ccff" stroke-width="1.2" opacity="0.7"/>
    <line x1="${s/2-3}" y1="${s-8}" x2="${s/2+1}" y2="${s/2+2}" stroke="#88ddff" stroke-width="0.8" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3}" fill="#66ccff" opacity="0.08"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="1.2" fill="#aaeeff" opacity="0.7"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.8" fill="#ccf" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2+3}" r="0.6" fill="#fff" opacity="0.5"/>
  `));

  // â”€â”€ Individual Wood Log Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Generic Wood Log â€” keep existing item_resource_wood

  // Oak Log â€” darker, wider rings
  mgr.cache['item_resource_oakLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#5a3a10" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#6a4a20" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#7a5a30" rx="3.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#4a2a08" stroke-width="0.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+5}" x2="${s-7}" y2="${s/3+5}" stroke="#4a2a08" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#4a2a08" stroke="#3a1a05" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#8a6a30"/>
    <ellipse cx="5" cy="${s/2}" rx="2.2" ry="${s/8}" fill="#7a5a20" opacity="0.7"/>
    <ellipse cx="5" cy="${s/2}" rx="1.5" ry="${s/10}" fill="#6a4a18" opacity="0.5"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#4a2a08"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#4a2a08" stroke="#3a1a05" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#8a6a30"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#4a2a08"/>
  `));

  // Pine Log â€” lighter, greenish tint
  mgr.cache['item_resource_pineLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#a08050" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#b89060" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#c8a070" rx="3.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#8a6a40" stroke-width="0.5" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#8a6a38" stroke="#7a5a28" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#c8a060"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#8a6a38"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#8a6a38" stroke="#7a5a28" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#c8a060"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#8a6a38"/>
    <circle cx="${s/2}" cy="${s/3+3}" r="1.5" fill="#6a8a40" opacity="0.2"/>
  `));

  // Birch Log â€” pale white bark
  mgr.cache['item_resource_birchLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.08"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#c8b890" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#d8c8a0" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#e8d8b0" rx="3.5" opacity="0.5"/>
    <line x1="8" y1="${s/3+1}" x2="${s-8}" y2="${s/3+1}" stroke="#b0a070" stroke-width="0.6" opacity="0.3"/>
    <line x1="9" y1="${s/3+4}" x2="${s-9}" y2="${s/3+4}" stroke="#b0a070" stroke-width="0.5" opacity="0.2"/>
    <line x1="10" y1="${s/3+7}" x2="${s-10}" y2="${s/3+7}" stroke="#b0a070" stroke-width="0.4" opacity="0.2"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#b0a078" stroke="#a09068" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#e0d0a8"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#b0a078"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#b0a078" stroke="#a09068" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#e0d0a8"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#b0a078"/>
  `));

  // Maple Log â€” reddish-orange bark
  mgr.cache['item_resource_mapleLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#a04818" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#c06020" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#d07030" rx="3.5" opacity="0.4"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#803810" stroke-width="0.5" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#803810" stroke="#702808" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#c08040"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#803810"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#803810" stroke="#702808" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#c08040"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#803810"/>
  `));

  // Yew Log â€” very dark wood
  mgr.cache['item_resource_yewLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.12"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#3a2010" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#5a3a1a" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#6a4a2a" rx="3.5" opacity="0.4"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#2a1008" stroke-width="0.6" opacity="0.5"/>
    <line x1="7" y1="${s/3+5}" x2="${s-7}" y2="${s/3+5}" stroke="#2a1008" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#2a1008" stroke="#1a0805" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#6a4a28"/>
    <ellipse cx="5" cy="${s/2}" rx="2" ry="${s/8}" fill="#5a3a18" opacity="0.7"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#2a1008"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#2a1008" stroke="#1a0805" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#6a4a28"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#2a1008"/>
  `));

  // â”€â”€ Tools â€” Tiered â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Woodcutting Axe (tool) â€” hatchet shape
  mgr.cache['item_tool_axe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-10},${s/3} ${s/2-6},${s/3+2} L${s/2-3},${s/4}" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-9},${s/3-2} ${s/2-5},${s/3}" fill="#aaa" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="8" r="0.8" fill="#ccc" opacity="0.5"/>
  `));

  // Pickaxe (tool) â€” pick head on a handle
  mgr.cache['item_tool_pickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+10},10 L${s/2+8},12 L${s/2-8},12 L${s/2-10},10 Z" fill="#777" stroke="#555" stroke-width="0.8"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+10},10 L${s/2-10},10 Z" fill="#999" opacity="0.5"/>
    <line x1="${s/2-9}" y1="10" x2="${s/2-11}" y2="11" stroke="#888" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-8}" cy="10" r="0.6" fill="#bbb" opacity="0.5"/>
    <circle cx="${s/2+8}" cy="10" r="0.6" fill="#bbb" opacity="0.5"/>
  `));

  // Iron Woodcutter's Axe â€” polished iron head
  mgr.cache['item_tool_ironAxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-11},${s/3} ${s/2-6},${s/3+2} L${s/2-3},${s/4}" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-9},${s/3-2} ${s/2-5},${s/3}" fill="#aaa" opacity="0.5"/>
    <line x1="${s/2-9}" y1="${s/3-1}" x2="${s/2-5}" y2="${s/4+1}" stroke="#ccc" stroke-width="0.4" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="8" r="0.8" fill="#ddd" opacity="0.6"/>
  `));

  // Steel Woodcutter's Axe â€” shinier blade
  mgr.cache['item_tool_steelAxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-12},${s/3} ${s/2-6},${s/3+3} L${s/2-3},${s/4}" fill="#a0a0b0" stroke="#808090" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-10},${s/3-2} ${s/2-5},${s/3}" fill="#c0c0d0" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#b0b0c0" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-9}" cy="10" r="0.6" fill="#ddd" opacity="0.6"/>
    <circle cx="${s/2+9}" cy="10" r="0.6" fill="#ddd" opacity="0.6"/>
    <line x1="${s/2-6}" y1="9" x2="${s/2+6}" y2="9" stroke="#e0e0f0" stroke-width="0.3" opacity="0.4"/>
  `));

  // Mythril Woodcutter's Axe â€” blue glow
  mgr.cache['item_tool_mythrilAxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#66ccff" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-12},${s/3} ${s/2-6},${s/3+3} L${s/2-3},${s/4}" fill="#66aacc" stroke="#4488aa" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-10},${s/3-2} ${s/2-5},${s/3}" fill="#88ccee" opacity="0.5"/>
    <circle cx="${s/2-7}" cy="${s/3}" r="${s/4}" fill="#66ccff" opacity="0.08"/>
    <circle cx="${s/2-5}" cy="8" r="1" fill="#aaeeff" opacity="0.7"/>
    <circle cx="${s/2-8}" cy="${s/3+1}" r="0.5" fill="#fff" opacity="0.5"/>
  `));

  // Stone Pickaxe â€” crude stone head
  mgr.cache['item_tool_stonePickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+9},10 L${s/2+7},12 L${s/2-7},12 L${s/2-9},10 Z" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+9},10 L${s/2-9},10 Z" fill="#999" opacity="0.4"/>
    <circle cx="${s/2-7}" cy="10" r="0.5" fill="#aaa" opacity="0.3"/>
  `));

  // Iron Pickaxe â€” polished iron head
  mgr.cache['item_tool_ironPickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-9},8 L${s/2+9},8 L${s/2+11},10 L${s/2+9},12 L${s/2-9},12 L${s/2-11},10 Z" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-9},8 L${s/2+9},8 L${s/2+11},10 L${s/2-11},10 Z" fill="#aaa" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#999" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-9}" cy="10" r="0.6" fill="#ccc" opacity="0.5"/>
    <circle cx="${s/2+9}" cy="10" r="0.6" fill="#ccc" opacity="0.5"/>
  `));

  // Steel Pickaxe â€” gleaming steel
  mgr.cache['item_tool_steelPickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2+9},13 L${s/2-9},13 L${s/2-11},10 Z" fill="#99a" stroke="#778" stroke-width="0.8"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2-11},10 Z" fill="#bbc" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#aab" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-9}" cy="10" r="0.7" fill="#dde" opacity="0.5"/>
    <circle cx="${s/2+9}" cy="10" r="0.7" fill="#dde" opacity="0.5"/>
    <line x1="${s/2-3}" y1="9" x2="${s/2+3}" y2="9" stroke="#fff" stroke-width="0.3" opacity="0.3"/>
  `));

  // Mythril Pickaxe â€” ethereal blue-silver
  mgr.cache['item_tool_mythrilPickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#66ccff" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2+9},13 L${s/2-9},13 L${s/2-11},10 Z" fill="#6699bb" stroke="#4477aa" stroke-width="0.8"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2-11},10 Z" fill="#88bbdd" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#88ccee" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2}" cy="10" r="${s/4}" fill="#66ccff" opacity="0.08"/>
    <circle cx="${s/2-8}" cy="9" r="1" fill="#aaeeff" opacity="0.6"/>
    <circle cx="${s/2+8}" cy="9" r="0.7" fill="#fff" opacity="0.4"/>
  `));

  // â”€â”€ Light Sources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Torch â€” burning stick
  mgr.cache['item_light_torch'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+2}" stroke="#5a3a10" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+2}" stroke="#7a5a20" stroke-width="2.5" stroke-linecap="round"/>
    <ellipse cx="${s/2}" cy="${s/3}" rx="3" ry="4" fill="#f80" opacity="0.6"/>
    <ellipse cx="${s/2}" cy="${s/3-1}" rx="2" ry="3" fill="#fa4" opacity="0.7"/>
    <ellipse cx="${s/2}" cy="${s/3-2}" rx="1.2" ry="2" fill="#ff8" opacity="0.8"/>
    <circle cx="${s/2}" cy="${s/3-3}" r="1" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/3+1}" r="5" fill="#f80" opacity="0.08"/>
  `));

  // Lantern â€” metal frame with glass and flame
  mgr.cache['item_light_lantern'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="${s/2-5}" y="8" width="10" height="${s-14}" fill="#888" stroke="#666" stroke-width="0.8" rx="1"/>
    <rect x="${s/2-4}" y="9" width="8" height="${s-16}" fill="#ffee88" opacity="0.3" rx="1"/>
    <rect x="${s/2-4}" y="9" width="8" height="${s-16}" fill="#ccddee" opacity="0.2" rx="1"/>
    <line x1="${s/2-5}" y1="8" x2="${s/2+5}" y2="8" stroke="#aaa" stroke-width="1.5"/>
    <line x1="${s/2-5}" y1="${s-6}" x2="${s/2+5}" y2="${s-6}" stroke="#aaa" stroke-width="1.5"/>
    <path d="M${s/2-1},6 Q${s/2},4 ${s/2+1},6" stroke="#888" stroke-width="1" fill="none"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="2" ry="3" fill="#ff4" opacity="0.6"/>
    <ellipse cx="${s/2}" cy="${s/2-1}" rx="1.2" ry="2" fill="#ffa" opacity="0.7"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.8" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#ff4" opacity="0.06"/>
  `));

  // Everlight Orb â€” magical glowing sphere
  mgr.cache['item_light_magicLight'] = mgr.svgToImage(mgr.wrap(`
    <circle cx="${s/2}" cy="${s/2}" r="${s/3+2}" fill="#8ff" opacity="0.08"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3}" fill="#2288aa" opacity="0.2"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/4+1}" fill="#44bbdd" stroke="#2299bb" stroke-width="1"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/4}" fill="#66ddee" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/5}" fill="#88eeff" opacity="0.5"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="2" fill="#aaffff" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2-2}" r="1" fill="#fff" opacity="0.7"/>
    <circle cx="${s/2+3}" cy="${s/2+2}" r="0.6" fill="#aff" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3+4}" fill="#8ff" opacity="0.04"/>
  `));

  // â”€â”€ Seeds â€” individual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Seeds â€” small pouch with scattered seeds, soil crumbs
  mgr.cache['item_seed'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2-5}" cy="${s/2+1}" rx="3.5" ry="4.5" fill="#557733" transform="rotate(-10 ${s/2-5} ${s/2+1})"/>
    <ellipse cx="${s/2-5}" cy="${s/2+1}" rx="3" ry="4" fill="#6a9944" transform="rotate(-10 ${s/2-5} ${s/2+1})" opacity="0.8"/>
    <line x1="${s/2-5}" y1="${s/2-2}" x2="${s/2-5}" y2="${s/2+4}" stroke="#446622" stroke-width="0.4" opacity="0.5" transform="rotate(-10 ${s/2-5} ${s/2+1})"/>
    <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="3.5" ry="4.5" fill="#557733" transform="rotate(15 ${s/2+4} ${s/2+3})"/>
    <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="3" ry="4" fill="#6a8833" transform="rotate(15 ${s/2+4} ${s/2+3})" opacity="0.8"/>
    <line x1="${s/2+4}" y1="${s/2}" x2="${s/2+4}" y2="${s/2+6}" stroke="#446622" stroke-width="0.4" opacity="0.5" transform="rotate(15 ${s/2+4} ${s/2+3})"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="3" ry="4" fill="#668844" transform="rotate(5 ${s/2} ${s/2-2})"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="2.5" ry="3.5" fill="#7baa55" transform="rotate(5 ${s/2} ${s/2-2})" opacity="0.7"/>
    <line x1="${s/2}" y1="${s/2-5}" x2="${s/2}" y2="${s/2+1}" stroke="#446622" stroke-width="0.3" opacity="0.4" transform="rotate(5 ${s/2} ${s/2-2})"/>
    <circle cx="${s/2-5}" cy="${s/2}" r="0.5" fill="#8a7" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="0.4" fill="#8a7" opacity="0.4"/>
    <circle cx="${s/2+1}" cy="${s/2-5}" r="0.6" fill="#654" opacity="0.3"/>
    <circle cx="${s/2-3}" cy="${s/2-4}" r="0.5" fill="#654" opacity="0.2"/>
  `));

  // Turnip Seeds â€” green pouch
  mgr.cache['item_seed_turnip'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#557733" stroke="#446622" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#6a9944" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#8a6a40" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#8a6a40" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2+4}" r="0.8" fill="#8a6a40" opacity="0.5"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">T</text>
  `));

  // Potato Seeds
  mgr.cache['item_seed_potato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#557733" stroke="#446622" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#6a9944" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#ca8" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#ca8" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2+4}" r="0.8" fill="#ca8" opacity="0.5"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">P</text>
  `));

  // Strawberry Seeds
  mgr.cache['item_seed_strawberry'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#993333" stroke="#882222" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#bb4444" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#d44" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#d44" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">S</text>
  `));

  // Corn Seeds
  mgr.cache['item_seed_corn'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#998844" stroke="#887733" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#bbaa55" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#da4" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#da4" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">C</text>
  `));

  // Tomato Seeds
  mgr.cache['item_seed_tomato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#883322" stroke="#772211" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#aa4433" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#e32" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#e32" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">To</text>
  `));

  // Carrot Seeds
  mgr.cache['item_seed_carrot'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#885522" stroke="#774411" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#aa6633" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#e82" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#e82" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">Ca</text>
  `));

  // Herb Seeds
  mgr.cache['item_seed_herb'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#227733" stroke="#116622" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#33aa44" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#0c0" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#0c0" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">H</text>
  `));

  // Pumpkin Seeds
  mgr.cache['item_seed_pumpkin'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#886622" stroke="#775511" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#aa8833" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#e80" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#e80" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">Pu</text>
  `));

  // Wheat Seeds
  mgr.cache['item_seed_wheat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#998844" stroke="#887733" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#bbaa55" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#da4" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#da4" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">W</text>
  `));

  // â”€â”€ Spellbooks â€” individual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Spellbook â€” ornate leather-bound tome, gold clasp, arcane glyph, glowing rune
  mgr.cache['item_spellbook'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+1}" cy="${s-2}" rx="8" ry="2" fill="#000" opacity="0.1"/>
    <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#4a2880" rx="2.5" stroke="#3a1870" stroke-width="0.8"/>
    <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#5a3890" rx="2.5" opacity="0.7"/>
    <rect x="7" y="5" width="${s-14}" height="${s-10}" fill="#6a48a0" rx="1.5"/>
    <rect x="5" y="3" width="3.5" height="${s-6}" fill="#4a2880" rx="1.5"/>
    <rect x="5" y="3" width="2.5" height="${s-6}" fill="#3a1870" rx="1" opacity="0.6"/>
    <line x1="5" y1="${s/2}" x2="8.5" y2="${s/2}" stroke="#5a3890" stroke-width="0.5" opacity="0.5"/>
    <line x1="12" y1="${s/3}" x2="${s-8}" y2="${s/3}" stroke="#aa88dd" stroke-width="0.8" opacity="0.7"/>
    <line x1="13" y1="${s/3+3}" x2="${s-9}" y2="${s/3+3}" stroke="#9978cc" stroke-width="0.5" opacity="0.4"/>
    <line x1="12" y1="${s/2+1}" x2="${s-10}" y2="${s/2+1}" stroke="#aa88dd" stroke-width="0.6" opacity="0.5"/>
    <line x1="14" y1="${s/2+4}" x2="${s-10}" y2="${s/2+4}" stroke="#9978cc" stroke-width="0.4" opacity="0.3"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3.5" fill="#3322aa" opacity="0.25"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3" fill="#ff0" opacity="0.35"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="2" fill="#ffa" opacity="0.45"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="0.8" fill="#fff" opacity="0.6"/>
    <rect x="${s-10}" y="${s/2-1}" width="3" height="4" fill="#c8a040" rx="0.5" opacity="0.6"/>
    <circle cx="${s-8.5}" cy="${s/2+1}" r="0.8" fill="#e8c060" opacity="0.7"/>
    <circle cx="9" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
    <circle cx="${s-9}" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
  `));

  // Helper to create colored spellbooks
  function spellbook(glowColor, runeColor, accentColor) {
    return mgr.svgToImage(mgr.wrap(`
      <ellipse cx="${s/2+1}" cy="${s-2}" rx="8" ry="2" fill="#000" opacity="0.1"/>
      <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#4a2880" rx="2.5" stroke="#3a1870" stroke-width="0.8"/>
      <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#5a3890" rx="2.5" opacity="0.7"/>
      <rect x="7" y="5" width="${s-14}" height="${s-10}" fill="#6a48a0" rx="1.5"/>
      <rect x="5" y="3" width="3.5" height="${s-6}" fill="#4a2880" rx="1.5"/>
      <rect x="5" y="3" width="2.5" height="${s-6}" fill="#3a1870" rx="1" opacity="0.6"/>
      <line x1="12" y1="${s/3}" x2="${s-8}" y2="${s/3}" stroke="#aa88dd" stroke-width="0.8" opacity="0.5"/>
      <line x1="13" y1="${s/3+3}" x2="${s-9}" y2="${s/3+3}" stroke="#9978cc" stroke-width="0.5" opacity="0.4"/>
      <line x1="12" y1="${s/2+1}" x2="${s-10}" y2="${s/2+1}" stroke="#aa88dd" stroke-width="0.6" opacity="0.5"/>
      <line x1="14" y1="${s/2+4}" x2="${s-10}" y2="${s/2+4}" stroke="#9978cc" stroke-width="0.4" opacity="0.3"/>
      <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3.5" fill="${glowColor}" opacity="0.2"/>
      <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3" fill="${runeColor}" opacity="0.45"/>
      <circle cx="${s/2+2}" cy="${s*2/3+1}" r="1.5" fill="${accentColor}" opacity="0.7"/>
      <circle cx="${s/2+1}" cy="${s*2/3}" r="0.5" fill="#fff" opacity="0.5"/>
      <rect x="${s-10}" y="${s/2-1}" width="3" height="4" fill="#c8a040" rx="0.5" opacity="0.6"/>
      <circle cx="${s-8.5}" cy="${s/2+1}" r="0.8" fill="#e8c060" opacity="0.7"/>
      <circle cx="9" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
      <circle cx="${s-9}" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
    `));
  }

  mgr.cache['item_spellbook_magicArrow'] = spellbook('#c8f', '#c080ff', '#e0b0ff');
  mgr.cache['item_spellbook_iceBolt'] = spellbook('#6cf', '#60b0ff', '#a0d8ff');
  mgr.cache['item_spellbook_fireBolt'] = spellbook('#f64', '#e04020', '#ff8040');
  mgr.cache['item_spellbook_lightningBolt'] = spellbook('#ff4', '#ddcc00', '#ffee44');
  mgr.cache['item_spellbook_darkBolt'] = spellbook('#a4f', '#8020c0', '#c060ff');
  mgr.cache['item_spellbook_fireBall'] = spellbook('#f84', '#e05030', '#ff9050');
  mgr.cache['item_spellbook_iceBall'] = spellbook('#8ef', '#70c0ff', '#b0e0ff');
  mgr.cache['item_spellbook_chaosBall'] = spellbook('#f0f', '#cc00cc', '#ff44ff');
  mgr.cache['item_spellbook_heal'] = spellbook('#4f4', '#20c020', '#60ff60');
  mgr.cache['item_spellbook_healCritical'] = spellbook('#2f2', '#00aa00', '#44ff44');
  mgr.cache['item_spellbook_holyLight'] = spellbook('#ffa', '#ddaa00', '#ffdd44');
  mgr.cache['item_spellbook_holyVeil'] = spellbook('#ffa', '#ccaa20', '#ffcc44');
  mgr.cache['item_spellbook_mist'] = spellbook('#aaf', '#8080dd', '#b0b0ff');
  mgr.cache['item_spellbook_speed'] = spellbook('#4ff', '#00cccc', '#44ffff');
  mgr.cache['item_spellbook_teleport'] = spellbook('#f8f', '#cc40cc', '#ff80ff');
  mgr.cache['item_spellbook_shortTeleport'] = spellbook('#88f', '#4040cc', '#8080ff');
  mgr.cache['item_spellbook_magicStorm'] = spellbook('#f4f', '#dd00dd', '#ff44ff');

  // â”€â”€ Scrolls â€” individual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Generic scroll â€” rolled parchment with glowing rune seal
  mgr.cache['item_scroll'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#f0e8c8" rx="2" opacity="0.6"/>
    <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <line x1="12" y1="10" x2="${s-12}" y2="10" stroke="#c0a870" stroke-width="0.5" opacity="0.4"/>
    <line x1="12" y1="14" x2="${s-12}" y2="14" stroke="#c0a870" stroke-width="0.5" opacity="0.3"/>
    <line x1="12" y1="18" x2="${s-14}" y2="18" stroke="#c0a870" stroke-width="0.5" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#ffa" opacity="0.4"/>
    <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="#ff8" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="1" fill="#fff" opacity="0.7"/>
    <circle cx="${s/2-1}" cy="${s/2-1}" r="0.5" fill="#fff" opacity="0.5"/>
  `));

  // Fire enchant scroll
  mgr.cache['item_scroll_fire'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
    <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#f64" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="#f84" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="1.5" fill="#fa4" opacity="0.7"/>
  `));

  // Ice enchant scroll
  mgr.cache['item_scroll_ice'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
    <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#6cf" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="#8df" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="1" fill="#fff" opacity="0.7"/>
  `));

  // Helper to create colored scrolls with rune seal
  function scrollSprite(sealColor, sealGlow) {
    return mgr.svgToImage(mgr.wrap(`
      <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
      <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
      <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#f0e8c8" rx="2" opacity="0.5"/>
      <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
      <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
      <line x1="12" y1="10" x2="${s-12}" y2="10" stroke="#c0a870" stroke-width="0.5" opacity="0.3"/>
      <line x1="12" y1="14" x2="${s-12}" y2="14" stroke="#c0a870" stroke-width="0.5" opacity="0.2"/>
      <circle cx="${s/2}" cy="${s/2}" r="4" fill="${sealGlow}" opacity="0.35"/>
      <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="${sealColor}" opacity="0.6"/>
      <circle cx="${s/2}" cy="${s/2}" r="1" fill="#fff" opacity="0.6"/>
    `));
  }

  mgr.cache['item_scroll_enchantWeapon'] = scrollSprite('#ffa', '#ff8');
  mgr.cache['item_scroll_enchantArmor'] = scrollSprite('#aaf', '#88f');
  mgr.cache['item_scroll_greaterEnchant'] = scrollSprite('#ff4', '#ee2');
  mgr.cache['item_scroll_supremeEnchant'] = scrollSprite('#f4f', '#d2d');
  mgr.cache['item_scroll_lightning'] = scrollSprite('#ff4', '#dd2');
  mgr.cache['item_scroll_holy'] = scrollSprite('#ffa', '#eed');
  mgr.cache['item_scroll_speed'] = scrollSprite('#4ff', '#2dd');
  mgr.cache['item_scroll_teleport'] = scrollSprite('#f8f', '#cc40cc', '#ff80ff');
  mgr.cache['item_scroll_shortTeleport'] = scrollSprite('#88f', '#4040cc', '#8080ff');
  mgr.cache['item_scroll_magicStorm'] = scrollSprite('#f4f', '#dd00dd', '#ff44ff');
});

</script>
  <script>
// ============================================================
// Monster Tiles â€” visual representations for each monster type
// Linked to: data/monsters.json (monster properties like level, hp, ai)
// Each key here maps to monster_<id> where <id> matches monsters.json
// ============================================================

SVGTileManager.register('monsters', (mgr) => {
  const s = mgr.tileSize;

  // Putit (slime) â€” monsters.json: putit
  mgr.cache['monster_putit'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3}" ry="${s/4}" fill="#4a4" opacity="0.3"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3-2}" ry="${s/3}" fill="#44cc44"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3-4}" ry="${s/4}" fill="#66ee66" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2}" r="2" fill="#fff"/>
    <circle cx="${s/2+4}" cy="${s/2}" r="2" fill="#fff"/>
    <circle cx="${s/2-4}" cy="${s/2}" r="1" fill="#222"/>
    <circle cx="${s/2+4}" cy="${s/2}" r="1" fill="#222"/>
  `));

  // Giant Rat â€” monsters.json: rat
  mgr.cache['monster_rat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#8a7060"/>
    <circle cx="${s/2-6}" cy="${s/2-2}" r="4" fill="#9a8070"/>
    <circle cx="${s/2-8}" cy="${s/2-5}" r="2" fill="#a88"/>
    <circle cx="${s/2-4}" cy="${s/2-3}" r="1.5" fill="#f88" opacity="0.8"/>
    <circle cx="${s/2-3}" cy="${s/2-4}" r="1" fill="#300"/>
    <path d="M${s/2+6},${s/2+3} Q${s/2+10},${s/2+6} ${s/2+12},${s/2}" stroke="#8a7060" stroke-width="1.5" fill="none"/>
  `));

  // Cave Bat â€” monsters.json: bat
  mgr.cache['monster_bat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2}" rx="3" ry="4" fill="#554"/>
    <path d="M${s/2-3},${s/2-2} L${s/2-14},${s/2-8} L${s/2-10},${s/2+2} L${s/2-3},${s/2+1}" fill="#665" opacity="0.9"/>
    <path d="M${s/2+3},${s/2-2} L${s/2+14},${s/2-8} L${s/2+10},${s/2+2} L${s/2+3},${s/2+1}" fill="#665" opacity="0.9"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1" fill="#f44"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1" fill="#f44"/>
  `));

  // Kobold â€” monsters.json: kobold
  mgr.cache['monster_kobold'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2}" width="8" height="${s/2-4}" fill="#8a6a40" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="5" fill="#9a7a50"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#ff0"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="1.5" fill="#ff0"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="0.7" fill="#300"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="0.7" fill="#300"/>
    <polygon points="${s/2-4},${s/2-6} ${s/2-2},${s/2-10} ${s/2-1},${s/2-5}" fill="#9a7a50"/>
    <polygon points="${s/2+4},${s/2-6} ${s/2+2},${s/2-10} ${s/2+1},${s/2-5}" fill="#9a7a50"/>
  `));

  // Goblin â€” monsters.json: goblin
  mgr.cache['monster_goblin'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="${s/2-6}" fill="#4a8a40" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#5a9a50"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="2" fill="#ff0"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="2" fill="#ff0"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="1" fill="#300"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="1" fill="#300"/>
    <polygon points="${s/2-5},${s/2-4} ${s/2-3},${s/2-10} ${s/2-1},${s/2-4}" fill="#5a9a50"/>
    <polygon points="${s/2+5},${s/2-4} ${s/2+3},${s/2-10} ${s/2+1},${s/2-4}" fill="#5a9a50"/>
    <path d="M${s/2-3},${s/2+3} Q${s/2},${s/2+6} ${s/2+3},${s/2+3}" stroke="#300" stroke-width="1" fill="none"/>
  `));

  // Wild Wolf â€” monsters.json: wolf
  mgr.cache['monster_wolf'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#707070"/>
    <circle cx="${s/2-6}" cy="${s/2}" r="5" fill="#808080"/>
    <polygon points="${s/2-8},${s/2-4} ${s/2-6},${s/2-10} ${s/2-4},${s/2-4}" fill="#808080"/>
    <polygon points="${s/2-4},${s/2-4} ${s/2-2},${s/2-10} ${s/2},${s/2-4}" fill="#808080"/>
    <circle cx="${s/2-8}" cy="${s/2-1}" r="1.2" fill="#8f8"/>
    <circle cx="${s/2-5}" cy="${s/2-1}" r="1.2" fill="#8f8"/>
    <path d="M${s/2+10},${s/2+4} Q${s/2+14},${s/2} ${s/2+12},${s/2-2}" stroke="#707070" stroke-width="2" fill="none"/>
  `));

  // Skeleton â€” monsters.json: skeleton
  mgr.cache['monster_skeleton'] = mgr.svgToImage(mgr.wrap(`
    <circle cx="${s/2}" cy="8" r="5" fill="#ddd" stroke="#bbb" stroke-width="0.5"/>
    <rect x="${s/2-1}" y="13" width="2" height="8" fill="#ddd"/>
    <line x1="${s/2-6}" y1="16" x2="${s/2+6}" y2="16" stroke="#ddd" stroke-width="2"/>
    <line x1="${s/2-2}" y1="21" x2="${s/2-4}" y2="${s-4}" stroke="#ddd" stroke-width="1.5"/>
    <line x1="${s/2+2}" y1="21" x2="${s/2+4}" y2="${s-4}" stroke="#ddd" stroke-width="1.5"/>
    <circle cx="${s/2-2}" cy="7" r="1.5" fill="#000"/>
    <circle cx="${s/2+2}" cy="7" r="1.5" fill="#000"/>
    <path d="M${s/2-2},10 L${s/2},11 L${s/2+2},10" stroke="#000" stroke-width="0.8" fill="none"/>
  `));

  // Zombie â€” monsters.json: zombie
  mgr.cache['monster_zombie'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#556a44" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="6" fill="#667a55"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="2" fill="#cc0" opacity="0.8"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1.5" fill="#cc0" opacity="0.6"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1" fill="#600"/>
    <path d="M${s/2-3},${s/2+2} Q${s/2},${s/2+4} ${s/2+4},${s/2+1}" stroke="#400" stroke-width="1" fill="none"/>
    <line x1="${s/2+5}" y1="${s/2+1}" x2="${s/2+10}" y2="${s/2+4}" stroke="#667a55" stroke-width="2" stroke-linecap="round"/>
  `));

  // Orc â€” monsters.json: orc
  mgr.cache['monster_orc'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-6}" y="${s/2+2}" width="12" height="${s/2-6}" fill="#5a8040" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-1}" r="7" fill="#6a9050"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="2" fill="#ff0"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="2" fill="#ff0"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1" fill="#300"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1" fill="#300"/>
    <polygon points="${s/2-2},${s/2+3} ${s/2},${s/2+1} ${s/2+2},${s/2+3}" fill="#fff"/>
    <rect x="${s/2-8}" y="${s/2}" width="3" height="8" fill="#6a9050" rx="1"/>
    <rect x="${s/2+5}" y="${s/2}" width="3" height="8" fill="#6a9050" rx="1"/>
  `));

  // Imp â€” monsters.json: imp
  mgr.cache['monster_imp'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="${s/3}" fill="#8a2020" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#aa3030"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#ff0"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#ff0"/>
    <polygon points="${s/2-4},${s/2-4} ${s/2-2},${s/2-10} ${s/2},${s/2-4}" fill="#cc2020"/>
    <polygon points="${s/2+4},${s/2-4} ${s/2+2},${s/2-10} ${s/2},${s/2-4}" fill="#cc2020"/>
    <path d="M${s/2-5},${s/2-2} L${s/2-10},${s/2-6} L${s/2-8},${s/2+2}" fill="#aa3030" opacity="0.7"/>
    <path d="M${s/2+5},${s/2-2} L${s/2+10},${s/2-6} L${s/2+8},${s/2+2}" fill="#aa3030" opacity="0.7"/>
  `));

  // Troll â€” monsters.json: troll
  mgr.cache['monster_troll'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-7}" y="${s/2}" width="14" height="${s/2-4}" fill="#5a7a4a" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="8" fill="#6a8a5a"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="2" fill="#ff4"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="2" fill="#ff4"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1" fill="#300"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="1" fill="#300"/>
    <path d="M${s/2-4},${s/2+2} Q${s/2},${s/2+5} ${s/2+4},${s/2+2}" stroke="#400" stroke-width="1.5" fill="none"/>
    <rect x="${s/2-10}" y="${s/2}" width="4" height="10" fill="#6a8a5a" rx="2"/>
    <rect x="${s/2+6}" y="${s/2}" width="4" height="10" fill="#6a8a5a" rx="2"/>
  `));

  // Minotaur â€” monsters.json: minotaur
  mgr.cache['monster_minotaur'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-7}" y="${s/2}" width="14" height="${s/2-2}" fill="#7a4a2a" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="7" fill="#8a5a3a"/>
    <path d="M${s/2-7},${s/2-4} L${s/2-12},${s/2-12} L${s/2-8},${s/2-6}" fill="#8a5a3a" stroke="#6a3a1a" stroke-width="0.5"/>
    <path d="M${s/2+7},${s/2-4} L${s/2+12},${s/2-12} L${s/2+8},${s/2-6}" fill="#8a5a3a" stroke="#6a3a1a" stroke-width="0.5"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1" fill="#400"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1" fill="#400"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="3" ry="2" fill="#7a4a2a"/>
  `));

  // Drake â€” monsters.json: drake
  mgr.cache['monster_drake'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+4}" ry="${s/4}" fill="#4a2060"/>
    <circle cx="${s/2-4}" cy="${s/2-2}" r="5" fill="#6a3080"/>
    <path d="M${s/2-6},${s/2-6} L${s/2-14},${s/2-12} L${s/2-10},${s/2-2} L${s/2-6},${s/2-2}" fill="#5a2070" opacity="0.8"/>
    <path d="M${s/2+4},${s/2-4} L${s/2+14},${s/2-12} L${s/2+10},${s/2} L${s/2+4},${s/2}" fill="#5a2070" opacity="0.8"/>
    <circle cx="${s/2-6}" cy="${s/2-3}" r="1.5" fill="#f80"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1.5" fill="#f80"/>
    <polygon points="${s/2-8},${s/2} ${s/2-6},${s/2+2} ${s/2-4},${s/2}" fill="#f44" opacity="0.6"/>
    <path d="M${s/2+6},${s/2+4} Q${s/2+10},${s/2+8} ${s/2+8},${s/2+2}" stroke="#4a2060" stroke-width="2" fill="none"/>
  `));

  // â”€â”€ Desert Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Sand Viper â€” monsters.json: sandViper
  mgr.cache['monster_sandViper'] = mgr.svgToImage(mgr.wrap(`
    <path d="M${s/2-10},${s/2+4} Q${s/2-5},${s/2-4} ${s/2},${s/2+2} Q${s/2+5},${s/2+8} ${s/2+10},${s/2}" stroke="#c8a030" stroke-width="3" fill="none"/>
    <circle cx="${s/2-10}" cy="${s/2+4}" r="3" fill="#c8a030"/>
    <circle cx="${s/2-11}" cy="${s/2+3}" r="1" fill="#f00"/>
    <circle cx="${s/2-9}" cy="${s/2+3}" r="1" fill="#f00"/>
    <polygon points="${s/2-13},${s/2+5} ${s/2-12},${s/2+3} ${s/2-11},${s/2+5}" fill="#f44"/>
  `));

  // Giant Scorpion â€” monsters.json: scorpion
  mgr.cache['monster_scorpion'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3}" ry="${s/5}" fill="#8a5020"/>
    <circle cx="${s/2-5}" cy="${s/2+3}" r="2" fill="#8a5020"/>
    <circle cx="${s/2+5}" cy="${s/2+3}" r="2" fill="#8a5020"/>
    <path d="M${s/2},${s/2+1} Q${s/2+2},${s/2-8} ${s/2+6},${s/2-10}" stroke="#8a5020" stroke-width="2" fill="none"/>
    <circle cx="${s/2+6}" cy="${s/2-10}" r="2" fill="#d04040"/>
    <circle cx="${s/2-3}" cy="${s/2+1}" r="1" fill="#ff0"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="1" fill="#ff0"/>
  `));

  // Mummy â€” monsters.json: mummy
  mgr.cache['monster_mummy'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#c8b888" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="6" fill="#d8c898"/>
    <line x1="${s/2-5}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2+1}" stroke="#b8a878" stroke-width="1.5"/>
    <line x1="${s/2-5}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2+4}" stroke="#b8a878" stroke-width="1.5"/>
    <line x1="${s/2-5}" y1="${s/2+7}" x2="${s/2+5}" y2="${s/2+7}" stroke="#b8a878" stroke-width="1.5"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="2" fill="#4a0" opacity="0.8"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="2" fill="#4a0" opacity="0.8"/>
  `));

  // Dust Wraith â€” monsters.json: dustWraith
  mgr.cache['monster_dustWraith'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/3+2}" fill="#a08050" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="5" fill="#b89060" opacity="0.7"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="2" fill="#ff4" opacity="0.9"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="2" fill="#ff4" opacity="0.9"/>
    <path d="M${s/2-6},${s/2+6} Q${s/2},${s/2+10} ${s/2+6},${s/2+6}" stroke="#a08050" stroke-width="1" fill="none" opacity="0.4"/>
  `));

  // Cactoid â€” monsters.json: cactoid
  mgr.cache['monster_cactoid'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-3}" y="${s/2-4}" width="6" height="${s/2+2}" fill="#3a8a30" rx="3"/>
    <rect x="${s/2-8}" y="${s/2-2}" width="5" height="3" fill="#3a8a30" rx="1"/>
    <rect x="${s/2+3}" y="${s/2}" width="5" height="3" fill="#3a8a30" rx="1"/>
    <circle cx="${s/2-1}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <circle cx="${s/2+1}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <circle cx="${s/2}" cy="${s/2-6}" r="1.5" fill="#f44"/>
  `));

  // â”€â”€ Snow Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Frost Wolf â€” monsters.json: frostWolf
  mgr.cache['monster_frostWolf'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#a0b8d0"/>
    <circle cx="${s/2-6}" cy="${s/2}" r="5" fill="#b0c8e0"/>
    <polygon points="${s/2-8},${s/2-4} ${s/2-6},${s/2-10} ${s/2-4},${s/2-4}" fill="#b0c8e0"/>
    <polygon points="${s/2-4},${s/2-4} ${s/2-2},${s/2-10} ${s/2},${s/2-4}" fill="#b0c8e0"/>
    <circle cx="${s/2-8}" cy="${s/2-1}" r="1.2" fill="#4af"/>
    <circle cx="${s/2-5}" cy="${s/2-1}" r="1.2" fill="#4af"/>
    <path d="M${s/2+10},${s/2+4} Q${s/2+14},${s/2} ${s/2+12},${s/2-2}" stroke="#a0b8d0" stroke-width="2" fill="none"/>
  `));

  // Ice Elemental â€” monsters.json: iceElemental
  mgr.cache['monster_iceElemental'] = mgr.svgToImage(mgr.wrap(`
    <polygon points="${s/2},${s/2-10} ${s/2+8},${s/2+2} ${s/2+4},${s/2+8} ${s/2-4},${s/2+8} ${s/2-8},${s/2+2}" fill="#6af" opacity="0.7"/>
    <polygon points="${s/2},${s/2-6} ${s/2+5},${s/2+1} ${s/2+2},${s/2+5} ${s/2-2},${s/2+5} ${s/2-5},${s/2+1}" fill="#aef" opacity="0.5"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#fff"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#fff"/>
  `));

  // Snow Harpy â€” monsters.json: snowHarpy
  mgr.cache['monster_snowHarpy'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-3}" y="${s/2+2}" width="6" height="${s/3}" fill="#c0d0e0" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#d0e0f0"/>
    <path d="M${s/2-4},${s/2-1} L${s/2-14},${s/2-6} L${s/2-10},${s/2+3} L${s/2-4},${s/2+2}" fill="#b0c0d8" opacity="0.9"/>
    <path d="M${s/2+4},${s/2-1} L${s/2+14},${s/2-6} L${s/2+10},${s/2+3} L${s/2+4},${s/2+2}" fill="#b0c0d8" opacity="0.9"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#88f"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#88f"/>
  `));

  // Yeti â€” monsters.json: yeti
  mgr.cache['monster_yeti'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-8}" y="${s/2}" width="16" height="${s/2-2}" fill="#d8d8e8" rx="4"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="8" fill="#e8e8f0"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="2" fill="#44f"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="2" fill="#44f"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1" fill="#113"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="1" fill="#113"/>
    <path d="M${s/2-3},${s/2+2} Q${s/2},${s/2+4} ${s/2+3},${s/2+2}" stroke="#446" stroke-width="1.5" fill="none"/>
    <rect x="${s/2-11}" y="${s/2}" width="4" height="10" fill="#e8e8f0" rx="2"/>
    <rect x="${s/2+7}" y="${s/2}" width="4" height="10" fill="#e8e8f0" rx="2"/>
  `));

  // â”€â”€ Forest Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Forest Spider â€” monsters.json: forestSpider
  mgr.cache['monster_forestSpider'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="5" ry="4" fill="#2a4a20"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="3" fill="#3a5a30"/>
    <line x1="${s/2-4}" y1="${s/2}" x2="${s/2-10}" y2="${s/2-6}" stroke="#2a4a20" stroke-width="1.5"/>
    <line x1="${s/2+4}" y1="${s/2}" x2="${s/2+10}" y2="${s/2-6}" stroke="#2a4a20" stroke-width="1.5"/>
    <line x1="${s/2-4}" y1="${s/2+2}" x2="${s/2-10}" y2="${s/2+6}" stroke="#2a4a20" stroke-width="1.5"/>
    <line x1="${s/2+4}" y1="${s/2+2}" x2="${s/2+10}" y2="${s/2+6}" stroke="#2a4a20" stroke-width="1.5"/>
    <circle cx="${s/2-1}" cy="${s/2-3}" r="1" fill="#f44"/>
    <circle cx="${s/2+1}" cy="${s/2-3}" r="1" fill="#f44"/>
    <circle cx="${s/2-2}" cy="${s/2-2}" r="0.7" fill="#f44"/>
    <circle cx="${s/2+2}" cy="${s/2-2}" r="0.7" fill="#f44"/>
  `));

  // Treant â€” monsters.json: treant
  mgr.cache['monster_treant'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2}" width="8" height="${s/2-2}" fill="#5a3a1a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-4}" r="8" fill="#2a6a18"/>
    <circle cx="${s/2-4}" cy="${s/2-6}" r="5" fill="#3a8a28" opacity="0.7"/>
    <circle cx="${s/2+4}" cy="${s/2-6}" r="5" fill="#3a8a28" opacity="0.7"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="2" fill="#cc4" opacity="0.8"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="2" fill="#cc4" opacity="0.8"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="1" fill="#420"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="1" fill="#420"/>
    <path d="M${s/2-8}" y1="${s/2+2}" x2="${s/2-12}" y2="${s/2-2}" stroke="#5a3a1a" stroke-width="2" fill="none"/>
  `));

  // Will-o'-Wisp â€” monsters.json: willOWisp
  mgr.cache['monster_willOWisp'] = mgr.svgToImage(mgr.wrap(`
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#8af" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#aef" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="2" fill="#fff" opacity="0.9"/>
    <circle cx="${s/2-5}" cy="${s/2-5}" r="1.5" fill="#8af" opacity="0.4"/>
    <circle cx="${s/2+4}" cy="${s/2+4}" r="1" fill="#8af" opacity="0.3"/>
  `));

  // Wild Bear â€” monsters.json: bear
  mgr.cache['monster_bear'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+3}" ry="${s/4}" fill="#6a4a2a"/>
    <circle cx="${s/2-4}" cy="${s/2}" r="6" fill="#7a5a3a"/>
    <circle cx="${s/2-8}" cy="${s/2-5}" r="3" fill="#7a5a3a"/>
    <circle cx="${s/2}" cy="${s/2-5}" r="3" fill="#7a5a3a"/>
    <circle cx="${s/2-6}" cy="${s/2-1}" r="1.5" fill="#300"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#300"/>
    <ellipse cx="${s/2-4}" cy="${s/2+1}" rx="2" ry="1.5" fill="#444"/>
  `));

  // Mushroom Man â€” monsters.json: mushMan
  mgr.cache['monster_mushMan'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#c8b088"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="7" ry="5" fill="#c04040"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="5" ry="3" fill="#d06060" opacity="0.5"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="2" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="1.5" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2-1}" cy="${s/2+2}" r="1" fill="#222"/>
    <circle cx="${s/2+1}" cy="${s/2+2}" r="1" fill="#222"/>
  `));

  // â”€â”€ Mountain Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Stone Golem â€” monsters.json: stoneGolem
  mgr.cache['monster_stoneGolem'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-8}" y="${s/2}" width="16" height="${s/2-2}" fill="#7a7a7a" rx="3"/>
    <rect x="${s/2-6}" y="${s/2-8}" width="12" height="10" fill="#8a8a8a" rx="4"/>
    <circle cx="${s/2-3}" cy="${s/2-4}" r="2" fill="#f80"/>
    <circle cx="${s/2+3}" cy="${s/2-4}" r="2" fill="#f80"/>
    <rect x="${s/2-10}" y="${s/2+1}" width="4" height="9" fill="#7a7a7a" rx="2"/>
    <rect x="${s/2+6}" y="${s/2+1}" width="4" height="9" fill="#7a7a7a" rx="2"/>
    <line x1="${s/2-4}" y1="${s/2-1}" x2="${s/2+4}" y2="${s/2-1}" stroke="#555" stroke-width="1.5"/>
  `));

  // Rock Worm â€” monsters.json: rockWorm
  mgr.cache['monster_rockWorm'] = mgr.svgToImage(mgr.wrap(`
    <path d="M${s/2-8},${s/2+6} Q${s/2-4},${s/2} ${s/2},${s/2+4} Q${s/2+4},${s/2+8} ${s/2+8},${s/2+2}" stroke="#8a7a60" stroke-width="4" fill="none"/>
    <circle cx="${s/2-8}" cy="${s/2+6}" r="3" fill="#8a7a60"/>
    <circle cx="${s/2-9}" cy="${s/2+5}" r="1" fill="#f44"/>
    <circle cx="${s/2-7}" cy="${s/2+5}" r="1" fill="#f44"/>
    <path d="M${s/2-11},${s/2+7} L${s/2-8},${s/2+8} L${s/2-5},${s/2+7}" stroke="#8a7a60" stroke-width="1" fill="none"/>
  `));

  // Griffin â€” monsters.json: griffin
  mgr.cache['monster_griffin'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#c8a040"/>
    <circle cx="${s/2-4}" cy="${s/2-1}" r="5" fill="#d8b050"/>
    <polygon points="${s/2-9},${s/2-2} ${s/2-12},${s/2-1} ${s/2-9},${s/2}" fill="#f80"/>
    <path d="M${s/2-2},${s/2-3} L${s/2-10},${s/2-12} L${s/2-6},${s/2} " fill="#c8a040" opacity="0.8"/>
    <path d="M${s/2+6},${s/2-1} L${s/2+14},${s/2-10} L${s/2+10},${s/2+3}" fill="#c8a040" opacity="0.8"/>
    <circle cx="${s/2-6}" cy="${s/2-2}" r="1.5" fill="#f80"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1.5" fill="#f80"/>
    <path d="M${s/2+8},${s/2+4} Q${s/2+12},${s/2+8} ${s/2+10},${s/2+2}" stroke="#b89030" stroke-width="2" fill="none"/>
  `));

  // Mountain Ogre â€” monsters.json: mountainOgre
  mgr.cache['monster_mountainOgre'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-7}" y="${s/2+1}" width="14" height="${s/2-3}" fill="#6a5a40" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-1}" r="8" fill="#7a6a50"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1" fill="#400"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1" fill="#400"/>
    <path d="M${s/2-3},${s/2+3} Q${s/2},${s/2+5} ${s/2+3},${s/2+3}" stroke="#400" stroke-width="1.5" fill="none"/>
    <rect x="${s/2+8}" y="${s/2-4}" width="3" height="14" fill="#5a4a30" rx="1"/>
  `));

  // â”€â”€ Sea / Beach Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Giant Crab â€” monsters.json: crab
  mgr.cache['monster_crab'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+2}" ry="${s/5}" fill="#cc4040"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#cc4040"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#cc4040"/>
    <path d="M${s/2-8},${s/2} L${s/2-12},${s/2-6} L${s/2-10},${s/2-4}" stroke="#cc4040" stroke-width="2" fill="none"/>
    <path d="M${s/2+8},${s/2} L${s/2+12},${s/2-6} L${s/2+10},${s/2-4}" stroke="#cc4040" stroke-width="2" fill="none"/>
    <circle cx="${s/2-2}" cy="${s/2}" r="1" fill="#222"/>
    <circle cx="${s/2+2}" cy="${s/2}" r="1" fill="#222"/>
  `));

  // Siren â€” monsters.json: siren
  mgr.cache['monster_siren'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-3}" y="${s/2+2}" width="6" height="${s/3}" fill="#4a8aaa" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#7ab8d0"/>
    <path d="M${s/2-3},${s/2+6} Q${s/2},${s/2+10} ${s/2+3},${s/2+6}" fill="#4a8aaa"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#4ff"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#4ff"/>
    <path d="M${s/2-4},${s/2-4} Q${s/2-2},${s/2-8} ${s/2+2},${s/2-6} Q${s/2+5},${s/2-4} ${s/2+4},${s/2-2}" stroke="#7ab8d0" stroke-width="1" fill="none"/>
  `));

  // Sea Serpent â€” monsters.json: seaSerpent
  mgr.cache['monster_seaSerpent'] = mgr.svgToImage(mgr.wrap(`
    <path d="M${s/2-12},${s/2+2} Q${s/2-6},${s/2-6} ${s/2},${s/2+2} Q${s/2+6},${s/2+10} ${s/2+12},${s/2}" stroke="#2a6a8a" stroke-width="4" fill="none"/>
    <circle cx="${s/2-12}" cy="${s/2+2}" r="4" fill="#3a7a9a"/>
    <circle cx="${s/2-14}" cy="${s/2+1}" r="1" fill="#ff0"/>
    <circle cx="${s/2-11}" cy="${s/2+1}" r="1" fill="#ff0"/>
    <polygon points="${s/2+11},${s/2-1} ${s/2+14},${s/2-4} ${s/2+14},${s/2+2}" fill="#2a6a8a"/>
  `));

  // Man-o'-War (jellyfish) â€” monsters.json: jellyfish
  mgr.cache['monster_jellyfish'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="6" ry="4" fill="#c8a0d8" opacity="0.6"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="4" ry="2" fill="#d8b0e8" opacity="0.4"/>
    <line x1="${s/2-4}" y1="${s/2+2}" x2="${s/2-5}" y2="${s/2+8}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2+2}" x2="${s/2}" y2="${s/2+10}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2+4}" y1="${s/2+2}" x2="${s/2+5}" y2="${s/2+8}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2-2}" y1="${s/2+2}" x2="${s/2-3}" y2="${s/2+9}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2+2}" y1="${s/2+2}" x2="${s/2+3}" y2="${s/2+9}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
  `));

  // â”€â”€ Plains Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Plains Stalker â€” monsters.json: plainsStalker
  mgr.cache['monster_plainsStalker'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+3}" ry="${s/5-1}" fill="#b89848"/>
    <circle cx="${s/2-6}" cy="${s/2}" r="4" fill="#c8a858"/>
    <polygon points="${s/2-8},${s/2-3} ${s/2-6},${s/2-8} ${s/2-4},${s/2-3}" fill="#c8a858"/>
    <polygon points="${s/2-4},${s/2-3} ${s/2-2},${s/2-8} ${s/2},${s/2-3}" fill="#c8a858"/>
    <circle cx="${s/2-7}" cy="${s/2-1}" r="1.2" fill="#4e4"/>
    <circle cx="${s/2-5}" cy="${s/2-1}" r="1.2" fill="#4e4"/>
    <path d="M${s/2+8},${s/2+3} Q${s/2+14},${s/2} ${s/2+12},${s/2-3}" stroke="#b89848" stroke-width="2" fill="none"/>
  `));

  // Wild Boar â€” monsters.json: wildBoar
  mgr.cache['monster_wildBoar'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+3}" rx="${s/3+2}" ry="${s/5}" fill="#6a4a3a"/>
    <circle cx="${s/2-6}" cy="${s/2+1}" r="5" fill="#7a5a4a"/>
    <circle cx="${s/2-9}" cy="${s/2}" r="1" fill="#222"/>
    <ellipse cx="${s/2-9}" cy="${s/2+2}" rx="2" ry="1.5" fill="#c88a7a"/>
    <polygon points="${s/2-11},${s/2+1} ${s/2-12},${s/2-1} ${s/2-10},${s/2+1}" fill="#fff"/>
    <polygon points="${s/2-8},${s/2+1} ${s/2-7},${s/2-1} ${s/2-9},${s/2+1}" fill="#fff"/>
  `));

  // Hawk Rider Goblin â€” monsters.json: hawkRider
  mgr.cache['monster_hawkRider'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#8a6a30"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#5a9a50"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <path d="M${s/2-6},${s/2+2} L${s/2-14},${s/2-4} L${s/2-10},${s/2+4}" fill="#9a7a40" opacity="0.8"/>
    <path d="M${s/2+6},${s/2+2} L${s/2+14},${s/2-4} L${s/2+10},${s/2+4}" fill="#9a7a40" opacity="0.8"/>
    <polygon points="${s/2-2},${s/2+5} ${s/2-4},${s/2+4} ${s/2},${s/2+5}" fill="#8a6a30"/>
  `));

  // Centaur â€” monsters.json: centaur
  mgr.cache['monster_centaur'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+3}" ry="${s/5}" fill="#8a6a4a"/>
    <rect x="${s/2-6}" y="${s/2-2}" width="6" height="8" fill="#c0a080" rx="2"/>
    <circle cx="${s/2-3}" cy="${s/2-6}" r="4" fill="#c0a080"/>
    <circle cx="${s/2-5}" cy="${s/2-7}" r="1" fill="#300"/>
    <circle cx="${s/2-2}" cy="${s/2-7}" r="1" fill="#300"/>
    <line x1="${s/2-2}" y1="${s/2+7}" x2="${s/2-3}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
    <line x1="${s/2+2}" y1="${s/2+7}" x2="${s/2+1}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
    <line x1="${s/2+6}" y1="${s/2+7}" x2="${s/2+7}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
    <line x1="${s/2+8}" y1="${s/2+7}" x2="${s/2+9}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
  `));
});

</script>
  <script>
// ============================================================
// NPC Tiles â€” shopkeeper, smith, mage, farmer, barkeep, etc.
// Linked to: data/shops.json (shop/NPC properties)
// ============================================================

SVGTileManager.register('npcs', (mgr) => {
  const s = mgr.tileSize;

  // Shopkeeper
  mgr.cache['npc_shopkeeper'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#6a5a40" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="6" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <path d="M${s/2-2},${s/2}" Q${s/2},${s/2+2} ${s/2+2},${s/2}" stroke="#333" stroke-width="0.8" fill="none"/>
    <rect x="${s/2-7}" y="${s/2-8}" width="14" height="4" fill="#8a6a30" rx="2"/>
    <rect x="${s/2-8}" y="${s/2-6}" width="16" height="2" fill="#a07838"/>
  `));

  // Smith (Blacksmith)
  mgr.cache['npc_smith'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-6}" y="${s/2}" width="12" height="${s/2-3}" fill="#6a3a2a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="6" fill="#cc9977"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <rect x="${s/2-8}" y="${s/2+1}" width="3" height="8" fill="#cc9977" rx="1"/>
    <rect x="${s/2+5}" y="${s/2+1}" width="3" height="8" fill="#cc9977" rx="1"/>
    <rect x="${s/2+6}" y="${s/2+4}" width="8" height="3" fill="#888" rx="1"/>
  `));

  // Mage
  mgr.cache['npc_mage'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#4040a0" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="5" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="1.5" fill="#333"/>
    <polygon points="${s/2-6},${s/2-6} ${s/2},${s/2-16} ${s/2+6},${s/2-6}" fill="#5050c0"/>
    <circle cx="${s/2}" cy="${s/2-13}" r="2" fill="#ff0" opacity="0.7"/>
    <rect x="${s/2+5}" y="${s/2-2}" width="10" height="2" fill="#8a6030" rx="1"/>
    <circle cx="${s/2+14}" cy="${s/2-2}" r="2.5" fill="#88f" opacity="0.6"/>
  `));

  // Farmer
  mgr.cache['npc_farmer'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#5a7a3a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="5" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <rect x="${s/2-7}" y="${s/2-8}" width="14" height="3" fill="#c8a848" rx="4"/>
    <rect x="${s/2-8}" y="${s/2-6}" width="16" height="2" fill="#dab858"/>
  `));

  // Barkeep
  mgr.cache['npc_barkeep'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#8a5a3a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="6" fill="#ddaa88"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <path d="M${s/2-3},${s/2+1} Q${s/2},${s/2+3} ${s/2+3},${s/2+1}" stroke="#333" stroke-width="0.8" fill="none"/>
    <rect x="${s/2-10}" y="${s/2+4}" width="6" height="8" fill="#c8a040" rx="1"/>
    <ellipse cx="${s/2-7}" cy="${s/2+4}" rx="3" ry="1" fill="#e8c060"/>
  `));

  // Generic NPC fallback
  mgr.cache['npc_generic'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#666" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="5" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
  `));
});

</script>
  <script>
// ============================================================
// Player Tile â€” the player character sprite
// ============================================================

SVGTileManager.register('player', (mgr) => {
  const s = mgr.tileSize;

  mgr.cache['player'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2+2}" width="10" height="${s/2-4}" fill="#3060c0" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="6" fill="#e0c8a8"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#2244aa"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="1.5" fill="#2244aa"/>
    <path d="M${s/2-3},${s/2+1} Q${s/2},${s/2+2} ${s/2+3},${s/2+1}" stroke="#333" stroke-width="0.8" fill="none"/>
    <rect x="${s/2-7}" y="${s/2-8}" width="14" height="5" fill="#6a4a2a" rx="2"/>
    <line x1="${s/2+5}" y1="${s/2+2}" x2="${s/2+12}" y2="${s/2-4}" stroke="#c0c0d0" stroke-width="2" stroke-linecap="round"/>
  `));
});

</script>
  <script>
// ============================================================
// Location Marker Tiles â€” world map markers (town, nefia, home)
// Linked to: data/locations/*.json (location properties like type, danger)
// ============================================================

SVGTileManager.register('locations', (mgr) => {
  const s = mgr.tileSize;

  // Town marker
  mgr.cache['location_town'] = mgr.svgToImage(mgr.wrap(`
    <rect x="4" y="${s/2-2}" width="${s-8}" height="${s/2}" fill="#aa8855" rx="2"/>
    <polygon points="${s/2},4 4,${s/2-2} ${s-4},${s/2-2}" fill="#cc9966"/>
    <rect x="${s/2-3}" y="${s/2+4}" width="6" height="${s/2-6}" fill="#6a4a2a"/>
    <rect x="8" y="${s/2+2}" width="4" height="3" fill="#aae" opacity="0.7"/>
    <rect x="${s-12}" y="${s/2+2}" width="4" height="3" fill="#aae" opacity="0.7"/>
  `));

  // Nefia (dungeon) marker
  mgr.cache['location_nefia'] = mgr.svgToImage(mgr.wrap(`
    <polygon points="${s/2},${s-4} 4,4 ${s-4},4" fill="#884444"/>
    <polygon points="${s/2},${s-8} 8,6 ${s-8},6" fill="#aa5555"/>
    <rect x="${s/2-3}" y="${s/3}" width="6" height="8" fill="#333" rx="2"/>
    <rect x="${s/2-2}" y="${s/3+2}" width="4" height="5" fill="#600"/>
  `));

  // Home marker
  mgr.cache['location_home'] = mgr.svgToImage(mgr.wrap(`
    <rect x="6" y="${s/2}" width="${s-12}" height="${s/2-4}" fill="#5a8a3a" rx="2"/>
    <polygon points="${s/2},4 4,${s/2} ${s-4},${s/2}" fill="#6aaa4a"/>
    <rect x="${s/2-3}" y="${s/2+4}" width="6" height="${s/2-6}" fill="#8a6a3a"/>
    <rect x="10" y="${s/2+2}" width="3" height="3" fill="#ffe" opacity="0.7"/>
  `));
});

</script>
  <script>
// ============================================================
// Crop Tiles â€” growth stages for each crop type
// Linked to: data/crops.json (crop properties like growthTime, stages)
// Crop colors pulled from crops.json color arrays (stage 4 color)
// ============================================================

SVGTileManager.register('crops', (mgr) => {
  const s = mgr.tileSize;

  // â”€â”€ Generic crop stages (fallback) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let stage = 0; stage <= 4; stage++) {
    const height = 2 + stage * 4;
    const green = Math.min(255, 80 + stage * 40);
    mgr.cache[`crop_stage_${stage}`] = mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5a4030"/>
      <line x1="0" y1="5" x2="${s}" y2="5" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="17" x2="${s}" y2="17" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="29" x2="${s}" y2="29" stroke="#4a3020" stroke-width="2"/>
      ${stage > 0 ? `
        <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s-4-height}" stroke="rgb(40,${green},40)" stroke-width="2" stroke-linecap="round"/>
        ${stage >= 2 ? `<ellipse cx="${s/2-3}" cy="${s-6-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${green},50)" opacity="0.8" transform="rotate(-15 ${s/2-3} ${s-6-height/2})"/>` : ''}
        ${stage >= 2 ? `<ellipse cx="${s/2+3}" cy="${s-8-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${green},50)" opacity="0.8" transform="rotate(15 ${s/2+3} ${s-8-height/2})"/>` : ''}
        ${stage >= 4 ? `<circle cx="${s/2}" cy="${s-4-height}" r="3" fill="#e44" opacity="0.8"/>` : ''}
      ` : ''}
    `));
  }

  // â”€â”€ Per-crop stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Colors match the harvest color from data/crops.json
  const cropColors = {
    turnip:     '#2d2',   // crops.json â†’ turnip.colors[4]
    potato:     '#ca8',   // crops.json â†’ potato.colors[4]
    strawberry: '#d44',   // crops.json â†’ strawberry.colors[4]
    corn:       '#cc4',   // crops.json â†’ corn.colors[4]
    tomato:     '#e32',   // crops.json â†’ tomato.colors[4]
    carrot:     '#e82',   // crops.json â†’ carrot.colors[4]
    herb:       '#0c0',   // crops.json â†’ herb.colors[4]
    pumpkin:    '#e80',   // crops.json â†’ pumpkin.colors[4]
    wheat:      '#da4'    // crops.json â†’ wheat.colors[4]
  };

  Object.entries(cropColors).forEach(([crop, color]) => {
    for (let stage = 0; stage <= 4; stage++) {
      const height = 2 + stage * 4;
      const g = Math.min(255, 80 + stage * 40);
      mgr.cache[`crop_${crop}_${stage}`] = mgr.svgToImage(mgr.wrap(`
        <rect width="${s}" height="${s}" fill="#5a4030"/>
        <line x1="0" y1="5" x2="${s}" y2="5" stroke="#4a3020" stroke-width="2"/>
        <line x1="0" y1="17" x2="${s}" y2="17" stroke="#4a3020" stroke-width="2"/>
        <line x1="0" y1="29" x2="${s}" y2="29" stroke="#4a3020" stroke-width="2"/>
        ${stage > 0 ? `
          <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s-4-height}" stroke="rgb(40,${g},40)" stroke-width="2" stroke-linecap="round"/>
          ${stage >= 2 ? `<ellipse cx="${s/2-3}" cy="${s-6-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${g},50)" opacity="0.8" transform="rotate(-15 ${s/2-3} ${s-6-height/2})"/>` : ''}
          ${stage >= 2 ? `<ellipse cx="${s/2+3}" cy="${s-8-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${g},50)" opacity="0.8" transform="rotate(15 ${s/2+3} ${s-8-height/2})"/>` : ''}
          ${stage >= 4 ? `<circle cx="${s/2}" cy="${s-4-height}" r="3" fill="${color}" opacity="0.9"/>` : ''}
        ` : ''}
      `));
    }
  });
});

</script>

  <script>
// ============================================================
// Renderer â€” Canvas drawing with SVG tiles for world & local maps
// ============================================================

class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.tileSize = 32;
    this.cameraX = 0;
    this.cameraY = 0;
    this.viewCols = 0;
    this.viewRows = 0;
    this.tiles = new SVGTileManager(this.tileSize);
    this._resize();
    window.addEventListener('resize', () => this._resize());
  }

  _resize() {
    const parent = this.canvas.parentElement;
    if (!parent) return;
    // Use the canvas element's own CSS-layout size, not the parent's full width.
    // The parent (#gameViewport) is a flex container shared with the side panel,
    // so parent.clientWidth includes space allocated to the side panel.
    // canvas.clientWidth respects the flex: 1 constraint and gives us just our slice.
    const w = this.canvas.clientWidth;
    const h = this.canvas.clientHeight;
    const newW = Math.max(Math.floor(w), 200);
    const newH = Math.max(Math.floor(h), 200);
    // Only resize if dimensions actually changed to avoid canvas reset / 1px drift
    if (this.canvas.width !== newW || this.canvas.height !== newH) {
      this.canvas.width = newW;
      this.canvas.height = newH;
    }
    this.viewCols = Math.floor(this.canvas.width / this.tileSize);
    this.viewRows = Math.floor(this.canvas.height / this.tileSize);
  }

  // â”€â”€ World Map Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderWorldMap(state) {
    const ctx = this.ctx;
    const ts = this.tileSize;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    if (!state.worldMap) return;

    const mapH = state.worldMap.length;
    const mapW = state.worldMap[0].length;

    // Center camera on player
    this.cameraX = Math.max(0, Math.min(state.worldX - Math.floor(this.viewCols / 2), mapW - this.viewCols));
    this.cameraY = Math.max(0, Math.min(state.worldY - Math.floor(this.viewRows / 2), mapH - this.viewRows));

    for (let row = 0; row < this.viewRows && row + this.cameraY < mapH; row++) {
      for (let col = 0; col < this.viewCols && col + this.cameraX < mapW; col++) {
        const wy = row + this.cameraY;
        const wx = col + this.cameraX;
        const biome = state.worldMap[wy][wx];
        const dx = col * ts;
        const dy = row * ts;

        // Try SVG tile first
        const biomeId = biome.id || biome.biome || '';
        const tileImg = this.tiles.getBiome(biomeId, wx, wy);
        if (tileImg && tileImg.complete && tileImg.naturalWidth > 0) {
          ctx.drawImage(tileImg, dx, dy, ts, ts);
        } else {
          // Fallback: colored rect
          ctx.fillStyle = biome.color || '#333';
          ctx.fillRect(dx, dy, ts, ts);
        }
      }
    }

    // Draw locations
    if (state.locations) {
      Object.values(state.locations).forEach(loc => {
        const sx = (loc.x - this.cameraX) * ts;
        const sy = (loc.y - this.cameraY) * ts;
        if (sx < 0 || sy < 0 || sx >= this.canvas.width || sy >= this.canvas.height) return;

        const locKey = `location_${loc.type}`;
        const locImg = this.tiles.getLocation(loc.type);
        if (locImg && locImg.complete && locImg.naturalWidth > 0) {
          // Support multi-grid location sprites
          const gs = this.tiles.getGridSize(locKey);
          ctx.drawImage(locImg, sx, sy, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = loc.type === 'town' ? '#ffd700' : loc.type === 'nefia' ? '#ff4444' : '#44ff44';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(loc.type === 'town' ? 'â– ' : loc.type === 'nefia' ? 'â–¼' : 'â™¦', sx + ts / 2, sy + ts / 2);
        }

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 3;
        ctx.fillText(loc.name, sx + ts / 2, sy + ts + 8);
        ctx.shadowBlur = 0;
      });
    }

    // Draw player on world map
    const px = (state.worldX - this.cameraX) * ts;
    const py = (state.worldY - this.cameraY) * ts;
    const playerImg = this.tiles.get('player');
    if (playerImg && playerImg.complete && playerImg.naturalWidth > 0) {
      ctx.drawImage(playerImg, px, py, ts, ts);
    } else {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${ts}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('@', px + ts / 2, py + ts / 2);
    }

    // Player selection glow
    ctx.strokeStyle = 'rgba(106, 143, 223, 0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(px + 1, py + 1, ts - 2, ts - 2);

    // Mini info bar
    ctx.fillStyle = 'rgba(10, 10, 18, 0.8)';
    ctx.fillRect(0, this.canvas.height - 28, this.canvas.width, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = '11px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`World Map â€” Use arrow keys to move, Enter to enter current tile`, 10, this.canvas.height - 12);
  }

  // â”€â”€ Local Map Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderLocalMap(state) {
    const ctx = this.ctx;
    const ts = this.tileSize;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    if (!state.localMap) return;
    const map = state.localMap;
    const player = state.player;

    // Center camera on player
    this.cameraX = Math.max(0, Math.min(player.x - Math.floor(this.viewCols / 2), map.width - this.viewCols));
    this.cameraY = Math.max(0, Math.min(player.y - Math.floor(this.viewRows / 2), map.height - this.viewRows));

    const isNight = state.time && state.time.isNight;
    const fogActive = map.fogActive && map.fogMap;

    // Helper: get fog state for a world tile coordinate
    const getFog = (wx, wy) => {
      if (!fogActive) return 2; // No fog â†’ fully visible
      if (wy < 0 || wy >= map.height || wx < 0 || wx >= map.width) return 0;
      return map.fogMap[wy][wx];
    };

    // Draw tiles
    for (let row = 0; row < this.viewRows && row + this.cameraY < map.height; row++) {
      for (let col = 0; col < this.viewCols && col + this.cameraX < map.width; col++) {
        const ty = row + this.cameraY;
        const tx = col + this.cameraX;
        const tile = map.tiles[ty][tx];
        const dx = col * ts;
        const dy = row * ts;
        const fog = getFog(tx, ty);

        // Unseen tiles: draw pure black
        if (fog === 0) {
          ctx.fillStyle = '#0a0a0f';
          ctx.fillRect(dx, dy, ts, ts);
          continue;
        }

        // Draw the tile (seen or visible)
        // Check for crop tile
        if (tile.crop && tile.crop.cropId !== undefined) {
          const cropImg = this.tiles.getCrop(tile.crop.cropId, tile.crop.stage || 0);
          if (cropImg && cropImg.complete && cropImg.naturalWidth > 0) {
            ctx.drawImage(cropImg, dx, dy, ts, ts);
          } else {
            ctx.fillStyle = tile.color || '#333';
            ctx.fillRect(dx, dy, ts, ts);
          }
        } else {
          // Regular tile
          const tileId = tile.type || tile.tileId || tile.id || '';
          const tileImg = this.tiles.getTile(tileId, tx, ty);
          if (tileImg && tileImg.complete && tileImg.naturalWidth > 0) {
            ctx.drawImage(tileImg, dx, dy, ts, ts);
          } else {
            // Fallback to colored rect
            ctx.fillStyle = tile.color || '#333';
            ctx.fillRect(dx, dy, ts, ts);
          }
        }

        // Draw bed overlay on tile if present
        if (tile.bed && fog >= 1) {
          ctx.fillStyle = tile.bed.color || '#a07040';
          ctx.font = `${Math.floor(ts * 0.7)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.bed.char || '\u2261', dx + ts / 2, dy + ts / 2);
        }

        // Draw furniture (decoration) overlay on tile if present
        if (tile.furniture && fog >= 1) {
          ctx.fillStyle = tile.furniture.color || '#a07040';
          ctx.font = `${Math.floor(ts * 0.7)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.furniture.char || 'â–¡', dx + ts / 2, dy + ts / 2);
        }

        // Draw workshop overlay on tile if present
        if (tile.workshop && fog >= 1) {
          ctx.fillStyle = tile.workshop.color || '#8a6a3a';
          ctx.font = `${Math.floor(ts * 0.7)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.workshop.char || '\u03c0', dx + ts / 2, dy + ts / 2);
        }

        // Night overlay (for visible tiles only; seen tiles get darker overlay below)
        if (isNight && fog === 2) {
          ctx.fillStyle = 'rgba(0, 0, 30, 0.35)';
          ctx.fillRect(dx, dy, ts, ts);
        }

        // Fog overlays for remembered/seen tiles (state 1) â€” dim them significantly
        if (fog === 1) {
          ctx.fillStyle = 'rgba(5, 5, 15, 0.65)';
          ctx.fillRect(dx, dy, ts, ts);
        }
      }
    }

    // Draw items (only on visible tiles; on seen tiles show them dimmed)
    if (map.items) {
      map.items.forEach(item => {
        const fog = getFog(item.x, item.y);
        if (fog === 0) return; // Unseen: don't show

        const sx = (item.x - this.cameraX) * ts;
        const sy = (item.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // Item glow (only on visible tiles)
        if (fog === 2) {
          ctx.fillStyle = 'rgba(200, 200, 50, 0.12)';
          ctx.fillRect(sx, sy, ts, ts);
        }

        // Save context for dimming seen-but-not-visible items
        if (fog === 1) {
          ctx.globalAlpha = 0.35;
        }

        const itemImg = this.tiles.getItem(item);
        if (itemImg && itemImg.complete && itemImg.naturalWidth > 0) {
          // Check multi-grid size for the item's cache key
          const itemKey = this.tiles._getItemKey(item);
          const gs = itemKey ? this.tiles.getGridSize(itemKey) : { w: 1, h: 1 };
          ctx.drawImage(itemImg, sx, sy, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = item.color || '#dd0';
          ctx.font = `bold ${ts - 3}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(item.char || '!', sx + ts / 2, sy + ts / 2);
        }

        if (fog === 1) {
          ctx.globalAlpha = 1.0;
        }
      });
    }

    // Draw monsters (only if currently visible â€” fog state 2)
    if (map.monsters) {
      map.monsters.forEach(m => {
        if (fogActive && getFog(m.x, m.y) !== 2) return; // Hidden in fog

        const sx = (m.x - this.cameraX) * ts;
        const sy = (m.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // Monster background tint
        ctx.fillStyle = 'rgba(200, 50, 50, 0.15)';
        ctx.fillRect(sx, sy, ts, ts);

        const mId = m.templateId || m.id || '';
        const mKey = `monster_${mId}`;
        const monImg = this.tiles.getMonster(mId);
        if (monImg && monImg.complete && monImg.naturalWidth > 0) {
          const gs = this.tiles.getGridSize(mKey);
          // For multi-grid monsters, offset so anchor is bottom-center
          const drawX = gs.w > 1 ? sx - ts * (gs.w - 1) / 2 : sx;
          const drawY = gs.h > 1 ? sy - ts * (gs.h - 1) : sy;
          ctx.drawImage(monImg, drawX, drawY, ts * gs.w, ts * gs.h);
          // Boss: purple glow
          if (m.isBoss) {
            ctx.strokeStyle = 'rgba(180, 80, 255, 0.7)';
            ctx.lineWidth = 2;
            ctx.strokeRect(sx + 1, sy + 1, ts - 2, ts - 2);
          }
        } else {
          ctx.fillStyle = m.color || '#e44';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(m.char || 'M', sx + ts / 2, sy + ts / 2);
        }

        // HP bar
        if (m.hp < m.maxHp) {
          const hpPct = m.hp / m.maxHp;
          const barH = 4;
          ctx.fillStyle = '#300';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
          ctx.fillStyle = hpPct > 0.5 ? '#4d4' : hpPct > 0.25 ? '#dd4' : '#d44';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, (ts - 4) * hpPct, barH);
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
        }
      });
    }

    // Draw pets (player allies â€” only if currently visible)
    if (state.pets) {
      state.pets.forEach(pet => {
        if (pet.isDead) return;
        if (fogActive && getFog(pet.x, pet.y) !== 2) return;

        const sx = (pet.x - this.cameraX) * ts;
        const sy = (pet.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // Pet background glow (green-tinted)
        ctx.fillStyle = 'rgba(50, 200, 80, 0.15)';
        ctx.fillRect(sx, sy, ts, ts);

        // Use monster sprite with a green tint overlay
        const mId = pet.templateId || '';
        const petKey = `monster_${mId}`;
        const petImg = this.tiles.getMonster(mId);
        if (petImg && petImg.complete && petImg.naturalWidth > 0) {
          const gs = this.tiles.getGridSize(petKey);
          const drawX = gs.w > 1 ? sx - ts * (gs.w - 1) / 2 : sx;
          const drawY = gs.h > 1 ? sy - ts * (gs.h - 1) : sy;
          ctx.drawImage(petImg, drawX, drawY, ts * gs.w, ts * gs.h);
          // Green tint overlay to distinguish from hostiles
          ctx.fillStyle = 'rgba(50, 255, 100, 0.15)';
          ctx.fillRect(drawX, drawY, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = pet.color || '#4f4';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(pet.char || 'p', sx + ts / 2, sy + ts / 2);
        }

        // Green ally border
        ctx.strokeStyle = 'rgba(80, 220, 120, 0.7)';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(sx + 1, sy + 1, ts - 2, ts - 2);

        // HP bar
        if (pet.hp < pet.maxHp) {
          const hpPct = pet.hp / pet.maxHp;
          const barH = 4;
          ctx.fillStyle = '#030';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
          ctx.fillStyle = hpPct > 0.5 ? '#4d4' : hpPct > 0.25 ? '#dd4' : '#d44';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, (ts - 4) * hpPct, barH);
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
        }

        // Pet name label
        ctx.fillStyle = '#8f8';
        ctx.font = '9px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 2;
        ctx.fillText(pet.name, sx + ts / 2, sy - 1);
        ctx.shadowBlur = 0;
      });
    }

    // Draw NPCs (shop keepers â€” only if currently visible)
    if (state.npcs) {
      state.npcs.forEach(npc => {
        if (fogActive && getFog(npc.x, npc.y) !== 2) return;

        const sx = (npc.x - this.cameraX) * ts;
        const sy = (npc.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // NPC background glow
        ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
        ctx.fillRect(sx, sy, ts, ts);

        const npcName = npc.npcName || npc.name || '';
        const npcKey = `npc_${npcName ? npcName.toLowerCase().replace(/\s/g, '') : 'generic'}`;
        const npcImg = this.tiles.getNpc(npcName);
        if (npcImg && npcImg.complete && npcImg.naturalWidth > 0) {
          const gs = this.tiles.getGridSize(npcKey);
          const drawX = gs.w > 1 ? sx - ts * (gs.w - 1) / 2 : sx;
          const drawY = gs.h > 1 ? sy - ts * (gs.h - 1) : sy;
          ctx.drawImage(npcImg, drawX, drawY, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = npc.color || '#ffd700';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(npc.char || 'â˜º', sx + ts / 2, sy + ts / 2);
        }

        // NPC name label
        ctx.fillStyle = '#ffd700';
        ctx.font = '9px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 2;
        ctx.fillText(npc.name, sx + ts / 2, sy - 1);
        ctx.shadowBlur = 0;
      });
    }

    // Draw player
    const ppx = (player.x - this.cameraX) * ts;
    const ppy = (player.y - this.cameraY) * ts;

    const playerImg = this.tiles.get('player');
    if (playerImg && playerImg.complete && playerImg.naturalWidth > 0) {
      const gs = this.tiles.getGridSize('player');
      const drawX = gs.w > 1 ? ppx - ts * (gs.w - 1) / 2 : ppx;
      const drawY = gs.h > 1 ? ppy - ts * (gs.h - 1) : ppy;
      ctx.drawImage(playerImg, drawX, drawY, ts * gs.w, ts * gs.h);
    } else {
      ctx.fillStyle = 'rgba(100, 150, 255, 0.15)';
      ctx.fillRect(ppx, ppy, ts, ts);
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${ts}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('@', ppx + ts / 2, ppy + ts / 2);
    }

    // Player glow
    ctx.strokeStyle = 'rgba(106, 143, 223, 0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ppx + 1, ppy + 1, ts - 2, ts - 2);

    // â”€â”€ Atmospheric light gradient overlay (fog of war) â”€â”€
    // Draw a subtle radial light gradient around the player for immersive feel
    if (fogActive && map.visRange) {
      const centerX = ppx + ts / 2;
      const centerY = ppy + ts / 2;
      const lightPixelRadius = map.visRange * ts;

      // Create a soft vignette effect at the visibility boundary
      const gradient = ctx.createRadialGradient(
        centerX, centerY, lightPixelRadius * 0.5,
        centerX, centerY, lightPixelRadius * 1.1
      );
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(1, 'rgba(5, 5, 15, 0.3)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    // Location name bar
    ctx.fillStyle = 'rgba(10, 10, 18, 0.8)';
    ctx.fillRect(0, this.canvas.height - 28, this.canvas.width, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = '11px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const floorText = state.nefiaFloor ? ` â€” Floor ${state.nefiaFloor}` : '';
    // Show visibility range info when fog is active
    const visText = fogActive ? ` â€” Vis: ${map.visRange}` : '';
    ctx.fillText(`${map.locationName || 'Unknown'}${floorText}${visText} â€” Arrow keys to move, bump to attack`, 10, this.canvas.height - 12);

    // Draw minimap overlay
    this.renderMiniMap(state);
  }

  // â”€â”€ Mini Map Overlay (shown on local map) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderMiniMap(state) {
    if (!state.localMap) return;

    const ctx = this.ctx;
    const map = state.localMap;
    const player = state.player;
    const mapH = map.height;
    const mapW = map.width;

    // Mini map configuration â€” scale to fit a reasonable size
    const maxMiniSize = 160;
    const miniTile = Math.max(1, Math.min(Math.floor(maxMiniSize / Math.max(mapW, mapH)), 4));
    const miniW = mapW * miniTile;
    const miniH = mapH * miniTile;
    const padding = 10;
    const borderRadius = 6;

    // Position: bottom-left corner of the canvas
    const ox = padding + 4;
    const oy = this.canvas.height - miniH - padding - 34; // 34 = above the info bar

    const fogActive = map.fogActive && map.fogMap;

    // Draw background with rounded corners
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(ox - 4, oy - 4, miniW + 8, miniH + 8, borderRadius + 2);
    ctx.fillStyle = 'rgba(5, 5, 15, 0.85)';
    ctx.fill();

    // Clip to rounded rect for inner content
    ctx.beginPath();
    ctx.roundRect(ox - 2, oy - 2, miniW + 4, miniH + 4, borderRadius);
    ctx.clip();

    // Draw border
    ctx.strokeStyle = 'rgba(100, 120, 160, 0.6)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Draw tiles
    for (let row = 0; row < mapH; row++) {
      for (let col = 0; col < mapW; col++) {
        const fog = fogActive ? map.fogMap[row][col] : 2;

        if (fog === 0) {
          // Unseen
          ctx.fillStyle = '#0a0a0f';
        } else {
          const tile = map.tiles[row][col];
          ctx.fillStyle = tile.color || '#333';
        }
        ctx.fillRect(ox + col * miniTile, oy + row * miniTile, miniTile, miniTile);

        // Dim seen-but-not-visible tiles
        if (fog === 1) {
          ctx.fillStyle = 'rgba(5, 5, 15, 0.55)';
          ctx.fillRect(ox + col * miniTile, oy + row * miniTile, miniTile, miniTile);
        }
      }
    }

    // Draw monsters as red dots (only visible ones)
    if (map.monsters) {
      map.monsters.forEach(m => {
        const fog = fogActive ? (map.fogMap[m.y] && map.fogMap[m.y][m.x]) : 2;
        if (fog !== 2) return;
        ctx.fillStyle = '#e44';
        ctx.fillRect(ox + m.x * miniTile, oy + m.y * miniTile, miniTile, miniTile);
      });
    }

    // Draw NPCs as gold dots
    if (state.npcs) {
      state.npcs.forEach(npc => {
        const fog = fogActive ? (map.fogMap[npc.y] && map.fogMap[npc.y][npc.x]) : 2;
        if (fog !== 2) return;
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(ox + npc.x * miniTile, oy + npc.y * miniTile, miniTile, miniTile);
      });
    }

    // Draw pets as green dots
    if (state.pets) {
      state.pets.forEach(pet => {
        if (pet.isDead) return;
        ctx.fillStyle = '#4f4';
        ctx.fillRect(ox + pet.x * miniTile, oy + pet.y * miniTile, miniTile, miniTile);
      });
    }

    // Draw player position â€” pulsing glow
    const px = ox + player.x * miniTile;
    const py = oy + player.y * miniTile;

    // Glow effect
    const pulse = 0.6 + 0.4 * Math.sin(Date.now() / 300);
    ctx.fillStyle = `rgba(106, 143, 223, ${0.3 * pulse})`;
    const glowSize = Math.max(miniTile, 3);
    ctx.fillRect(px - glowSize, py - glowSize, glowSize * 3, glowSize * 3);

    // Player dot
    ctx.fillStyle = '#fff';
    ctx.fillRect(px, py, miniTile, miniTile);
    ctx.strokeStyle = `rgba(106, 180, 255, ${pulse})`;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(px - 0.5, py - 0.5, miniTile + 1, miniTile + 1);

    // Draw camera viewport rectangle
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 1;
    ctx.strokeRect(
      ox + this.cameraX * miniTile,
      oy + this.cameraY * miniTile,
      this.viewCols * miniTile,
      this.viewRows * miniTile
    );

    ctx.restore();

    // Label
    ctx.fillStyle = 'rgba(200, 210, 230, 0.7)';
    ctx.font = '9px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(map.locationName || 'Local Map', ox + 2, oy + miniH + 6);
  }

  // â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _lighten(hex, amt) {
    return this._adjustColor(hex, amt);
  }

  _darken(hex, amt) {
    return this._adjustColor(hex, -amt);
  }

  _adjustColor(hex, amt) {
    hex = hex.replace('#', '');
    if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    return `rgb(${r},${g},${b})`;
  }

  getClickedTile(clientX, clientY) {
    const rect = this.canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    return {
      tileX: Math.floor(x / this.tileSize) + this.cameraX,
      tileY: Math.floor(y / this.tileSize) + this.cameraY
    };
  }
}

</script>
  <script>
// ============================================================
// UI â€” Screen management, HUD, panels, menus
// ============================================================

class UI {
  constructor() {
    // Screens
    this.screens = {
      mainMenu: document.getElementById('mainMenu'),
      charCreation: document.getElementById('charCreation'),
      gameScreen: document.getElementById('gameScreen'),
      gameOver: document.getElementById('gameOver')
    };

    // HUD elements
    this.hud = {
      name: document.getElementById('hudName'),
      level: document.getElementById('hudLevel'),
      hpBar: document.getElementById('hpFill'),
      hpText: document.getElementById('hpText'),
      mpBar: document.getElementById('mpFill'),
      mpText: document.getElementById('mpText'),
      spBar: document.getElementById('spFill'),
      spText: document.getElementById('spText'),
      foodBar: document.getElementById('foodFill'),
      foodText: document.getElementById('foodText'),
      time: document.getElementById('hudTime'),
      weather: document.getElementById('hudWeather')
    };

    // Side panel
    this.inventoryList = document.getElementById('inventoryList');
    this.characterInfo = document.getElementById('characterInfo');
    this.skillsList = document.getElementById('skillsList');
    this.spellList = document.getElementById('spellList');
    this.shopPanel = document.getElementById('shopPanel');
    this.craftPanel = document.getElementById('craftPanel');
    this.questPanel = document.getElementById('questPanel');
    this.petPanel = document.getElementById('petPanel');
    this.faithPanel = document.getElementById('faithPanel');
    this.cardBookPanel = document.getElementById('cardBookPanel');
    this.messageLog = document.getElementById('messageLog');

    // Create selects
    this.raceSelect = document.getElementById('raceSelect');
    this.classSelect = document.getElementById('classSelect');
    this.raceInfo = document.getElementById('raceInfo');
    this.classInfo = document.getElementById('classInfo');

    this._initTabs();
    this._populateCharCreation();
  }

  // â”€â”€ Screen Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  showScreen(name) {
    Object.values(this.screens).forEach(s => s.classList.add('hidden'));
    if (this.screens[name]) this.screens[name].classList.remove('hidden');
  }

  // â”€â”€ Tab Switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _initTabs() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        const panels = document.querySelectorAll('.tab-panel');
        panels.forEach(p => p.classList.remove('active'));
        const target = document.getElementById(tab.dataset.tab);
        if (target) target.classList.add('active');
      });
    });
  }

  // â”€â”€ Character Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _populateCharCreation() {
    if (!this.raceSelect || !this.classSelect) return;

    CLIENT_RACES.forEach(r => {
      const opt = document.createElement('option');
      opt.value = r.id;
      opt.textContent = r.name;
      this.raceSelect.appendChild(opt);
    });

    CLIENT_CLASSES.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = c.name;
      this.classSelect.appendChild(opt);
    });

    this.raceSelect.addEventListener('change', () => this._updateRaceInfo());
    this.classSelect.addEventListener('change', () => this._updateClassInfo());

    this._updateRaceInfo();
    this._updateClassInfo();
  }

  _updateRaceInfo() {
    const r = CLIENT_RACES.find(x => x.id === this.raceSelect.value);
    if (!r || !this.raceInfo) return;
    const attrText = r.attrs
      .filter(a => a.mod !== 0)
      .map(a => `${a.id} ${a.mod > 0 ? '+' : ''}${a.mod}`)
      .join(', ');
    this.raceInfo.innerHTML = `
      <p class="desc">${r.desc}</p>
      <p><strong>Attributes:</strong> ${attrText || 'None'}</p>
      <p><strong>Feat:</strong> ${r.feat}</p>
    `;
  }

  _updateClassInfo() {
    const c = CLIENT_CLASSES.find(x => x.id === this.classSelect.value);
    if (!c || !this.classInfo) return;
    const attrText = c.attrs
      .filter(a => a.mod !== 0)
      .map(a => `${a.id} ${a.mod > 0 ? '+' : ''}${a.mod}`)
      .join(', ');
    this.classInfo.innerHTML = `
      <p class="desc">${c.desc}</p>
      <p><strong>Attributes:</strong> ${attrText || 'None'}</p>
      <p><strong>Feat:</strong> ${c.feat}</p>
      <p><strong>Domains:</strong> ${c.domains.join(', ')}</p>
    `;
  }

  getCreationData() {
    const nameInput = document.getElementById('charName');
    return {
      name: nameInput ? nameInput.value.trim() || 'Adventurer' : 'Adventurer',
      race: this.raceSelect ? this.raceSelect.value : 'yerles',
      class: this.classSelect ? this.classSelect.value : 'warrior'
    };
  }

  // â”€â”€ HUD Updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateHUD(state) {
    if (!state || !state.player) return;
    const p = state.player;

    if (this.hud.name) this.hud.name.textContent = p.name || 'Unknown';
    if (this.hud.level) this.hud.level.textContent = `Lv. ${p.level || 1}`;

    this._updateBar(this.hud.hpBar, this.hud.hpText, p.hp, p.maxHp, 'HP');
    this._updateBar(this.hud.mpBar, this.hud.mpText, p.mp, p.maxMp, 'MP');
    this._updateBar(this.hud.spBar, this.hud.spText, p.sp, p.maxSp, 'SP');

    // Food / nutrition
    const maxNut = 15000;
    const nutPct = Math.max(0, (p.nutrition || 0) / maxNut);
    if (this.hud.foodBar) this.hud.foodBar.style.width = `${nutPct * 100}%`;
    if (this.hud.foodText) {
      let label = 'Full';
      if (nutPct < 0.1) label = 'Starving!';
      else if (nutPct < 0.25) label = 'Very Hungry';
      else if (nutPct < 0.5) label = 'Hungry';
      else if (nutPct < 0.75) label = 'Normal';
      this.hud.foodText.textContent = label;
    }

    // Time
    if (this.hud.time && state.time) {
      this.hud.time.textContent = state.time.timeString || '';
    }
    // Weather
    if (this.hud.weather && state.weather) {
      const icon = WEATHER_ICONS[state.weather] || '';
      this.hud.weather.textContent = `${icon} ${state.weather}`;
    }

    // Crop info overlay (when standing on a crop)
    let cropEl = document.getElementById('cropOverlay');
    if (state.cropInfo) {
      if (!cropEl) {
        cropEl = document.createElement('div');
        cropEl.id = 'cropOverlay';
        cropEl.style.cssText = 'position:absolute;bottom:4px;left:50%;transform:translateX(-50%);background:rgba(20,30,10,0.85);padding:4px 12px;border-radius:4px;font-size:11px;color:#bda;border:1px solid #4a4;z-index:10;white-space:nowrap;';
        document.getElementById('gameViewport').appendChild(cropEl);
      }
      const ci = state.cropInfo;
      const harvestable = ci.harvestable;
      const statusColor = harvestable ? '#4f4' : (ci.inSeason ? '#ad4' : '#a84');
      const barPct = ci.progress;
      cropEl.innerHTML = `ğŸŒ± <strong>${ci.name}</strong> â€” <span style="color:${statusColor}">${ci.stageName}</span> ` +
        `<span style="color:#888">[${barPct}%]</span>` +
        (ci.inSeason ? '' : ' <span style="color:#a64">â˜€off-season</span>') +
        (harvestable ? ' <span style="color:#4f4">âŸ¶ Press H to harvest!</span>' : '');
      cropEl.style.display = '';
    } else if (cropEl) {
      cropEl.style.display = 'none';
    }

    // Furniture info overlay (when standing on placed furniture)
    let furnEl = document.getElementById('furnitureOverlay');
    if (state.furnitureInfo) {
      if (!furnEl) {
        furnEl = document.createElement('div');
        furnEl.id = 'furnitureOverlay';
        furnEl.style.cssText = 'position:absolute;bottom:22px;left:50%;transform:translateX(-50%);background:rgba(20,20,30,0.85);padding:4px 12px;border-radius:4px;font-size:11px;color:#cba;border:1px solid #886;z-index:10;white-space:nowrap;';
        document.getElementById('gameViewport').appendChild(furnEl);
      }
      const fi = state.furnitureInfo;
      furnEl.innerHTML = `ğŸ  <strong>${fi.name}</strong>` +
        (fi.beauty ? ` â€” <span style="color:#8aaa6a">Beauty: ${fi.beauty}</span>` : '') +
        ` <span style="color:#888">(U to pick up)</span>`;
      furnEl.style.display = '';
    } else if (furnEl) {
      furnEl.style.display = 'none';
    }
  }

  _updateBar(fillEl, textEl, cur, max, label) {
    if (!fillEl) return;
    const pct = max > 0 ? Math.max(0, cur / max) : 0;
    fillEl.style.width = `${pct * 100}%`;
    if (textEl) textEl.textContent = `${label}: ${cur}/${max}`;
  }

  // â”€â”€ Context Actions Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateContextActions(contextActions, onAction) {
    const bar = document.getElementById('contextActions');
    if (!bar) return;
    bar.innerHTML = '';
    if (!contextActions || contextActions.length === 0) return;

    // Separate highlighted (contextual) from always-available
    const highlighted = contextActions.filter(a => a.highlight);
    const normal = contextActions.filter(a => !a.highlight && !a.always);
    const always = contextActions.filter(a => a.always && !a.highlight);

    // Deduplicate by action type (keep the first one with highlight priority)
    const seen = new Set();
    const deduped = [];
    for (const a of [...highlighted, ...normal, ...always]) {
      if (!seen.has(a.action)) {
        seen.add(a.action);
        deduped.push(a);
      }
    }

    // Re-separate after dedup
    const hlActions = deduped.filter(a => a.highlight);
    const restActions = deduped.filter(a => !a.highlight);

    const createActionEl = (a) => {
      const el = document.createElement('div');
      el.className = 'ctx-action' + (a.highlight ? ' ctx-highlight' : '');
      el.innerHTML = `<span class="ctx-icon">${a.icon || ''}</span><span class="ctx-key">${a.key}</span><span class="ctx-label">${a.label}</span>`;
      el.title = `${a.label} (${a.key})`;
      el.addEventListener('click', () => {
        if (onAction) onAction({ type: a.action });
      });
      return el;
    };

    // Render highlighted actions first
    hlActions.forEach(a => bar.appendChild(createActionEl(a)));

    // Separator between highlighted and rest
    if (hlActions.length > 0 && restActions.length > 0) {
      const sep = document.createElement('div');
      sep.className = 'ctx-sep';
      bar.appendChild(sep);
    }

    // Render the rest
    restActions.forEach(a => bar.appendChild(createActionEl(a)));
  }

  // â”€â”€ Messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateMessages(messages) {
    if (!this.messageLog || !messages) return;
    this.messageLog.innerHTML = '';
    const recent = messages.slice(-60);
    recent.forEach(msg => {
      const div = document.createElement('div');
      div.className = 'message';
      if (typeof msg === 'object') {
        div.textContent = msg.text || msg;
        if (msg.type === 'damage') div.style.color = '#e44';
        else if (msg.type === 'heal') div.style.color = '#4e4';
        else if (msg.type === 'loot') div.style.color = '#dd0';
        else if (msg.type === 'important') div.style.color = '#f80';
        else if (msg.type === 'level') div.style.color = '#4af';
      } else {
        div.textContent = msg;
      }
      this.messageLog.appendChild(div);
    });
    this.messageLog.scrollTop = this.messageLog.scrollHeight;
  }

  // â”€â”€ Inventory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateInventory(player, onAction) {
    if (!this.inventoryList || !player) return;
    const inv = player.inventory || [];
    this.inventoryList.innerHTML = '';

    // Gold display
    const goldDiv = document.createElement('div');
    goldDiv.className = 'inventory-gold';
    goldDiv.textContent = `ğŸ’° ${player.gold || 0} Gold`;
    this.inventoryList.appendChild(goldDiv);

    if (inv.length === 0) {
      this.inventoryList.innerHTML += '<p style="color:#666;padding:8px;text-align:center;">Inventory is empty.</p>';
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'inv-grid';

    inv.forEach((item, idx) => {
      const cell = document.createElement('div');
      cell.className = 'inv-cell';

      const equipped = (player.equipment &&
        (player.equipment.weapon === item.id || player.equipment.armor === item.id));
      if (equipped) cell.classList.add('inv-cell-equipped');

      // Type-based border color hint
      const typeColors = {
        weapon: '#8af', armor: '#88f', potion: '#d4f', food: '#4c4',
        seed: '#6a4', spellbook: '#c8f', resource: '#a86', currency: '#ffd700',
        light: '#f80', scroll: '#ffa', tool: '#c90'
      };
      const borderColor = typeColors[item.type] || '#444';
      cell.style.borderColor = borderColor;

      // Icon â€” use SVG sprite if available
      const icon = document.createElement('div');
      icon.className = 'inv-cell-icon';
      const spriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
      if (spriteURL) {
        const img = document.createElement('img');
        img.src = spriteURL;
        img.className = 'inv-cell-sprite';
        img.alt = item.name || '';
        img.draggable = false;
        icon.appendChild(img);
      } else {
        icon.style.color = item.color || '#ccc';
        icon.textContent = item.char || '?';
      }
      cell.appendChild(icon);

      // Quantity badge (only if > 1)
      const qty = item.quantity || 1;
      if (qty > 1) {
        const badge = document.createElement('span');
        badge.className = 'inv-cell-qty';
        badge.textContent = qty;
        cell.appendChild(badge);
      }

      // Equipped badge
      if (equipped) {
        const eBadge = document.createElement('span');
        eBadge.className = 'inv-cell-equip-badge';
        eBadge.textContent = 'E';
        cell.appendChild(eBadge);
      }

      // Tooltip on hover
      cell.title = `${item.name}${qty > 1 ? ' Ã—' + qty : ''}${equipped ? ' [Equipped]' : ''}`;

      // Right-click context menu
      cell.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showInvContextMenu(e, item, idx, player, onAction);
      });

      // Left-click: default quick action
      cell.addEventListener('click', (e) => {
        e.preventDefault();
        this._showInvContextMenu(e, item, idx, player, onAction);
      });

      grid.appendChild(cell);
    });

    this.inventoryList.appendChild(grid);
  }

  // â”€â”€ Inventory Context Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _showInvContextMenu(e, item, idx, player, onAction) {
    // Remove existing menu
    this._closeInvContextMenu();

    const menu = document.createElement('div');
    menu.className = 'inv-context-menu';
    menu.id = 'invContextMenu';

    // Header
    const header = document.createElement('div');
    header.className = 'inv-ctx-header';
    const qty = item.quantity || 1;
    const ctxSpriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
    if (ctxSpriteURL) {
      header.innerHTML = `<img src="${ctxSpriteURL}" class="inv-ctx-sprite" alt="" draggable="false"/> ${item.name}${qty > 1 ? ' <span style="color:#888">Ã—' + qty + '</span>' : ''}`;
    } else {
      header.innerHTML = `<span style="color:${item.color || '#ccc'}">${item.char || '?'}</span> ${item.name}${qty > 1 ? ' <span style="color:#888">Ã—' + qty + '</span>' : ''}`;
    }
    menu.appendChild(header);

    // Stat info
    if (item.type === 'weapon' || item.type === 'armor') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      let stats = '';
      if (item.dice) {
        const enchDmg = item.enchantDamageBonus || 0;
        stats += `Dmg: ${item.dice}${enchDmg > 0 ? '+' + enchDmg : ''} `;
      }
      if (item.PV != null) {
        const enchPV = item.enchantPVBonus || 0;
        stats += `PV: ${item.PV + enchPV} `;
      }
      if (item.DV != null) {
        const enchDV = item.enchantDVBonus || 0;
        stats += `DV: ${item.DV + enchDV} `;
      }
      if (item.damageType) stats += `(${item.damageType})`;
      statsDiv.textContent = stats.trim();
      menu.appendChild(statsDiv);

      // Enchantment info
      if (item.enchantBonus || (item.enchantments && item.enchantments.length > 0)) {
        const enchDiv = document.createElement('div');
        enchDiv.className = 'inv-ctx-stats';
        enchDiv.style.color = '#ffa';
        let enchText = `âœ¨ +${item.enchantBonus || 0}`;
        if (item.enchantments) {
          item.enchantments.forEach(e => {
            enchText += ` | ${e.name || e.type} +${e.power}`;
          });
        }
        enchDiv.textContent = enchText;
        menu.appendChild(enchDiv);
      }
    }
    if (item.type === 'food') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.textContent = `Nutrition: ${item.nutrition || '?'}${item.healHP ? '  HP+' + item.healHP : ''}`;
      menu.appendChild(statsDiv);
    }
    if (item.type === 'potion') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      let info = '';
      if (item.healHP) info += `HP+${item.healHP} `;
      if (item.healMP) info += `MP+${item.healMP} `;
      statsDiv.textContent = info.trim();
      menu.appendChild(statsDiv);
    }
    if (item.type === 'light' || item.lightRadius) {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#ffa';
      statsDiv.textContent = `ğŸ”¥ Light radius: +${item.lightRadius}`;
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
      menu.appendChild(statsDiv);
    }
    if (item.type === 'tool') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#cc9900';
      const toolLabel = item.subtype === 'axeTool' ? 'ğŸª“ Woodcutting' : item.subtype === 'pickaxe' ? 'â› Mining' : 'ğŸ”§ Tool';
      statsDiv.textContent = `${toolLabel} Power: ${item.toolPower || 1}`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'furniture' && item.subtype === 'bed') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#6a8aaa';
      statsDiv.textContent = `ğŸ› Sleep Comfort: ${item.comfort || 0}%`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'furniture' && item.subtype === 'workshop') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#ca8';
      statsDiv.textContent = `ğŸ”¨ Workshop: ${item.workshopType || 'unknown'}`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'furniture' && item.subtype === 'decoration') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#8aaa6a';
      statsDiv.textContent = `ğŸ  Beauty: ${item.beauty || 0}${item.lightRadius ? ` | ğŸ’¡ Light: ${item.lightRadius}` : ''}`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'recipePaper') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#dda';
      statsDiv.textContent = `ğŸ“œ ${item.description || 'Read to learn a new recipe.'}`;
      menu.appendChild(statsDiv);
    }

    const equipped = (player.equipment &&
      (player.equipment.weapon === item.id || player.equipment.armor === item.id));

    // Actions based on item type
    const actions = [];

    if (item.type === 'food') {
      actions.push({ label: 'ğŸ– Eat', action: { type: 'eat', itemIndex: idx } });
    }
    if (item.type === 'potion') {
      actions.push({ label: 'ğŸ§ª Drink', action: { type: 'use', itemIndex: idx } });
    }
    if (item.type === 'spellbook') {
      actions.push({ label: 'ğŸ“– Read', action: { type: 'readSpellbook', itemIndex: idx } });
    }
    if (item.type === 'seed') {
      actions.push({ label: 'ğŸŒ± Plant', action: { type: 'plant', itemIndex: idx } });
    }
    if (item.type === 'scroll' && item.enchantTier) {
      actions.push({ label: 'âœ¨ Enchant...', action: { type: 'openEnchantTarget', scrollIndex: idx } });
    }
    if (item.type === 'furniture' && item.subtype === 'bed') {
      actions.push({ label: 'ğŸ› Place Bed', action: { type: 'placeBed', invIndex: idx } });
    }
    if (item.type === 'furniture' && item.subtype === 'workshop') {
      actions.push({ label: 'ğŸ”¨ Place Workshop', action: { type: 'placeWorkshop', invIndex: idx } });
    }
    if (item.type === 'furniture' && item.subtype === 'decoration') {
      actions.push({ label: 'ğŸ  Place Furniture', action: { type: 'placeFurniture', invIndex: idx } });
    }
    if (item.type === 'recipePaper') {
      actions.push({ label: 'ğŸ“– Read Recipe', action: { type: 'readRecipe', itemIndex: idx } });
    }
    if (item.type === 'weapon' || item.type === 'armor') {
      actions.push({
        label: equipped ? 'ğŸ”“ Unequip' : 'âš”ï¸ Equip',
        action: { type: 'equip', itemIndex: idx }
      });
    }
    actions.push({ label: 'ğŸ—‘ Drop', action: { type: 'drop', itemIndex: idx }, danger: true });

    actions.forEach(act => {
      const btn = document.createElement('div');
      btn.className = 'inv-ctx-action';
      if (act.danger) btn.classList.add('inv-ctx-danger');
      btn.textContent = act.label;
      btn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        this._closeInvContextMenu();
        onAction(act.action);
      });
      menu.appendChild(btn);
    });

    // Position the menu
    document.body.appendChild(menu);

    // Adjust position to stay on screen
    const rect = menu.getBoundingClientRect();
    let x = e.clientX;
    let y = e.clientY;
    if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 4;
    if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 4;
    if (x < 0) x = 4;
    if (y < 0) y = 4;
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Close on click outside
    const closeHandler = (ev) => {
      if (!menu.contains(ev.target)) {
        this._closeInvContextMenu();
        document.removeEventListener('mousedown', closeHandler);
      }
    };
    setTimeout(() => document.addEventListener('mousedown', closeHandler), 0);
  }

  _closeInvContextMenu() {
    const existing = document.getElementById('invContextMenu');
    if (existing) existing.remove();
  }

  // â”€â”€ Character Sheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateCharacter(player) {
    if (!this.characterInfo || !player) return;

    const attrs = player.attributes || {};
    let html = `
      <div class="char-section">
        <h4>${player.name} â€” ${player.raceName || ''} ${player.className || ''}</h4>
        <p>Level: ${player.level || 1} &nbsp; XP: ${player.exp || 0}/${player.expNext || 100}</p>
        <p>Gold: ${player.gold || 0}</p>
      </div>
      <div class="char-section">
        <h4>Attributes</h4>
        <table style="width:100%;font-size:11px;">
    `;
    Object.entries(ATTR_NAMES).forEach(([id, name]) => {
      const val = attrs[id] || 0;
      html += `<tr><td style="color:#8af">${id}</td><td>${name}</td><td style="text-align:right">${val}</td></tr>`;
    });
    html += `</table></div>`;

    // Equipment
    html += `<div class="char-section"><h4>Equipment</h4>`;
    if (player.equipment) {
      if (player.equipment.weaponName) html += `<p>Weapon: ${player.equipment.weaponName}</p>`;
      else html += `<p>Weapon: (none)</p>`;
      if (player.equipment.armorName) html += `<p>Armor: ${player.equipment.armorName}</p>`;
      else html += `<p>Armor: (none)</p>`;
    }
    html += `</div>`;

    // Combat stats
    html += `<div class="char-section"><h4>Stats</h4>`;
    html += `<p>DV: ${player.dv || 0} &nbsp; PV: ${player.pv || 0}</p>`;
    html += `<p>Speed: ${player.speed || 100}</p>`;
    html += `</div>`;

    this.characterInfo.innerHTML = html;
  }

  // â”€â”€ Skills â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateSkills(player) {
    if (!this.skillsList || !player || !player.skills) return;
    const skills = player.skills;

    // Group skills by category
    const grouped = {};
    Object.entries(skills).forEach(([id, data]) => {
      const def = (typeof SKILL_DEFS !== 'undefined' && SKILL_DEFS[id]) || {};
      const cat = def.category || 'other';
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push({ id, data, def });
    });

    const categoryOrder = ['combat', 'weapon', 'crafting', 'general', 'other'];
    const categoryLabels = { combat: 'âš” Combat', weapon: 'ğŸ—¡ Weapon', crafting: 'ğŸ”¨ Crafting', general: 'ğŸ“‹ General', other: 'â“ Other' };

    let html = '';
    categoryOrder.forEach(cat => {
      if (!grouped[cat] || grouped[cat].length === 0) return;
      html += `<div class="skill-category-header">${categoryLabels[cat] || cat}</div>`;
      grouped[cat].forEach(({ id, data, def }) => {
        const lvl = data.level || data;
        const displayName = def.name || id;
        const attr = def.attr || '';
        html += `<div class="skill-row" data-skill-id="${id}" title="Click for details">
          <span class="skill-name">${displayName}</span>
          <span class="skill-meta"><span class="skill-attr">${attr}</span> <span class="skill-level">Lv.${lvl}</span></span>
        </div>`;
      });
    });

    this.skillsList.innerHTML = html || '<p style="color:#666">No skills yet.</p>';

    // Add click handlers for skill popups
    this.skillsList.querySelectorAll('.skill-row[data-skill-id]').forEach(row => {
      row.addEventListener('click', (e) => {
        const skillId = row.dataset.skillId;
        const def = (typeof SKILL_DEFS !== 'undefined' && SKILL_DEFS[skillId]) || {};
        const playerSkill = skills[skillId];
        const lvl = playerSkill.level || playerSkill;
        this._showSkillPopup(e, skillId, def, lvl);
      });
    });
  }

  _showSkillPopup(e, skillId, def, level) {
    // Remove any existing skill popup
    const existing = document.querySelector('.skill-popup');
    if (existing) existing.remove();

    const popup = document.createElement('div');
    popup.className = 'skill-popup';

    const displayName = def.name || skillId;
    const attr = def.attr || 'â€”';
    const category = def.category || 'other';
    const description = def.description || 'No description available.';
    const catLabels = { combat: 'âš” Combat', weapon: 'ğŸ—¡ Weapon', crafting: 'ğŸ”¨ Crafting', general: 'ğŸ“‹ General', other: 'â“ Other' };

    popup.innerHTML = `
      <div class="skill-popup-header">
        <span class="skill-popup-name">${displayName}</span>
        <span class="skill-popup-close">âœ•</span>
      </div>
      <div class="skill-popup-tags">
        <span class="skill-popup-tag">${catLabels[category] || category}</span>
        <span class="skill-popup-tag">Attr: ${attr}</span>
        <span class="skill-popup-tag">Level ${level}</span>
      </div>
      <div class="skill-popup-desc">${description}</div>
    `;

    document.body.appendChild(popup);

    // Position near click
    const rect = popup.getBoundingClientRect();
    let x = e.clientX + 10;
    let y = e.clientY - 10;
    if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 10;
    if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 10;
    if (y < 0) y = 10;
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';

    // Close on click outside or close button
    const closePopup = () => { popup.remove(); document.removeEventListener('mousedown', outsideClick); };
    popup.querySelector('.skill-popup-close').addEventListener('click', closePopup);
    const outsideClick = (ev) => { if (!popup.contains(ev.target)) closePopup(); };
    setTimeout(() => document.addEventListener('mousedown', outsideClick), 0);
  }

  // â”€â”€ Spells â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateSpells(player, onCastSpell) {
    if (!this.spellList) return;
    const spells = player && player.spells ? player.spells : [];
    this.spellList.innerHTML = '';

    if (spells.length === 0) {
      this.spellList.innerHTML = '<p style="color:#666">No spells memorized.<br><span style="font-size:10px">Read a spellbook to learn spells.</span></p>';
      return;
    }

    // Active buffs display
    if (player.buffs && player.buffs.length > 0) {
      const buffDiv = document.createElement('div');
      buffDiv.style.cssText = 'padding:4px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;';
      buffDiv.innerHTML = '<strong style="color:#ffa">Active Buffs:</strong><br>' +
        player.buffs.map(b => `<span style="color:#8cf">âœ¦ ${b.name}</span> <span style="color:#666">(${b.turnsLeft}t)</span>`).join('<br>');
      this.spellList.appendChild(buffDiv);
    }

    spells.forEach(spell => {
      const div = document.createElement('div');
      div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:4px;border-bottom:1px solid #222;font-size:11px;';

      const info = document.createElement('div');
      info.style.flex = '1';
      const stockColor = spell.stock > 0 ? '#4f4' : '#f44';
      const typeIcon = { bolt: 'â†’', ball: 'â—', heal: '+', buff: 'â—‡', teleport: 'Â¤' }[spell.type] || '?';
      info.innerHTML = `
        <span style="color:${spell.color || '#c8f'}">${typeIcon}</span>
        <strong>${spell.name}</strong>
        <span style="color:#888;font-size:9px"> Lv.${spell.skillLevel}</span><br>
        <span style="color:#68c;font-size:9px">MP:${spell.manaCost}</span>
        <span style="color:${stockColor};font-size:9px"> Stock:${spell.stock}</span>
        <span style="color:#666;font-size:9px"> [${spell.domain}]</span>
      `;
      div.appendChild(info);

      if (spell.stock > 0) {
        const castBtn = document.createElement('button');
        castBtn.textContent = 'Cast';
        castBtn.className = 'btn btn-small';
        castBtn.style.cssText = 'font-size:9px;padding:2px 8px;margin-left:4px;background:#436;';
        castBtn.onclick = () => onCastSpell(spell.id);
        div.appendChild(castBtn);
      } else {
        const emptySpan = document.createElement('span');
        emptySpan.textContent = 'Empty';
        emptySpan.style.cssText = 'color:#f44;font-size:9px;padding:2px 4px;';
        div.appendChild(emptySpan);
      }

      this.spellList.appendChild(div);
    });
  }

  // â”€â”€ Shop Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateShop(state, onBuy, onSell) {
    if (!this.shopPanel) return;
    this.shopPanel.innerHTML = '';

    if (!state.shop) {
      this.shopPanel.innerHTML = '<p style="color:#666">Walk onto an NPC in a town to browse their shop.</p>';
      return;
    }

    const shop = state.shop;
    const player = state.player;

    // Header
    const header = document.createElement('div');
    header.style.cssText = 'padding:6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;text-align:center;';
    header.innerHTML = `<span style="color:${shop.color};font-size:16px">${shop.char}</span> <strong>${shop.name}</strong><br><span style="color:#888;font-size:10px">${shop.npcName} â€” Gold: <span style="color:#ffd700">${player.gold || 0}gp</span></span>`;
    this.shopPanel.appendChild(header);

    // Buy section
    const buyLabel = document.createElement('div');
    buyLabel.style.cssText = 'font-size:10px;color:#4af;padding:2px 4px;border-bottom:1px solid #333;margin-bottom:2px;font-weight:bold;';
    buyLabel.textContent = 'â”€â”€ BUY â”€â”€';
    this.shopPanel.appendChild(buyLabel);

    shop.items.forEach(item => {
      const div = document.createElement('div');
      div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:3px 4px;border-bottom:1px solid #1a1a2a;font-size:11px;';

      const info = document.createElement('span');
      info.style.flex = '1';
      const stockColor = item.stock > 0 ? '#8c8' : '#844';
      const shopBuySpriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
      const shopBuyIcon = shopBuySpriteURL
        ? `<img src="${shopBuySpriteURL}" class="shop-item-sprite" alt="" draggable="false"/>`
        : `<span style="color:${item.color}">${item.char}</span>`;
      info.innerHTML = `${shopBuyIcon} ${item.name} <span style="color:#888;font-size:9px">(${item.type})</span><br><span style="color:#ffd700;font-size:9px">${item.buyPrice}gp</span> <span style="color:${stockColor};font-size:9px">Ã—${item.stock}</span>`;
      div.appendChild(info);

      if (item.stock > 0) {
        const buyBtn = document.createElement('button');
        buyBtn.textContent = 'Buy';
        buyBtn.className = 'btn btn-small';
        buyBtn.style.cssText = 'font-size:9px;padding:2px 8px;margin-left:4px;background:#254;';
        const canAfford = (player.gold || 0) >= item.buyPrice;
        if (!canAfford) {
          buyBtn.style.opacity = '0.4';
          buyBtn.title = 'Not enough gold';
        }
        buyBtn.onclick = () => onBuy(item.itemId);
        div.appendChild(buyBtn);
      } else {
        const oos = document.createElement('span');
        oos.textContent = 'Sold Out';
        oos.style.cssText = 'color:#844;font-size:9px;';
        div.appendChild(oos);
      }

      this.shopPanel.appendChild(div);
    });

    // Sell section
    const sellLabel = document.createElement('div');
    sellLabel.style.cssText = 'font-size:10px;color:#fa4;padding:4px 4px 2px;border-bottom:1px solid #333;margin:6px 0 2px;font-weight:bold;';
    sellLabel.textContent = 'â”€â”€ SELL â”€â”€';
    this.shopPanel.appendChild(sellLabel);

    const inv = player.inventory || [];
    if (inv.length === 0) {
      const empty = document.createElement('p');
      empty.style.cssText = 'color:#666;font-size:10px;padding:4px;';
      empty.textContent = 'No items to sell.';
      this.shopPanel.appendChild(empty);
    } else {
      inv.forEach((item, idx) => {
        const sellPrice = Math.max(1, Math.floor((item.value || 1) * (shop.items[0] ? 0.3 : 0.3)));
        const equipped = (player.equipment &&
          (player.equipment.weapon === item.id || player.equipment.armor === item.id));
        if (equipped) return; // skip equipped items

        const div = document.createElement('div');
        div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:2px 4px;border-bottom:1px solid #1a1a2a;font-size:10px;';

        const info = document.createElement('span');
        const shopSellSpriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
        const shopSellIcon = shopSellSpriteURL
          ? `<img src="${shopSellSpriteURL}" class="shop-item-sprite" alt="" draggable="false"/>`
          : `<span style="color:${item.color || '#ccc'}">${item.char || '?'}</span>`;
        info.innerHTML = `${shopSellIcon} ${item.name} <span style="color:#ffd700">${sellPrice}gp</span>`;
        div.appendChild(info);

        const sellBtn = document.createElement('button');
        sellBtn.textContent = 'Sell';
        sellBtn.className = 'btn btn-small';
        sellBtn.style.cssText = 'font-size:9px;padding:1px 6px;margin-left:4px;background:#542;';
        sellBtn.onclick = () => onSell(idx);
        div.appendChild(sellBtn);

        this.shopPanel.appendChild(div);
      });
    }
  }

  // â”€â”€ Crafting Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateCrafting(state, onCraft) {
    if (!this.craftPanel) return;
    this.craftPanel.innerHTML = '';

    const recipes = state.recipes || [];
    const nearbyWorkshops = state.nearbyWorkshops || [];
    const knownCount = state.knownRecipeCount || 0;
    const totalCount = state.totalRecipeCount || 0;

    // Header with recipe/workshop info
    const header = document.createElement('div');
    header.style.cssText = 'padding:4px 6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;color:#888;text-align:center;';
    let headerHtml = `ğŸ“– Recipes: <span style="color:#4af">${knownCount}/${totalCount}</span>`;
    if (nearbyWorkshops.length > 0) {
      headerHtml += `<br>ğŸ”¨ Nearby: <span style="color:#4c4">${nearbyWorkshops.join(', ')}</span>`;
    } else {
      headerHtml += `<br><span style="color:#a86">No workshops nearby â€” hand-craft only</span>`;
    }
    header.innerHTML = headerHtml;
    this.craftPanel.appendChild(header);

    if (recipes.length === 0) {
      this.craftPanel.innerHTML += '<p style="color:#666;font-size:10px;padding:4px;">No known recipes. Sleep to dream of new recipes, or find recipe papers.</p>';
      return;
    }

    // Group by workshop requirement
    const byWorkshop = {};
    recipes.forEach(r => {
      const wsKey = r.workshopNeeded || '_hand';
      if (!byWorkshop[wsKey]) byWorkshop[wsKey] = [];
      byWorkshop[wsKey].push(r);
    });

    // Sort workshop groups: hand first, then available workshops, then unavailable
    const wsOrder = ['_hand', ...nearbyWorkshops];
    const sortedKeys = Object.keys(byWorkshop).sort((a, b) => {
      const ai = wsOrder.indexOf(a);
      const bi = wsOrder.indexOf(b);
      if (ai >= 0 && bi >= 0) return ai - bi;
      if (ai >= 0) return -1;
      if (bi >= 0) return 1;
      return a.localeCompare(b);
    });

    sortedKeys.forEach(wsKey => {
      const recs = byWorkshop[wsKey];
      const wsAvailable = wsKey === '_hand' || nearbyWorkshops.includes(wsKey);

      const groupLabel = document.createElement('div');
      groupLabel.style.cssText = 'font-size:10px;padding:4px 4px 2px;border-bottom:1px solid #333;margin-top:4px;font-weight:bold;';
      if (wsKey === '_hand') {
        groupLabel.style.color = '#8c8';
        groupLabel.textContent = 'â”€â”€ âœ‹ Hand Craft â”€â”€';
      } else {
        const wsName = recs[0].workshopName || wsKey;
        groupLabel.style.color = wsAvailable ? '#4af' : '#666';
        groupLabel.textContent = `â”€â”€ ${wsAvailable ? 'âœ“' : 'âœ—'} ${wsName} â”€â”€`;
      }
      this.craftPanel.appendChild(groupLabel);

      recs.forEach(recipe => {
        const div = document.createElement('div');
        div.style.cssText = 'padding:4px;border-bottom:1px solid #1a1a2a;font-size:11px;';
        if (!wsAvailable) div.style.opacity = '0.5';

        const canColor = recipe.canCraft ? '#4f4' : '#844';
        const skillColor = recipe.meetsSkill ? '#8c8' : '#f44';
        const wsColor = recipe.hasWorkshop ? '#8c8' : '#f66';

        let html = `<div style="display:flex;justify-content:space-between;align-items:center;">`;
        html += `<div style="flex:1;">`;
        html += `<strong style="color:${canColor}">${recipe.name}</strong>`;
        html += ` <span style="color:#888;font-size:9px">â†’ ${recipe.resultCount}Ã— ${recipe.resultName}</span><br>`;
        html += `<span style="color:${skillColor};font-size:9px">${recipe.skill} Lv.${recipe.skillReq}</span>`;
        html += ` <span style="color:#888;font-size:9px">(${recipe.successChance}%)</span>`;
        if (!recipe.hasWorkshop && recipe.workshopName) {
          html += ` <span style="color:${wsColor};font-size:9px">âš  need ${recipe.workshopName}</span>`;
        }
        html += `</div>`;

        if (recipe.canCraft) {
          html += `<button class="btn btn-small craft-btn" data-recipe="${recipe.id}" style="font-size:9px;padding:2px 8px;background:#354;">Craft</button>`;
        } else {
          html += `<span style="color:#666;font-size:9px;padding:2px 4px;">â€”</span>`;
        }
        html += `</div>`;

        // Ingredients
        html += `<div style="font-size:9px;color:#888;padding-top:2px;">`;
        recipe.ingredients.forEach(ing => {
          const iColor = ing.enough ? '#8c8' : '#f66';
          html += `<span style="color:${iColor}">â€¢ ${ing.name} ${ing.have}/${ing.needed}</span> `;
        });
        html += `</div>`;

        div.innerHTML = html;

        const craftBtn = div.querySelector('.craft-btn');
        if (craftBtn) {
          craftBtn.addEventListener('click', () => onCraft(recipe.id));
        }

        this.craftPanel.appendChild(div);
      });
    });
  }

  // â”€â”€ Auto-switch to Shop Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToShopTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const shopTab = document.querySelector('[data-tab="shopTab"]');
    if (shopTab) shopTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const shopPanel = document.getElementById('shopTab');
    if (shopPanel) shopPanel.classList.add('active');
  }

  // â”€â”€ Quest Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateQuests(state, onAccept, onTurnIn, onAbandon) {
    if (!this.questPanel) return;
    this.questPanel.innerHTML = '';

    const activeQuests = state.activeQuests || [];
    const questBoard = state.questBoard || [];
    const currentTownId = state.currentTownId;
    const onBoard = state.onQuestBoard;
    const completedCount = state.completedQuestCount || 0;

    // Summary header
    const summary = document.createElement('div');
    summary.style.cssText = 'padding:4px 6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;color:#888;text-align:center;';
    summary.innerHTML = `ğŸ“œ Active: <span style="color:#4af">${activeQuests.length}/5</span> &nbsp; Completed: <span style="color:#4c4">${completedCount}</span>`;
    this.questPanel.appendChild(summary);

    // â”€â”€ Active Quests â”€â”€
    const activeLabel = document.createElement('div');
    activeLabel.style.cssText = 'font-size:10px;color:#4af;padding:2px 4px;border-bottom:1px solid #333;margin-bottom:2px;font-weight:bold;';
    activeLabel.textContent = 'â”€â”€ ACTIVE QUESTS â”€â”€';
    this.questPanel.appendChild(activeLabel);

    if (activeQuests.length === 0) {
      const empty = document.createElement('p');
      empty.style.cssText = 'color:#666;font-size:10px;padding:4px;text-align:center;';
      empty.textContent = 'No active quests. Visit a quest board in town.';
      this.questPanel.appendChild(empty);
    } else {
      activeQuests.forEach(quest => {
        const div = document.createElement('div');
        div.style.cssText = 'padding:5px;border-bottom:1px solid #1a1a2a;font-size:11px;margin-bottom:2px;';

        const readyColor = quest.isComplete ? '#4f4' : '#ca8';
        const progressPct = quest.targetCount > 0 ? Math.floor((quest.progress / quest.targetCount) * 100) : 0;

        let html = `<div style="display:flex;justify-content:space-between;align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<span style="color:${quest.color}">${quest.icon}</span> `;
        html += `<strong style="color:${readyColor}">${quest.name}</strong><br>`;
        html += `<span style="color:#888;font-size:9px">${quest.description}</span><br>`;

        // Progress bar
        html += `<div style="display:flex;align-items:center;margin-top:3px;">`;
        html += `<div style="flex:1;height:6px;background:#1a1a2e;border-radius:3px;overflow:hidden;margin-right:6px;">`;
        html += `<div style="width:${progressPct}%;height:100%;background:${quest.isComplete ? '#4c4' : '#ca8'};border-radius:3px;"></div>`;
        html += `</div>`;
        html += `<span style="color:#888;font-size:9px;white-space:nowrap;">${quest.progressText}</span>`;
        html += `</div>`;

        // Rewards preview
        html += `<div style="font-size:9px;color:#666;margin-top:2px;">`;
        html += `<span style="color:#ffd700">${quest.goldReward}gp</span>`;
        html += ` <span style="color:#4af">${quest.xpReward}xp</span>`;
        if (quest.bonusItem) html += ` <span style="color:#8c8">+item</span>`;
        html += `</div>`;

        html += `</div>`;
        html += `<div style="display:flex;flex-direction:column;gap:2px;margin-left:4px;">`;

        // Turn-in button (if complete and in the right town)
        if (quest.isComplete && quest.townId === currentTownId) {
          html += `<button class="btn btn-small quest-turnin-btn" data-quest="${quest.id}" style="font-size:9px;padding:2px 6px;background:#254;color:#4f4;">âœ“ Turn In</button>`;
        } else if (quest.isComplete) {
          html += `<span style="font-size:8px;color:#ca8;text-align:center;">Return to<br>${quest.townId}</span>`;
        }

        html += `<button class="btn btn-small quest-abandon-btn" data-quest="${quest.id}" style="font-size:8px;padding:1px 4px;background:#422;color:#a66;">âœ• Drop</button>`;
        html += `</div></div>`;

        div.innerHTML = html;

        // Wire up buttons
        const turnInBtn = div.querySelector('.quest-turnin-btn');
        if (turnInBtn) {
          turnInBtn.addEventListener('click', () => onTurnIn(quest.id));
        }
        const abandonBtn = div.querySelector('.quest-abandon-btn');
        if (abandonBtn) {
          abandonBtn.addEventListener('click', () => onAbandon(quest.id));
        }

        this.questPanel.appendChild(div);
      });
    }

    // â”€â”€ Quest Board (if in town and standing on it) â”€â”€
    if (onBoard && questBoard.length > 0) {
      const boardLabel = document.createElement('div');
      boardLabel.style.cssText = 'font-size:10px;color:#ffa;padding:4px 4px 2px;border-bottom:1px solid #555;margin-top:8px;margin-bottom:2px;font-weight:bold;';
      boardLabel.textContent = 'â”€â”€ QUEST BOARD â”€â”€';
      this.questPanel.appendChild(boardLabel);

      questBoard.forEach(quest => {
        const div = document.createElement('div');
        div.style.cssText = 'padding:5px;border-bottom:1px solid #1a1a2a;font-size:11px;margin-bottom:2px;background:#141420;border-radius:3px;';

        let html = `<div style="display:flex;justify-content:space-between;align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<span style="color:${quest.color}">${quest.icon}</span> `;
        html += `<strong style="color:#ddd">${quest.name}</strong>`;
        html += ` <span style="color:#888;font-size:9px">[${quest.typeName}]</span><br>`;
        html += `<span style="color:#888;font-size:9px">${quest.description}</span><br>`;
        html += `<div style="font-size:9px;color:#666;margin-top:2px;">`;
        html += `Rewards: <span style="color:#ffd700">${quest.goldReward}gp</span>`;
        html += ` <span style="color:#4af">${quest.xpReward}xp</span>`;
        html += ` <span style="color:#8af">+${quest.fameReward} fame</span>`;
        if (quest.bonusItem) html += ` <span style="color:#8c8">+bonus item</span>`;
        html += `</div>`;
        html += `</div>`;

        html += `<button class="btn btn-small quest-accept-btn" data-quest="${quest.id}" style="font-size:9px;padding:3px 8px;background:#243;color:#8f8;margin-left:4px;">Accept</button>`;
        html += `</div>`;

        div.innerHTML = html;

        const acceptBtn = div.querySelector('.quest-accept-btn');
        if (acceptBtn) {
          acceptBtn.addEventListener('click', () => onAccept(quest.id));
        }

        this.questPanel.appendChild(div);
      });
    } else if (questBoard.length === 0 && onBoard) {
      const noQuests = document.createElement('div');
      noQuests.style.cssText = 'font-size:10px;color:#ffa;padding:4px 4px 2px;border-bottom:1px solid #555;margin-top:8px;margin-bottom:2px;font-weight:bold;';
      noQuests.textContent = 'â”€â”€ QUEST BOARD â”€â”€';
      this.questPanel.appendChild(noQuests);
      const emptyBoard = document.createElement('p');
      emptyBoard.style.cssText = 'color:#666;font-size:10px;padding:4px;text-align:center;';
      emptyBoard.textContent = 'No quests available. Check back later.';
      this.questPanel.appendChild(emptyBoard);
    }
  }

  // â”€â”€ Auto-switch to Quest Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToQuestTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const questTab = document.querySelector('[data-tab="questTab"]');
    if (questTab) questTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const questPanel = document.getElementById('questTab');
    if (questPanel) questPanel.classList.add('active');
  }

  // â”€â”€ Pets Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updatePets(state, onRelease, onRename, onRevive) {
    if (!this.petPanel) return;
    this.petPanel.innerHTML = '';

    const pets = state.pets || [];
    const maxPets = state.maxPets || 2;

    // Summary header
    const summary = document.createElement('div');
    summary.style.cssText = 'padding:4px 6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;color:#888;text-align:center;';
    summary.innerHTML = `ğŸ¾ Pets: <span style="color:#4af">${pets.length}/${maxPets}</span> &nbsp; <span style="color:#666;font-size:9px">(CHA increases max)</span>`;
    this.petPanel.appendChild(summary);

    // How to tame hint
    const hint = document.createElement('div');
    hint.style.cssText = 'font-size:9px;color:#666;text-align:center;padding:2px 4px;margin-bottom:6px;';
    hint.textContent = 'Stand next to a wounded monster and press T to tame it.';
    this.petPanel.appendChild(hint);

    if (pets.length === 0) {
      const empty = document.createElement('p');
      empty.style.cssText = 'color:#555;font-size:11px;padding:12px;text-align:center;';
      empty.textContent = 'No pets yet. Tame monsters to gain allies!';
      this.petPanel.appendChild(empty);
      return;
    }

    pets.forEach(pet => {
      const div = document.createElement('div');
      div.style.cssText = `padding:6px;border-bottom:1px solid #1a1a2a;font-size:11px;margin-bottom:2px;${pet.isDead ? 'opacity:0.6;' : ''}`;

      const hpPct = pet.maxHp > 0 ? Math.floor((pet.hp / pet.maxHp) * 100) : 0;
      const hpColor = pet.isDead ? '#f44' : hpPct > 50 ? '#4d4' : hpPct > 25 ? '#dd4' : '#d44';
      const xpPct = pet.xpNext > 0 ? Math.floor((pet.xp / pet.xpNext) * 100) : 0;
      const loyaltyColor = (pet.loyalty || 0) >= 70 ? '#4f4' : (pet.loyalty || 0) >= 40 ? '#dd4' : '#f44';

      // Try to get monster sprite
      const spriteURL = window._tileManager && window._tileManager.getMonster(pet.templateId);
      let iconHtml;
      if (spriteURL && spriteURL.src) {
        iconHtml = `<img src="${spriteURL.src}" style="width:28px;height:28px;vertical-align:middle;margin-right:6px;border:1px solid #4a4;border-radius:3px;" draggable="false"/>`;
      } else {
        iconHtml = `<span style="color:${pet.color || '#4f4'};font-size:18px;margin-right:6px;vertical-align:middle;">${pet.char || 'p'}</span>`;
      }

      let html = `<div style="display:flex;align-items:flex-start;">`;
      html += `<div style="flex-shrink:0;">${iconHtml}</div>`;
      html += `<div style="flex:1;">`;
      html += `<strong style="color:${pet.isDead ? '#f44' : '#8f8'}">${pet.name}</strong>`;
      html += ` <span style="color:#888;font-size:9px">Lv.${pet.level}</span>`;
      if (pet.isDead) html += ` <span style="color:#f44;font-size:9px">ğŸ’€ DEAD</span>`;
      html += `<br>`;

      // HP bar
      html += `<div style="display:flex;align-items:center;margin-top:2px;">`;
      html += `<span style="color:#888;font-size:9px;width:20px;">HP</span>`;
      html += `<div style="flex:1;height:6px;background:#1a1a2e;border-radius:3px;overflow:hidden;margin-right:4px;">`;
      html += `<div style="width:${hpPct}%;height:100%;background:${hpColor};border-radius:3px;"></div>`;
      html += `</div>`;
      html += `<span style="color:#888;font-size:9px;">${pet.hp}/${pet.maxHp}</span>`;
      html += `</div>`;

      // XP bar
      html += `<div style="display:flex;align-items:center;margin-top:1px;">`;
      html += `<span style="color:#888;font-size:9px;width:20px;">XP</span>`;
      html += `<div style="flex:1;height:4px;background:#1a1a2e;border-radius:2px;overflow:hidden;margin-right:4px;">`;
      html += `<div style="width:${xpPct}%;height:100%;background:#48f;border-radius:2px;"></div>`;
      html += `</div>`;
      html += `<span style="color:#888;font-size:8px;">${pet.xp}/${pet.xpNext}</span>`;
      html += `</div>`;

      // Stats line
      html += `<div style="font-size:9px;color:#666;margin-top:2px;">`;
      html += `Atk: <span style="color:#c88">${pet.attack}</span>`;
      html += ` &nbsp; Loyalty: <span style="color:${loyaltyColor}">${pet.loyalty || 0}%</span>`;
      html += `</div>`;

      html += `</div>`; // end flex:1

      // Action buttons column
      html += `<div style="display:flex;flex-direction:column;gap:2px;margin-left:4px;flex-shrink:0;">`;
      if (pet.isDead) {
        html += `<button class="btn btn-small pet-revive-btn" data-pet="${pet.id}" style="font-size:8px;padding:2px 5px;background:#254;color:#4f4;">âœ¦ Revive</button>`;
      }
      html += `<button class="btn btn-small pet-rename-btn" data-pet="${pet.id}" style="font-size:8px;padding:1px 4px;background:#334;color:#8af;">âœ Name</button>`;
      html += `<button class="btn btn-small pet-release-btn" data-pet="${pet.id}" style="font-size:8px;padding:1px 4px;background:#422;color:#a66;">âœ• Free</button>`;
      html += `</div>`;
      html += `</div>`; // end flex container

      div.innerHTML = html;

      // Wire up buttons
      const reviveBtn = div.querySelector('.pet-revive-btn');
      if (reviveBtn) {
        reviveBtn.addEventListener('click', () => onRevive(pet.id));
      }
      const renameBtn = div.querySelector('.pet-rename-btn');
      if (renameBtn) {
        renameBtn.addEventListener('click', () => {
          const newName = prompt(`Rename ${pet.name}:`, pet.name);
          if (newName && newName.trim()) {
            onRename(pet.id, newName.trim());
          }
        });
      }
      const releaseBtn = div.querySelector('.pet-release-btn');
      if (releaseBtn) {
        releaseBtn.addEventListener('click', () => {
          if (confirm(`Release ${pet.name} into the wild?`)) {
            onRelease(pet.id);
          }
        });
      }

      this.petPanel.appendChild(div);
    });
  }

  // â”€â”€ Auto-switch to Pets Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToPetsTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const petsTab = document.querySelector('[data-tab="petsTab"]');
    if (petsTab) petsTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const petsPanel = document.getElementById('petsTab');
    if (petsPanel) petsPanel.classList.add('active');
  }

  // â”€â”€ Faith Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateFaith(state, onWorship, onOffer, onPray) {
    if (!this.faithPanel) return;
    this.faithPanel.innerHTML = '';

    const faith = state.faith || {};
    const onAltar = state.onAltar || false;
    const player = state.player || {};

    // â”€â”€ Current God Info â”€â”€
    if (faith.godId) {
      const godHeader = document.createElement('div');
      godHeader.style.cssText = 'padding:8px;margin-bottom:6px;background:#1a1a2e;border-radius:5px;text-align:center;border:1px solid ' + (faith.godColor || '#444') + ';';

      const favorPct = Math.min(100, Math.floor((faith.favor / 1500) * 100));
      const blessingColor = faith.activeBlessingKey === 'major' ? '#f4f' :
                            faith.activeBlessingKey === 'moderate' ? '#4af' :
                            faith.activeBlessingKey === 'minor' ? '#8c8' : '#555';

      let godHtml = `<span style="font-size:24px">${faith.godIcon || '?'}</span><br>`;
      godHtml += `<strong style="color:${faith.godColor || '#ccc'};font-size:13px;">${faith.godName}</strong><br>`;
      godHtml += `<span style="color:#888;font-size:10px;">${faith.godTitle || ''}</span><br>`;

      // Favor bar
      godHtml += `<div style="margin-top:6px;">`;
      godHtml += `<div style="display:flex;justify-content:space-between;font-size:9px;color:#888;margin-bottom:2px;">`;
      godHtml += `<span>Favor</span><span style="color:${faith.godColor || '#ccc'}">${faith.favor}</span>`;
      godHtml += `</div>`;
      godHtml += `<div style="height:8px;background:#111;border-radius:4px;overflow:hidden;border:1px solid #333;">`;
      godHtml += `<div style="width:${favorPct}%;height:100%;background:${faith.godColor || '#888'};border-radius:4px;transition:width 0.3s;"></div>`;
      godHtml += `</div></div>`;

      // Active blessing
      if (faith.activeBlessing) {
        godHtml += `<div style="margin-top:6px;padding:4px;background:#0a0a1a;border-radius:3px;border:1px solid ${blessingColor};">`;
        godHtml += `<span style="color:${blessingColor};font-size:10px;font-weight:bold;">âœ¦ ${faith.activeBlessing.name}</span><br>`;
        godHtml += `<span style="color:#888;font-size:9px;">${faith.activeBlessing.description}</span>`;
        godHtml += `</div>`;
      }

      // Next blessing
      if (faith.nextBlessing && faith.nextThreshold > 0) {
        const remaining = faith.nextThreshold - faith.favor;
        godHtml += `<div style="margin-top:3px;font-size:9px;color:#666;">`;
        godHtml += `Next: <span style="color:#aaa">${faith.nextBlessing.name}</span> in <span style="color:${faith.godColor || '#888'}">${remaining}</span> favor`;
        godHtml += `</div>`;
      }

      godHeader.innerHTML = godHtml;
      this.faithPanel.appendChild(godHeader);

      // Prayer button
      const prayDiv = document.createElement('div');
      prayDiv.style.cssText = 'text-align:center;margin-bottom:6px;';
      const prayBtn = document.createElement('button');
      prayBtn.className = 'btn btn-small';
      const canPray = faith.prayerCooldown <= 0;
      prayBtn.style.cssText = `font-size:11px;padding:6px 16px;background:${canPray ? '#243' : '#222'};color:${canPray ? '#8f8' : '#555'};border:1px solid ${canPray ? '#4a4' : '#333'};`;
      prayBtn.textContent = canPray ? `ğŸ™ Pray to ${faith.godName.split(' ')[0]}` : `ğŸ™ Prayer cooldown (${faith.prayerCooldown}t)`;
      if (canPray) {
        prayBtn.addEventListener('click', () => onPray());
      }
      prayDiv.appendChild(prayBtn);
      this.faithPanel.appendChild(prayDiv);

      // Offer item (only if on altar)
      if (onAltar) {
        const offerLabel = document.createElement('div');
        offerLabel.style.cssText = 'font-size:10px;color:#ffa;padding:2px 4px;border-bottom:1px solid #333;margin-bottom:2px;font-weight:bold;';
        offerLabel.textContent = 'â”€â”€ OFFER ITEM â”€â”€';
        this.faithPanel.appendChild(offerLabel);

        const inv = player.inventory || [];
        const offerableItems = [];
        inv.forEach((item, idx) => {
          // Can't offer equipped items or currency
          const equipped = player.equipment &&
            (player.equipment.weapon === item.id || player.equipment.armor === item.id);
          if (!equipped && item.type !== 'currency') {
            offerableItems.push({ item, idx });
          }
        });

        if (offerableItems.length === 0) {
          const noItems = document.createElement('p');
          noItems.style.cssText = 'color:#666;font-size:10px;padding:4px;text-align:center;';
          noItems.textContent = 'No items to offer.';
          this.faithPanel.appendChild(noItems);
        } else {
          offerableItems.slice(0, 10).forEach(({ item, idx }) => {
            const div = document.createElement('div');
            div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:3px 4px;border-bottom:1px solid #1a1a2a;font-size:10px;';

            const info = document.createElement('span');
            const favorGain = Math.max(5, Math.floor((item.value || 10) * 0.3) + 3);
            info.innerHTML = `<span style="color:${item.color || '#ccc'}">${item.char || '?'}</span> ${item.name} <span style="color:${faith.godColor || '#888'}">+${favorGain}</span>`;
            div.appendChild(info);

            const offerBtn = document.createElement('button');
            offerBtn.className = 'btn btn-small';
            offerBtn.style.cssText = 'font-size:9px;padding:1px 6px;background:#332;color:#ffa;';
            offerBtn.textContent = 'Offer';
            offerBtn.addEventListener('click', () => onOffer(idx));
            div.appendChild(offerBtn);

            this.faithPanel.appendChild(div);
          });
        }
      }

      // Description
      if (faith.godDescription) {
        const descDiv = document.createElement('div');
        descDiv.style.cssText = 'margin-top:6px;padding:4px;font-size:9px;color:#666;font-style:italic;text-align:center;';
        descDiv.textContent = faith.godDescription;
        this.faithPanel.appendChild(descDiv);
      }
    } else {
      // No god worshipped
      const noGod = document.createElement('div');
      noGod.style.cssText = 'text-align:center;padding:12px;color:#888;font-size:11px;';
      noGod.innerHTML = 'ğŸ™ You worship no god.<br><span style="font-size:9px;color:#666;">Visit an altar (â€ ) in a town to choose a deity.</span>';
      this.faithPanel.appendChild(noGod);
    }

    // â”€â”€ God Selection (when on altar) â”€â”€
    if (onAltar && faith.allGods) {
      const godsLabel = document.createElement('div');
      godsLabel.style.cssText = 'font-size:10px;color:#d0d050;padding:4px 4px 2px;border-bottom:1px solid #555;margin-top:8px;margin-bottom:2px;font-weight:bold;';
      godsLabel.textContent = 'â”€â”€ GODS OF THE WORLD â”€â”€';
      this.faithPanel.appendChild(godsLabel);

      faith.allGods.forEach(god => {
        const div = document.createElement('div');
        const isCurrentGod = faith.godId === god.id;
        div.style.cssText = `padding:6px;border-bottom:1px solid #1a1a2a;font-size:11px;${isCurrentGod ? 'background:#1a1a2e;border-left:2px solid ' + god.color + ';' : ''}`;

        let html = `<div style="display:flex;justify-content:space-between;align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<span style="font-size:16px">${god.icon}</span> `;
        html += `<strong style="color:${god.color}">${god.name}</strong>`;
        if (isCurrentGod) html += ` <span style="color:#4f4;font-size:9px;">â˜… Worshipped</span>`;
        html += `<br>`;
        html += `<span style="color:#888;font-size:9px;">${god.description}</span>`;
        html += `</div>`;

        if (!isCurrentGod) {
          html += `<button class="btn btn-small worship-btn" data-god="${god.id}" style="font-size:9px;padding:3px 8px;background:#332;color:${god.color};border:1px solid ${god.color};margin-left:4px;white-space:nowrap;">Worship</button>`;
        }
        html += `</div>`;

        div.innerHTML = html;

        const worshipBtn = div.querySelector('.worship-btn');
        if (worshipBtn) {
          worshipBtn.addEventListener('click', () => {
            if (faith.godId) {
              if (confirm(`Abandon ${faith.godName} and worship ${god.name}? Your old god may punish you!`)) {
                onWorship(god.id);
              }
            } else {
              onWorship(god.id);
            }
          });
        }

        this.faithPanel.appendChild(div);
      });
    } else if (!onAltar && !faith.godId) {
      // Hint about finding altars
      const hint = document.createElement('div');
      hint.style.cssText = 'text-align:center;padding:8px;font-size:9px;color:#555;';
      hint.innerHTML = 'Look for the <span style="color:#d0d050">â€ </span> altar tile in towns.';
      this.faithPanel.appendChild(hint);
    }
  }

  // â”€â”€ Auto-switch to Faith Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToFaithTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const faithTab = document.querySelector('[data-tab="faithTab"]');
    if (faithTab) faithTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const faithPanel = document.getElementById('faithTab');
    if (faithPanel) faithPanel.classList.add('active');
  }

  // â”€â”€ Auto-switch to Card Book Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToCardBookTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const cardTab = document.querySelector('[data-tab="cardBookTab"]');
    if (cardTab) cardTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const cardPanel = document.getElementById('cardBookTab');
    if (cardPanel) cardPanel.classList.add('active');
  }

  // â”€â”€ Card Book Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateCardBook(state, onBuyCard, onSellCard) {
    if (!this.cardBookPanel) return;
    this.cardBookPanel.innerHTML = '';

    const collection = state.cardCollection;
    if (!collection) return;

    // Completion header
    const header = document.createElement('div');
    header.className = 'card-book-header';
    const pct = collection.totalMonsters > 0 ? Math.round((collection.totalUnique / collection.totalMonsters) * 100) : 0;
    header.innerHTML = `
      <div class="card-book-stats">
        <span>ğŸ“– Collection: <strong>${collection.totalUnique}</strong> / ${collection.totalMonsters} (${pct}%)</span>
        <span>Total Cards: <strong>${collection.totalCards}</strong></span>
      </div>
      <div class="card-book-progress">
        <div class="card-book-bar" style="width:${pct}%"></div>
      </div>
    `;
    this.cardBookPanel.appendChild(header);

    // Card shop section (if near card merchant)
    const cardShop = state.cardShop;
    if (cardShop && cardShop.length > 0) {
      const shopSection = document.createElement('div');
      shopSection.className = 'card-shop-section';
      shopSection.innerHTML = '<h4>ğŸª Card Merchant</h4>';

      // Buy section
      const buyHeader = document.createElement('div');
      buyHeader.className = 'card-subsection-header';
      buyHeader.textContent = 'â€” Buy Cards â€”';
      shopSection.appendChild(buyHeader);

      cardShop.forEach((card, idx) => {
        if (card.stock <= 0) return;
        const ri = this._getCardRarityInfo(card.rarity);
        const buyMonsterImg = window._tileManager && window._tileManager.getMonster(card.monsterId);
        const buyMonsterHtml = buyMonsterImg && buyMonsterImg.src
          ? `<img src="${buyMonsterImg.src}" style="width:24px;height:24px;vertical-align:middle;image-rendering:pixelated;" draggable="false"/>`
          : `<span style="color:${card.color}">${card.char || 'M'}</span>`;
        const div = document.createElement('div');
        div.className = `card-shop-item card-rarity-${card.rarity}`;
        div.innerHTML = `
          <span class="card-preview">${buyMonsterHtml}</span>
          <span class="card-info">
            <span class="card-name" style="color:${ri.color}">${ri.emoji} ${card.monsterName}</span>
            <span class="card-detail">Lv.${card.monsterLevel} ${ri.name}</span>
          </span>
          <button class="btn-card-buy" data-idx="${idx}">${card.buyPrice}gp</button>
        `;
        div.querySelector('.btn-card-buy').addEventListener('click', () => onBuyCard(idx));
        shopSection.appendChild(div);
      });

      // Sell section
      const sellHeader = document.createElement('div');
      sellHeader.className = 'card-subsection-header';
      sellHeader.textContent = 'â€” Sell Cards â€”';
      shopSection.appendChild(sellHeader);

      if (collection.cards.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'card-empty';
        empty.textContent = 'No cards to sell.';
        shopSection.appendChild(empty);
      } else {
        collection.cards.forEach((card, idx) => {
          const ri = this._getCardRarityInfo(card.rarity);
          const sellPrice = Math.max(1, Math.floor(card.value * 0.6));
          const sellMonsterImg = window._tileManager && window._tileManager.getMonster(card.monsterId);
          const sellMonsterHtml = sellMonsterImg && sellMonsterImg.src
            ? `<img src="${sellMonsterImg.src}" style="width:24px;height:24px;vertical-align:middle;image-rendering:pixelated;" draggable="false"/>`
            : `<span style="color:${card.color}">${card.char || 'M'}</span>`;
          const div = document.createElement('div');
          div.className = `card-shop-item card-rarity-${card.rarity}`;
          div.innerHTML = `
            <span class="card-preview">${sellMonsterHtml}</span>
            <span class="card-info">
              <span class="card-name" style="color:${ri.color}">${ri.emoji} ${card.monsterName} x${card.quantity || 1}</span>
              <span class="card-detail">Lv.${card.monsterLevel} ${ri.name}</span>
            </span>
            <button class="btn-card-sell" data-idx="${idx}">Sell ~${sellPrice}gp</button>
          `;
          div.querySelector('.btn-card-sell').addEventListener('click', () => onSellCard(idx));
          shopSection.appendChild(div);
        });
      }

      this.cardBookPanel.appendChild(shopSection);
    }

    // Collection grid
    const gridLabel = document.createElement('div');
    gridLabel.className = 'card-subsection-header';
    gridLabel.textContent = 'â€” Collection â€”';
    this.cardBookPanel.appendChild(gridLabel);

    if (collection.cards.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'card-empty';
      empty.textContent = 'No cards collected yet. Defeat monsters to collect their cards!';
      this.cardBookPanel.appendChild(empty);
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'card-grid';

    collection.cards.forEach(card => {
      const ri = this._getCardRarityInfo(card.rarity);
      const monsterImg = window._tileManager && window._tileManager.getMonster(card.monsterId);
      const monsterHtml = monsterImg && monsterImg.src
        ? `<img src="${monsterImg.src}" class="card-monster-sprite" draggable="false"/>`
        : `<span style="color:${card.color};font-size:1.6rem">${card.char || 'M'}</span>`;
      const cardEl = document.createElement('div');
      cardEl.className = `card-item card-rarity-${card.rarity}`;
      cardEl.innerHTML = `
        <div class="card-frame" style="border-color:${ri.border}">
          <div class="card-monster">${monsterHtml}</div>
          <div class="card-name-plate" style="background:${ri.border}22">
            <span style="color:${ri.color}">${card.monsterName}</span>
          </div>
          <div class="card-meta">
            <span>Lv.${card.monsterLevel}</span>
            <span style="color:${ri.color}">${ri.emoji} ${ri.name}</span>
          </div>
          ${(card.quantity || 1) > 1 ? `<div class="card-qty">x${card.quantity}</div>` : ''}
        </div>
      `;
      grid.appendChild(cardEl);
    });

    this.cardBookPanel.appendChild(grid);
  }

  _getCardRarityInfo(rarity) {
    const info = {
      normal:    { name: 'Normal',     color: '#ccc',    border: '#666',    emoji: 'ğŸƒ' },
      rare:      { name: 'Rare',       color: '#ffd740', border: '#ffa000', emoji: 'âœ¨' },
      superFoil: { name: 'Super Foil', color: '#e040fb', border: '#aa00ff', emoji: 'ğŸŒŸ' }
    };
    return info[rarity] || info.normal;
  }

  // â”€â”€ Enchant Target Picker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  showEnchantTargetPicker(targets, onSelect) {
    // Remove any existing picker
    this._closeEnchantPicker();

    const overlay = document.createElement('div');
    overlay.id = 'enchantPicker';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:200;display:flex;align-items:center;justify-content:center;';

    const panel = document.createElement('div');
    panel.style.cssText = 'background:#1a1a2e;border:2px solid #ffa;border-radius:8px;padding:16px;max-width:360px;width:90%;max-height:70vh;overflow-y:auto;';

    const title = document.createElement('div');
    title.style.cssText = 'text-align:center;font-size:14px;color:#ffa;margin-bottom:12px;font-weight:bold;';
    title.textContent = 'âœ¨ Choose item to enchant';
    panel.appendChild(title);

    targets.forEach(({ item, index }) => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:8px;border-bottom:1px solid #333;cursor:pointer;border-radius:4px;';
      row.addEventListener('mouseenter', () => row.style.background = '#2a2a4e');
      row.addEventListener('mouseleave', () => row.style.background = 'transparent');

      const info = document.createElement('div');
      info.style.flex = '1';
      const spriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
      const iconHtml = spriteURL
        ? `<img src="${spriteURL}" style="width:20px;height:20px;vertical-align:middle;margin-right:4px;" draggable="false"/>`
        : `<span style="color:${item.color || '#ccc'};margin-right:4px;">${item.char || '?'}</span>`;

      let statsText = '';
      if (item.dice) statsText += `Dmg:${item.dice} `;
      if (item.PV != null) statsText += `PV:${item.PV + (item.enchantPVBonus || 0)} `;
      if (item.DV != null) statsText += `DV:${item.DV + (item.enchantDVBonus || 0)} `;
      const bonusText = item.enchantBonus ? ` <span style="color:#ffa">+${item.enchantBonus}</span>` : '';

      info.innerHTML = `${iconHtml}<strong style="color:#ddd">${item.name}</strong>${bonusText}<br>` +
        `<span style="color:#888;font-size:10px">${item.type} â€” ${statsText}</span>`;
      row.appendChild(info);

      const btn = document.createElement('button');
      btn.className = 'btn btn-small';
      btn.style.cssText = 'font-size:10px;padding:4px 10px;background:#443;color:#ffa;border:1px solid #664;';
      btn.textContent = 'Enchant';
      btn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        this._closeEnchantPicker();
        onSelect(index);
      });
      row.appendChild(btn);

      panel.appendChild(row);
    });

    // Cancel button
    const cancelRow = document.createElement('div');
    cancelRow.style.cssText = 'text-align:center;margin-top:12px;';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-small';
    cancelBtn.style.cssText = 'font-size:10px;padding:4px 16px;background:#422;color:#a88;';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', () => this._closeEnchantPicker());
    cancelRow.appendChild(cancelBtn);
    panel.appendChild(cancelRow);

    overlay.appendChild(panel);

    // Close on overlay click
    overlay.addEventListener('click', (ev) => {
      if (ev.target === overlay) this._closeEnchantPicker();
    });

    document.body.appendChild(overlay);
  }

  _closeEnchantPicker() {
    const existing = document.getElementById('enchantPicker');
    if (existing) existing.remove();
  }

  // â”€â”€ Gather Node Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateGatherOverlay(state) {
    let gatherEl = document.getElementById('gatherOverlay');
    if (state.gatherNode) {
      if (!gatherEl) {
        gatherEl = document.createElement('div');
        gatherEl.id = 'gatherOverlay';
        gatherEl.style.cssText = 'position:absolute;top:4px;left:50%;transform:translateX(-50%);background:rgba(20,25,40,0.88);padding:4px 14px;border-radius:4px;font-size:11px;color:#adf;border:1px solid #48a;z-index:10;white-space:nowrap;';
        document.getElementById('gameViewport').appendChild(gatherEl);
      }
      const node = state.gatherNode;
      gatherEl.innerHTML = `${node.icon} <strong>${node.name}</strong> â€” <span style="color:#888">${node.skill}</span> <span style="color:#6af">âŸ¶ Press M to ${node.verb}!</span>`;
      gatherEl.style.display = '';
    } else if (gatherEl) {
      gatherEl.style.display = 'none';
    }
  }

  // â”€â”€ Save List (main menu) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  populateSaveList(saves, onLoad) {
    const list = document.getElementById('saveList');
    if (!list) return;
    list.innerHTML = '';
    if (!saves || saves.length === 0) {
      list.innerHTML = '<p style="color:#666">No saved games found.</p>';
      return;
    }
    saves.forEach(s => {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.display = 'block';
      btn.style.width = '100%';
      btn.style.marginBottom = '6px';
      btn.textContent = `${s.playerName || s.id} â€” Lv.${s.level || '?'} â€” ${s.savedAt ? new Date(s.savedAt).toLocaleDateString() : 'Unknown'}`;
      btn.onclick = () => onLoad(s.id);
      list.appendChild(btn);
    });
  }

  // â”€â”€ Game Over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  showGameOver(state) {
    this.showScreen('gameOver');
    const deathMsg = document.getElementById('deathMessage');
    if (deathMsg && state && state.player) {
      deathMsg.textContent = `${state.player.name} the ${state.player.raceName} ${state.player.className} has died at level ${state.player.level || 1}.`;
    }

    const recapEl = document.getElementById('deathRecap');
    const recap = state && state.deathRecap;
    if (!recapEl || !recap) return;

    recapEl.style.display = '';

    // Killer banner
    const killerEl = document.getElementById('recapKiller');
    if (killerEl) {
      const locText = recap.floor > 0
        ? `${recap.location} (Floor ${recap.floor})`
        : recap.location;
      killerEl.innerHTML = `â˜  Slain by <strong>${recap.killedBy}</strong> in ${locText} on turn ${recap.turn}`;
    }

    // Last hits
    const lastHitsEl = document.getElementById('recapLastHits');
    if (lastHitsEl) {
      if (recap.lastHits.length === 0) {
        lastHitsEl.innerHTML = '<span style="color:var(--text-dim)">No data</span>';
      } else {
        lastHitsEl.innerHTML = recap.lastHits.map(h =>
          `<div class="recap-list-item">` +
            `<span class="source">${h.source}</span>` +
            `<span><span class="damage">-${h.damage}</span><span class="turn-num">T${h.turn}</span></span>` +
          `</div>`
        ).join('');
      }
    }

    // Top damage sources
    const topEl = document.getElementById('recapTopSources');
    if (topEl) {
      if (recap.topDamageSources.length === 0) {
        topEl.innerHTML = '<span style="color:var(--text-dim)">No data</span>';
      } else {
        topEl.innerHTML = recap.topDamageSources.map(s => {
          const pct = recap.totalDamageTaken > 0
            ? Math.round(s.total / recap.totalDamageTaken * 100) : 0;
          return `<div class="recap-list-item">` +
            `<span class="source">${s.source}</span>` +
            `<span><span class="damage">${s.total}</span> <span class="turn-num">${pct}%</span></span>` +
          `</div>`;
        }).join('');
      }
    }

    // Adventure summary stats
    const statsEl = document.getElementById('recapStats');
    if (statsEl) {
      const stats = [
        { label: 'Turns Survived', value: recap.turn },
        { label: 'Time Alive', value: recap.timeAlive || 'â€”' },
        { label: 'Monsters Slain', value: recap.killCount },
        { label: 'Deepest Floor', value: recap.deepestFloor > 0 ? `B${recap.deepestFloor}` : 'â€”' },
        { label: 'Locations Visited', value: recap.locationsVisited },
        { label: 'Fame', value: recap.fame },
        { label: 'Karma', value: recap.karma },
        { label: 'Gold', value: `${recap.gold} gp` },
      ];
      statsEl.innerHTML = stats.map(s =>
        `<div class="recap-stat">` +
          `<span class="label">${s.label}</span>` +
          `<span class="value">${s.value}</span>` +
        `</div>`
      ).join('');
    }

    // Card collection summary
    const cardsEl = document.getElementById('recapCards');
    if (cardsEl && recap.cardSummary) {
      const cs = recap.cardSummary;
      let html = `
        <div class="recap-stat-grid" style="margin-bottom:0.6rem">
          <div class="recap-stat"><span class="label">Unique Collected</span><span class="value">${cs.uniqueCollected} / ${cs.totalMonsters} (${cs.completionPct}%)</span></div>
          <div class="recap-stat"><span class="label">Total Cards</span><span class="value">${cs.totalCards}</span></div>
          <div class="recap-stat"><span class="label">âœ¨ Rare Cards</span><span class="value" style="color:#ffd740">${cs.rareCount}</span></div>
          <div class="recap-stat"><span class="label">ğŸŒŸ Super Foil</span><span class="value" style="color:#e040fb">${cs.foilCount}</span></div>
        </div>`;
      if (cs.topCards && cs.topCards.length > 0) {
        html += '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:0.3rem">Top Cards:</div>';
        html += cs.topCards.map(c => {
          const ri = this._getCardRarityInfo(c.rarity);
          return `<div style="display:flex;align-items:center;gap:0.4rem;padding:0.15rem 0;font-size:0.78rem">` +
            `<span style="color:${c.color}">${c.char || 'M'}</span>` +
            `<span style="color:${ri.color}">${ri.emoji} ${c.monsterName}</span>` +
            `<span style="color:var(--text-dim);font-size:0.7rem">(${ri.name}) x${c.quantity || 1}</span>` +
          `</div>`;
        }).join('');
      }
      cardsEl.innerHTML = html;
    } else if (cardsEl) {
      cardsEl.innerHTML = '<span style="color:var(--text-dim);font-size:0.78rem">No cards collected.</span>';
    }
  }
}

</script>
  <script>
// ============================================================
// Input â€” Keyboard & mouse input handling
// ============================================================

class InputHandler {
  constructor(canvas, onAction) {
    this.onAction = onAction; // callback: (action) => void
    this.canvas = canvas;
    this.enabled = false;
    this.mode = 'localMap'; // 'worldMap' | 'localMap'

    // Track currently held keys for timed-action system
    this.heldKeys = new Set();

    // Callbacks for the timed-action system
    this.onActionStart = null;  // (action, key) => void â€” called on keydown
    this.onActionCancel = null; // (key) => void â€” called on keyup, returns true if it cancelled something

    this._keyDownHandler = this._onKeyDown.bind(this);
    this._keyUpHandler = this._onKeyUp.bind(this);
    this._clickHandler = this._onClick.bind(this);
  }

  enable() {
    if (this.enabled) return;
    this.enabled = true;
    document.addEventListener('keydown', this._keyDownHandler);
    document.addEventListener('keyup', this._keyUpHandler);
    this.canvas.addEventListener('click', this._clickHandler);
  }

  disable() {
    this.enabled = false;
    this.heldKeys.clear();
    document.removeEventListener('keydown', this._keyDownHandler);
    document.removeEventListener('keyup', this._keyUpHandler);
    this.canvas.removeEventListener('click', this._clickHandler);
  }

  setMode(mode) {
    this.mode = mode;
  }

  isKeyHeld(key) {
    return this.heldKeys.has(key);
  }

  // â”€â”€ Key Up â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onKeyUp(e) {
    const key = e.key.toLowerCase();
    this.heldKeys.delete(key);
    this.heldKeys.delete(e.code);
    if (this.onActionCancel) {
      this.onActionCancel(key);
    }
  }

  // â”€â”€ Keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onKeyDown(e) {
    if (!this.enabled) return;

    // Ignore repeated keydown events (key held)
    if (e.repeat) return;

    // Track held key
    const keyLower = e.key.toLowerCase();
    this.heldKeys.add(keyLower);
    this.heldKeys.add(e.code);

    // Prevent default for game keys
    const gameKeys = [
      'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
      'Numpad1', 'Numpad2', 'Numpad3', 'Numpad4',
      'Numpad5', 'Numpad6', 'Numpad7', 'Numpad8', 'Numpad9',
      'Period', 'Comma', 'Enter', 'Escape',
    ];
    const letter = e.key.toLowerCase();

    // Movement directions
    const moveMap = {
      'ArrowUp': { dx: 0, dy: -1 },
      'ArrowDown': { dx: 0, dy: 1 },
      'ArrowLeft': { dx: -1, dy: 0 },
      'ArrowRight': { dx: 1, dy: 0 },
      'Numpad8': { dx: 0, dy: -1 },
      'Numpad2': { dx: 0, dy: 1 },
      'Numpad4': { dx: -1, dy: 0 },
      'Numpad6': { dx: 1, dy: 0 },
      'Numpad7': { dx: -1, dy: -1 },
      'Numpad9': { dx: 1, dy: -1 },
      'Numpad1': { dx: -1, dy: 1 },
      'Numpad3': { dx: 1, dy: 1 },
    };

    // Vi keys
    const viMap = {
      'k': { dx: 0, dy: -1 },
      'j': { dx: 0, dy: 1 },
      'h': { dx: -1, dy: 0 },
      'l': { dx: 1, dy: 0 },
      'y': { dx: -1, dy: -1 },
      'u': { dx: 1, dy: -1 },
      'b': { dx: -1, dy: 1 },
      'n': { dx: 1, dy: 1 },
    };

    // Check movement
    let dir = moveMap[e.code] || viMap[letter];
    if (dir) {
      e.preventDefault();
      this.onAction({ type: 'move', dx: dir.dx, dy: dir.dy });
      return;
    }

    // Other actions
    switch (letter) {
      case 'g': // Pickup
        e.preventDefault();
        this._dispatchTimedAction({ type: 'pickup' }, letter);
        break;
      case 'e': // Eat (first edible)
        e.preventDefault();
        this._dispatchTimedAction({ type: 'eat' }, letter);
        break;
      case '.': // Wait (also Numpad5)
        e.preventDefault();
        this.onAction({ type: 'wait' });
        break;
      case 's': // Save (Ctrl+S) or Sleep
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          this.onAction({ type: 'save' });
        } else {
          e.preventDefault();
          this._dispatchTimedAction({ type: 'sleep' }, letter);
        }
        break;
      case 'z': // Open spell menu / cast
        e.preventDefault();
        this.onAction({ type: 'openSpells' });
        break;
      case 'f': // Fire ranged weapon
        e.preventDefault();
        this._dispatchTimedAction({ type: 'rangedAttack' }, letter);
        break;
      case 'c': // Open crafting
        e.preventDefault();
        this.onAction({ type: 'openCraft' });
        break;
      case 'q': // Open quests
        e.preventDefault();
        this.onAction({ type: 'openQuests' });
        break;
      case 't': // Tame adjacent monster
        e.preventDefault();
        this._dispatchTimedAction({ type: 'tame' }, letter);
        break;
      case 'm': // Mine / gather resources
        e.preventDefault();
        this._dispatchTimedAction({ type: 'gather' }, letter);
        break;
      case 'p': // Plant seed
        e.preventDefault();
        this._dispatchTimedAction({ type: 'openPlant' }, letter);
        break;
      case 'r': // Pray to god
        e.preventDefault();
        this._dispatchTimedAction({ type: 'pray' }, letter);
        break;
      case 'b': // Open card book
        e.preventDefault();
        this.onAction({ type: 'openCardBook' });
        break;
      default:
        break;
    }

    // Shift keys
    if (e.shiftKey && e.key === 'H') {
      e.preventDefault();
      this._dispatchTimedAction({ type: 'harvest' }, 'h');
    }
    if (e.shiftKey && e.key === 'U') {
      e.preventDefault();
      this.onAction({ type: 'pickupFurniture' });
    }

    // Special keys by code
    switch (e.code) {
      case 'Numpad5': // Wait
        e.preventDefault();
        this.onAction({ type: 'wait' });
        break;
      case 'Enter':
        e.preventDefault();
        if (this.mode === 'worldMap') {
          this.onAction({ type: 'enterLocation' });
        }
        break;
      case 'Escape':
        e.preventDefault();
        // Cancel timed action only â€” map exit is handled by walking to the edge
        if (this.onActionCancel) {
          this.onActionCancel('__escape__');
        }
        break;
      case 'Period': // > descend
        if (e.shiftKey) {
          e.preventDefault();
          this.onAction({ type: 'descend' });
        }
        break;
      case 'Comma': // < ascend
        if (e.shiftKey) {
          e.preventDefault();
          this.onAction({ type: 'ascend' });
        }
        break;
    }
  }

  // â”€â”€ Dispatch action through timed system or directly â”€â”€
  _dispatchTimedAction(action, key) {
    if (this.onActionStart) {
      this.onActionStart(action, key);
    } else {
      this.onAction(action);
    }
  }

  // â”€â”€ Mouse Click â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onClick(e) {
    if (!this.enabled) return;
    // We'll let app.js handle translating clicks to tile coordinates
    // via renderer.getClickedTile
    const event = new CustomEvent('tileClick', {
      detail: { clientX: e.clientX, clientY: e.clientY }
    });
    this.canvas.dispatchEvent(event);
  }
}

</script>
  <script>
// ============================================================
// App â€” Main entry point, local engine, state management
// (No server required â€” all game logic runs in the browser)
// ============================================================

(async function () {
  'use strict';

  // Load all game data from static JSON files before initializing UI
  await loadGameData();

  // Core systems
  const canvas = document.getElementById('gameCanvas');
  const renderer = new Renderer(canvas);
  const ui = new UI();

  // Expose tile manager for UI sprite access
  window._tileManager = renderer.tiles;

  // Local game engine (replaces server-side socket.io)
  let engine = null;

  // Current game state
  let gameState = null;

  const input = new InputHandler(canvas, handleAction);

  // â”€â”€ Timed Action System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Tracks the currently progressing timed action
  let timedAction = null; // { action, timing, key, ticksDone, ticksTotal, timer }

  const progressOverlay = document.getElementById('actionProgressOverlay');
  const progressIcon = document.getElementById('actionProgressIcon');
  const progressLabel = document.getElementById('actionProgressLabel');
  const progressFill = document.getElementById('actionProgressFill');
  const progressTicks = document.getElementById('actionProgressTicks');

  // How fast each tick progresses (ms per tick) â€” feels snappy
  const BASE_TICK_MS = 180;

  function showProgressBar(timing) {
    progressIcon.textContent = timing.icon || 'â³';
    progressLabel.textContent = timing.label || 'Working...';
    progressFill.style.width = '0%';
    // Color speed indicator
    progressFill.className = 'action-progress-fill';
    if (timing.ticks <= 2) progressFill.classList.add('fill-fast');
    else if (timing.ticks >= 5) progressFill.classList.add('fill-slow');
    progressTicks.textContent = `0 / ${timing.ticks}`;
    progressOverlay.classList.remove('hidden');
  }

  function updateProgressBar(done, total) {
    const pct = Math.min(100, (done / total) * 100);
    progressFill.style.width = pct + '%';
    progressTicks.textContent = `${done} / ${total}`;
  }

  function hideProgressBar() {
    progressOverlay.classList.add('hidden');
  }

  function cancelTimedAction(showMessage) {
    if (!timedAction) return;
    clearInterval(timedAction.timer);
    if (showMessage && engine && gameState) {
      engine.addMessage('Action cancelled.');
      gameState = engine.getClientState();
      ui.updateMessages(gameState.messages);
    }
    timedAction = null;
    hideProgressBar();
  }

  function startTimedAction(action, key) {
    if (!engine || !gameState) return;

    // Get timing info
    const context = engine.getActionContext(action);
    const timing = ActionTimingSystem.getActionTiming(action, engine.player, context);

    // Instant actions â€” execute immediately
    if (timing.instant || timing.ticks <= 1) {
      handleAction(action);
      return;
    }

    // Cancel any existing timed action
    if (timedAction) {
      cancelTimedAction(false);
    }

    // Start timed action with progress bar
    showProgressBar(timing);

    // Show a message about the action starting
    const tickMsg = timing.ticks <= 2 ? '(quick)' : timing.ticks <= 4 ? '' : '(slow)';
    engine.addMessage(`${timing.label || 'Working...'} [${timing.ticks} ticks] ${tickMsg}`);
    gameState = engine.getClientState();
    ui.updateMessages(gameState.messages);

    const ta = {
      action,
      timing,
      key,
      ticksDone: 0,
      ticksTotal: timing.ticks,
      timer: null
    };

    ta.timer = setInterval(() => {
      // Check if key is still held (for keyboard actions)
      if (key && !input.isKeyHeld(key)) {
        cancelTimedAction(true);
        return;
      }

      ta.ticksDone++;
      updateProgressBar(ta.ticksDone, ta.ticksTotal);

      if (ta.ticksDone >= ta.ticksTotal) {
        // Action complete â€” execute it
        clearInterval(ta.timer);
        timedAction = null;
        hideProgressBar();
        handleAction(action);
      }
    }, BASE_TICK_MS);

    timedAction = ta;
  }

  // Wire up the timed action system to input handler
  input.onActionStart = (action, key) => {
    startTimedAction(action, key);
  };

  input.onActionCancel = (key) => {
    if (timedAction && (timedAction.key === key || key === '__escape__')) {
      cancelTimedAction(true);
      return true;
    }
    return false;
  };

  // â”€â”€ Screen: Main Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ui.showScreen('mainMenu');

  // New Game button
  document.getElementById('btnNewGame').addEventListener('click', () => {
    ui.showScreen('charCreation');
  });

  // Load Game button
  document.getElementById('btnLoadGame').addEventListener('click', () => {
    const saves = SaveManager.listSaves();
    ui.populateSaveList(saves, (saveId) => {
      const saveData = SaveManager.load(saveId);
      if (saveData) {
        engine = new GameEngine();
        engine.loadFromSave(saveData);
        applyGameState(engine.getClientState());
      } else {
        console.error('Save not found:', saveId);
      }
    });
  });

  // â”€â”€ Screen: Character Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('btnStartGame').addEventListener('click', () => {
    const data = ui.getCreationData();
    engine = new GameEngine();
    engine.createNewGame(data);
    applyGameState(engine.getClientState());
  });

  document.getElementById('btnBackToMenu').addEventListener('click', () => {
    ui.showScreen('mainMenu');
  });

  // â”€â”€ Screen: Game Over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('btnReturnMenu').addEventListener('click', () => {
    gameState = null;
    engine = null;
    input.disable();
    ui.showScreen('mainMenu');
  });

  // â”€â”€ Action Bar Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Actions that go through the timed system when triggered via button
  const timedBtnActions = new Set([
    'pickup', 'eat', 'rangedAttack', 'tame', 'gather', 'pray',
    'openPlant', 'harvest'
  ]);

  const actionBtns = {
    btnPickup: { type: 'pickup' },
    btnWait: { type: 'wait' },
    btnEat: { type: 'eat' },
    btnMagic: { type: 'openSpells' },
    btnShoot: { type: 'rangedAttack' },
    btnCraft: { type: 'openCraft' },
    btnQuest: { type: 'openQuests' },
    btnTame: { type: 'tame' },
    btnGather: { type: 'gather' },
    btnPray: { type: 'pray' },
    btnPlant: { type: 'openPlant' },
    btnHarvest: { type: 'harvest' },
    btnDescend: { type: 'descend' },
    btnAscend: { type: 'ascend' },
    btnSave: { type: 'save' },
    btnEnter: { type: 'enterLocation' }
  };
  Object.entries(actionBtns).forEach(([id, action]) => {
    const btn = document.getElementById(id);
    if (btn) {
      if (timedBtnActions.has(action.type)) {
        // For timed actions via button click: auto-complete with progress bar
        btn.addEventListener('click', () => handleTimedOrDirect(action));
      } else {
        btn.addEventListener('click', () => handleAction(action));
      }
    }
  });

  // â”€â”€ Handle Player Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Route UI-triggered actions through timed system (auto-completes, no key hold needed)
  function handleTimedOrDirect(action) {
    if (!engine || !gameState) return;
    const context = engine.getActionContext(action);
    const timing = ActionTimingSystem.getActionTiming(action, engine.player, context);
    if (timing.instant || timing.ticks <= 1) {
      handleAction(action);
      return;
    }
    // For UI-triggered timed actions: auto-complete (no key hold required)
    if (timedAction) cancelTimedAction(false);
    showProgressBar(timing);
    const ta = {
      action,
      timing,
      key: null, // null = auto-complete (UI-triggered)
      ticksDone: 0,
      ticksTotal: timing.ticks,
      timer: null
    };
    ta.timer = setInterval(() => {
      ta.ticksDone++;
      updateProgressBar(ta.ticksDone, ta.ticksTotal);
      if (ta.ticksDone >= ta.ticksTotal) {
        clearInterval(ta.timer);
        timedAction = null;
        hideProgressBar();
        handleAction(action);
      }
    }, BASE_TICK_MS);
    timedAction = ta;
  }

  function handleAction(action) {
    if (!gameState || !engine) return;

    // Cancel any active timed action if the player does something else
    if (timedAction && action.type !== timedAction.action.type) {
      cancelTimedAction(false);
    }

    if (action.type === 'save') {
      const id = SaveManager.save(engine.serialize());
      console.log('Game saved:', id);
      if (gameState && gameState.messages) {
        gameState.messages.push({ text: 'â€” Game saved â€”', type: 'important' });
        ui.updateMessages(gameState.messages);
      }
      return;
    }

    if (action.type === 'openSpells') {
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(t => t.classList.remove('active'));
      const spellTab = document.querySelector('[data-tab="spellsTab"]');
      if (spellTab) spellTab.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const spellPanel = document.getElementById('spellsTab');
      if (spellPanel) spellPanel.classList.add('active');
      return;
    }

    if (action.type === 'openCraft') {
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(t => t.classList.remove('active'));
      const craftTab = document.querySelector('[data-tab="craftTab"]');
      if (craftTab) craftTab.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const craftPanel = document.getElementById('craftTab');
      if (craftPanel) craftPanel.classList.add('active');
      return;
    }

    if (action.type === 'openQuests') {
      ui.switchToQuestTab();
      return;
    }

    if (action.type === 'openCardBook') {
      ui.switchToCardBookTab();
      return;
    }

    if (action.type === 'openFaith') {
      ui.switchToFaithTab();
      return;
    }

    // Worship a god (from faith panel)
    if (action.type === 'worship') {
      engine.processAction({ type: 'worship', godId: action.godId });
      applyGameState(engine.getClientState());
      return;
    }

    // Offer an item at an altar (from faith panel)
    if (action.type === 'offerItem') {
      engine.processAction({ type: 'offerItem', itemIndex: action.itemIndex });
      applyGameState(engine.getClientState());
      return;
    }

    if (action.type === 'openPlant') {
      if (gameState && gameState.player && gameState.player.inventory) {
        const seedIdx = gameState.player.inventory.findIndex(i => i.type === 'seed');
        if (seedIdx >= 0) {
          handleTimedOrDirect({ type: 'plant', itemIndex: seedIdx });
          return;
        }
      }
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(t => t.classList.remove('active'));
      const invTab = document.querySelector('[data-tab="inventory"]');
      if (invTab) invTab.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const invPanel = document.getElementById('inventory');
      if (invPanel) invPanel.classList.add('active');
      return;
    }

    // Enchant target selection â€” show a picker to choose a weapon/armor target
    if (action.type === 'openEnchantTarget') {
      const scrollIdx = action.scrollIndex;
      if (!gameState || !gameState.player) return;
      const inv = gameState.player.inventory;
      // Find all enchantable items (weapons and armor)
      const targets = [];
      inv.forEach((item, i) => {
        if (i !== scrollIdx && (item.type === 'weapon' || item.type === 'armor')) {
          targets.push({ item, index: i });
        }
      });
      if (targets.length === 0) {
        if (gameState.messages) {
          gameState.messages.push({ text: 'You have no weapons or armor to enchant.', type: 'important' });
          ui.updateMessages(gameState.messages);
        }
        return;
      }
      ui.showEnchantTargetPicker(targets, (targetIdx) => {
        engine.processAction({ type: 'enchant', scrollIndex: scrollIdx, targetIndex: targetIdx });
        applyGameState(engine.getClientState());
      });
      return;
    }

    // All other actions go directly to the engine
    engine.processAction(action);
    applyGameState(engine.getClientState());
  }

  // â”€â”€ Canvas Click â†’ Movement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  canvas.addEventListener('tileClick', (e) => {
    if (!gameState || !gameState.player) return;
    const { clientX, clientY } = e.detail;
    const tile = renderer.getClickedTile(clientX, clientY);

    let px, py;
    if (gameState.mode === 'worldMap') {
      px = gameState.worldX;
      py = gameState.worldY;
    } else {
      px = gameState.player.x;
      py = gameState.player.y;
    }

    const rawDx = tile.tileX - px;
    const rawDy = tile.tileY - py;
    const absDx = Math.abs(rawDx);
    const absDy = Math.abs(rawDy);

    if (absDx === 0 && absDy === 0) return;

    let dx, dy;
    // If the distances are close (ratio within ~1.5), allow diagonal
    if (absDx > 0 && absDy > 0 && Math.max(absDx, absDy) / Math.min(absDx, absDy) <= 1.5) {
      dx = Math.sign(rawDx);
      dy = Math.sign(rawDy);
    } else if (absDx >= absDy) {
      // Dominant horizontal â€” move only left/right
      dx = Math.sign(rawDx);
      dy = 0;
    } else {
      // Dominant vertical â€” move only up/down
      dx = 0;
      dy = Math.sign(rawDy);
    }

    handleAction({ type: 'move', dx, dy });
  });

  // â”€â”€ Apply Game State (replaces socket.on('gameState')) â”€â”€
  function applyGameState(state) {
    gameState = state;

    if (state.dead) {
      input.disable();
      ui.showGameOver(state);
      return;
    }

    ui.showScreen('gameScreen');
    renderer._resize();
    input.enable();
    input.setMode(state.mode);

    // Update UI
    ui.updateHUD(state);
    ui.updateMessages(state.messages);
    ui.updateGatherOverlay(state);
    ui.updateContextActions(state.contextActions, handleAction);
    ui.updateInventory(
      state.player,
      (action) => {
        if (action.type === 'plant') {
          handleTimedOrDirect(action);
        } else if (action.type === 'readSpellbook') {
          handleTimedOrDirect(action);
        } else if (action.type === 'openEnchantTarget') {
          handleAction(action);
        } else if (action.type === 'use') {
          handleTimedOrDirect(action);
        } else if (action.type === 'eat') {
          handleTimedOrDirect(action);
        } else if (action.type === 'readRecipe') {
          handleAction(action);
        } else if (action.type === 'placeWorkshop') {
          handleAction(action);
        } else {
          handleAction(action);
        }
      }
    );
    ui.updateCharacter(state.player);
    ui.updateSkills(state.player);
    ui.updateSpells(
      state.player,
      (spellId) => handleTimedOrDirect({ type: 'castSpell', spellId })
    );
    ui.updateShop(
      state,
      (itemId) => {
        engine.processAction({ type: 'shopBuy', itemId });
        applyGameState(engine.getClientState());
      },
      (itemIndex) => {
        engine.processAction({ type: 'shopSell', itemIndex });
        applyGameState(engine.getClientState());
      }
    );
    ui.updateCrafting(
      state,
      (recipeId) => {
        handleTimedOrDirect({ type: 'craft', recipeId });
      }
    );
    ui.updateQuests(
      state,
      (questId) => {
        engine.processAction({ type: 'acceptQuest', questId });
        applyGameState(engine.getClientState());
      },
      (questId) => {
        engine.processAction({ type: 'turnInQuest', questId });
        applyGameState(engine.getClientState());
      },
      (questId) => {
        engine.processAction({ type: 'abandonQuest', questId });
        applyGameState(engine.getClientState());
      }
    );
    ui.updateFaith(
      state,
      (godId) => handleAction({ type: 'worship', godId }),
      (itemIndex) => handleAction({ type: 'offerItem', itemIndex }),
      () => handleAction({ type: 'pray' })
    );
    ui.updatePets(
      state,
      (petId) => {
        engine.processAction({ type: 'releasePet', petId });
        applyGameState(engine.getClientState());
      },
      (petId, newName) => {
        engine.processAction({ type: 'renamePet', petId, newName });
        applyGameState(engine.getClientState());
      },
      (petId) => {
        engine.processAction({ type: 'revivePet', petId });
        applyGameState(engine.getClientState());
      }
    );
    ui.updateCardBook(
      state,
      (cardIndex) => {
        engine.processAction({ type: 'cardShopBuy', cardIndex });
        applyGameState(engine.getClientState());
      },
      (cardIndex) => {
        engine.processAction({ type: 'cardShopSell', cardIndex });
        applyGameState(engine.getClientState());
      }
    );

    // Auto-open shop tab when near NPC
    if (state.shop && !ui._shopTabOpened) {
      ui.switchToShopTab();
      ui._shopTabOpened = true;
    } else if (!state.shop) {
      ui._shopTabOpened = false;
    }

    // Auto-open quest tab when on quest board
    if (state.onQuestBoard && !ui._questTabOpened) {
      ui.switchToQuestTab();
      ui._questTabOpened = true;
    } else if (!state.onQuestBoard) {
      ui._questTabOpened = false;
    }

    // Auto-open pets tab when a pet is newly tamed
    if (state.pets && state.pets.length > 0 && !ui._petTabShown) {
      ui._petTabShown = state.pets.length;
    }
    if (state.pets && state.pets.length > (ui._petTabShown || 0)) {
      ui.switchToPetsTab();
      ui._petTabShown = state.pets.length;
    }

    // Auto-open faith tab when on altar
    if (state.onAltar && !ui._faithTabOpened) {
      ui.switchToFaithTab();
      ui._faithTabOpened = true;
    } else if (!state.onAltar) {
      ui._faithTabOpened = false;
    }

    // Auto-open card book tab when near card merchant
    if (state.cardShop && !ui._cardShopOpened) {
      ui.switchToCardBookTab();
      ui._cardShopOpened = true;
    } else if (!state.cardShop) {
      ui._cardShopOpened = false;
    }

    // Render
    if (state.mode === 'worldMap') {
      renderer.renderWorldMap(state);
    } else {
      renderer.renderLocalMap(state);
    }
  }

  // â”€â”€ Window Focus â†’ Resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  window.addEventListener('focus', () => {
    renderer._resize();
    if (gameState) {
      if (gameState.mode === 'worldMap') renderer.renderWorldMap(gameState);
      else renderer.renderLocalMap(gameState);
    }
  });

})();

</script>
</body>
</html>
;
        gold.color = '#ff0';
        drops.push(gold);
      }
    }

    const materialChance = 0.15 + (monster.level || 1) * 0.02;
    if (Math.random() < materialChance) {
      const materials = ['oreIron', 'woodLog', 'leather', 'string', 'emptyBottle'];
      const rareChance = (monster.level || 1) > 8 ? 0.3 : 0.05;
      if (Math.random() < rareChance) materials.push('crystalBlue');
      const matId = materials[Math.floor(Math.random() * materials.length)];
      const mat = ItemSystem.createItem(matId);
      if (mat) drops.push(mat);
    }

    const spellbookChance = 0.03 + (monster.level || 1) * 0.01;
    if (Math.random() < spellbookChance) {
      const spellbookIds = Object.keys(ITEM_TEMPLATES).filter(k => ITEM_TEMPLATES[k].type === 'spellbook');
      if (spellbookIds.length > 0) {
        const suitable = spellbookIds.filter(k => (ITEM_TEMPLATES[k].difficulty || 1) <= (monster.level || 1) + 3);
        const pool = suitable.length > 0 ? suitable : spellbookIds;
        const bookId = pool[Math.floor(Math.random() * pool.length)];
        const book = ItemSystem.createItem(bookId);
        if (book) {
          drops.push(book);
        }
      }
    }

    // Recipe paper drops (uncommon)
    const recipeChance = 0.05 + (monster.level || 1) * 0.01;
    if (Math.random() < recipeChance) {
      const paper = CraftingSystem.generateRandomRecipePaper(monster.level || 1);
      if (paper) drops.push(paper);
    }

    // Enchant scroll drops (rare, scale with monster level)
    const scrollChance = 0.02 + (monster.level || 1) * 0.008;
    if (Math.random() < scrollChance) {
      const scrollPool = ['scrollEnchant', 'scrollEnchantArmor'];
      if ((monster.level || 1) >= 8) scrollPool.push('scrollGreaterEnchant', 'scrollFireEnchant', 'scrollIceEnchant');
      if ((monster.level || 1) >= 12) scrollPool.push('scrollLightningEnchant', 'scrollHolyEnchant', 'scrollSpeedEnchant');
      if ((monster.level || 1) >= 15) scrollPool.push('scrollSupremeEnchant');
      const scrollId = scrollPool[Math.floor(Math.random() * scrollPool.length)];
      const scroll = ItemSystem.createItem(scrollId);
      if (scroll) drops.push(scroll);
    }

    return drops;
  }

  static equipItem(player, item) {
    if (item.type === 'weapon') {
      player.equipment.weapon = item;
      return { message: `Equipped ${item.name}.` };
    }
    if (item.type === 'armor') {
      const slot = item.slot || 'body';
      player.equipment[slot] = item;
      return { message: `Equipped ${item.name} on ${slot}.` };
    }
    return { message: `Cannot equip that.` };
  }

  // â”€â”€ Stacking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /**
   * Returns true if an item type is stackable.
   * Weapons, armor, and spellbooks are NOT stackable.
   */
  static isStackable(item) {
    if (!item) return false;
    const nonStackTypes = ['weapon', 'armor'];
    if (nonStackTypes.includes(item.type)) return false;
    return true;
  }

  /**
   * Finds the index of a matching stack in the inventory.
   * Two items stack if they share the same template id (not uuid).
   */
  static findStackIndex(inventory, item) {
    if (!ItemSystem.isStackable(item)) return -1;
    // Use the template id field â€” every item from createItem carries its original 'id' field
    // but also has a unique uuid in 'id'. We use the original template identifier.
    const templateId = item.templateId || item.id;
    return inventory.findIndex(existing =>
      (existing.templateId || existing.id) === templateId &&
      existing.name === item.name &&
      ItemSystem.isStackable(existing)
    );
  }

  /**
   * Adds an item to inventory, stacking if possible.
   * Returns the inventory index of the item.
   */
  static addToInventory(player, item) {
    if (!item.templateId) item.templateId = item.id;
    if (!item.quantity) item.quantity = 1;

    if (ItemSystem.isStackable(item)) {
      const stackIdx = ItemSystem.findStackIndex(player.inventory, item);
      if (stackIdx !== -1) {
        player.inventory[stackIdx].quantity = (player.inventory[stackIdx].quantity || 1) + item.quantity;
        return stackIdx;
      }
    }
    // Give unique id if stackable to avoid collisions
    if (ItemSystem.isStackable(item)) {
      item.id = uuidv4();
    }
    player.inventory.push(item);
    return player.inventory.length - 1;
  }

  /**
   * Remove one unit from a stack (or the whole item if quantity <= 1).
   * Returns the removed single item (for drop, etc).
   */
  static removeFromInventory(player, idx, count) {
    if (idx < 0 || idx >= player.inventory.length) return null;
    count = count || 1;
    const item = player.inventory[idx];
    const qty = item.quantity || 1;
    if (qty <= count) {
      return player.inventory.splice(idx, 1)[0];
    } else {
      item.quantity = qty - count;
      // Return a copy representing the removed portion
      const removed = { ...item, quantity: count, id: uuidv4() };
      return removed;
    }
  }
}

</script>
  <script>
// ============================================================
// TimeWeather â€” Day/night, seasons, weather cycle (browser)
// ============================================================

class TimeWeather {
  constructor(state) {
    if (state) {
      this.minute = state.minute || 0;
      this.hour = state.hour || 8;
      this.day = state.day || 1;
      this.month = state.month || 3;
      this.year = state.year || 517;
      this.weather = state.weather || 'sunny';
      this.weatherTimer = state.weatherTimer || 0;
    } else {
      this.minute = 0;
      this.hour = 8;
      this.day = 1;
      this.month = 3;
      this.year = 517;
      this.weather = 'sunny';
      this.weatherTimer = 0;
    }
  }

  advanceTurn() {
    this.minute += 1;
    this._normalize();
    this.weatherTimer--;
    if (this.weatherTimer <= 0) {
      this._changeWeather();
    }
  }

  advanceMinutes(mins) {
    this.minute += mins;
    this._normalize();
  }

  _normalize() {
    while (this.minute >= 60) {
      this.minute -= 60;
      this.hour++;
    }
    while (this.hour >= 24) {
      this.hour -= 24;
      this.day++;
    }
    while (this.day > 30) {
      this.day -= 30;
      this.month++;
    }
    while (this.month > 12) {
      this.month -= 12;
      this.year++;
    }
  }

  _changeWeather() {
    const season = this.getSeason();
    let pool;
    if (season === 'winter') {
      pool = ['sunny', 'cloudy', 'snow', 'heavySnow', 'cloudy'];
    } else if (season === 'spring') {
      pool = ['sunny', 'sunny', 'cloudy', 'rain', 'sunny'];
    } else if (season === 'summer') {
      pool = ['sunny', 'sunny', 'sunny', 'cloudy', 'rain'];
    } else {
      pool = ['sunny', 'cloudy', 'rain', 'heavyRain', 'cloudy'];
    }
    this.weather = pool[Math.floor(Math.random() * pool.length)];
    this.weatherTimer = Math.floor(Math.random() * 200) + 50;
  }

  getSeason() {
    if (this.month >= 3 && this.month <= 5) return 'spring';
    if (this.month >= 6 && this.month <= 8) return 'summer';
    if (this.month >= 9 && this.month <= 11) return 'autumn';
    return 'winter';
  }

  isNight() {
    return this.hour >= 20 || this.hour < 6;
  }

  getTimeString() {
    const hh = String(this.hour).padStart(2, '0');
    const mm = String(this.minute).padStart(2, '0');
    return `Year ${this.year}, Month ${this.month}, Day ${this.day} ${hh}:${mm}`;
  }

  getState() {
    return {
      minute: this.minute,
      hour: this.hour,
      day: this.day,
      month: this.month,
      year: this.year,
      weather: this.weather,
      weatherTimer: this.weatherTimer,
      season: this.getSeason(),
      isNight: this.isNight(),
      timeString: this.getTimeString()
    };
  }
}

</script>
  <script>
// ============================================================
// MapGenerator â€” World, Town, Outdoor, Dungeon maps (browser)
// ============================================================

class MapGenerator {
  // â”€â”€ World Map constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static WORLD_WIDTH = 128;
  static WORLD_HEIGHT = 96;

  // â”€â”€ World Map (biome grid) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateWorldMap(width, height) {
    width = width || MapGenerator.WORLD_WIDTH;
    height = height || MapGenerator.WORLD_HEIGHT;
    const map = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        row.push(MapGenerator._worldTileBiome(x, y, width, height));
      }
      map.push(row);
    }
    // Build road network connecting nearby towns
    const towns = Object.values(WORLD_LOCATIONS).filter(l => l.type === 'town');
    MapGenerator._buildRoadNetwork(map, towns);
    return map;
  }

  // Deterministic biome for any (x,y) world coordinate.
  // The noise functions are purely hash-based, so the same coordinates
  // always produce the same terrain â€” the world is always identical.
  static _worldTileBiome(x, y, w, h) {
    const nx = x / w; // 0..1
    const ny = y / h; // 0..1

    // â”€â”€ Hard ocean border â”€â”€
    const edgeDist = Math.min(x, y, w - 1 - x, h - 1 - y);
    if (edgeDist <= 1) return { ...BIOMES.sea };

    // â”€â”€ Continental shelf: irregular coastline â”€â”€
    const maxEdge = Math.min(w, h) * 0.5;
    const edgeFactor = Math.min(edgeDist / maxEdge, 1.0);
    const coastNoise = MapGenerator._fbmNoise(x * 0.06 + 500, y * 0.06 + 500, 5);
    const landValue = edgeFactor * 0.65 + coastNoise * 0.35;

    if (landValue < 0.12) return { ...BIOMES.sea };
    if (landValue < 0.18) return { ...BIOMES.beach };

    // â”€â”€ Elevation (mountains, highlands) â”€â”€
    const elevation = MapGenerator._fbmNoise(x * 0.05, y * 0.05, 6);

    // â”€â”€ Moisture (forests, swamps) â”€â”€
    const moisture = MapGenerator._fbmNoise(x * 0.04 + 100, y * 0.04 + 100, 5);

    // â”€â”€ Temperature: latitude gradient + noise + altitude â”€â”€
    // coldness is high in the north (y=0), low in the south (y=h)
    const latCold = 1.0 - ny;
    const coldNoise = MapGenerator._fbmNoise(x * 0.03 + 200, y * 0.03 + 200, 3);
    const coldness = latCold * 0.50 + coldNoise * 0.20 + elevation * 0.15 + 0.15;

    // â”€â”€ Inland lakes / seas â”€â”€
    if (elevation < 0.22 && moisture > 0.63 && edgeFactor > 0.30) {
      return { ...BIOMES.sea };
    }

    // â”€â”€ Biome selection â”€â”€
    if (coldness > 0.74) return { ...BIOMES.snow };
    if (elevation > 0.64) return { ...BIOMES.mountain };
    if (coldness < 0.34 && moisture < 0.44) return { ...BIOMES.desert };
    if (moisture > 0.55) return { ...BIOMES.forest };

    return { ...BIOMES.plains };
  }

  // â”€â”€ Road network: connect each town to its 2 nearest neighbours â”€â”€
  static _buildRoadNetwork(map, towns) {
    if (towns.length < 2) return;
    const connected = new Set();
    for (const town of towns) {
      const sorted = towns
        .filter(t => t.id !== town.id)
        .map(t => ({ t, d: Math.abs(t.x - town.x) + Math.abs(t.y - town.y) }))
        .sort((a, b) => a.d - b.d);
      const count = Math.min(2, sorted.length);
      for (let i = 0; i < count; i++) {
        const key = [town.id, sorted[i].t.id].sort().join('-');
        if (!connected.has(key)) {
          connected.add(key);
          MapGenerator._drawRoad(map, town, sorted[i].t);
        }
      }
    }
  }

  static _drawRoad(map, a, b) {
    let x = a.x, y = a.y;
    while (x !== b.x || y !== b.y) {
      if (x >= 0 && y >= 0 && y < map.length && x < map[0].length) {
        const tile = map[y][x];
        if (tile.id !== 'sea' && tile.id !== 'beach') {
          map[y][x] = { ...BIOMES.road };
        }
      }
      // Diagonal-aware pathfinding with slight noise for organic feel
      const dx = b.x - x, dy = b.y - y;
      if (Math.abs(dx) > Math.abs(dy)) {
        x += dx > 0 ? 1 : -1;
      } else if (Math.abs(dy) > Math.abs(dx)) {
        y += dy > 0 ? 1 : -1;
      } else {
        // Equal â€” alternate to create diagonal road
        const bias = MapGenerator._hash2d(x + 1000, y + 1000);
        if (bias > 0.5) x += dx > 0 ? 1 : -1;
        else y += dy > 0 ? 1 : -1;
      }
    }
  }

  // â”€â”€ Improved noise: multi-octave value noise â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _hash2d(x, y) {
    // Integer hash â€” no sin patterns
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >> 13)) * 1274126177;
    h = h ^ (h >> 16);
    return ((h >>> 0) & 0x7fffffff) / 0x7fffffff; // 0..1
  }

  static _smoothNoise(x, y) {
    const ix = Math.floor(x), iy = Math.floor(y);
    const fx = x - ix, fy = y - iy;
    // Smoothstep
    const sx = fx * fx * (3 - 2 * fx);
    const sy = fy * fy * (3 - 2 * fy);
    const n00 = MapGenerator._hash2d(ix, iy);
    const n10 = MapGenerator._hash2d(ix + 1, iy);
    const n01 = MapGenerator._hash2d(ix, iy + 1);
    const n11 = MapGenerator._hash2d(ix + 1, iy + 1);
    const nx0 = n00 + sx * (n10 - n00);
    const nx1 = n01 + sx * (n11 - n01);
    return nx0 + sy * (nx1 - nx0);
  }

  static _fbmNoise(x, y, octaves = 4) {
    let value = 0, amplitude = 0.5, frequency = 1, total = 0;
    for (let i = 0; i < octaves; i++) {
      value += amplitude * MapGenerator._smoothNoise(x * frequency, y * frequency);
      total += amplitude;
      amplitude *= 0.5;
      frequency *= 2.17; // non-integer avoids alignment
    }
    return value / total;
  }

  static _simpleNoise(x, y) {
    return MapGenerator._fbmNoise(x * 0.15, y * 0.15, 4);
  }

  // â”€â”€ Town Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateTownMap(location) {
    if (location.layout) {
      return MapGenerator._buildFromLayout(location.layout);
    }
    return MapGenerator._generateRandomTownMap();
  }

  static _buildFromLayout(layout) {
    const w = layout.width;
    const h = layout.height;
    const legend = layout.legend || {};
    const rows = layout.rows || [];

    const tiles = [];
    for (let y = 0; y < h; y++) {
      const row = [];
      const line = rows[y] || '';
      for (let x = 0; x < w; x++) {
        const ch = line[x] || ',';
        const tileType = legend[ch] || 'grass';
        row.push(MapGenerator._tile(tileType));
      }
      tiles.push(row);
    }

    return { width: w, height: h, tiles, monsters: [], items: [], type: 'town' };
  }

  static _generateRandomTownMap() {
    const w = 40, h = 30;
    const tiles = MapGenerator._emptyMap(w, h, 'grass');

    const buildings = Math.floor(Math.random() * 4) + 4;
    for (let i = 0; i < buildings; i++) {
      const bx = Math.floor(Math.random() * (w - 8)) + 2;
      const by = Math.floor(Math.random() * (h - 8)) + 2;
      const bw = Math.floor(Math.random() * 4) + 4;
      const bh = Math.floor(Math.random() * 4) + 4;
      for (let yy = by; yy < by + bh && yy < h; yy++) {
        for (let xx = bx; xx < bx + bw && xx < w; xx++) {
          if (yy === by || yy === by + bh - 1 || xx === bx || xx === bx + bw - 1) {
            tiles[yy][xx] = MapGenerator._tile('wall');
          } else {
            tiles[yy][xx] = MapGenerator._tile('floor');
          }
        }
      }
      const doorX = bx + Math.floor(bw / 2);
      tiles[by + bh - 1][doorX] = MapGenerator._tile('door');
    }

    for (let x = 2; x < w - 2; x++) {
      if (tiles[Math.floor(h / 2)][x].walkable || tiles[Math.floor(h / 2)][x].type === 'grass') {
        tiles[Math.floor(h / 2)][x] = MapGenerator._tile('road');
      }
    }

    return { width: w, height: h, tiles, monsters: [], items: [], type: 'town' };
  }

  // â”€â”€ Outdoor Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateOutdoorMap(biome, danger) {
    const w = 50, h = 40;

    // Pick biome-specific ground tile and features
    const biomeConfig = MapGenerator._getBiomeConfig(biome.id);
    const tiles = MapGenerator._emptyMap(w, h, biomeConfig.ground);

    // Generate varied ground using noise â€” mix in alternate ground tiles
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const n = MapGenerator._fbmNoise(x * 0.2 + 50, y * 0.2 + 50, 3);
        if (biomeConfig.altGround && n > 0.55) {
          tiles[y][x] = MapGenerator._tile(biomeConfig.altGround);
        } else if (biomeConfig.altGround2 && n < 0.25) {
          tiles[y][x] = MapGenerator._tile(biomeConfig.altGround2);
        }
      }
    }

    // Scatter biome features using noise for natural clustering
    for (let y = 1; y < h - 1; y++) {
      for (let x = 1; x < w - 1; x++) {
        const featureNoise = MapGenerator._fbmNoise(x * 0.3 + 300, y * 0.3 + 300, 3);
        const scatter = MapGenerator._hash2d(x + 500, y + 500);

        for (const feat of biomeConfig.features) {
          // Combine noise clusters with random scatter for natural look
          const threshold = feat.cluster
            ? feat.density * (featureNoise > feat.clusterMin ? 2.5 : 0.3)
            : feat.density;
          if (scatter < threshold) {
            tiles[y][x] = MapGenerator._tile(feat.tile);
            break; // Only one feature per tile
          }
        }
      }
    }

    // Scatter herb patches in forests and plains
    if (biome.id === 'forest' || biome.id === 'plains') {
      const herbCount = 2 + Math.floor(Math.random() * 4);
      for (let i = 0; i < herbCount; i++) {
        const pos = MapGenerator._randOpen(w, h, tiles);
        tiles[pos.y][pos.x] = MapGenerator._tile('herbPatch');
      }
    }

    // Scatter mushroom patches in forests
    if (biome.id === 'forest') {
      const mushCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < mushCount; i++) {
        const pos = MapGenerator._randOpen(w, h, tiles);
        tiles[pos.y][pos.x] = MapGenerator._tile('mushroomPatch');
      }
    }

    // Add fishing spots near water tiles (beach biome)
    if (biome.id === 'beach' || biome.id === 'sea') {
      const fishCount = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < fishCount; i++) {
        const pos = MapGenerator._randWater(w, h, tiles);
        if (pos) {
          tiles[pos.y][pos.x] = MapGenerator._tile('fishingSpot');
        }
      }
    }

    // Scatter reed patches near water in beach and plains
    if (biome.id === 'beach' || biome.id === 'plains') {
      const reedCount = Math.floor(Math.random() * 3);
      for (let i = 0; i < reedCount; i++) {
        const pos = MapGenerator._randOpen(w, h, tiles);
        tiles[pos.y][pos.x] = MapGenerator._tile('reedPatch');
      }
    }

    // Assign node subtypes to all gatherable tiles
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        GatheringSystem.assignNodeSubtype(tiles[y][x]);
      }
    }

    const monsters = MapGenerator._spawnMonsters(w, h, tiles, danger, 5 + Math.floor(danger / 2), biome.id);

    const items = [];
    if (Math.random() < 0.3) {
      const ix = MapGenerator._randOpen(w, h, tiles);
      items.push({ ...ITEM_TEMPLATES.herbGreen, id: uuidv4(), x: ix.x, y: ix.y, char: '!', color: '#0c0' });
    }

    return { width: w, height: h, tiles, monsters, items, type: 'outdoor' };
  }

  /** Returns ground tile, alternate ground, and feature config per biome */
  static _getBiomeConfig(biomeId) {
    const configs = {
      plains: {
        ground: 'grass',
        altGround: 'dirt',
        altGround2: null,
        features: [
          { tile: 'berryBush', density: 0.01 },
          { tile: 'bush', density: 0.03, cluster: true, clusterMin: 0.6 },
          { tile: 'oakTree', density: 0.015, cluster: true, clusterMin: 0.65 },
          { tile: 'birchTree', density: 0.005 },
          { tile: 'rock', density: 0.005 },
          { tile: 'flintNode', density: 0.003 },
        ]
      },
      forest: {
        ground: 'forestFloor',
        altGround: 'grass',
        altGround2: 'dirt',
        features: [
          { tile: 'oakTree', density: 0.10, cluster: true, clusterMin: 0.4 },
          { tile: 'pineTree', density: 0.04, cluster: true, clusterMin: 0.45 },
          { tile: 'birchTree', density: 0.03, cluster: true, clusterMin: 0.5 },
          { tile: 'mapleTree', density: 0.01 },
          { tile: 'bush', density: 0.04, cluster: true, clusterMin: 0.5 },
          { tile: 'berryBush', density: 0.015 },
          { tile: 'mushroomPatch', density: 0.008 },
          { tile: 'stump', density: 0.01 },
          { tile: 'rock', density: 0.006 },
          { tile: 'copperOre', density: 0.003 },
        ]
      },
      mountain: {
        ground: 'rockyGround',
        altGround: 'dirt',
        altGround2: 'rockyGround',
        features: [
          { tile: 'rock', density: 0.12, cluster: true, clusterMin: 0.45 },
          { tile: 'ironOre', density: 0.02, cluster: true, clusterMin: 0.6 },
          { tile: 'copperOre', density: 0.015, cluster: true, clusterMin: 0.6 },
          { tile: 'silverOre', density: 0.006, cluster: true, clusterMin: 0.7 },
          { tile: 'goldOre', density: 0.003, cluster: true, clusterMin: 0.75 },
          { tile: 'mythrilOre', density: 0.001, cluster: true, clusterMin: 0.8 },
          { tile: 'pineTree', density: 0.015 },
          { tile: 'yewTree', density: 0.005 },
          { tile: 'flintNode', density: 0.006 },
          { tile: 'clayDeposit', density: 0.004 },
        ]
      },
      snow: {
        ground: 'snowGround',
        altGround: 'rockyGround',
        altGround2: null,
        features: [
          { tile: 'pineTree', density: 0.04, cluster: true, clusterMin: 0.5 },
          { tile: 'yewTree', density: 0.01 },
          { tile: 'rock', density: 0.04, cluster: true, clusterMin: 0.55 },
          { tile: 'ironOre', density: 0.008, cluster: true, clusterMin: 0.65 },
          { tile: 'silverOre', density: 0.004 },
        ]
      },
      desert: {
        ground: 'sand',
        altGround: 'dirt',
        altGround2: null,
        features: [
          { tile: 'cactus', density: 0.03, cluster: true, clusterMin: 0.6 },
          { tile: 'rock', density: 0.02 },
          { tile: 'deadTree', density: 0.008 },
          { tile: 'sandDeposit', density: 0.01 },
          { tile: 'copperOre', density: 0.005 },
          { tile: 'goldOre', density: 0.002 },
        ]
      },
      beach: {
        ground: 'sand',
        altGround: 'grass',
        altGround2: null,
        features: [
          { tile: 'water', density: 0.08, cluster: true, clusterMin: 0.5 },
          { tile: 'shallowWater', density: 0.05, cluster: true, clusterMin: 0.45 },
          { tile: 'rock', density: 0.01 },
          { tile: 'sandDeposit', density: 0.008 },
          { tile: 'reedPatch', density: 0.006 },
          { tile: 'clayDeposit', density: 0.004 },
        ]
      },
      sea: {
        ground: 'sand',
        altGround: null,
        altGround2: null,
        features: [
          { tile: 'water', density: 0.55, cluster: true, clusterMin: 0.3 },
          { tile: 'shallowWater', density: 0.15, cluster: true, clusterMin: 0.4 },
          { tile: 'rock', density: 0.005 },
        ]
      }
    };
    return configs[biomeId] || configs.plains;
  }

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _emptyMap(w, h, fillType) {
    const tiles = [];
    for (let y = 0; y < h; y++) {
      const row = [];
      for (let x = 0; x < w; x++) {
        if (x === 0 || y === 0 || x === w - 1 || y === h - 1) {
          row.push(MapGenerator._tile('wall'));
        } else {
          row.push(MapGenerator._tile(fillType));
        }
      }
      tiles.push(row);
    }
    return tiles;
  }

  static _tile(type) {
    const t = TILE_TYPES[type] || TILE_TYPES.floor;
    return { type: t.id, char: t.char, color: t.color, walkable: t.walkable, transparent: t.transparent };
  }

  static _spawnMonsters(w, h, tiles, danger, count, biomeId) {
    const pool = [];
    MONSTER_TIERS.forEach(tier => {
      if (danger >= tier.minDanger && danger <= tier.maxDanger) {
        pool.push(...tier.monsters);
      }
    });
    if (pool.length === 0) pool.push('putit');

    // Separate monsters into biome-preferred and generic pools
    let biomePool = [];
    let genericPool = [];
    if (biomeId) {
      for (const mId of pool) {
        const tmpl = MONSTER_TEMPLATES[mId];
        if (tmpl && tmpl.biomes && tmpl.biomes.includes(biomeId)) {
          biomePool.push(mId);
        } else {
          genericPool.push(mId);
        }
      }
    }
    // If no biome matches, fall back to the full pool
    if (biomePool.length === 0) {
      biomePool = pool;
      genericPool = [];
    }

    const monsters = [];
    for (let i = 0; i < count; i++) {
      // 75% chance to pick from biome-affiliated monsters, 25% generic
      let chosenPool;
      if (genericPool.length > 0 && Math.random() < 0.25) {
        chosenPool = genericPool;
      } else {
        chosenPool = biomePool;
      }
      const templateId = chosenPool[Math.floor(Math.random() * chosenPool.length)];
      const template = MONSTER_TEMPLATES[templateId];
      if (!template) continue;
      const pos = MapGenerator._randOpen(w, h, tiles);
      const scaledLevel = Math.max(template.level, Math.floor(danger * 0.8));
      const hpScale = 1 + (scaledLevel - template.level) * 0.15;
      monsters.push({
        id: uuidv4(),
        templateId: templateId,
        ...template,
        level: scaledLevel,
        hp: Math.floor(template.hp * hpScale),
        maxHp: Math.floor(template.hp * hpScale),
        x: pos.x,
        y: pos.y,
        char: template.name[0].toUpperCase(),
        color: '#e44'
      });
    }
    return monsters;
  }

  static _randOpen(w, h, tiles) {
    for (let tries = 0; tries < 200; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].walkable) return { x, y };
    }
    return { x: 1, y: 1 };
  }

  static _randWater(w, h, tiles) {
    for (let tries = 0; tries < 200; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].type === 'water') return { x, y };
    }
    return null;
  }
}

</script>
  <script>
// ============================================================
// NefiaSystem â€” Dungeon floor generation (browser)
// ============================================================

class NefiaSystem {
  constructor() {
    this.cache = {};
  }

  generateFloor(location, floorNum) {
    const key = `${location.id}-${floorNum}`;
    if (this.cache[key]) return this.cache[key];

    const baseDanger = (location.danger || 1) + floorNum;
    const w = 40 + Math.floor(Math.random() * 10);
    const h = 30 + Math.floor(Math.random() * 8);
    const tiles = this._generateDungeonLayout(w, h);

    const stairsUp = this._findOpen(tiles, w, h);
    tiles[stairsUp.y][stairsUp.x] = MapGenerator._tile('stairsUp');

    const maxFloors = location.floors || 10;
    let stairsDown = null;
    if (floorNum < maxFloors) {
      stairsDown = this._findOpen(tiles, w, h);
      while (stairsDown.x === stairsUp.x && stairsDown.y === stairsUp.y) {
        stairsDown = this._findOpen(tiles, w, h);
      }
      tiles[stairsDown.y][stairsDown.x] = MapGenerator._tile('stairsDown');
    }

    const monsterCount = 5 + Math.floor(baseDanger / 2) + Math.floor(Math.random() * 4);
    const monsters = MapGenerator._spawnMonsters(w, h, tiles, baseDanger, monsterCount);

    if (floorNum === maxFloors) {
      const bossPos = this._findOpen(tiles, w, h);
      const bossTemplate = this._pickBoss(baseDanger);
      const boss = {
        id: uuidv4(),
        templateId: bossTemplate.id,
        ...bossTemplate,
        level: baseDanger + 5,
        hp: Math.floor(bossTemplate.hp * 3),
        maxHp: Math.floor(bossTemplate.hp * 3),
        x: bossPos.x,
        y: bossPos.y,
        char: bossTemplate.name[0].toUpperCase(),
        color: '#f0f',
        isBoss: true,
        name: `â˜… ${bossTemplate.name} Boss`
      };
      monsters.push(boss);
    }

    const trapCount = Math.floor(baseDanger / 3) + Math.floor(Math.random() * 3);
    for (let i = 0; i < trapCount; i++) {
      const pos = this._findOpen(tiles, w, h);
      tiles[pos.y][pos.x] = { ...MapGenerator._tile('trap'), hidden: true };
    }

    // Scatter ore veins in dungeon walls
    const oreCount = 1 + Math.floor(Math.random() * 3) + Math.floor(baseDanger / 5);
    for (let i = 0; i < oreCount; i++) {
      const pos = this._findWallNeighboringFloor(tiles, w, h);
      if (pos) {
        tiles[pos.y][pos.x] = MapGenerator._tile('ore');
      }
    }

    const items = [];
    const itemCount = 2 + Math.floor(Math.random() * 3);
    for (let i = 0; i < itemCount; i++) {
      const pos = this._findOpen(tiles, w, h);
      const itemPool = ['herbGreen', 'potionHeal', 'potionMana', 'bread', 'torch'];
      if (baseDanger > 5) itemPool.push('leatherArmor', 'longSword', 'scrollEnchant', 'lantern');
      if (baseDanger > 10) itemPool.push('chainMail', 'battleAxe', 'scrollGreaterEnchant');
      if (baseDanger > 15) itemPool.push('scrollSupremeEnchant', 'scrollFireEnchant', 'scrollIceEnchant', 'scrollLightningEnchant', 'magicLight');
      const templateId = itemPool[Math.floor(Math.random() * itemPool.length)];
      const item = { ...ITEM_TEMPLATES[templateId], id: uuidv4(), x: pos.x, y: pos.y };
      if (!item.char) {
        item.char = item.type === 'weapon' ? '/' : item.type === 'armor' ? '[' : '!';
      }
      if (!item.color) {
        item.color = item.type === 'weapon' ? '#aaa' : item.type === 'armor' ? '#88f' : '#dd0';
      }
      items.push(item);
    }

    if (Math.random() < 0.4 + floorNum * 0.05) {
      const pos = this._findOpen(tiles, w, h);
      tiles[pos.y][pos.x] = MapGenerator._tile('chest');
    }

    const floor = {
      width: w, height: h, tiles, monsters, items, type: 'nefia',
      stairsUpX: stairsUp.x, stairsUpY: stairsUp.y,
      stairsDownX: stairsDown ? stairsDown.x : null,
      stairsDownY: stairsDown ? stairsDown.y : null
    };

    this.cache[key] = floor;
    return floor;
  }

  _generateDungeonLayout(w, h) {
    const tiles = [];
    for (let y = 0; y < h; y++) {
      const row = [];
      for (let x = 0; x < w; x++) {
        row.push(MapGenerator._tile('wall'));
      }
      tiles.push(row);
    }

    const rooms = [];
    const roomCount = 6 + Math.floor(Math.random() * 5);
    for (let i = 0; i < roomCount; i++) {
      const rw = Math.floor(Math.random() * 8) + 4;
      const rh = Math.floor(Math.random() * 6) + 4;
      const rx = Math.floor(Math.random() * (w - rw - 2)) + 1;
      const ry = Math.floor(Math.random() * (h - rh - 2)) + 1;

      for (let yy = ry; yy < ry + rh; yy++) {
        for (let xx = rx; xx < rx + rw; xx++) {
          tiles[yy][xx] = MapGenerator._tile('floor');
        }
      }
      rooms.push({ x: rx + Math.floor(rw / 2), y: ry + Math.floor(rh / 2) });
    }

    for (let i = 0; i < rooms.length - 1; i++) {
      this._carveCorridor(tiles, rooms[i], rooms[i + 1], w, h);
    }

    return tiles;
  }

  _carveCorridor(tiles, a, b, w, h) {
    let x = a.x, y = a.y;
    while (x !== b.x) {
      if (x > 0 && x < w - 1 && y > 0 && y < h - 1) {
        tiles[y][x] = MapGenerator._tile('floor');
      }
      x += x < b.x ? 1 : -1;
    }
    while (y !== b.y) {
      if (x > 0 && x < w - 1 && y > 0 && y < h - 1) {
        tiles[y][x] = MapGenerator._tile('floor');
      }
      y += y < b.y ? 1 : -1;
    }
  }

  _findOpen(tiles, w, h) {
    for (let tries = 0; tries < 300; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].walkable) return { x, y };
    }
    return { x: 2, y: 2 };
  }

  _findWallNeighboringFloor(tiles, w, h) {
    for (let tries = 0; tries < 300; tries++) {
      const x = Math.floor(Math.random() * (w - 2)) + 1;
      const y = Math.floor(Math.random() * (h - 2)) + 1;
      if (tiles[y][x].type !== 'wall') continue;
      // Check if at least one neighbor is walkable
      const dirs = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];
      const hasFloor = dirs.some(d => {
        const nx = x + d.dx, ny = y + d.dy;
        return nx > 0 && ny > 0 && nx < w - 1 && ny < h - 1 && tiles[ny][nx].walkable;
      });
      if (hasFloor) return { x, y };
    }
    return null;
  }

  _pickBoss(danger) {
    const allMonsters = Object.values(MONSTER_TEMPLATES);
    const eligible = allMonsters.filter(m => m.level <= danger + 5);
    if (eligible.length === 0) return allMonsters[allMonsters.length - 1];
    return eligible[eligible.length - 1];
  }
}

</script>
  <script>
// ============================================================
// MagicSystem â€” Spells, spellbooks, casting (browser)
// ============================================================

class MagicSystem {
  static initSpells(player) {
    if (!player.spells) player.spells = {};
    if (!player.buffs) player.buffs = [];
  }

  static readSpellbook(player, book) {
    if (!book || book.type !== 'spellbook') {
      return { success: false, consumed: false, message: 'That is not a spellbook.' };
    }
    MagicSystem.initSpells(player);

    const spellDef = SPELL_DEFS[book.spellId];
    if (!spellDef) {
      return { success: false, consumed: false, message: 'The spellbook is indecipherable.' };
    }

    const literacy = player.skills.literacy || 0;
    const memorization = player.skills.memorization || 0;
    const difficulty = book.difficulty || spellDef.difficulty || 1;

    const successChance = Math.min(95, Math.max(10,
      50 + literacy * 3 + memorization * 2 - difficulty * 5
    ));
    const roll = Math.random() * 100;

    if (roll > successChance) {
      const destroyChance = 30 + difficulty * 3 - literacy;
      const destroyed = Math.random() * 100 < destroyChance;

      CharacterSystem.gainSkillExp(player, 'literacy', 5);

      if (destroyed) {
        return {
          success: false,
          consumed: true,
          message: `You fail to comprehend the ${book.name}. It crumbles to dust!`
        };
      }
      return {
        success: false,
        consumed: false,
        message: `You fail to understand the ${book.name}. (${Math.floor(successChance)}% chance)`
      };
    }

    const stockGain = book.charges || 3;
    if (!player.spells[book.spellId]) {
      player.spells[book.spellId] = { stock: 0, skillLevel: 1 };
    }
    player.spells[book.spellId].stock += stockGain;

    CharacterSystem.gainSkillExp(player, 'literacy', 10 + difficulty * 2);
    CharacterSystem.gainSkillExp(player, 'memorization', 8 + difficulty * 2);

    return {
      success: true,
      consumed: true,
      message: `You memorize ${spellDef.name} from the ${book.name}! Stock +${stockGain} (total: ${player.spells[book.spellId].stock})`
    };
  }

  static castSpell(player, spellId, context) {
    MagicSystem.initSpells(player);

    const spellDef = SPELL_DEFS[spellId];
    if (!spellDef) return { success: false, message: 'Unknown spell.' };

    const spellData = player.spells[spellId];
    if (!spellData || spellData.stock <= 0) {
      return { success: false, message: `You have no stock of ${spellDef.name}.` };
    }

    const castingSkill = player.skills.casting || 0;
    const controlMagic = player.skills.controlMagic || 0;
    const manaCost = Math.max(1, Math.floor(
      spellDef.baseCost * (1 - castingSkill * 0.02 - controlMagic * 0.01)
    ));

    if (player.mp < manaCost) {
      const overflow = manaCost - player.mp;
      player.mp = 0;
      player.hp -= overflow;
      if (player.race && player.race.id === 'eulderna') {
        player.hp += Math.floor(overflow * 0.3);
      }
    } else {
      player.mp -= manaCost;
    }

    spellData.stock--;

    const govAttr = player.attributes[spellDef.attr] || 10;
    const spellSkillLevel = spellData.skillLevel || 1;
    let power = spellDef.basePower + CombatSystem.rollDice(spellDef.dice || '1d4');
    power = Math.floor(power * (1 + govAttr * 0.03 + spellSkillLevel * 0.05 + castingSkill * 0.02));

    if (player.domains && player.domains.includes(spellDef.domain)) {
      power = Math.floor(power * 1.2);
    }

    CharacterSystem.gainSkillExp(player, 'casting', 5 + spellDef.difficulty);
    CharacterSystem.gainSkillExp(player, 'controlMagic', 3);

    if (!player._spellExp) player._spellExp = {};
    player._spellExp[spellId] = (player._spellExp[spellId] || 0) + 10 + spellDef.difficulty;
    const needed = spellData.skillLevel * 40 + 30;
    if (player._spellExp[spellId] >= needed) {
      player._spellExp[spellId] -= needed;
      spellData.skillLevel++;
    }

    const result = {
      success: true,
      spellId,
      spellName: spellDef.name,
      type: spellDef.type,
      manaCost,
      power,
      domain: spellDef.domain,
      message: ''
    };

    switch (spellDef.type) {
      case 'bolt':
        result.damage = power;
        result.range = spellDef.range || 5;
        result.message = `You cast ${spellDef.name}! (${power} dmg, cost ${manaCost} MP, stock ${spellData.stock})`;
        break;

      case 'ball':
        result.damage = power;
        result.range = spellDef.range || 4;
        result.radius = spellDef.radius || 2;
        result.message = `You cast ${spellDef.name}! (${power} dmg, radius ${result.radius}, cost ${manaCost} MP, stock ${spellData.stock})`;
        break;

      case 'heal': {
        const healAmt = power;
        player.hp = Math.min(player.maxHp, player.hp + healAmt);
        result.heal = healAmt;
        result.message = `You cast ${spellDef.name}! HP +${healAmt} (cost ${manaCost} MP, stock ${spellData.stock})`;
        break;
      }

      case 'buff': {
        const duration = spellDef.duration || 15;
        const scaledDuration = duration + Math.floor(spellSkillLevel * 2);
        if (!player.buffs) player.buffs = [];
        player.buffs = player.buffs.filter(b => b.type !== spellDef.buffType);
        player.buffs.push({
          type: spellDef.buffType,
          name: spellDef.name,
          turnsLeft: scaledDuration,
          power: Math.floor(power * 0.3)
        });
        result.buff = { type: spellDef.buffType, duration: scaledDuration };
        result.message = `You cast ${spellDef.name}! Effect for ${scaledDuration} turns. (cost ${manaCost} MP, stock ${spellData.stock})`;
        break;
      }

      case 'teleport':
        result.teleport = true;
        result.message = `You cast ${spellDef.name}! (cost ${manaCost} MP, stock ${spellData.stock})`;
        break;

      default:
        result.message = `You cast ${spellDef.name}! (cost ${manaCost} MP)`;
    }

    return result;
  }

  static applyBoltToTarget(target, damage) {
    if (!target || target.hp <= 0) return { hit: false, message: 'The spell dissipates.' };
    const actualDmg = Math.max(1, damage);
    target.hp -= actualDmg;
    return {
      hit: true,
      damage: actualDmg,
      killed: target.hp <= 0,
      message: `The spell hits ${target.name} for ${actualDmg} damage!${target.hp <= 0 ? ` ${target.name} is destroyed!` : ''}`
    };
  }

  static applyBallToArea(monsters, cx, cy, radius, damage) {
    const hits = [];
    for (const m of monsters) {
      if (m.hp <= 0) continue;
      const dist = Math.abs(m.x - cx) + Math.abs(m.y - cy);
      if (dist <= radius) {
        const falloff = dist === 0 ? 1.0 : (1 - dist / (radius + 1) * 0.3);
        const dmg = Math.max(1, Math.floor(damage * falloff));
        m.hp -= dmg;
        hits.push({
          name: m.name,
          damage: dmg,
          killed: m.hp <= 0
        });
      }
    }
    return hits;
  }

  static findBoltTarget(player, monsters, dx, dy, range) {
    let best = null;
    let bestDist = Infinity;

    for (const m of monsters) {
      if (m.hp <= 0) continue;
      const mdx = m.x - player.x;
      const mdy = m.y - player.y;
      const dist = Math.abs(mdx) + Math.abs(mdy);
      if (dist > range) continue;

      if (dx !== 0 || dy !== 0) {
        if (dx !== 0 && Math.sign(mdx) !== dx) continue;
        if (dy !== 0 && Math.sign(mdy) !== dy) continue;
      }

      if (dist < bestDist) {
        bestDist = dist;
        best = m;
      }
    }
    return best;
  }

  static findNearestMonster(player, monsters, range) {
    let best = null;
    let bestDist = Infinity;
    for (const m of monsters) {
      if (m.hp <= 0) continue;
      const dist = Math.abs(m.x - player.x) + Math.abs(m.y - player.y);
      if (dist <= range && dist < bestDist) {
        bestDist = dist;
        best = m;
      }
    }
    return best;
  }

  static tickBuffs(player) {
    if (!player.buffs) return;
    player.buffs.forEach(b => b.turnsLeft--);
    const expired = player.buffs.filter(b => b.turnsLeft <= 0);
    player.buffs = player.buffs.filter(b => b.turnsLeft > 0);
    return expired;
  }

  static getBuffBonuses(player) {
    const bonuses = { dv: 0, pv: 0, speed: 0 };
    if (!player.buffs) return bonuses;
    for (const b of player.buffs) {
      switch (b.type) {
        case 'holyVeil':
          bonuses.pv += b.power;
          break;
        case 'mistSilence':
          bonuses.dv += b.power;
          break;
        case 'speed':
          bonuses.speed += b.power;
          break;
      }
    }
    return bonuses;
  }

  static getSpellList(player) {
    if (!player.spells) return [];
    return Object.entries(player.spells).map(([id, data]) => {
      const def = SPELL_DEFS[id];
      if (!def) return null;
      const castingSkill = player.skills.casting || 0;
      const controlMagic = player.skills.controlMagic || 0;
      const manaCost = Math.max(1, Math.floor(
        def.baseCost * (1 - castingSkill * 0.02 - controlMagic * 0.01)
      ));
      return {
        id,
        name: def.name,
        type: def.type,
        domain: def.domain,
        description: def.description,
        stock: data.stock,
        skillLevel: data.skillLevel,
        manaCost,
        char: def.char,
        color: def.color
      };
    }).filter(Boolean);
  }
}

</script>
  <script>
// ============================================================
// FarmingSystem â€” Planting, growing, and harvesting (browser)
// ============================================================

class FarmingSystem {
  static plantSeed(player, seedItem, tile, season) {
    if (!seedItem || seedItem.type !== 'seed') {
      return { success: false, consumed: false, message: 'That is not a seed.' };
    }

    const cropDef = CROP_DEFS[seedItem.cropId];
    if (!cropDef) {
      return { success: false, consumed: false, message: 'Unknown crop type.' };
    }

    if (tile.type !== 'grass' && tile.type !== 'farmSoil') {
      return { success: false, consumed: false, message: 'You can only plant on grass or tilled soil.' };
    }

    if (tile.crop) {
      return { success: false, consumed: false, message: 'Something is already growing here.' };
    }

    const inSeason = cropDef.seasons.includes(season);
    const farmingSkill = player.skills.farming || 0;

    const successChance = Math.min(98, 60 + farmingSkill * 3 - cropDef.difficulty * 5);
    if (Math.random() * 100 > successChance) {
      CharacterSystem.gainSkillExp(player, 'farming', 3);
      return {
        success: false,
        consumed: true,
        message: `You fumble with the ${seedItem.name} and waste them. (${Math.floor(successChance)}% chance)`
      };
    }

    tile.crop = {
      id: uuidv4(),
      cropId: cropDef.id,
      stage: 0,
      growth: 0,
      growthNeeded: cropDef.growthTime,
      inSeason,
      plantedTurn: 0,
      quality: Math.floor(50 + farmingSkill * 2 + (inSeason ? 20 : -10))
    };

    if (tile.type === 'grass') {
      tile.type = 'farmSoil';
      tile.char = 'â‰ˆ';
      tile.color = '#654';
    }

    CharacterSystem.gainSkillExp(player, 'farming', 5 + cropDef.difficulty);

    const seasonMsg = inSeason ? '' : ' (Out of season â€” growth will be slow!)';
    return {
      success: true,
      consumed: true,
      message: `You plant ${cropDef.name} seeds.${seasonMsg}`
    };
  }

  static harvestCrop(player, tile) {
    if (!tile.crop) {
      return { success: false, message: 'Nothing to harvest here.' };
    }

    const crop = tile.crop;
    const cropDef = CROP_DEFS[crop.cropId];
    if (!cropDef) {
      tile.crop = null;
      return { success: false, message: 'The crop has withered away.' };
    }

    if (crop.stage < cropDef.stages) {
      const stageNames = ['Seed', 'Sprout', 'Growing', 'Mature', 'Harvestable'];
      return {
        success: false,
        message: `The ${cropDef.name} is still ${stageNames[crop.stage] || 'growing'}. (${Math.floor(crop.growth / crop.growthNeeded * 100)}% grown)`
      };
    }

    const farmingSkill = player.skills.farming || 0;
    const qualityBonus = Math.floor(crop.quality / 25);
    const yieldCount = cropDef.baseYield + Math.floor(farmingSkill / 10) + (Math.random() < 0.3 ? 1 : 0);

    const items = [];
    const harvestTemplate = ITEM_TEMPLATES[cropDef.harvestId];
    if (harvestTemplate) {
      for (let i = 0; i < yieldCount; i++) {
        const item = {
          ...harvestTemplate,
          id: uuidv4(),
          char: harvestTemplate.char || cropDef.chars[cropDef.stages] || 'â—',
          color: harvestTemplate.color || cropDef.colors[cropDef.stages] || '#4a4'
        };
        if (item.nutrition) {
          item.nutrition = Math.floor(item.nutrition * (1 + qualityBonus * 0.1));
        }
        if (item.healHP) {
          item.healHP = Math.floor(item.healHP * (1 + qualityBonus * 0.1));
        }
        items.push(item);
      }
    }

    if (Math.random() < 0.3 + farmingSkill * 0.01) {
      const seedTemplate = ITEM_TEMPLATES[cropDef.seedId];
      if (seedTemplate) {
        items.push({
          ...seedTemplate,
          id: uuidv4()
        });
      }
    }

    tile.crop = null;
    tile.char = 'â‰ˆ';
    tile.color = '#654';

    CharacterSystem.gainSkillExp(player, 'farming', 10 + cropDef.difficulty * 3);

    return {
      success: true,
      message: `You harvest ${yieldCount} ${cropDef.name}!`,
      items
    };
  }

  static tickCrops(map, season, weather) {
    if (!map || !map.tiles) return [];
    const messages = [];

    for (let y = 0; y < map.height; y++) {
      for (let x = 0; x < map.width; x++) {
        const tile = map.tiles[y][x];
        if (!tile.crop) continue;

        const crop = tile.crop;
        const cropDef = CROP_DEFS[crop.cropId];
        if (!cropDef) continue;

        if (crop.stage >= cropDef.stages) continue;

        let growthRate = 1;

        crop.inSeason = cropDef.seasons.includes(season);
        if (crop.inSeason) {
          growthRate *= 1.5;
        } else {
          growthRate *= 0.4;
        }

        if (weather === 'rain' || weather === 'heavyRain') {
          growthRate *= 1.5;
        } else if (weather === 'snow' || weather === 'heavySnow') {
          growthRate *= 0.2;
        } else if (weather === 'sunny') {
          growthRate *= 1.2;
        }

        if (season === 'winter' && !crop.inSeason && Math.random() < 0.005) {
          tile.crop = null;
          tile.char = 'â‰ˆ';
          tile.color = '#654';
          messages.push({ x, y, text: `A ${cropDef.name} plant has withered in the cold!` });
          continue;
        }

        crop.growth += growthRate;

        const stageThreshold = crop.growthNeeded / cropDef.stages;
        const newStage = Math.min(cropDef.stages, Math.floor(crop.growth / stageThreshold));

        if (newStage > crop.stage) {
          crop.stage = newStage;

          if (cropDef.chars[crop.stage]) {
            tile.char = cropDef.chars[crop.stage];
          }
          if (cropDef.colors[crop.stage]) {
            tile.color = cropDef.colors[crop.stage];
          }

          if (crop.stage >= cropDef.stages) {
            messages.push({ x, y, text: `Your ${cropDef.name} is ready to harvest!` });
          }
        }
      }
    }

    return messages;
  }

  static getCropInfo(tile) {
    if (!tile || !tile.crop) return null;
    const crop = tile.crop;
    const cropDef = CROP_DEFS[crop.cropId];
    if (!cropDef) return null;

    const stageNames = ['Seed', 'Sprout', 'Growing', 'Mature', 'Harvestable'];
    const progress = Math.min(100, Math.floor(crop.growth / crop.growthNeeded * 100));

    return {
      name: cropDef.name,
      stage: crop.stage,
      stageName: stageNames[crop.stage] || 'Unknown',
      progress,
      inSeason: crop.inSeason,
      quality: crop.quality,
      harvestable: crop.stage >= cropDef.stages
    };
  }
}

</script>
  <script>
// ============================================================
// ShopSystem â€” NPC shops: buying, selling, restocking (browser)
// ============================================================

class ShopSystem {
  static generateTownShops(location) {
    const shops = [];
    const townShopMap = {
      stonehaven: ['generalStore', 'blacksmith'],
      millfield: ['generalStore', 'farmSupply'],
      crownhold: ['generalStore', 'blacksmith', 'magicShop', 'tavern'],
      duskmarket: ['generalStore', 'tavern'],
      tidereach: ['generalStore', 'blacksmith', 'tavern'],
      archgate: ['magicShop', 'generalStore'],
      frostbell: ['generalStore', 'tavern'],
      homestead: []
    };

    const shopIds = townShopMap[location.id] || ['generalStore'];
    shopIds.forEach(shopId => {
      const def = SHOP_DEFS[shopId];
      if (!def) return;
      const inventory = def.inventory.map(slot => ({
        itemId: slot.itemId,
        stock: slot.stock,
        maxStock: slot.stock,
        restockRate: slot.restockRate
      }));
      shops.push({
        id: uuidv4(),
        shopDefId: shopId,
        name: def.name,
        npcName: def.npcName,
        char: def.char,
        color: def.color,
        buyMarkup: def.buyMarkup,
        sellMarkdown: def.sellMarkdown,
        inventory,
        x: 0, y: 0
      });
    });
    return shops;
  }

  static getShopDisplay(shop) {
    if (!shop) return null;
    return {
      id: shop.id,
      name: shop.name,
      npcName: shop.npcName,
      char: shop.char,
      color: shop.color,
      items: shop.inventory.map(slot => {
        const template = ITEM_TEMPLATES[slot.itemId];
        if (!template) return null;
        const buyPrice = Math.ceil(template.value * shop.buyMarkup);
        return {
          itemId: slot.itemId,
          id: template.id,
          name: template.name,
          type: template.type,
          subtype: template.subtype || '',
          slot: template.slot || '',
          char: template.char || '?',
          color: template.color || '#ccc',
          healMP: template.healMP || 0,
          buyPrice,
          stock: slot.stock,
          value: template.value
        };
      }).filter(Boolean)
    };
  }

  static buyItem(player, shop, itemId) {
    if (!shop || !player) return { success: false, message: 'No shop available.' };

    const slot = shop.inventory.find(s => s.itemId === itemId);
    if (!slot || slot.stock <= 0) {
      return { success: false, message: 'That item is out of stock.' };
    }

    const template = ITEM_TEMPLATES[itemId];
    if (!template) return { success: false, message: 'Unknown item.' };

    const price = Math.ceil(template.value * shop.buyMarkup);

    const negotiation = player.skills ? (player.skills.negotiation || 0) : 0;
    const discount = Math.floor(price * negotiation * 0.02);
    const finalPrice = Math.max(1, price - discount);

    if (player.gold < finalPrice) {
      return { success: false, message: `Not enough gold. Need ${finalPrice}gp, have ${player.gold}gp.` };
    }

    player.gold -= finalPrice;
    slot.stock--;

    const item = { ...template, id: uuidv4(), templateId: itemId, quantity: 1 };
    ItemSystem.addToInventory(player, item);

    if (player.skills) {
      CharacterSystem.gainSkillExp(player, 'negotiation', 3);
    }

    return {
      success: true,
      message: `Bought ${template.name} for ${finalPrice}gp.${discount > 0 ? ` (Saved ${discount}gp!)` : ''}`,
      price: finalPrice
    };
  }

  static sellItem(player, shop, itemIndex) {
    if (!shop || !player) return { success: false, message: 'No shop available.' };

    if (itemIndex < 0 || itemIndex >= player.inventory.length) {
      return { success: false, message: 'Invalid item.' };
    }

    const item = player.inventory[itemIndex];
    if (!item) return { success: false, message: 'No item selected.' };

    if (player.equipment) {
      const equipped = Object.values(player.equipment).some(e => e && e.id === item.id);
      if (equipped) return { success: false, message: 'Unequip the item first.' };
    }

    const baseValue = item.value || 1;
    const sellPrice = Math.max(1, Math.floor(baseValue * shop.sellMarkdown));

    const negotiation = player.skills ? (player.skills.negotiation || 0) : 0;
    const bonus = Math.floor(sellPrice * negotiation * 0.02);
    const finalPrice = sellPrice + bonus;

    player.gold += finalPrice;
    ItemSystem.removeFromInventory(player, itemIndex, 1);

    if (player.skills) {
      CharacterSystem.gainSkillExp(player, 'negotiation', 2);
    }

    return {
      success: true,
      message: `Sold ${item.name} for ${finalPrice}gp.${bonus > 0 ? ` (Bonus +${bonus}gp!)` : ''}`,
      price: finalPrice
    };
  }

  static restockShops(shops) {
    if (!shops) return;
    shops.forEach(shop => {
      shop.inventory.forEach(slot => {
        if (slot.stock < slot.maxStock && slot.restockRate > 0) {
          slot.stock = Math.min(slot.maxStock, slot.stock + slot.restockRate);
        }
      });
    });
  }
}

</script>
  <script>
// ============================================================
// CraftingSystem â€” Workshop-based crafting with recipe learning
// ============================================================

class CraftingSystem {

  // â”€â”€ Workshop detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getNearbyWorkshops(player, map) {
    const workshops = new Set();
    if (!map || !map.tiles) return workshops;
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const tx = player.x + dx;
        const ty = player.y + dy;
        if (ty >= 0 && ty < map.height && tx >= 0 && tx < map.width) {
          const tile = map.tiles[ty][tx];
          if (tile && tile.workshop) {
            workshops.add(tile.workshop.workshopType);
          }
        }
      }
    }
    return workshops;
  }

  // â”€â”€ Recipe Knowledge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static initRecipes(player) {
    if (!player.knownRecipes) {
      player.knownRecipes = [];
      Object.values(RECIPE_DEFS).forEach(r => {
        if (r.defaultKnown) player.knownRecipes.push(r.id);
      });
    }
  }

  static knowsRecipe(player, recipeId) {
    CraftingSystem.initRecipes(player);
    return player.knownRecipes.includes(recipeId);
  }

  static learnRecipe(player, recipeId) {
    CraftingSystem.initRecipes(player);
    if (!player.knownRecipes.includes(recipeId)) {
      player.knownRecipes.push(recipeId);
      return true;
    }
    return false;
  }

  // â”€â”€ Recipe Learning: Dreaming (sleep) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static tryLearnRecipeFromSleep(player) {
    CraftingSystem.initRecipes(player);
    // 25% base chance to dream of a recipe
    if (Math.random() > 0.25) return null;

    const candidates = Object.values(RECIPE_DEFS).filter(r => {
      if (player.knownRecipes.includes(r.id)) return false;
      if (r.defaultKnown) return false;
      const skillLevel = player.skills ? (player.skills[r.skill] || 0) : 0;
      return skillLevel >= r.skillReq;
    });
    if (candidates.length === 0) return null;

    // Weighted random: lower-level recipes more likely
    candidates.sort((a, b) => a.level - b.level);
    const weights = candidates.map((r, i) => Math.max(1, candidates.length - i));
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let roll = Math.random() * totalWeight;
    let picked = candidates[0];
    for (let i = 0; i < candidates.length; i++) {
      roll -= weights[i];
      if (roll <= 0) { picked = candidates[i]; break; }
    }

    CraftingSystem.learnRecipe(player, picked.id);
    return picked;
  }

  // â”€â”€ Recipe Learning: Skill Practice â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static tryLearnRecipeFromSkill(player, skillId) {
    CraftingSystem.initRecipes(player);
    // ~3% + perception bonus chance
    const luckBonus = ((player.attributes && player.attributes.PER) || 10) * 0.002;
    if (Math.random() > 0.03 + luckBonus) return null;

    const skillLevel = player.skills ? (player.skills[skillId] || 0) : 0;
    const candidates = Object.values(RECIPE_DEFS).filter(r => {
      if (player.knownRecipes.includes(r.id)) return false;
      if (r.defaultKnown) return false;
      if (r.skill !== skillId) return false;
      return skillLevel >= r.skillReq;
    });
    if (candidates.length === 0) return null;

    const picked = candidates[Math.floor(Math.random() * candidates.length)];
    CraftingSystem.learnRecipe(player, picked.id);
    return picked;
  }

  // â”€â”€ Recipe Learning: Recipe Paper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static readRecipePaper(player, recipeId) {
    const recipe = RECIPE_DEFS[recipeId];
    if (!recipe) return { success: false, message: 'The recipe paper is illegible.' };
    if (CraftingSystem.knowsRecipe(player, recipeId)) {
      return { success: false, message: `You already know how to make: ${recipe.name}.`, consumed: false };
    }
    CraftingSystem.learnRecipe(player, recipeId);
    return { success: true, message: `You study the recipe paper and learn: ${recipe.name}!`, consumed: true };
  }

  // â”€â”€ Get Available Recipes for UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getAvailableRecipes(player, nearbyWorkshops) {
    if (!player) return [];
    CraftingSystem.initRecipes(player);
    const workshops = nearbyWorkshops || new Set();

    return Object.values(RECIPE_DEFS).map(recipe => {
      const known = player.knownRecipes.includes(recipe.id);
      if (!known) return null;

      const skillLevel = player.skills ? (player.skills[recipe.skill] || 0) : 0;
      const meetsSkill = skillLevel >= recipe.skillReq;

      const workshopNeeded = recipe.workshop || null;
      const hasWorkshop = !workshopNeeded || workshops.has(workshopNeeded);

      const ingredients = recipe.ingredients.map(ing => {
        const template = ITEM_TEMPLATES[ing.itemId];
        const haveCount = CraftingSystem._countItem(player, ing.itemId);
        return {
          itemId: ing.itemId,
          name: template ? template.name : ing.itemId,
          needed: ing.count,
          have: haveCount,
          enough: haveCount >= ing.count
        };
      });

      const resultTemplate = ITEM_TEMPLATES[recipe.result.itemId];
      const canCraft = meetsSkill && hasWorkshop && ingredients.every(i => i.enough);

      const successChance = Math.min(95, Math.max(10,
        50 + skillLevel * 5 - recipe.difficulty * 5
      ));

      let workshopName = null;
      if (workshopNeeded) {
        const wsItem = Object.values(ITEM_TEMPLATES).find(t => t.workshopType === workshopNeeded);
        workshopName = wsItem ? wsItem.name : workshopNeeded;
      }

      return {
        id: recipe.id,
        name: recipe.name,
        skill: recipe.skill,
        skillReq: recipe.skillReq,
        level: recipe.level || recipe.skillReq,
        difficulty: recipe.difficulty,
        meetsSkill,
        hasWorkshop,
        workshopNeeded,
        workshopName,
        canCraft,
        successChance,
        ingredients,
        resultName: resultTemplate ? resultTemplate.name : 'Unknown',
        resultCount: recipe.result.count
      };
    }).filter(r => r !== null);
  }

  static _countItem(player, templateId) {
    if (!player || !player.inventory) return 0;
    const template = ITEM_TEMPLATES[templateId];
    if (!template) return 0;
    let total = 0;
    player.inventory.forEach(i => {
      if ((i.templateId === templateId) || (i.id === templateId) ||
          (i.name === template.name && i.type === template.type)) {
        total += (i.quantity || 1);
      }
    });
    return total;
  }

  static _removeItems(player, templateId, count) {
    const template = ITEM_TEMPLATES[templateId];
    if (!template) return false;
    let removed = 0;
    for (let i = player.inventory.length - 1; i >= 0 && removed < count; i--) {
      const item = player.inventory[i];
      if (item.name === template.name && item.type === template.type) {
        const isEquipped = player.equipment && Object.values(player.equipment).some(
          e => e && e.id === item.id
        );
        if (!isEquipped) {
          const qty = item.quantity || 1;
          const toRemove = Math.min(qty, count - removed);
          ItemSystem.removeFromInventory(player, i, toRemove);
          removed += toRemove;
        }
      }
    }
    return removed >= count;
  }

  static craft(player, recipeId, nearbyWorkshops) {
    const recipe = RECIPE_DEFS[recipeId];
    if (!recipe) return { success: false, message: 'Unknown recipe.' };

    CraftingSystem.initRecipes(player);
    if (!player.knownRecipes.includes(recipeId)) {
      return { success: false, message: "You don't know this recipe." };
    }

    const skillLevel = player.skills ? (player.skills[recipe.skill] || 0) : 0;
    if (skillLevel < recipe.skillReq) {
      return {
        success: false,
        message: `Your ${recipe.skill} skill is too low. Need level ${recipe.skillReq}, have ${skillLevel}.`
      };
    }

    const workshopNeeded = recipe.workshop || null;
    const workshops = nearbyWorkshops || new Set();
    if (workshopNeeded && !workshops.has(workshopNeeded)) {
      const wsItem = Object.values(ITEM_TEMPLATES).find(t => t.workshopType === workshopNeeded);
      const wsName = wsItem ? wsItem.name : workshopNeeded;
      return { success: false, message: `You need to be near a ${wsName} to craft this.` };
    }

    for (const ing of recipe.ingredients) {
      const have = CraftingSystem._countItem(player, ing.itemId);
      const template = ITEM_TEMPLATES[ing.itemId];
      if (have < ing.count) {
        return {
          success: false,
          message: `Not enough ${template ? template.name : ing.itemId}. Need ${ing.count}, have ${have}.`
        };
      }
    }

    for (const ing of recipe.ingredients) {
      CraftingSystem._removeItems(player, ing.itemId, ing.count);
    }

    const successChance = Math.min(95, Math.max(10,
      50 + skillLevel * 5 - recipe.difficulty * 5
    ));
    const roll = Math.random() * 100;

    CharacterSystem.gainSkillExp(player, recipe.skill, recipe.xpGain || 10);

    if (roll > successChance) {
      return {
        success: false,
        consumed: true,
        message: `You failed to craft ${recipe.name}! Materials lost. (${Math.floor(successChance)}% chance)`
      };
    }

    const resultTemplate = ITEM_TEMPLATES[recipe.result.itemId];
    if (!resultTemplate) {
      return { success: false, message: 'Recipe result item not found!' };
    }

    const createdItems = [];
    for (let i = 0; i < recipe.result.count; i++) {
      const item = ItemSystem.createItem(recipe.result.itemId);
      if (item) {
        ItemSystem.addToInventory(player, item);
        createdItems.push(item.name);
      }
    }

    return {
      success: true,
      message: `Successfully crafted ${createdItems.join(', ')}! (${recipe.skill} +exp)`,
      items: createdItems
    };
  }

  // â”€â”€ Create Recipe Paper Item â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static createRecipePaper(recipeId) {
    const recipe = RECIPE_DEFS[recipeId];
    if (!recipe) return null;
    const paper = ItemSystem.createItem('recipePaper');
    if (!paper) return null;
    paper.recipeId = recipeId;
    paper.name = `Recipe: ${recipe.name}`;
    return paper;
  }

  // â”€â”€ Generate random recipe paper for monster drops â”€â”€
  static generateRandomRecipePaper(monsterLevel) {
    const candidates = Object.values(RECIPE_DEFS).filter(r => {
      if (r.defaultKnown) return false;
      return r.level <= Math.max(3, monsterLevel + 2);
    });
    if (candidates.length === 0) return null;
    const picked = candidates[Math.floor(Math.random() * candidates.length)];
    return CraftingSystem.createRecipePaper(picked.id);
  }
}

</script>
  <script>
// ============================================================
// QuestSystem â€” Quest generation, tracking, completion (browser)
// ============================================================

class QuestSystem {
  // â”€â”€ Generate quests for a town's quest board â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static generateBoardQuests(townId, playerLevel) {
    if (!QUEST_DEFS || !QUEST_DEFS.boards) return [];
    const boardDef = QUEST_DEFS.boards[townId];
    if (!boardDef) return [];

    const quests = [];
    const maxQ = boardDef.maxQuests || 3;
    const [minDanger, maxDanger] = boardDef.dangerRange || [1, 10];
    const [minLevel, maxLevel] = boardDef.levelRange || [1, 10];

    // Effective level for scaling (clamped to board range)
    const effLevel = Math.max(minLevel, Math.min(maxLevel, playerLevel));

    const questTypes = ['hunt', 'bounty', 'delivery', 'gather', 'explore'];

    for (let i = 0; i < maxQ; i++) {
      const type = questTypes[Math.floor(Math.random() * questTypes.length)];
      const quest = QuestSystem._generateQuest(type, townId, effLevel, minDanger, maxDanger);
      if (quest) quests.push(quest);
    }

    return quests;
  }

  static _generateQuest(type, townId, level, minDanger, maxDanger) {
    const typeDef = QUEST_DEFS.types[type];
    if (!typeDef) return null;

    const danger = Math.floor(minDanger + Math.random() * (maxDanger - minDanger + 1));
    const rewards = QUEST_DEFS.rewards;
    const goldReward = Math.floor(rewards.goldPerDanger * danger * (0.8 + Math.random() * 0.4));
    const xpReward = Math.floor(rewards.xpPerDanger * danger * (0.8 + Math.random() * 0.4));
    const fameReward = rewards.famePerQuest + Math.floor(danger / 3);
    const karmaReward = rewards.karmaPerQuest;

    // Bonus item reward
    let bonusItem = null;
    if (Math.random() < rewards.bonusItemChance) {
      const items = QUEST_DEFS.bonusItems;
      bonusItem = items[Math.floor(Math.random() * items.length)];
    }

    const flavorTexts = QUEST_DEFS.flavorText[type] || ['Complete this task.'];
    const flavor = flavorTexts[Math.floor(Math.random() * flavorTexts.length)];

    const base = {
      id: uuidv4(),
      type,
      typeName: typeDef.name,
      icon: typeDef.icon,
      color: typeDef.color,
      townId,
      danger,
      flavor,
      goldReward,
      xpReward,
      fameReward,
      karmaReward,
      bonusItem,
      accepted: false,
      completed: false,
      failed: false,
      turnAccepted: 0,
      progress: 0
    };

    switch (type) {
      case 'hunt':
        return QuestSystem._buildHuntQuest(base, danger);
      case 'bounty':
        return QuestSystem._buildBountyQuest(base, danger);
      case 'delivery':
        return QuestSystem._buildDeliveryQuest(base, townId);
      case 'gather':
        return QuestSystem._buildGatherQuest(base, danger);
      case 'explore':
        return QuestSystem._buildExploreQuest(base, danger);
      default:
        return null;
    }
  }

  static _buildHuntQuest(base, danger) {
    // Pick a monster appropriate for danger
    const eligible = [];
    if (MONSTER_TIERS) {
      MONSTER_TIERS.forEach(tier => {
        if (danger >= tier.minDanger && danger <= tier.maxDanger) {
          tier.monsters.forEach(mId => eligible.push(mId));
        }
      });
    }
    if (eligible.length === 0) eligible.push('putit');
    const monsterId = eligible[Math.floor(Math.random() * eligible.length)];
    const monsterDef = MONSTER_TEMPLATES[monsterId];
    const monsterName = monsterDef ? monsterDef.name : monsterId;
    const count = 3 + Math.floor(Math.random() * 5); // 3-7

    return {
      ...base,
      name: `Hunt: ${count} ${monsterName}s`,
      description: `${base.flavor} Slay ${count} ${monsterName}s and report back.`,
      targetMonsterId: monsterId,
      targetMonsterName: monsterName,
      targetCount: count,
      progress: 0
    };
  }

  static _buildBountyQuest(base, danger) {
    // Pick a strong monster for the danger level
    const eligible = [];
    if (MONSTER_TIERS) {
      MONSTER_TIERS.forEach(tier => {
        if (danger >= tier.minDanger - 2 && danger <= tier.maxDanger) {
          tier.monsters.forEach(mId => eligible.push(mId));
        }
      });
    }
    if (eligible.length === 0) eligible.push('goblin');
    // Pick the strongest
    const monsterId = eligible[eligible.length - 1];
    const monsterDef = MONSTER_TEMPLATES[monsterId];
    const monsterName = monsterDef ? monsterDef.name : monsterId;

    // Bounty gives 2x gold
    base.goldReward = Math.floor(base.goldReward * 2);

    return {
      ...base,
      name: `Bounty: â˜… ${monsterName}`,
      description: `${base.flavor} Slay a â˜… ${monsterName} (any boss variant counts).`,
      targetMonsterId: monsterId,
      targetMonsterName: monsterName,
      targetCount: 1,
      progress: 0,
      requireBoss: false // any of this type counts
    };
  }

  static _buildDeliveryQuest(base, fromTownId) {
    // Pick a random destination town (different from origin)
    const towns = Object.values(WORLD_LOCATIONS).filter(
      l => l.type === 'town' && l.id !== fromTownId
    );
    if (towns.length === 0) return null;
    const destTown = towns[Math.floor(Math.random() * towns.length)];

    // Pick a delivery item
    const deliveryItems = QUEST_DEFS.deliveryItems || [];
    const dItem = deliveryItems[Math.floor(Math.random() * deliveryItems.length)] || { id: 'parcel', name: 'Sealed Parcel' };

    return {
      ...base,
      name: `Deliver: ${dItem.name} â†’ ${destTown.name}`,
      description: `${base.flavor} Deliver the ${dItem.name} to ${destTown.name}.`,
      deliveryItem: dItem,
      destinationTownId: destTown.id,
      destinationTownName: destTown.name,
      progress: 0,
      targetCount: 1
    };
  }

  static _buildGatherQuest(base, danger) {
    const targets = QUEST_DEFS.gatherTargets || [];
    if (targets.length === 0) return null;
    const target = targets[Math.floor(Math.random() * targets.length)];
    const countIdx = Math.min(Math.floor(danger / 5), target.counts.length - 1);
    const count = target.counts[countIdx];

    return {
      ...base,
      name: `Gather: ${count} ${target.name}`,
      description: `${base.flavor} Collect ${count} ${target.name} and bring them back.`,
      targetItemId: target.itemId,
      targetItemName: target.name,
      targetCount: count,
      progress: 0
    };
  }

  static _buildExploreQuest(base, danger) {
    // Pick a nefia
    const nefias = Object.values(WORLD_LOCATIONS).filter(l => l.type === 'nefia');
    if (nefias.length === 0) return null;
    const nefia = nefias[Math.floor(Math.random() * nefias.length)];
    const targetFloor = Math.max(2, Math.floor(danger / 2) + 1);

    return {
      ...base,
      name: `Explore: ${nefia.name} Floor ${targetFloor}`,
      description: `${base.flavor} Reach floor ${targetFloor} of ${nefia.name}.`,
      targetNefiaId: nefia.id,
      targetNefiaName: nefia.name,
      targetFloor,
      progress: 0,
      targetCount: targetFloor
    };
  }

  // â”€â”€ Accept a quest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static acceptQuest(player, quest, turn) {
    if (quest.accepted) return { success: false, message: 'Quest already accepted.' };

    // Max 5 active quests
    const activeQuests = (player.quests || []).filter(q => q.accepted && !q.completed && !q.failed);
    if (activeQuests.length >= 5) {
      return { success: false, message: 'You can only have 5 active quests. Complete or abandon one first.' };
    }

    quest.accepted = true;
    quest.turnAccepted = turn;

    // For delivery quests, add the delivery item to inventory
    if (quest.type === 'delivery' && quest.deliveryItem) {
      const dItem = {
        id: uuidv4(),
        templateId: `quest_${quest.deliveryItem.id}`,
        name: quest.deliveryItem.name,
        type: 'quest',
        char: quest.deliveryItem.char || 'âœ‰',
        color: quest.deliveryItem.color || '#ca8',
        value: 0,
        weight: 1,
        quantity: 1,
        questId: quest.id
      };
      ItemSystem.addToInventory(player, dItem);
    }

    if (!player.quests) player.quests = [];
    player.quests.push(quest);

    return { success: true, message: `Quest accepted: ${quest.name}` };
  }

  // â”€â”€ Abandon a quest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static abandonQuest(player, questId) {
    if (!player.quests) return { success: false, message: 'No quests.' };
    const idx = player.quests.findIndex(q => q.id === questId);
    if (idx === -1) return { success: false, message: 'Quest not found.' };

    const quest = player.quests[idx];
    if (quest.completed) return { success: false, message: 'Quest already completed.' };

    // Remove delivery item if any
    if (quest.type === 'delivery') {
      const dIdx = player.inventory.findIndex(i => i.questId === quest.id);
      if (dIdx >= 0) {
        ItemSystem.removeFromInventory(player, dIdx, 1);
      }
    }

    player.quests.splice(idx, 1);
    return { success: true, message: `Quest abandoned: ${quest.name}` };
  }

  // â”€â”€ Notify: monster killed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onMonsterKilled(player, monster) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;

      if (quest.type === 'hunt' && monster.templateId === quest.targetMonsterId) {
        quest.progress = Math.min(quest.progress + 1, quest.targetCount);
        if (quest.progress >= quest.targetCount) {
          messages.push({ text: `Quest ready to turn in: ${quest.name}`, type: 'important' });
        } else {
          messages.push({
            text: `Quest progress: ${quest.name} (${quest.progress}/${quest.targetCount})`,
            type: 'loot'
          });
        }
      }

      if (quest.type === 'bounty' && monster.templateId === quest.targetMonsterId) {
        quest.progress = Math.min(quest.progress + 1, quest.targetCount);
        if (quest.progress >= quest.targetCount) {
          messages.push({ text: `Bounty target slain! Return to ${quest.townId} to claim reward.`, type: 'important' });
        }
      }
    });

    return messages;
  }

  // â”€â”€ Notify: entered a town â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onEnterTown(player, townId) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;

      if (quest.type === 'delivery' && quest.destinationTownId === townId) {
        quest.progress = 1;
        messages.push({ text: `Delivery arrived! Turn in quest: ${quest.name}`, type: 'important' });
      }
    });

    return messages;
  }

  // â”€â”€ Notify: reached nefia floor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onNefiaFloorReached(player, nefiaId, floor) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;

      if (quest.type === 'explore' && quest.targetNefiaId === nefiaId) {
        if (floor >= quest.targetFloor) {
          quest.progress = quest.targetFloor;
          messages.push({ text: `Exploration complete! Return to ${quest.townId} to claim reward.`, type: 'important' });
        } else if (floor > quest.progress) {
          quest.progress = floor;
          messages.push({
            text: `Exploration progress: Floor ${floor}/${quest.targetFloor}`,
            type: 'loot'
          });
        }
      }
    });

    return messages;
  }

  // â”€â”€ Check if quest is ready to turn in â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static isQuestComplete(quest) {
    if (!quest || quest.completed || quest.failed) return false;
    return quest.progress >= quest.targetCount;
  }

  // â”€â”€ Check gather quests against inventory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static checkGatherQuests(player) {
    if (!player.quests) return [];
    const messages = [];

    player.quests.forEach(quest => {
      if (quest.completed || quest.failed || !quest.accepted) return;
      if (quest.type !== 'gather') return;

      const count = QuestSystem._countItem(player, quest.targetItemId);
      const oldProgress = quest.progress;
      quest.progress = Math.min(count, quest.targetCount);

      if (quest.progress >= quest.targetCount && oldProgress < quest.targetCount) {
        messages.push({ text: `You have enough ${quest.targetItemName}! Return to ${quest.townId} to turn in.`, type: 'important' });
      }
    });

    return messages;
  }

  static _countItem(player, itemId) {
    if (!player.inventory) return 0;
    return player.inventory
      .filter(i => i.templateId === itemId)
      .reduce((sum, i) => sum + (i.quantity || 1), 0);
  }

  // â”€â”€ Turn in a quest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static turnInQuest(player, questId, currentTownId) {
    if (!player.quests) return { success: false, message: 'No quests.' };
    const quest = player.quests.find(q => q.id === questId);
    if (!quest) return { success: false, message: 'Quest not found.' };
    if (quest.completed) return { success: false, message: 'Quest already completed.' };

    // Must be in the quest's origin town to turn in
    if (quest.townId !== currentTownId) {
      return { success: false, message: `Return to the quest board in ${quest.townId} to turn in.` };
    }

    // Check if conditions are met
    if (!QuestSystem.isQuestComplete(quest)) {
      return { success: false, message: `Quest not yet complete: ${quest.name}` };
    }

    // For gather quests, consume the items
    if (quest.type === 'gather') {
      let remaining = quest.targetCount;
      for (let i = player.inventory.length - 1; i >= 0 && remaining > 0; i--) {
        if (player.inventory[i].templateId === quest.targetItemId) {
          const qty = player.inventory[i].quantity || 1;
          if (qty <= remaining) {
            remaining -= qty;
            ItemSystem.removeFromInventory(player, i, qty);
          } else {
            player.inventory[i].quantity -= remaining;
            remaining = 0;
          }
        }
      }
    }

    // For delivery quests, remove the delivery item
    if (quest.type === 'delivery') {
      const dIdx = player.inventory.findIndex(i => i.questId === quest.id);
      if (dIdx >= 0) {
        ItemSystem.removeFromInventory(player, dIdx, 1);
      }
    }

    quest.completed = true;

    // Grant rewards
    const rewardMessages = [];
    player.gold = (player.gold || 0) + quest.goldReward;
    rewardMessages.push(`+${quest.goldReward} gold`);

    if (quest.xpReward > 0) {
      CharacterSystem.gainExp(player, quest.xpReward);
      rewardMessages.push(`+${quest.xpReward} XP`);
    }

    // Bonus item
    let bonusItemObj = null;
    if (quest.bonusItem) {
      bonusItemObj = ItemSystem.createItem(quest.bonusItem);
      if (bonusItemObj) {
        ItemSystem.addToInventory(player, bonusItemObj);
        rewardMessages.push(`+${bonusItemObj.name}`);
      }
    }

    const rewardStr = rewardMessages.join(', ');

    return {
      success: true,
      message: `Quest complete: ${quest.name}! Rewards: ${rewardStr}`,
      fame: quest.fameReward,
      karma: quest.karmaReward
    };
  }

  // â”€â”€ Get quests for display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getActiveQuests(player) {
    if (!player.quests) return [];
    return player.quests
      .filter(q => q.accepted && !q.completed && !q.failed)
      .map(q => ({
        ...q,
        isComplete: QuestSystem.isQuestComplete(q),
        progressText: `${q.progress}/${q.targetCount}`
      }));
  }

  static getCompletedQuests(player) {
    if (!player.quests) return [];
    return player.quests.filter(q => q.completed);
  }
}

</script>
  <script>
// ============================================================
// PetSystem â€” Taming, pet AI, pet management (browser)
// ============================================================
// Pets are tamed monsters that follow the player, fight enemies,
// and persist across maps. Uses the Taming skill + CHA attribute.
// ============================================================

class PetSystem {
  /**
   * Initialize pet array on the player if not present.
   */
  static init(player) {
    if (!player.pets) player.pets = [];
  }

  /**
   * Maximum number of pets a player can have.
   * Scales with CHA: base 2 + floor(CHA / 8).
   */
  static getMaxPets(player) {
    const cha = player.attributes ? (player.attributes.CHA || 7) : 7;
    return 2 + Math.floor(cha / 8);
  }

  /**
   * Attempt to tame a monster on an adjacent tile.
   * @param {object} player - The player object
   * @param {object} monster - The target monster (from currentMap.monsters)
   * @returns {{ success: boolean, message: string }}
   */
  static attemptTame(player, monster) {
    PetSystem.init(player);

    if (!monster || monster.hp <= 0) {
      return { success: false, message: 'Nothing to tame here.' };
    }

    if (monster.isBoss) {
      return { success: false, message: `${monster.name} is far too powerful to tame!` };
    }

    if (monster.isPet) {
      return { success: false, message: `${monster.name} is already your ally.` };
    }

    const maxPets = PetSystem.getMaxPets(player);
    if (player.pets.length >= maxPets) {
      return { success: false, message: `You already have ${maxPets} pets. Release one first. (CHA increases max)` };
    }

    const tamingSkill = player.skills.taming || 0;
    const cha = player.attributes ? (player.attributes.CHA || 7) : 7;
    const monsterLevel = monster.level || 1;

    // Taming is easier when the monster is wounded
    const hpRatio = monster.hp / monster.maxHp;
    const woundBonus = Math.floor((1 - hpRatio) * 30); // Up to +30% when near death

    // Success chance: 20 + taming*4 + CHA*2 + woundBonus - monsterLevel*5
    const successChance = Math.min(90, Math.max(5,
      20 + tamingSkill * 4 + cha * 2 + woundBonus - monsterLevel * 5
    ));

    // Always gain skill XP for attempting
    CharacterSystem.gainSkillExp(player, 'taming', 5 + monsterLevel);

    const roll = Math.random() * 100;
    if (roll > successChance) {
      // Failed â€” the monster is angered
      return {
        success: false,
        message: `You try to tame ${monster.name} but fail! (${Math.floor(successChance)}% chance)`
      };
    }

    // Success! Convert monster to pet
    const pet = PetSystem._monsterToPet(monster, player);
    player.pets.push(pet);

    // Mark monster as tamed (will be removed from hostile list)
    monster._tamed = true;

    CharacterSystem.gainSkillExp(player, 'taming', 15 + monsterLevel * 2);

    return {
      success: true,
      message: `You successfully tame ${monster.name}! It joins you as an ally. ğŸ¾`
    };
  }

  /**
   * Convert a monster object into a pet data structure.
   */
  static _monsterToPet(monster, player) {
    return {
      id: uuidv4(),
      templateId: monster.templateId || monster.id,
      name: monster.name,
      level: monster.level || 1,
      hp: monster.hp,
      maxHp: monster.maxHp,
      mp: monster.mp || 0,
      speed: monster.speed || 100,
      attack: monster.attack || '1d3',
      xp: 0,
      xpNext: (monster.level || 1) * 40 + 40,
      loyalty: 50,  // 0â€“100, affects behavior
      x: monster.x,
      y: monster.y,
      char: monster.char || 'p',
      color: monster.color || '#4f4',
      isBoss: false,
      isPet: true
    };
  }

  /**
   * Release a pet back into the wild.
   */
  static releasePet(player, petId) {
    PetSystem.init(player);
    const idx = player.pets.findIndex(p => p.id === petId);
    if (idx === -1) {
      return { success: false, message: 'Pet not found.' };
    }
    const pet = player.pets.splice(idx, 1)[0];
    return { success: true, message: `You release ${pet.name} back into the wild. Farewell! ğŸ¾` };
  }

  /**
   * Rename a pet.
   */
  static renamePet(player, petId, newName) {
    PetSystem.init(player);
    const pet = player.pets.find(p => p.id === petId);
    if (!pet) return { success: false, message: 'Pet not found.' };
    const oldName = pet.name;
    pet.name = newName;
    return { success: true, message: `${oldName} is now known as ${newName}.` };
  }

  /**
   * Place pets on the map near the player when entering a new map.
   */
  static placePetsOnMap(player, map) {
    PetSystem.init(player);
    if (player.pets.length === 0) return;

    const adjacent = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
    ];

    let placed = 0;
    for (const pet of player.pets) {
      let didPlace = false;
      for (const d of adjacent) {
        const nx = player.x + d.dx;
        const ny = player.y + d.dy;
        if (nx < 0 || ny < 0 || nx >= map.width || ny >= map.height) continue;
        const tile = map.tiles[ny][nx];
        if (!tile.walkable) continue;
        const blocked = map.monsters.some(m => m.hp > 0 && m.x === nx && m.y === ny);
        if (blocked) continue;
        // Check no other pet placed here
        const petBlocked = player.pets.some(p => p !== pet && p.x === nx && p.y === ny);
        if (petBlocked) continue;

        pet.x = nx;
        pet.y = ny;
        didPlace = true;
        placed++;
        break;
      }
      // If no adjacent tile found, place further away
      if (!didPlace) {
        for (let radius = 2; radius <= 5; radius++) {
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const nx = player.x + dx;
              const ny = player.y + dy;
              if (nx < 0 || ny < 0 || nx >= map.width || ny >= map.height) continue;
              const tile = map.tiles[ny][nx];
              if (!tile.walkable) continue;
              const bk = map.monsters.some(m => m.hp > 0 && m.x === nx && m.y === ny);
              if (bk) continue;
              pet.x = nx;
              pet.y = ny;
              didPlace = true;
              break;
            }
            if (didPlace) break;
          }
          if (didPlace) break;
        }
      }
    }
  }

  /**
   * Run one turn of pet AI for all pets.
   * Pets attack adjacent enemies, otherwise move toward the nearest enemy
   * (if one is nearby) or follow the player.
   */
  static petTurn(player, map, addMessage) {
    PetSystem.init(player);
    if (player.pets.length === 0) return;

    for (const pet of player.pets) {
      if (pet.hp <= 0) continue;

      // Find nearest hostile monster
      let nearestEnemy = null;
      let nearestDist = Infinity;
      for (const m of map.monsters) {
        if (m.hp <= 0 || m._tamed || m.isPet) continue;
        const dist = Math.abs(m.x - pet.x) + Math.abs(m.y - pet.y);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestEnemy = m;
        }
      }

      // If adjacent to an enemy, attack it
      if (nearestEnemy && nearestDist <= 1) {
        const result = PetSystem._petAttack(pet, nearestEnemy);
        if (addMessage) addMessage(result.message);
        if (nearestEnemy.hp <= 0) {
          if (addMessage) addMessage(`${pet.name} defeats ${nearestEnemy.name}!`);
          // Pet gains XP
          PetSystem.gainPetExp(pet, nearestEnemy.xp || 5);
          // Give player taming XP for the pet's kill
          CharacterSystem.gainSkillExp(player, 'taming', 3);
        }
        continue;
      }

      // If an enemy is within 6 tiles, move toward it
      if (nearestEnemy && nearestDist <= 6) {
        PetSystem._moveToward(pet, nearestEnemy.x, nearestEnemy.y, player, map);
        continue;
      }

      // Otherwise, follow the player if more than 3 tiles away
      const distToPlayer = Math.abs(player.x - pet.x) + Math.abs(player.y - pet.y);
      if (distToPlayer > 3) {
        PetSystem._moveToward(pet, player.x, player.y, player, map);
      }
      // If close to player, idle (or wander slightly)
    }
  }

  /**
   * Pet melee attack against a target.
   */
  static _petAttack(pet, target) {
    const hitChance = 65 + (pet.level || 1) * 2;
    const roll = Math.random() * 100;

    if (roll > hitChance) {
      return {
        hit: false,
        damage: 0,
        message: `${pet.name} attacks ${target.name} but misses!`
      };
    }

    let damage = CombatSystem.rollDice(pet.attack || '1d3');
    damage += Math.floor((pet.level || 1) / 2);

    // Critical chance: 5%
    let critical = false;
    if (Math.random() < 0.05) {
      critical = true;
      damage = Math.floor(damage * 1.5);
    }

    damage = Math.max(1, damage);
    target.hp -= damage;

    const critMsg = critical ? ' Critical hit!' : '';
    return {
      hit: true,
      damage,
      critical,
      message: `${pet.name} hits ${target.name} for ${damage} damage.${critMsg}`
    };
  }

  /**
   * Move a pet one step toward a target coordinate.
   */
  static _moveToward(pet, tx, ty, player, map) {
    const dx = tx - pet.x;
    const dy = ty - pet.y;
    const mx = dx === 0 ? 0 : Math.sign(dx);
    const my = dy === 0 ? 0 : Math.sign(dy);
    const nx = pet.x + mx;
    const ny = pet.y + my;

    if (nx < 0 || ny < 0 || nx >= map.width || ny >= map.height) return;

    const tile = map.tiles[ny][nx];
    if (!tile.walkable) return;

    // Don't step on the player
    if (nx === player.x && ny === player.y) return;

    // Don't step on hostile monsters (they should attack instead)
    const monsterBlocked = map.monsters.some(m => m.hp > 0 && m.x === nx && m.y === ny);
    if (monsterBlocked) return;

    // Don't step on other pets
    const petBlocked = player.pets.some(p => p !== pet && p.hp > 0 && p.x === nx && p.y === ny);
    if (petBlocked) return;

    pet.x = nx;
    pet.y = ny;
  }

  /**
   * Give a pet experience and handle level-ups.
   */
  static gainPetExp(pet, amount) {
    pet.xp = (pet.xp || 0) + amount;
    while (pet.xp >= pet.xpNext) {
      pet.xp -= pet.xpNext;
      pet.level = (pet.level || 1) + 1;
      pet.xpNext = pet.level * 40 + 40;
      // Increase stats on level up
      pet.maxHp = Math.floor(pet.maxHp * 1.12) + 2;
      pet.hp = pet.maxHp; // Full heal on level up
      pet.loyalty = Math.min(100, (pet.loyalty || 50) + 5);
      // Upgrade attack dice every 3 levels
      if (pet.level % 3 === 0) {
        pet.attack = PetSystem._upgradeDice(pet.attack);
      }
    }
  }

  /**
   * Upgrade dice notation (e.g., 1d3 â†’ 1d4, 2d6 â†’ 2d7, max at 4d10).
   */
  static _upgradeDice(diceStr) {
    if (!diceStr) return '1d4';
    const [n, m] = diceStr.split('d').map(Number);
    if (m < 10) return `${n}d${m + 1}`;
    if (n < 4) return `${n + 1}d${m}`;
    return diceStr; // Max
  }

  /**
   * Handle damage dealt to a pet by a monster.
   */
  static damagePet(pet, damage) {
    pet.hp = Math.max(0, pet.hp - damage);
    return pet.hp <= 0;
  }

  /**
   * Heal all pets by a small amount each turn (natural regeneration).
   */
  static regenPets(player) {
    PetSystem.init(player);
    for (const pet of player.pets) {
      if (pet.hp <= 0) continue;
      if (pet.hp < pet.maxHp) {
        pet.hp = Math.min(pet.maxHp, pet.hp + 1);
      }
    }
  }

  /**
   * Revive a dead pet at 25% HP (costs gold).
   */
  static revivePet(player, petId) {
    PetSystem.init(player);
    const pet = player.pets.find(p => p.id === petId);
    if (!pet) return { success: false, message: 'Pet not found.' };
    if (pet.hp > 0) return { success: false, message: `${pet.name} is not dead.` };

    const cost = (pet.level || 1) * 50;
    if ((player.gold || 0) < cost) {
      return { success: false, message: `Not enough gold to revive ${pet.name}. (Need ${cost}gp)` };
    }

    player.gold -= cost;
    pet.hp = Math.floor(pet.maxHp * 0.25);
    pet.loyalty = Math.max(0, (pet.loyalty || 50) - 10);

    return { success: true, message: `${pet.name} has been revived! (Cost: ${cost}gp) ğŸ¾` };
  }

  /**
   * Get pet list for client state display.
   */
  static getPetList(player) {
    PetSystem.init(player);
    return player.pets.map(pet => ({
      id: pet.id,
      templateId: pet.templateId,
      name: pet.name,
      level: pet.level || 1,
      hp: pet.hp,
      maxHp: pet.maxHp,
      attack: pet.attack,
      xp: pet.xp || 0,
      xpNext: pet.xpNext || 80,
      loyalty: pet.loyalty || 50,
      x: pet.x,
      y: pet.y,
      char: pet.char || 'p',
      color: pet.color || '#4f4',
      isDead: pet.hp <= 0,
      isPet: true
    }));
  }

  /**
   * Check if a position is occupied by a live pet.
   */
  static isPetAt(player, x, y) {
    PetSystem.init(player);
    return player.pets.some(p => p.hp > 0 && p.x === x && p.y === y);
  }

  /**
   * Get a pet at a specific position.
   */
  static getPetAt(player, x, y) {
    PetSystem.init(player);
    return player.pets.find(p => p.hp > 0 && p.x === x && p.y === y) || null;
  }
}

</script>
  <script>
// ============================================================
// GatheringSystem â€” Mining, Chopping, Fishing, Herb Gathering,
//                   Berry Picking, Mushroom Foraging, and more
// ============================================================
// Players interact with resource nodes on maps to gather materials.
// Each node type uses a different skill and yields different items.
// Tree and ore nodes come in subtypes with different hardness values.
// Equipping better tools (axes, pickaxes) speeds up gathering.
// Nodes are consumed on use and regenerate when the map is revisited.
// ============================================================

class GatheringSystem {

  /**
   * Attempt to gather from an adjacent or current tile resource node.
   * @param {object} player
   * @param {object} tile - The map tile being gathered from
   * @param {object} map - The current map (to place items)
   * @param {number} tileX - Tile world x
   * @param {number} tileY - Tile world y
   * @returns {{ success: boolean, message: string, items: object[], skillUsed: string }}
   */
  static gather(player, tile, map, tileX, tileY) {
    const nodeType = GatheringSystem.getNodeType(tile);
    if (!nodeType) {
      return { success: false, message: 'Nothing to gather here.', items: [], skillUsed: null };
    }

    const cfg = GatheringSystem.NODE_CONFIG[nodeType];
    if (!cfg) {
      return { success: false, message: 'Nothing to gather here.', items: [], skillUsed: null };
    }

    // Determine subtype config (for trees/ores with variants)
    const subtype = tile._nodeSubtype || null;
    const subCfg = (subtype && cfg.subtypes && cfg.subtypes[subtype]) ? cfg.subtypes[subtype] : null;

    // Merge subtype overrides with base config
    const difficulty = (subCfg && subCfg.difficulty != null) ? subCfg.difficulty : cfg.difficulty;
    const hardness = (subCfg && subCfg.hardness != null) ? subCfg.hardness : (cfg.hardness || 1);
    const drops = (subCfg && subCfg.drops) ? subCfg.drops : cfg.drops;
    const rareDrops = (subCfg && subCfg.rareDrops) ? subCfg.rareDrops : cfg.rareDrops;
    const xpGain = (subCfg && subCfg.xpGain != null) ? subCfg.xpGain : cfg.xpGain;
    const spCostBase = (subCfg && subCfg.spCost != null) ? subCfg.spCost : cfg.spCost;
    const nodeName = (subCfg && subCfg.name) ? subCfg.name : cfg.name;
    const requiredToolPower = (subCfg && subCfg.requiredToolPower != null) ? subCfg.requiredToolPower : (cfg.requiredToolPower || 0);

    const skillLevel = player.skills ? (player.skills[cfg.skill] || 0) : 0;

    // Tool bonus â€” find the best equipped tool of the right type
    const toolBonus = GatheringSystem._getToolBonus(player, cfg.toolType);

    // Check if the player has a strong enough tool for hard nodes
    if (requiredToolPower > 0 && toolBonus.power < requiredToolPower) {
      const toolName = cfg.toolType === 'axeTool' ? 'axe' : cfg.toolType === 'pickaxe' ? 'pickaxe' : 'tool';
      return {
        success: false,
        message: `This ${nodeName} requires a better ${toolName} (power ${requiredToolPower}+) to harvest.`,
        items: [],
        skillUsed: cfg.skill
      };
    }

    // Effective difficulty reduced by tool power
    const effectiveDifficulty = Math.max(1, difficulty - toolBonus.power);
    const successChance = Math.min(95, Math.max(15, 40 + skillLevel * 5 - effectiveDifficulty * 3 + toolBonus.power * 5));
    const roll = Math.random() * 100;

    // Always grant skill XP (scaled by hardness)
    CharacterSystem.gainSkillExp(player, cfg.skill, Math.floor(xpGain * hardness));

    // SP cost â€” reduced by skill and tool
    const spCost = Math.max(1, Math.ceil(spCostBase * hardness) - Math.floor(skillLevel / 5) - toolBonus.power);
    if (player.sp < spCost) {
      return {
        success: false,
        message: `You're too tired to ${cfg.verb}. (Need ${spCost} SP)`,
        items: [],
        skillUsed: cfg.skill
      };
    }
    player.sp = Math.max(0, player.sp - spCost);

    if (roll > successChance) {
      const toolMsg = toolBonus.name ? ` [${toolBonus.name}]` : '';
      return {
        success: false,
        message: `You ${cfg.verb} the ${nodeName} but find nothing useful.${toolMsg} (${cfg.skill} +exp, ${Math.floor(successChance)}%)`,
        items: [],
        skillUsed: cfg.skill
      };
    }

    // Determine yield
    const items = GatheringSystem._rollYield(drops, rareDrops, skillLevel, toolBonus.power);

    // Deplete the node (convert to a depleted version)
    const depletedTile = (subCfg && subCfg.depletedTile) ? subCfg.depletedTile : cfg.depletedTile;
    const depletedChar = (subCfg && subCfg.depletedChar) ? subCfg.depletedChar : cfg.depletedChar;
    const depletedColor = (subCfg && subCfg.depletedColor) ? subCfg.depletedColor : cfg.depletedColor;
    const depletedWalkable = (subCfg && subCfg.depletedWalkable != null) ? subCfg.depletedWalkable : cfg.depletedWalkable;

    tile.type = depletedTile;
    tile.char = depletedChar;
    tile.color = depletedColor;
    tile.walkable = depletedWalkable;
    tile.transparent = true;
    tile._depletedNode = nodeType; // mark for potential regrowth
    tile._depletedTurn = 0; // will be set by caller
    tile._nodeSubtype = null;

    const toolMsg = toolBonus.name ? ` [${toolBonus.name}]` : '';
    return {
      success: true,
      message: `You ${cfg.verb} the ${nodeName} successfully!${toolMsg} (${cfg.skill} +exp)`,
      items,
      skillUsed: cfg.skill
    };
  }

  /**
   * Get the best tool bonus for a given tool type from the player's equipment/inventory.
   * @returns {{ power: number, name: string|null }}
   */
  static _getToolBonus(player, toolType) {
    if (!toolType) return { power: 0, name: null };
    let bestPower = 0;
    let bestName = null;

    // Check equipped weapon first (axes/pickaxes can be used as weapons too)
    const equipped = player.equipment && player.equipment.weapon;
    if (equipped && equipped.subtype === toolType && equipped.toolPower) {
      bestPower = equipped.toolPower;
      bestName = equipped.name;
    }

    // Check inventory for dedicated tools
    if (player.inventory) {
      for (const item of player.inventory) {
        if (item.type === 'tool' && item.subtype === toolType && item.toolPower > bestPower) {
          bestPower = item.toolPower;
          bestName = item.name;
        }
      }
    }
    return { power: bestPower, name: bestName };
  }

  /**
   * Check what kind of resource node a tile is (if any).
   */
  static getNodeType(tile) {
    if (!tile) return null;
    const type = tile.type;

    // Tree variants
    if (type === 'tree' || type === 'oakTree' || type === 'pineTree' ||
        type === 'birchTree' || type === 'mapleTree' || type === 'yewTree' ||
        type === 'snowTree') {
      return 'tree';
    }
    // Ore variants
    if (type === 'ore' || type === 'oreVein' || type === 'copperOre' ||
        type === 'ironOre' || type === 'silverOre' || type === 'goldOre' || type === 'mythrilOre') {
      return 'ore';
    }
    // Other resource nodes
    switch (type) {
      case 'water':
      case 'fishingSpot':
        return 'fish';
      case 'herbPatch':
        return 'herb';
      case 'berryBush':
        return 'berry';
      case 'mushroomPatch':
        return 'mushroom';
      case 'clayDeposit':
        return 'clay';
      case 'sandDeposit':
        return 'sandNode';
      case 'flintNode':
        return 'flintNode';
      case 'reedPatch':
        return 'reed';
      case 'bush':
        return 'bush';
      case 'deadTree':
        return 'deadTree';
      case 'cactus':
        return 'cactus';
      default:
        return null;
    }
  }

  /**
   * Returns info about a gatherable node for UI display.
   */
  static getNodeInfo(tile) {
    const nodeType = GatheringSystem.getNodeType(tile);
    if (!nodeType) return null;
    const cfg = GatheringSystem.NODE_CONFIG[nodeType];
    if (!cfg) return null;

    // Get subtype-specific name if available
    const subtype = tile._nodeSubtype || null;
    const subCfg = (subtype && cfg.subtypes && cfg.subtypes[subtype]) ? cfg.subtypes[subtype] : null;
    const nodeName = (subCfg && subCfg.name) ? subCfg.name : cfg.name;

    return {
      type: nodeType,
      subtype: subtype,
      name: nodeName,
      skill: cfg.skill,
      verb: cfg.verb,
      icon: cfg.icon,
      toolType: cfg.toolType || null
    };
  }

  /**
   * Find the nearest adjacent gatherable node to the player.
   * Returns { tile, x, y, nodeType } or null.
   */
  static findAdjacentNode(player, map) {
    if (!map || !map.tiles) return null;
    const dirs = [
      { dx: 0, dy: 0 },   // current tile
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
      { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      { dx: 1, dy: 1 }, { dx: -1, dy: 1 },
      { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
    ];
    for (const { dx, dy } of dirs) {
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (ny >= 0 && ny < map.height && nx >= 0 && nx < map.width) {
        const tile = map.tiles[ny][nx];
        const nodeType = GatheringSystem.getNodeType(tile);
        if (nodeType) {
          return { tile, x: nx, y: ny, nodeType };
        }
      }
    }
    return null;
  }

  /**
   * Roll items yielded from a successful gather.
   */
  static _rollYield(drops, rareDrops, skillLevel, toolPower) {
    const items = [];
    const bonusChance = Math.min(50, skillLevel * 3 + toolPower * 5); // tool increases bonus yield

    // Primary drop
    const primaryPool = drops || [];
    if (primaryPool.length > 0) {
      const pick = primaryPool[Math.floor(Math.random() * primaryPool.length)];
      const item = ItemSystem.createItem(pick);
      if (item) items.push(item);
    }

    // Bonus yield at higher skill / better tools
    if (primaryPool.length > 0 && Math.random() * 100 < bonusChance) {
      const bonusPick = primaryPool[Math.floor(Math.random() * primaryPool.length)];
      const bonusItem = ItemSystem.createItem(bonusPick);
      if (bonusItem) items.push(bonusItem);
    }

    // Rare drops
    if (rareDrops && rareDrops.length > 0) {
      const rareChance = 5 + skillLevel * 1.5 + toolPower * 2;
      if (Math.random() * 100 < rareChance) {
        const rarePick = rareDrops[Math.floor(Math.random() * rareDrops.length)];
        const rareItem = ItemSystem.createItem(rarePick);
        if (rareItem) items.push(rareItem);
      }
    }

    return items;
  }

  /**
   * Assign a node subtype to a tile based on its tile type.
   * Called by MapGenerator when placing resource tiles.
   */
  static assignNodeSubtype(tile) {
    const type = tile.type;
    // Tree subtypes
    if (type === 'oakTree') { tile._nodeSubtype = 'oak'; }
    else if (type === 'pineTree') { tile._nodeSubtype = 'pine'; }
    else if (type === 'birchTree') { tile._nodeSubtype = 'birch'; }
    else if (type === 'mapleTree') { tile._nodeSubtype = 'maple'; }
    else if (type === 'yewTree') { tile._nodeSubtype = 'yew'; }
    else if (type === 'snowTree') { tile._nodeSubtype = 'pine'; } // snow trees are pine
    else if (type === 'tree') { tile._nodeSubtype = 'oak'; } // default tree = oak
    // Ore subtypes
    else if (type === 'copperOre') { tile._nodeSubtype = 'copper'; }
    else if (type === 'ironOre') { tile._nodeSubtype = 'iron'; }
    else if (type === 'silverOre') { tile._nodeSubtype = 'silver'; }
    else if (type === 'goldOre') { tile._nodeSubtype = 'gold'; }
    else if (type === 'mythrilOre') { tile._nodeSubtype = 'mythril'; }
    else if (type === 'ore' || type === 'oreVein') { tile._nodeSubtype = 'iron'; } // default ore = iron
  }
}

// â”€â”€ Node Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GatheringSystem.NODE_CONFIG = {
  ore: {
    name: 'Ore Vein',
    skill: 'mining',
    verb: 'mine',
    icon: 'â›',
    toolType: 'pickaxe',
    difficulty: 3,
    hardness: 1,
    spCost: 3,
    xpGain: 8,
    drops: ['oreIron', 'oreIron'],
    rareDrops: ['crystalBlue'],
    depletedTile: 'rock',
    depletedChar: 'o',
    depletedColor: '#555',
    depletedWalkable: false,
    subtypes: {
      copper: {
        name: 'Copper Vein',
        difficulty: 1,
        hardness: 0.8,
        spCost: 2,
        xpGain: 5,
        requiredToolPower: 0,
        drops: ['oreCopper', 'oreCopper'],
        rareDrops: ['flint']
      },
      iron: {
        name: 'Iron Vein',
        difficulty: 3,
        hardness: 1.0,
        spCost: 3,
        xpGain: 8,
        requiredToolPower: 1,
        drops: ['oreIron', 'oreIron'],
        rareDrops: ['crystalBlue']
      },
      silver: {
        name: 'Silver Vein',
        difficulty: 5,
        hardness: 1.3,
        spCost: 4,
        xpGain: 12,
        requiredToolPower: 2,
        drops: ['oreSilver'],
        rareDrops: ['crystalBlue', 'amber']
      },
      gold: {
        name: 'Gold Vein',
        difficulty: 7,
        hardness: 1.5,
        spCost: 5,
        xpGain: 18,
        requiredToolPower: 3,
        drops: ['oreGold'],
        rareDrops: ['crystalBlue', 'amber']
      },
      mythril: {
        name: 'Mythril Vein',
        difficulty: 10,
        hardness: 2.0,
        spCost: 6,
        xpGain: 30,
        requiredToolPower: 4,
        drops: ['oreMythril'],
        rareDrops: ['crystalBlue']
      }
    }
  },
  tree: {
    name: 'Tree',
    skill: 'lumberjacking',
    verb: 'chop',
    icon: 'ğŸª“',
    toolType: 'axeTool',
    difficulty: 2,
    hardness: 1,
    spCost: 3,
    xpGain: 6,
    drops: ['woodLog', 'woodLog'],
    rareDrops: ['string'],
    depletedTile: 'stump',
    depletedChar: '.',
    depletedColor: '#5a4a2a',
    depletedWalkable: true,
    subtypes: {
      pine: {
        name: 'Pine Tree',
        difficulty: 1,
        hardness: 0.7,
        spCost: 2,
        xpGain: 4,
        requiredToolPower: 0,
        drops: ['pineLog', 'pineLog'],
        rareDrops: ['sap', 'string']
      },
      oak: {
        name: 'Oak Tree',
        difficulty: 2,
        hardness: 1.0,
        spCost: 3,
        xpGain: 6,
        requiredToolPower: 0,
        drops: ['oakLog', 'oakLog'],
        rareDrops: ['bark', 'string']
      },
      birch: {
        name: 'Birch Tree',
        difficulty: 2,
        hardness: 0.8,
        spCost: 2,
        xpGain: 5,
        requiredToolPower: 0,
        drops: ['birchLog', 'birchLog'],
        rareDrops: ['bark', 'sap']
      },
      maple: {
        name: 'Maple Tree',
        difficulty: 4,
        hardness: 1.3,
        spCost: 4,
        xpGain: 10,
        requiredToolPower: 1,
        drops: ['mapleLog', 'mapleLog'],
        rareDrops: ['sap', 'amber']
      },
      yew: {
        name: 'Yew Tree',
        difficulty: 6,
        hardness: 1.8,
        spCost: 5,
        xpGain: 15,
        requiredToolPower: 2,
        drops: ['yewLog'],
        rareDrops: ['sap', 'amber']
      }
    }
  },
  fish: {
    name: 'Fishing Spot',
    skill: 'fishing',
    verb: 'fish at',
    icon: 'ğŸ£',
    toolType: null,
    difficulty: 4,
    hardness: 1,
    spCost: 2,
    xpGain: 7,
    drops: ['rawFish', 'rawFish'],
    rareDrops: ['rareFish', 'pearl', 'driftwood'],
    depletedTile: 'water',
    depletedChar: '~',
    depletedColor: '#2a5aaa',
    depletedWalkable: false
  },
  herb: {
    name: 'Herb Patch',
    skill: 'gathering',
    verb: 'gather herbs from',
    icon: 'ğŸŒ¿',
    toolType: null,
    difficulty: 1,
    hardness: 1,
    spCost: 1,
    xpGain: 5,
    drops: ['herbGreen', 'herbGreen'],
    rareDrops: ['seedHerb'],
    depletedTile: 'grass',
    depletedChar: '.',
    depletedColor: '#3a6a28',
    depletedWalkable: true
  },
  berry: {
    name: 'Berry Bush',
    skill: 'gathering',
    verb: 'pick berries from',
    icon: 'ğŸ«',
    toolType: null,
    difficulty: 1,
    hardness: 1,
    spCost: 1,
    xpGain: 4,
    drops: ['berryRed', 'berryBlue', 'berryRed'],
    rareDrops: ['berryPoison', 'seedHerb'],
    depletedTile: 'bush',
    depletedChar: 'â™£',
    depletedColor: '#3a7a2a',
    depletedWalkable: false
  },
  mushroom: {
    name: 'Mushroom Patch',
    skill: 'gathering',
    verb: 'forage mushrooms from',
    icon: 'ğŸ„',
    toolType: null,
    difficulty: 2,
    hardness: 1,
    spCost: 1,
    xpGain: 6,
    drops: ['mushroom', 'mushroom'],
    rareDrops: ['mushroomGlow', 'mushroomPoison'],
    depletedTile: 'dirt',
    depletedChar: '.',
    depletedColor: '#7a6a4a',
    depletedWalkable: true
  },
  clay: {
    name: 'Clay Deposit',
    skill: 'mining',
    verb: 'dig clay from',
    icon: 'ğŸº',
    toolType: 'pickaxe',
    difficulty: 1,
    hardness: 0.6,
    spCost: 2,
    xpGain: 4,
    drops: ['clay', 'clay', 'clay'],
    rareDrops: ['flint'],
    depletedTile: 'dirt',
    depletedChar: '.',
    depletedColor: '#7a6a4a',
    depletedWalkable: true
  },
  sandNode: {
    name: 'Sand Deposit',
    skill: 'mining',
    verb: 'dig sand from',
    icon: 'ğŸ–',
    toolType: null,
    difficulty: 0,
    hardness: 0.4,
    spCost: 1,
    xpGain: 2,
    drops: ['sand', 'sand', 'sand'],
    rareDrops: ['flint', 'emptyBottle'],
    depletedTile: 'sand',
    depletedChar: '.',
    depletedColor: '#d8c878',
    depletedWalkable: true
  },
  flintNode: {
    name: 'Flint Node',
    skill: 'mining',
    verb: 'chip flint from',
    icon: 'ğŸª¨',
    toolType: null,
    difficulty: 2,
    hardness: 1,
    spCost: 2,
    xpGain: 5,
    drops: ['flint', 'flint'],
    rareDrops: ['oreCopper'],
    depletedTile: 'rockyGround',
    depletedChar: '.',
    depletedColor: '#6a6a50',
    depletedWalkable: true
  },
  reed: {
    name: 'Reed Patch',
    skill: 'gathering',
    verb: 'harvest reeds from',
    icon: 'ï¿½',
    toolType: null,
    difficulty: 0,
    hardness: 1,
    spCost: 1,
    xpGain: 3,
    drops: ['reeds', 'reeds', 'string'],
    rareDrops: ['seedHerb'],
    depletedTile: 'grass',
    depletedChar: '.',
    depletedColor: '#3a6a28',
    depletedWalkable: true
  },
  bush: {
    name: 'Bush',
    skill: 'gathering',
    verb: 'search',
    icon: 'ğŸŒ³',
    toolType: null,
    difficulty: 0,
    hardness: 1,
    spCost: 1,
    xpGain: 2,
    drops: ['string', 'herbGreen'],
    rareDrops: ['berryRed', 'seedHerb'],
    depletedTile: 'grass',
    depletedChar: '.',
    depletedColor: '#3a6a28',
    depletedWalkable: true
  },
  deadTree: {
    name: 'Dead Tree',
    skill: 'lumberjacking',
    verb: 'break apart',
    icon: 'ğŸªµ',
    toolType: 'axeTool',
    difficulty: 1,
    hardness: 0.5,
    spCost: 2,
    xpGain: 3,
    drops: ['woodLog', 'bark'],
    rareDrops: ['string'],
    depletedTile: 'stump',
    depletedChar: '.',
    depletedColor: '#5a4a2a',
    depletedWalkable: true
  },
  cactus: {
    name: 'Cactus',
    skill: 'gathering',
    verb: 'carefully harvest',
    icon: 'ğŸŒµ',
    toolType: null,
    difficulty: 3,
    hardness: 1,
    spCost: 2,
    xpGain: 6,
    drops: ['herbGreen'],
    rareDrops: ['berryRed'],
    depletedTile: 'sand',
    depletedChar: '.',
    depletedColor: '#d8c878',
    depletedWalkable: true
  }
};

</script>
  <script>
// ============================================================
// EnchantSystem â€” Item Enchanting & Upgrading
// ============================================================
// Players can enchant weapons and armor using enchant scrolls.
// Enchantments add +N bonus to stats and can apply prefixes/suffixes.
// Higher enchant levels have increasing failure (and destruction) risk.
// ============================================================

class EnchantSystem {

  /**
   * Attempt to enchant an item using a scroll.
   * @param {object} player
   * @param {object} targetItem - The weapon or armor to enchant
   * @param {object} scrollItem - The enchant scroll being used
   * @returns {{ success: boolean, consumed: boolean, destroyed: boolean, message: string }}
   */
  static enchant(player, targetItem, scrollItem) {
    if (!targetItem || (targetItem.type !== 'weapon' && targetItem.type !== 'armor')) {
      return { success: false, consumed: false, destroyed: false, message: 'You can only enchant weapons and armor.' };
    }
    if (!scrollItem || scrollItem.type !== 'scroll') {
      return { success: false, consumed: false, destroyed: false, message: 'You need an enchant scroll.' };
    }

    const currentBonus = targetItem.enchantBonus || 0;
    const scrollTier = scrollItem.enchantTier || 1; // 1 = basic, 2 = greater, 3 = supreme
    const scrollType = scrollItem.enchantType || 'enhance'; // enhance, fire, ice, lightning, holy, speed

    // Success chance decreases with current enchant level
    // Better scrolls and higher crafting skill help
    const craftSkill = player.skills ? (player.skills.crafting || 0) : 0;
    const magicDevice = player.skills ? (player.skills.magicDevice || 0) : 0;
    const skillBonus = Math.floor((craftSkill + magicDevice) / 2);

    const baseChance = 90 - currentBonus * 12;
    const tierBonus = (scrollTier - 1) * 15;
    const successChance = Math.min(98, Math.max(5, baseChance + tierBonus + skillBonus * 2));

    const roll = Math.random() * 100;

    // Always gain skill exp
    CharacterSystem.gainSkillExp(player, 'crafting', 5 + scrollTier * 3);

    if (roll > successChance) {
      // Failure â€” check if item is destroyed
      const destroyChance = Math.max(0, (currentBonus - 2) * 8 - scrollTier * 5);
      const destroyed = Math.random() * 100 < destroyChance;

      if (destroyed) {
        return {
          success: false,
          consumed: true,
          destroyed: true,
          message: `The enchantment fails catastrophically! ${targetItem.name} shatters into pieces! (${Math.floor(successChance)}% chance)`
        };
      }
      return {
        success: false,
        consumed: true,
        destroyed: false,
        message: `The enchantment fizzles. The scroll crumbles to dust. (${Math.floor(successChance)}% chance)`
      };
    }

    // â”€â”€ Success! Apply enchantment â”€â”€
    targetItem.enchantBonus = currentBonus + 1;

    if (scrollType === 'enhance') {
      // Generic enhancement â€” boost primary stat
      if (targetItem.type === 'weapon') {
        targetItem.enchantDamageBonus = (targetItem.enchantDamageBonus || 0) + 2;
      } else {
        targetItem.enchantPVBonus = (targetItem.enchantPVBonus || 0) + 1;
        targetItem.enchantDVBonus = (targetItem.enchantDVBonus || 0) + 1;
      }
    } else {
      // Elemental / special enchantment
      if (!targetItem.enchantments) targetItem.enchantments = [];
      const existing = targetItem.enchantments.find(e => e.type === scrollType);
      if (existing) {
        existing.power += scrollTier;
      } else {
        targetItem.enchantments.push({
          type: scrollType,
          power: scrollTier,
          ...EnchantSystem.ENCHANT_EFFECTS[scrollType]
        });
      }
      // Also give a small primary stat boost
      if (targetItem.type === 'weapon') {
        targetItem.enchantDamageBonus = (targetItem.enchantDamageBonus || 0) + 1;
      } else {
        targetItem.enchantPVBonus = (targetItem.enchantPVBonus || 0) + 1;
      }
    }

    // Update the item name with enchant prefix/suffix
    EnchantSystem._updateItemName(targetItem);

    return {
      success: true,
      consumed: true,
      destroyed: false,
      message: `âœ¨ ${targetItem.name} glows with power! (+${targetItem.enchantBonus}) (${Math.floor(successChance)}% chance)`
    };
  }

  /**
   * Update the display name of an enchanted item.
   */
  static _updateItemName(item) {
    // Strip any previous enchant prefixes/suffixes
    let baseName = item._baseName || item.name;
    item._baseName = baseName;

    // Build prefix from elemental enchantments
    let prefix = '';
    if (item.enchantments && item.enchantments.length > 0) {
      const primary = item.enchantments[0];
      const prefixMap = {
        fire: 'Flaming',
        ice: 'Freezing',
        lightning: 'Shocking',
        holy: 'Holy',
        speed: 'Swift',
        poison: 'Venomous',
        vampiric: 'Vampiric'
      };
      prefix = prefixMap[primary.type] || '';
    }

    // Build the name
    const bonus = item.enchantBonus || 0;
    if (prefix) {
      item.name = `${prefix} ${baseName} +${bonus}`;
    } else if (bonus > 0) {
      item.name = `${baseName} +${bonus}`;
    }
  }

  /**
   * Get effective PV bonus from enchantments on an armor piece.
   */
  static getEnchantPV(item) {
    if (!item) return 0;
    return (item.enchantPVBonus || 0);
  }

  /**
   * Get effective DV bonus from enchantments on an armor piece.
   */
  static getEnchantDV(item) {
    if (!item) return 0;
    let dv = item.enchantDVBonus || 0;
    if (item.enchantments) {
      const speed = item.enchantments.find(e => e.type === 'speed');
      if (speed) dv += speed.power;
    }
    return dv;
  }

  /**
   * Get effective bonus damage from enchantments on a weapon.
   */
  static getEnchantDamage(item) {
    if (!item) return 0;
    return (item.enchantDamageBonus || 0);
  }

  /**
   * Get any elemental bonus damage for combat messages.
   * Returns { type, bonusDamage } or null.
   */
  static getElementalBonus(item) {
    if (!item || !item.enchantments || item.enchantments.length === 0) return null;
    // Pick the strongest elemental enchantment
    let best = null;
    for (const ench of item.enchantments) {
      if (ench.type !== 'speed' && (!best || ench.power > best.power)) {
        best = ench;
      }
    }
    if (!best) return null;
    return {
      type: best.type,
      bonusDamage: best.power * 2,
      name: best.name || best.type
    };
  }

  /**
   * Get display info for an item's enchantments (for UI tooltip).
   */
  static getEnchantInfo(item) {
    if (!item) return null;
    const bonus = item.enchantBonus || 0;
    if (bonus === 0 && (!item.enchantments || item.enchantments.length === 0)) return null;

    const info = { bonus, effects: [] };

    if (item.enchantDamageBonus) info.effects.push(`Damage +${item.enchantDamageBonus}`);
    if (item.enchantPVBonus) info.effects.push(`PV +${item.enchantPVBonus}`);
    if (item.enchantDVBonus) info.effects.push(`DV +${item.enchantDVBonus}`);

    if (item.enchantments) {
      for (const ench of item.enchantments) {
        const label = EnchantSystem.ENCHANT_EFFECTS[ench.type];
        if (label) {
          info.effects.push(`${label.name} +${ench.power}`);
        }
      }
    }

    return info;
  }
}

// â”€â”€ Enchantment Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EnchantSystem.ENCHANT_EFFECTS = {
  fire: { name: 'Fire', color: '#f64', description: 'Burns enemies on hit' },
  ice: { name: 'Ice', color: '#6cf', description: 'Chills enemies on hit' },
  lightning: { name: 'Lightning', color: '#ff4', description: 'Shocks enemies on hit' },
  holy: { name: 'Holy', color: '#ffa', description: 'Smites undead' },
  speed: { name: 'Speed', color: '#4ff', description: 'Increases evasion' },
  poison: { name: 'Poison', color: '#4f4', description: 'Poisons enemies on hit' },
  vampiric: { name: 'Vampiric', color: '#f4f', description: 'Steals life on hit' }
};

</script>
  <script>
// ============================================================
// FaithSystem â€” God worship, prayer, favor, blessings, gifts
// ============================================================

class FaithSystem {

  // â”€â”€ Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static init(player) {
    if (!player.faith) {
      player.faith = {
        godId: null,        // currently worshipped god id
        favor: 0,           // favor with current god (0â€“2000+)
        prayerCooldown: 0,  // turns until next prayer allowed
        giftsReceived: [],   // list of gift favor thresholds already received
        deathSaveUsed: false // Ehekatl's "Nine Lives" one-time save
      };
    }
    return player.faith;
  }

  // â”€â”€ Worship a God at an Altar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static worship(player, godId) {
    FaithSystem.init(player);
    const god = GOD_DEFS[godId];
    if (!god) return { success: false, message: 'Unknown deity.' };

    const oldGodId = player.faith.godId;

    // Already worshipping this god
    if (oldGodId === godId) {
      return { success: false, message: `You already worship ${god.name}.` };
    }

    const messages = [];

    // Switching gods â€” incur wrath from old god
    if (oldGodId && GOD_DEFS[oldGodId]) {
      const oldGod = GOD_DEFS[oldGodId];
      const wrath = oldGod.wrathEffects || {};
      // Apply attribute penalties
      for (const [attr, amount] of Object.entries(wrath)) {
        if (attr === 'message') continue;
        if (player.attributes && player.attributes[attr] !== undefined) {
          player.attributes[attr] = Math.max(1, player.attributes[attr] + amount);
        }
      }
      messages.push(wrath.message || `${oldGod.name} is angered by your betrayal!`);
      // Lose half of old favor
      player.faith.favor = Math.floor(player.faith.favor * 0.3);
    } else {
      player.faith.favor = 0;
    }

    player.faith.godId = godId;
    player.faith.giftsReceived = [];
    player.faith.deathSaveUsed = false;

    messages.push(`You begin to worship ${god.name}. ${god.icon}`);
    messages.push(`"${FaithSystem._getWorshipQuote(god)}"`);

    return { success: true, messages };
  }

  // â”€â”€ Prayer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static pray(player) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) {
      return { success: false, message: 'You have no god to pray to. Visit an altar in town to worship a deity.' };
    }

    const god = GOD_DEFS[godId];
    if (!god) return { success: false, message: 'Your god has vanished from the world.' };

    // Cooldown check
    if (player.faith.prayerCooldown > 0) {
      return { success: false, message: `You must wait before praying again. (${player.faith.prayerCooldown} turns)` };
    }

    const faithSkill = player.skills.faith || 1;
    const favorGain = 10 + Math.floor(faithSkill * 2) + Math.floor(Math.random() * 5);
    player.faith.favor += favorGain;
    player.faith.prayerCooldown = Math.max(30, 80 - faithSkill * 2);

    // Gain faith skill experience
    CharacterSystem.gainSkillExp(player, 'faith', 8);

    // Small immediate effect based on god
    const result = {
      success: true,
      favorGain,
      messages: [`You pray to ${god.name}. ${god.icon} (+${favorGain} favor)`]
    };

    // Prayer healing (minor)
    const healAmt = Math.floor(faithSkill * 0.5) + 2;
    player.hp = Math.min(player.maxHp, player.hp + healAmt);
    player.mp = Math.min(player.maxMp, player.mp + Math.floor(healAmt * 0.5));
    result.messages.push(`A warm light surrounds you. HP +${healAmt}`);

    // Check for divine gifts at favor thresholds
    const giftMessages = FaithSystem._checkGifts(player, god);
    result.messages.push(...giftMessages);

    return result;
  }

  // â”€â”€ Offer an Item at an Altar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static offerItem(player, item) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) {
      return { success: false, consumed: false, message: 'You have no god to offer to.' };
    }

    const god = GOD_DEFS[godId];
    if (!god) return { success: false, consumed: false, message: 'Unknown god.' };

    // Calculate offering value based on item value
    const baseValue = item.value || 10;
    const favorGain = Math.max(5, Math.floor(baseValue * 0.3) + 3);

    player.faith.favor += favorGain;
    CharacterSystem.gainSkillExp(player, 'faith', 5 + Math.floor(baseValue * 0.05));

    const result = {
      success: true,
      consumed: true,
      favorGain,
      messages: [
        `You offer ${item.name} to ${god.name}. ${god.icon}`,
        `${god.name} accepts your offering! (+${favorGain} favor)`
      ]
    };

    // Check for divine gifts
    const giftMessages = FaithSystem._checkGifts(player, god);
    result.messages.push(...giftMessages);

    return result;
  }

  // â”€â”€ Gain Favor from In-Game Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static onAction(player, actionType, context) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) return [];

    const god = GOD_DEFS[godId];
    if (!god || !god.favoredActions) return [];

    if (!god.favoredActions.includes(actionType)) return [];

    // Gain favor passively from favored actions
    const gain = Math.floor(Math.random() * 3) + 1;
    player.faith.favor += gain;

    // Occasionally notify (10% of the time to avoid spam)
    if (Math.random() < 0.1) {
      return [`${god.icon} ${god.name} is pleased. (+${gain} favor)`];
    }
    return [];
  }

  // â”€â”€ Tick (per turn) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static tick(player) {
    FaithSystem.init(player);
    if (player.faith.prayerCooldown > 0) {
      player.faith.prayerCooldown--;
    }
  }

  // â”€â”€ Get Blessing Bonuses (applied to stats) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getBlessingBonuses(player) {
    const bonuses = {
      pv: 0, dv: 0, speed: 0, hpRegen: 0, mpRegen: 0,
      critBonus: 0, goldBonus: 0, craftBonus: 0, enchantBonus: 0,
      harvestBonus: 0, nutritionBonus: 0, healBoost: 0, spellPower: 0,
      deathSave: false,
      attrBonuses: {}
    };

    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) return bonuses;

    const god = GOD_DEFS[godId];
    if (!god || !god.blessings) return bonuses;

    const favor = player.faith.favor;

    // Determine the highest blessing tier the player qualifies for
    let activeBlessingKey = null;
    if (favor >= god.blessings.major.threshold) activeBlessingKey = 'major';
    else if (favor >= god.blessings.moderate.threshold) activeBlessingKey = 'moderate';
    else if (favor >= god.blessings.minor.threshold) activeBlessingKey = 'minor';

    if (!activeBlessingKey) return bonuses;

    const blessing = god.blessings[activeBlessingKey];
    const effect = blessing.effect;

    // Apply effects
    for (const [key, value] of Object.entries(effect)) {
      if (key === 'deathSave') {
        bonuses.deathSave = value && !player.faith.deathSaveUsed;
      } else if (['STR', 'END', 'DEX', 'PER', 'LRN', 'WIL', 'MAG', 'CHA'].includes(key)) {
        bonuses.attrBonuses[key] = (bonuses.attrBonuses[key] || 0) + value;
      } else if (bonuses[key] !== undefined) {
        bonuses[key] += value;
      }
    }

    return bonuses;
  }

  // â”€â”€ Get Active Blessing Info (for UI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getActiveBlessingInfo(player) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    if (!godId) return null;

    const god = GOD_DEFS[godId];
    if (!god || !god.blessings) return null;

    const favor = player.faith.favor;
    let activeKey = null;
    let nextKey = null;
    let nextThreshold = 0;

    if (favor >= god.blessings.major.threshold) {
      activeKey = 'major';
    } else if (favor >= god.blessings.moderate.threshold) {
      activeKey = 'moderate';
      nextKey = 'major';
      nextThreshold = god.blessings.major.threshold;
    } else if (favor >= god.blessings.minor.threshold) {
      activeKey = 'minor';
      nextKey = 'moderate';
      nextThreshold = god.blessings.moderate.threshold;
    } else {
      nextKey = 'minor';
      nextThreshold = god.blessings.minor.threshold;
    }

    return {
      active: activeKey ? god.blessings[activeKey] : null,
      activeKey,
      nextBlessing: nextKey ? god.blessings[nextKey] : null,
      nextKey,
      nextThreshold
    };
  }

  // â”€â”€ Death Save (Ehekatl's Nine Lives) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static checkDeathSave(player) {
    FaithSystem.init(player);
    const bonuses = FaithSystem.getBlessingBonuses(player);
    if (bonuses.deathSave && player.hp <= 0) {
      player.hp = Math.floor(player.maxHp * 0.25);
      player.faith.deathSaveUsed = true;
      return {
        saved: true,
        message: 'ğŸ± Ehekatl winks! You miraculously survive with a sliver of life!'
      };
    }
    return { saved: false };
  }

  // â”€â”€ Get State for Client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getState(player) {
    FaithSystem.init(player);
    const godId = player.faith.godId;
    const god = godId ? GOD_DEFS[godId] : null;
    const blessingInfo = FaithSystem.getActiveBlessingInfo(player);

    return {
      godId,
      godName: god ? god.name : null,
      godTitle: god ? god.title : null,
      godIcon: god ? god.icon : null,
      godColor: god ? god.color : null,
      godDescription: god ? god.description : null,
      favor: player.faith.favor,
      prayerCooldown: player.faith.prayerCooldown,
      activeBlessing: blessingInfo ? blessingInfo.active : null,
      activeBlessingKey: blessingInfo ? blessingInfo.activeKey : null,
      nextBlessing: blessingInfo ? blessingInfo.nextBlessing : null,
      nextBlessingKey: blessingInfo ? blessingInfo.nextKey : null,
      nextThreshold: blessingInfo ? blessingInfo.nextThreshold : 0,
      allGods: Object.values(GOD_DEFS).map(g => ({
        id: g.id,
        name: g.name,
        title: g.title,
        icon: g.icon,
        color: g.color,
        description: g.description
      }))
    };
  }

  // â”€â”€ Internal: Check & Deliver Gifts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _checkGifts(player, god) {
    const messages = [];
    if (!god.gifts) return messages;

    for (const gift of god.gifts) {
      if (player.faith.favor >= gift.favor && !player.faith.giftsReceived.includes(gift.favor)) {
        player.faith.giftsReceived.push(gift.favor);

        switch (gift.type) {
          case 'item': {
            const template = ITEM_TEMPLATES[gift.itemId];
            if (template) {
              const count = gift.count || 1;
              for (let i = 0; i < count; i++) {
                const item = ItemSystem.createItem(gift.itemId);
                if (item) ItemSystem.addToInventory(player, item);
              }
            }
            break;
          }
          case 'gold': {
            player.gold = (player.gold || 0) + (gift.amount || 100);
            break;
          }
          case 'attribute': {
            if (player.attributes && player.attributes[gift.attr] !== undefined) {
              player.attributes[gift.attr] += gift.amount || 1;
              CharacterSystem.recalcDerived(player);
            }
            break;
          }
          case 'spellStock': {
            MagicSystem.initSpells(player);
            if (!player.spells[gift.spellId]) {
              player.spells[gift.spellId] = { stock: 0, skillLevel: 1 };
            }
            player.spells[gift.spellId].stock += (gift.amount || 5);
            break;
          }
        }

        messages.push(`âœ¦ ${gift.message || 'A divine gift appears!'}`);
      }
    }

    return messages;
  }

  // â”€â”€ Internal: Flavor Quotes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _getWorshipQuote(god) {
    const quotes = {
      opatos: 'Stand firm, mortal. The earth shall be your shield.',
      lulwy: 'Let the wind carry you. Speed is life.',
      itzpalt: 'Knowledge is the greatest power. Cast wisely.',
      ehekatl: 'Meow! Luck favors the bold... and the generous!',
      jure: 'All life is precious. I shall mend what is broken.',
      kumiromi: 'The seed you plant today becomes tomorrow\'s forest.',
      mani: 'Every problem has a mechanical solution. Build it.'
    };
    return quotes[god.id] || 'I acknowledge your devotion.';
  }
}

</script>
  <script>
// ============================================================
// FogOfWarSystem â€” Fog of war with line-of-sight visibility
// Tiles can be: 0 = unseen (black), 1 = seen/remembered (dim),
//               2 = currently visible (full)
// ============================================================

class FogOfWarSystem {
  constructor() {
    this.fogMap = null;       // 2D array of visibility state per tile
    this.width = 0;
    this.height = 0;
    this._mapKey = null;      // Track which map we're on
  }

  // â”€â”€ Initialize / Reset fog for a new map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  init(mapWidth, mapHeight, mapKey) {
    // If same map, keep existing fog (for returning to floors, etc.)
    if (this._mapKey === mapKey && this.fogMap) return;

    this.width = mapWidth;
    this.height = mapHeight;
    this._mapKey = mapKey;
    this.fogMap = [];
    for (let y = 0; y < mapHeight; y++) {
      const row = new Uint8Array(mapWidth); // All zeros = unseen
      this.fogMap.push(row);
    }
  }

  // â”€â”€ Compute the player's current visibility range â”€â”€â”€â”€
  static computeVisibilityRange(player, timeState, locationType) {
    // Base range depends on PER attribute
    const per = (player.attributes && player.attributes.PER) || 8;
    let baseRange = 4 + Math.floor(per / 3);

    // Spot Hidden skill bonus
    const spotHidden = (player.skills && player.skills.spotHidden) || 0;
    baseRange += Math.floor(spotHidden / 5);

    // Eye of Mind skill bonus
    const eyeOfMind = (player.skills && player.skills.eyeOfMind) || 0;
    baseRange += Math.floor(eyeOfMind / 4);

    // Night penalty (only applies to non-underground areas)
    const isUnderground = locationType === 'nefia';
    const isNight = timeState && timeState.isNight;
    if (!isUnderground && isNight) {
      baseRange = Math.max(3, baseRange - 3);
    }

    // Underground base penalty
    if (isUnderground) {
      baseRange = Math.max(3, baseRange - 2);
    }

    // Light source bonuses (check inventory and equipment)
    const lightBonus = FogOfWarSystem.getLightBonus(player);
    baseRange += lightBonus;

    // Clamp to reasonable range
    return Math.min(Math.max(baseRange, 2), 20);
  }

  // â”€â”€ Calculate light bonus from carried/equipped items â”€
  static getLightBonus(player) {
    let bonus = 0;
    if (!player) return bonus;

    // Check equipment first (wielded torch gives more light)
    if (player.equipment) {
      Object.values(player.equipment).forEach(item => {
        if (item && item.lightRadius) {
          bonus += item.lightRadius;
        }
      });
    }

    // Check inventory for passive light sources (reduced effect)
    if (player.inventory) {
      for (const item of player.inventory) {
        if (item && item.lightRadius) {
          // Items in inventory give half their light radius
          bonus += Math.floor(item.lightRadius / 2);
        }
      }
    }

    // Buff-based light (e.g., from a Light spell)
    if (player.buffs) {
      for (const buff of player.buffs) {
        if (buff.lightRadius) {
          bonus += buff.lightRadius;
        }
      }
    }

    return bonus;
  }

  // â”€â”€ Should fog be active for this context? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static shouldUseFog(locationType, timeState) {
    // No fog on the world map
    // Towns during daytime: no fog (reveal everything)
    // Nefias, outdoor encounters, towns at night: fog active
    if (locationType === 'nefia') return true;
    if (locationType === 'outdoor') return true;
    // Towns: fog only at night
    if (locationType === 'town' || locationType === 'home') {
      return timeState && timeState.isNight;
    }
    return false;
  }

  // â”€â”€ Should all tiles be revealed as "seen" (daytime outdoors)? â”€
  static shouldRevealAll(locationType, timeState) {
    // During day and not underground, reveal all tiles as seen
    const isUnderground = locationType === 'nefia';
    const isDay = !timeState || !timeState.isNight;
    if (!isUnderground && isDay) return true;
    return false;
  }

  // â”€â”€ Update visibility based on player position â”€â”€â”€â”€â”€â”€â”€
  update(playerX, playerY, visRange, tiles) {
    if (!this.fogMap) return;

    // First, downgrade all currently visible (2) tiles to seen (1)
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.fogMap[y][x] === 2) {
          this.fogMap[y][x] = 1;
        }
      }
    }

    // Cast rays in 360 degrees from the player to determine visible tiles
    this._castVisibility(playerX, playerY, visRange, tiles);
  }

  // â”€â”€ Reveal all tiles as "seen" (for daytime outdoor) â”€
  revealAllAsSeen() {
    if (!this.fogMap) return;
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.fogMap[y][x] === 0) {
          this.fogMap[y][x] = 1;
        }
      }
    }
  }

  // â”€â”€ Shadowcasting-based visibility (recursive) â”€â”€â”€â”€â”€â”€â”€
  // Uses the "symmetric recursive shadowcasting" algorithm for
  // accurate FOV in roguelikes.
  _castVisibility(ox, oy, range, tiles) {
    // Player's own tile is always visible
    if (oy >= 0 && oy < this.height && ox >= 0 && ox < this.width) {
      this.fogMap[oy][ox] = 2;
    }

    // 8 octants for full 360Â° field of view
    for (let octant = 0; octant < 8; octant++) {
      this._castOctant(ox, oy, range, 1, 1.0, 0.0, octant, tiles);
    }
  }

  _castOctant(ox, oy, range, row, startSlope, endSlope, octant, tiles) {
    if (startSlope < endSlope) return;

    let nextStartSlope = startSlope;

    for (let i = row; i <= range; i++) {
      let blocked = false;

      for (let dx = -i; dx <= 0; dx++) {
        const dy = -i;
        const leftSlope = (dx - 0.5) / (dy + 0.5);
        const rightSlope = (dx + 0.5) / (dy - 0.5);

        if (startSlope < rightSlope) continue;
        if (endSlope > leftSlope) break;

        // Transform coordinates based on octant
        const { tx, ty } = this._transformOctant(dx, dy, octant);
        const ax = ox + tx;
        const ay = oy + ty;

        // Check distance (circular FOV)
        const dist2 = tx * tx + ty * ty;
        if (dist2 > range * range) continue;

        if (ax >= 0 && ax < this.width && ay >= 0 && ay < this.height) {
          this.fogMap[ay][ax] = 2;
        }

        // Check if this tile blocks light
        const isBlocking = this._isOpaque(ax, ay, tiles);

        if (blocked) {
          if (isBlocking) {
            nextStartSlope = rightSlope;
            continue;
          } else {
            blocked = false;
            startSlope = nextStartSlope;
          }
        } else if (isBlocking && i < range) {
          blocked = true;
          this._castOctant(ox, oy, range, i + 1, startSlope, leftSlope, octant, tiles);
          nextStartSlope = rightSlope;
        }
      }

      if (blocked) break;
    }
  }

  _transformOctant(col, row, octant) {
    switch (octant) {
      case 0: return { tx: col, ty: row };
      case 1: return { tx: row, ty: col };
      case 2: return { tx: row, ty: -col };
      case 3: return { tx: col, ty: -row };
      case 4: return { tx: -col, ty: -row };
      case 5: return { tx: -row, ty: -col };
      case 6: return { tx: -row, ty: col };
      case 7: return { tx: -col, ty: row };
      default: return { tx: col, ty: row };
    }
  }

  _isOpaque(x, y, tiles) {
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return true;
    const tile = tiles[y][x];
    // Walls and other non-walkable solid tiles block vision
    if (!tile) return true;
    if (tile.type === 'wall') return true;
    if (tile.type === 'tree' && !tile.walkable) return true;
    // Default: walkable tiles don't block vision
    if (!tile.walkable && tile.type !== 'ore') return true;
    return false;
  }

  // â”€â”€ Check if a specific position is currently visible â”€
  isVisible(x, y) {
    if (!this.fogMap) return true;
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return false;
    return this.fogMap[y][x] === 2;
  }

  // â”€â”€ Check if a specific position has been seen â”€â”€â”€â”€â”€â”€â”€â”€
  isSeen(x, y) {
    if (!this.fogMap) return true;
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return false;
    return this.fogMap[y][x] >= 1;
  }

  // â”€â”€ Get fog state at position: 0=unseen, 1=seen, 2=visible â”€
  getState(x, y) {
    if (!this.fogMap) return 2;
    if (x < 0 || y < 0 || x >= this.width || y >= this.height) return 0;
    return this.fogMap[y][x];
  }

  // â”€â”€ Serialize fog state for saving â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  serialize() {
    if (!this.fogMap) return null;
    return {
      width: this.width,
      height: this.height,
      mapKey: this._mapKey,
      data: this.fogMap.map(row => Array.from(row))
    };
  }

  // â”€â”€ Load fog state from save data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  loadFromSave(data) {
    if (!data) return;
    this.width = data.width;
    this.height = data.height;
    this._mapKey = data.mapKey;
    this.fogMap = data.data.map(row => new Uint8Array(row));
  }

  // â”€â”€ Cache for nefia floors (so revisiting a floor keeps fog) â”€
  static _fogCache = {};

  static saveFogToCache(mapKey, fogSystem) {
    if (!fogSystem.fogMap) return;
    FogOfWarSystem._fogCache[mapKey] = fogSystem.serialize();
  }

  static loadFogFromCache(mapKey, fogSystem) {
    const cached = FogOfWarSystem._fogCache[mapKey];
    if (cached && cached.mapKey === mapKey) {
      fogSystem.loadFromSave(cached);
      return true;
    }
    return false;
  }

  static clearCache() {
    FogOfWarSystem._fogCache = {};
  }
}

</script>
  <script>
// ============================================================
// ActionTimingSystem â€” Timed actions with skill-based speed
// ============================================================
// Each action has a base tick cost. Proficiency in the relevant
// skill reduces the time needed. Some actions (like moving) are
// always instant (1 tick). Others require holding the action key
// while a progress bar fills up.
// ============================================================

class ActionTimingSystem {

  // â”€â”€ Action Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Returns { ticks, skill, label, icon } for a given action.
  // `ticks` is the BASE cost before skill reduction.
  // `skill` is the skill id used to reduce the time.
  // If ticks === 1 the action is instant (no progress bar).

  static getActionTiming(action, player, context) {
    const type = action.type;

    switch (type) {
      // â”€â”€ Instant actions (1 tick) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      case 'move':
      case 'wait':
      case 'pickup':
      case 'drop':
      case 'equip':
      case 'enterLocation':
      case 'exitToWorldMap':
      case 'descend':
      case 'ascend':
      case 'shopBuy':
      case 'shopSell':
      case 'closeShop':
      case 'acceptQuest':
      case 'turnInQuest':
      case 'abandonQuest':
      case 'releasePet':
      case 'renamePet':
      case 'worship':
        return { ticks: 1, skill: null, label: null, icon: null, instant: true };

      // â”€â”€ Melee attack: 2-4 ticks, reduced by weapon skill + tactics â”€â”€
      case 'attack':
        return ActionTimingSystem._meleeAttackTiming(player);

      // â”€â”€ Ranged attack: 3-5 ticks, reduced by marksman â”€â”€
      case 'rangedAttack':
        return {
          ticks: ActionTimingSystem._reduceTicks(4, player, 'marksman', 1),
          skill: 'marksman',
          label: 'Aiming...',
          icon: 'ğŸ¹',
          instant: false
        };

      // â”€â”€ Spellcasting: 3-8 ticks, reduced by casting + spell level â”€â”€
      case 'castSpell':
        return ActionTimingSystem._spellCastTiming(action, player);

      // â”€â”€ Reading spellbook: 5-12 ticks, reduced by literacy â”€â”€
      case 'readSpellbook':
        return {
          ticks: ActionTimingSystem._reduceTicks(8, player, 'literacy', 1),
          skill: 'literacy',
          label: 'Studying...',
          icon: 'ğŸ“–',
          instant: false
        };

      // â”€â”€ Eating: 2-3 ticks â”€â”€
      case 'eat':
        return {
          ticks: 2,
          skill: null,
          label: 'Eating...',
          icon: 'ğŸ–',
          instant: false
        };

      // â”€â”€ Crafting: 4-10 ticks, reduced by crafting skill â”€â”€
      case 'craft':
        return ActionTimingSystem._craftTiming(action, player);

      // â”€â”€ Gathering (mine/chop/fish/herb): 4-8 ticks â”€â”€
      case 'gather':
        return ActionTimingSystem._gatherTiming(player, context);

      // â”€â”€ Planting: 3-5 ticks, reduced by farming â”€â”€
      case 'plant':
        return {
          ticks: ActionTimingSystem._reduceTicks(4, player, 'farming', 1),
          skill: 'farming',
          label: 'Planting...',
          icon: 'ğŸŒ±',
          instant: false
        };

      // â”€â”€ Harvesting: 2-4 ticks, reduced by farming â”€â”€
      case 'harvest':
        return {
          ticks: ActionTimingSystem._reduceTicks(3, player, 'farming', 1),
          skill: 'farming',
          label: 'Harvesting...',
          icon: 'ğŸŒ¾',
          instant: false
        };

      // â”€â”€ Taming: 4-8 ticks, reduced by taming â”€â”€
      case 'tame':
        return {
          ticks: ActionTimingSystem._reduceTicks(6, player, 'taming', 2),
          skill: 'taming',
          label: 'Taming...',
          icon: 'ğŸ¾',
          instant: false
        };

      // â”€â”€ Enchanting: 4-6 ticks â”€â”€
      case 'enchant':
        return {
          ticks: ActionTimingSystem._reduceTicks(5, player, 'magicDevice', 1),
          skill: 'magicDevice',
          label: 'Enchanting...',
          icon: 'âœ¨',
          instant: false
        };

      // â”€â”€ Praying: 3-5 ticks, reduced by faith â”€â”€
      case 'pray':
        return {
          ticks: ActionTimingSystem._reduceTicks(4, player, 'faith', 1),
          skill: 'faith',
          label: 'Praying...',
          icon: 'ğŸ™',
          instant: false
        };

      // â”€â”€ Offering: 2 ticks â”€â”€
      case 'offerItem':
        return {
          ticks: 2,
          skill: null,
          label: 'Offering...',
          icon: 'ğŸ™',
          instant: false
        };

      // â”€â”€ Sleeping: 8 ticks (long action) â”€â”€
      case 'sleep':
        return {
          ticks: 8,
          skill: null,
          label: 'Sleeping...',
          icon: 'ğŸ’¤',
          instant: false
        };

      // â”€â”€ Placing bed: 3 ticks â”€â”€
      case 'placeBed':
        return {
          ticks: 3,
          skill: null,
          label: 'Placing...',
          icon: 'ğŸ›',
          instant: false
        };

      // â”€â”€ Reviving pet: 3 ticks â”€â”€
      case 'revivePet':
        return {
          ticks: 3,
          skill: null,
          label: 'Reviving...',
          icon: 'ğŸ’«',
          instant: false
        };

      // â”€â”€ Use item: 2 ticks â”€â”€
      case 'use':
        return {
          ticks: 2,
          skill: null,
          label: 'Using...',
          icon: 'ğŸ’',
          instant: false
        };

      default:
        return { ticks: 1, skill: null, label: null, icon: null, instant: true };
    }
  }

  // â”€â”€ Internal: Reduce ticks based on skill level â”€â”€â”€â”€â”€
  // formula: max(minTicks, baseTicks - floor(skillLevel / divisor))
  static _reduceTicks(baseTicks, player, skillId, minTicks) {
    const skillLevel = player && player.skills ? (player.skills[skillId] || 0) : 0;
    const reduction = Math.floor(skillLevel / 5);
    return Math.max(minTicks, baseTicks - reduction);
  }

  // â”€â”€ Melee attack timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _meleeAttackTiming(player) {
    // Weapon-type skill (longSword, axe, etc.) reduces attack time
    let weaponSkill = 0;
    if (player && player.equipment && player.equipment.weapon) {
      const w = player.equipment.weapon;
      const skillMap = {
        'sword': 'longSword', 'axe': 'axe', 'scythe': 'scythe',
        'staff': 'staff', 'polearm': 'polearm', 'mace': 'mace',
        'shortSword': 'shortSword', 'dagger': 'shortSword'
      };
      const wSkillId = skillMap[w.subtype] || 'martialArt';
      weaponSkill = player.skills ? (player.skills[wSkillId] || 0) : 0;
    } else {
      weaponSkill = player && player.skills ? (player.skills.martialArt || 0) : 0;
    }
    const baseTicks = 3;
    const reduction = Math.floor(weaponSkill / 6);
    return {
      ticks: Math.max(1, baseTicks - reduction),
      skill: 'combat',
      label: 'Attacking...',
      icon: 'âš”',
      instant: Math.max(1, baseTicks - reduction) <= 1
    };
  }

  // â”€â”€ Spell cast timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _spellCastTiming(action, player) {
    const castingSkill = player && player.skills ? (player.skills.casting || 0) : 0;
    let spellLevel = 1;
    let spellName = 'spell';
    if (action.spellId && player && player.spells && player.spells[action.spellId]) {
      spellLevel = player.spells[action.spellId].skillLevel || 1;
      const def = typeof SPELL_DEFS !== 'undefined' ? SPELL_DEFS[action.spellId] : null;
      if (def) spellName = def.name;
    }
    // Higher spell difficulty = more base ticks, higher casting + spell level = fewer
    const baseTicks = 4 + Math.floor(spellLevel * 0.3);
    const reduction = Math.floor(castingSkill / 4) + Math.floor(spellLevel / 3);
    const ticks = Math.max(2, baseTicks - reduction);
    return {
      ticks,
      skill: 'casting',
      label: `Casting ${spellName}...`,
      icon: 'âœ¨',
      instant: false
    };
  }

  // â”€â”€ Craft timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _craftTiming(action, player) {
    let skill = 'crafting';
    if (action.recipeId && typeof RECIPE_DEFS !== 'undefined') {
      const recipe = RECIPE_DEFS[action.recipeId];
      if (recipe && recipe.skill) skill = recipe.skill;
    }
    return {
      ticks: ActionTimingSystem._reduceTicks(6, player, skill, 2),
      skill,
      label: 'Crafting...',
      icon: 'ğŸ”¨',
      instant: false
    };
  }

  // â”€â”€ Gather timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static _gatherTiming(player, context) {
    // Context can contain nodeType to pick the right skill
    const nodeSkillMap = {
      'ore': 'mining',
      'tree': 'lumberjacking',
      'fish': 'fishing',
      'herb': 'gathering'
    };
    const nodeType = context && context.nodeType ? context.nodeType : 'ore';
    const skill = nodeSkillMap[nodeType] || 'mining';
    const verbMap = {
      'ore': 'Mining...',
      'tree': 'Chopping...',
      'fish': 'Fishing...',
      'herb': 'Gathering...'
    };
    const iconMap = {
      'ore': 'â›',
      'tree': 'ğŸª“',
      'fish': 'ğŸ£',
      'herb': 'ğŸŒ¿'
    };
    return {
      ticks: ActionTimingSystem._reduceTicks(5, player, skill, 2),
      skill,
      label: verbMap[nodeType] || 'Gathering...',
      icon: iconMap[nodeType] || 'â›',
      instant: false
    };
  }
}

</script>
  <script>
// ============================================================
// CardSystem â€” Monster Card Collection (browser version)
// ============================================================

class CardSystem {
  // Card rarity tiers
  static RARITY = {
    NORMAL: 'normal',
    RARE: 'rare',
    SUPER_FOIL: 'superFoil'
  };

  static RARITY_INFO = {
    normal:    { name: 'Normal',     color: '#ccc',    border: '#666',    emoji: 'ğŸƒ', multiplier: 1 },
    rare:      { name: 'Rare',       color: '#ffd740', border: '#ffa000', emoji: 'âœ¨', multiplier: 3 },
    superFoil: { name: 'Super Foil', color: '#e040fb', border: '#aa00ff', emoji: 'ğŸŒŸ', multiplier: 10 }
  };

  // â”€â”€ Initialize player card collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static init(player) {
    if (!player.cardCollection) player.cardCollection = [];
    if (!player.cardStats) player.cardStats = { totalCollected: 0, totalSold: 0 };
  }

  // â”€â”€ Roll for card drop when a monster dies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static rollCardDrop(monster) {
    // 50% chance of dropping a card
    if (Math.random() > 0.50) return null;

    // Determine rarity
    const roll = Math.random();
    let rarity;
    if (roll < 0.005) {
      rarity = CardSystem.RARITY.SUPER_FOIL;  // 0.5% chance
    } else if (roll < 0.055) {
      rarity = CardSystem.RARITY.RARE;          // 5% chance
    } else {
      rarity = CardSystem.RARITY.NORMAL;         // 94.5% chance
    }

    return CardSystem.createCard(monster.templateId || monster.id, rarity);
  }

  // â”€â”€ Create a card object â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static createCard(monsterId, rarity) {
    const monsterDef = typeof MONSTER_TEMPLATES !== 'undefined' ? MONSTER_TEMPLATES[monsterId] : null;
    const name = monsterDef ? monsterDef.name : monsterId;
    const level = monsterDef ? monsterDef.level : 1;
    const race = monsterDef ? monsterDef.race : 'unknown';

    // Card value scales with monster level and rarity
    const rarityInfo = CardSystem.RARITY_INFO[rarity];
    const baseValue = 5 + (level * 3);
    const value = baseValue * rarityInfo.multiplier;

    return {
      id: typeof uuidv4 === 'function' ? uuidv4() : Math.random().toString(36).slice(2),
      type: 'monsterCard',
      monsterId: monsterId,
      monsterName: name,
      monsterLevel: level,
      monsterRace: race,
      rarity: rarity,
      rarityName: rarityInfo.name,
      value: value,
      char: monsterDef ? (monsterDef.char || 'M') : 'M',
      color: monsterDef ? (monsterDef.color || '#c33') : '#c33'
    };
  }

  // â”€â”€ Add card to player's collection (stacks duplicates) â”€â”€
  static addCard(player, card) {
    CardSystem.init(player);

    // Find existing stack (same monsterId + same rarity)
    const existing = player.cardCollection.find(
      c => c.monsterId === card.monsterId && c.rarity === card.rarity
    );

    if (existing) {
      existing.quantity = (existing.quantity || 1) + 1;
    } else {
      card.quantity = 1;
      player.cardCollection.push(card);
    }

    player.cardStats.totalCollected++;
    return card;
  }

  // â”€â”€ Remove cards from collection (for selling) â”€â”€â”€â”€â”€â”€
  static removeCard(player, cardIndex, count) {
    CardSystem.init(player);
    if (cardIndex < 0 || cardIndex >= player.cardCollection.length) return false;

    const card = player.cardCollection[cardIndex];
    const qty = card.quantity || 1;
    const removeCount = Math.min(count || 1, qty);

    if (removeCount >= qty) {
      player.cardCollection.splice(cardIndex, 1);
    } else {
      card.quantity = qty - removeCount;
    }
    return true;
  }

  // â”€â”€ Get collection display data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static getCollectionDisplay(player) {
    CardSystem.init(player);

    // Get all known monster IDs for completion tracking
    const allMonsterIds = typeof MONSTER_TEMPLATES !== 'undefined' ? Object.keys(MONSTER_TEMPLATES) : [];
    const collectedMonsterIds = new Set(player.cardCollection.map(c => c.monsterId));

    // Sort cards: by monster level, then rarity
    const rarityOrder = { superFoil: 0, rare: 1, normal: 2 };
    const sortedCards = [...player.cardCollection].sort((a, b) => {
      const levelDiff = (b.monsterLevel || 0) - (a.monsterLevel || 0);
      if (levelDiff !== 0) return levelDiff;
      return (rarityOrder[a.rarity] || 99) - (rarityOrder[b.rarity] || 99);
    });

    return {
      cards: sortedCards.map(c => ({
        ...c,
        rarityInfo: CardSystem.RARITY_INFO[c.rarity] || CardSystem.RARITY_INFO.normal
      })),
      totalUnique: collectedMonsterIds.size,
      totalMonsters: allMonsterIds.length,
      totalCards: player.cardCollection.reduce((sum, c) => sum + (c.quantity || 1), 0),
      stats: player.cardStats
    };
  }

  // â”€â”€ Card Shop: generate card merchant inventory â”€â”€â”€â”€â”€
  static generateCardShopInventory(player) {
    CardSystem.init(player);

    // Card merchant sells random cards the player might not have
    const allMonsterIds = typeof MONSTER_TEMPLATES !== 'undefined' ? Object.keys(MONSTER_TEMPLATES) : [];
    const collectedNormalIds = new Set(
      player.cardCollection
        .filter(c => c.rarity === CardSystem.RARITY.NORMAL)
        .map(c => c.monsterId)
    );

    // Offer 6-10 random cards, biased toward ones the player doesn't have
    const uncollected = allMonsterIds.filter(id => !collectedNormalIds.has(id));
    const collected = allMonsterIds.filter(id => collectedNormalIds.has(id));

    const shopCards = [];
    const shopSize = 6 + Math.floor(Math.random() * 5); // 6-10 cards

    for (let i = 0; i < shopSize; i++) {
      // 70% chance to offer uncollected cards if available
      let pool = (Math.random() < 0.7 && uncollected.length > 0) ? uncollected : allMonsterIds;
      const monsterId = pool[Math.floor(Math.random() * pool.length)];

      // 10% chance the shop sells a rare variant
      const rarity = Math.random() < 0.10 ? CardSystem.RARITY.RARE : CardSystem.RARITY.NORMAL;
      const card = CardSystem.createCard(monsterId, rarity);
      card.stock = 1;
      card.buyPrice = Math.ceil(card.value * 1.5); // Shop markup
      shopCards.push(card);
    }

    return shopCards;
  }

  // â”€â”€ Card Shop: buy a card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static buyCard(player, shopInventory, cardIndex) {
    if (cardIndex < 0 || cardIndex >= shopInventory.length) {
      return { success: false, message: 'Invalid card.' };
    }
    const shopCard = shopInventory[cardIndex];
    if (shopCard.stock <= 0) {
      return { success: false, message: 'That card is sold out.' };
    }

    const price = shopCard.buyPrice || Math.ceil(shopCard.value * 1.5);
    if (player.gold < price) {
      return { success: false, message: `Not enough gold. Need ${price}gp, have ${player.gold}gp.` };
    }

    player.gold -= price;
    shopCard.stock--;

    const newCard = CardSystem.createCard(shopCard.monsterId, shopCard.rarity);
    CardSystem.addCard(player, newCard);

    const rarityInfo = CardSystem.RARITY_INFO[shopCard.rarity];
    return {
      success: true,
      message: `Bought ${rarityInfo.emoji} ${shopCard.monsterName} (${rarityInfo.name}) card for ${price}gp!`
    };
  }

  // â”€â”€ Card Shop: sell a card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static sellCard(player, cardIndex) {
    CardSystem.init(player);
    if (cardIndex < 0 || cardIndex >= player.cardCollection.length) {
      return { success: false, message: 'Invalid card.' };
    }

    const card = player.cardCollection[cardIndex];
    const sellPrice = Math.max(1, Math.floor(card.value * 0.6));

    // Negotiation bonus
    const negotiation = player.skills ? (player.skills.negotiation || 0) : 0;
    const bonus = Math.floor(sellPrice * negotiation * 0.02);
    const finalPrice = sellPrice + bonus;

    player.gold += finalPrice;
    CardSystem.removeCard(player, cardIndex, 1);
    player.cardStats.totalSold++;

    const rarityInfo = CardSystem.RARITY_INFO[card.rarity];
    return {
      success: true,
      message: `Sold ${rarityInfo.emoji} ${card.monsterName} (${rarityInfo.name}) card for ${finalPrice}gp.${bonus > 0 ? ` (Bonus +${bonus}gp!)` : ''}`,
      price: finalPrice
    };
  }

  // â”€â”€ Death recap: get card collection summary â”€â”€â”€â”€â”€â”€â”€â”€
  static getDeathSummary(player) {
    CardSystem.init(player);
    const allMonsterIds = typeof MONSTER_TEMPLATES !== 'undefined' ? Object.keys(MONSTER_TEMPLATES) : [];
    const uniqueCollected = new Set(player.cardCollection.map(c => c.monsterId)).size;
    const totalCards = player.cardCollection.reduce((sum, c) => sum + (c.quantity || 1), 0);
    const rareCount = player.cardCollection.filter(c => c.rarity === 'rare').reduce((s, c) => s + (c.quantity || 1), 0);
    const foilCount = player.cardCollection.filter(c => c.rarity === 'superFoil').reduce((s, c) => s + (c.quantity || 1), 0);

    // Get top 3 rarest cards
    const rarityValue = { superFoil: 3, rare: 2, normal: 1 };
    const topCards = [...player.cardCollection]
      .sort((a, b) => (rarityValue[b.rarity] || 0) - (rarityValue[a.rarity] || 0) || (b.monsterLevel || 0) - (a.monsterLevel || 0))
      .slice(0, 5);

    return {
      uniqueCollected,
      totalMonsters: allMonsterIds.length,
      totalCards,
      rareCount,
      foilCount,
      topCards,
      completionPct: allMonsterIds.length > 0 ? Math.round((uniqueCollected / allMonsterIds.length) * 100) : 0,
      stats: player.cardStats
    };
  }
}

</script>
  <script>
// ============================================================
// SaveManager â€” LocalStorage-based save/load (browser)
// ============================================================

class SaveManager {
  static _storageKey(id) {
    return `elinclone_save_${id}`;
  }

  static _indexKey() {
    return 'elinclone_saves_index';
  }

  static _getIndex() {
    try {
      const raw = localStorage.getItem(SaveManager._indexKey());
      return raw ? JSON.parse(raw) : [];
    } catch {
      return [];
    }
  }

  static _setIndex(index) {
    localStorage.setItem(SaveManager._indexKey(), JSON.stringify(index));
  }

  static save(data) {
    const id = data.id || uuidv4();
    const saveData = {
      ...data,
      savedAt: new Date().toISOString()
    };
    localStorage.setItem(SaveManager._storageKey(id), JSON.stringify(saveData));

    // Update index
    const index = SaveManager._getIndex();
    const existing = index.findIndex(e => e.id === id);
    const entry = {
      id,
      playerName: data.player ? data.player.name : 'Unknown',
      level: data.player ? data.player.level : 0,
      turn: data.turn || 0,
      savedAt: saveData.savedAt
    };
    if (existing >= 0) {
      index[existing] = entry;
    } else {
      index.push(entry);
    }
    SaveManager._setIndex(index);

    return id;
  }

  static load(id) {
    try {
      const raw = localStorage.getItem(SaveManager._storageKey(id));
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {
      return null;
    }
  }

  static listSaves() {
    return SaveManager._getIndex();
  }

  static deleteSave(id) {
    localStorage.removeItem(SaveManager._storageKey(id));
    const index = SaveManager._getIndex().filter(e => e.id !== id);
    SaveManager._setIndex(index);
  }
}

</script>
  <script>
// ============================================================
// GameEngine â€” Master orchestrator (browser version)
// ============================================================

class GameEngine {
  constructor() {
    this.id = uuidv4();
    this.player = null;
    this.worldMap = null;
    this.currentMap = null;
    this.currentLocation = null;
    this.worldX = 10;
    this.worldY = 10;
    this.turn = 0;
    this.messages = [];
    this.mode = 'worldMap';
    this.timeWeather = new TimeWeather();
    this.nefiaSystem = new NefiaSystem();
    this.fogSystem = new FogOfWarSystem();
    this.nefiaFloor = 0;
    this.gameOver = false;
    this.fame = 0;
    this.karma = 0;
    this.townShops = [];
    this.activeShop = null;
    this.activeCardShop = null; // card merchant inventory when visiting card shop
    this.questBoard = [];  // quests available at current town's quest board
    this.homesteadMap = null; // persisted homestead map

    // Death recap tracking
    this.damageLog = [];       // recent damage events: { source, damage, turn }
    this.killCount = 0;        // total monsters killed
    this.deepestFloor = 0;     // deepest nefia floor reached
    this.locationsVisited = new Set(); // unique locations entered
  }

  // â”€â”€ Death Recap Tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _logDamage(source, damage) {
    this.damageLog.push({ source, damage, turn: this.turn });
    // Keep only the last 50 entries
    if (this.damageLog.length > 50) this.damageLog.shift();
  }

  _buildDeathRecap() {
    const recap = {
      killedBy: 'Unknown',
      lastHits: [],
      totalDamageTaken: 0,
      topDamageSources: [],
      turn: this.turn,
      floor: this.nefiaFloor || 0,
      location: this.currentLocation ? this.currentLocation.name : 'the Wilderness',
      locationType: this.currentLocation ? this.currentLocation.type : 'outdoor',
      killCount: this.killCount,
      deepestFloor: this.deepestFloor,
      locationsVisited: this.locationsVisited.size,
      playerLevel: this.player.level,
      playerRace: this.player.race.name,
      playerClass: this.player.cls.name,
      fame: this.fame,
      karma: this.karma,
      gold: this.player.gold || 0,
      timeAlive: this.timeWeather.getState().timeString || '',
      cardSummary: CardSystem.getDeathSummary(this.player)
    };

    if (this.damageLog.length > 0) {
      // Last hit is the killer
      const lastHit = this.damageLog[this.damageLog.length - 1];
      recap.killedBy = lastHit.source;

      // Show last 5 damage events (most recent first)
      recap.lastHits = this.damageLog.slice(-5).reverse().map(e => ({
        source: e.source,
        damage: e.damage,
        turn: e.turn
      }));

      // Aggregate damage by source
      const sourceMap = {};
      for (const entry of this.damageLog) {
        if (!sourceMap[entry.source]) sourceMap[entry.source] = 0;
        sourceMap[entry.source] += entry.damage;
        recap.totalDamageTaken += entry.damage;
      }
      recap.topDamageSources = Object.entries(sourceMap)
        .map(([source, total]) => ({ source, total }))
        .sort((a, b) => b.total - a.total)
        .slice(0, 5);
    }

    return recap;
  }

  // â”€â”€ Create New Game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  createNewGame(data) {
    const raceId = data.raceId || data.race || 'yerles';
    const classId = data.classId || data.class || 'warrior';
    const name = data.name || 'Adventurer';
    const race = RACES[raceId];
    const cls = CLASSES[classId];
    if (!race || !cls) throw new Error('Invalid race or class');

    this.player = CharacterSystem.createPlayer(name, race, cls);
    this.worldMap = MapGenerator.generateWorldMap();
    const home = WORLD_LOCATIONS.homestead;
    this.worldX = home.x;
    this.worldY = home.y;
    this.mode = 'worldMap';
    this.karma = 0;
    this.fame = 0;
    ItemSystem.giveStartingItems(this.player);
    MagicSystem.initSpells(this.player);
    PetSystem.init(this.player);
    FaithSystem.init(this.player);
    this.player.quests = [];
    this.addMessage(`Welcome to the Ashen Reaches, ${name}! Your adventure begins.`);
  }

  // â”€â”€ Process Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  processAction(action) {
    if (this.gameOver) return { ok: false, msg: 'Game Over' };
    const result = { ok: true, events: [] };

    switch (action.type) {
      case 'move':
        this._handleMove(action, result);
        break;
      case 'attack':
        this._handleAttack(action, result);
        break;
      case 'use':
        this._handleUseItem(action, result);
        break;
      case 'pickup':
        this._handlePickup(action, result);
        break;
      case 'drop':
        this._handleDrop(action, result);
        break;
      case 'wait':
        this._advanceTurn(result);
        break;
      case 'enterLocation':
        this._handleEnterLocation(action, result);
        break;
      case 'exitToWorldMap':
        this._handleExitToWorldMap(result);
        break;
      case 'descend':
        this._handleDescend(result);
        break;
      case 'ascend':
        this._handleAscend(result);
        break;
      case 'eat':
        this._handleEat(action, result);
        break;
      case 'equip':
        this._handleEquip(action, result);
        break;
      case 'castSpell':
        this._handleCastSpell(action, result);
        break;
      case 'readSpellbook':
        this._handleReadSpellbook(action, result);
        break;
      case 'plant':
        this._handlePlant(action, result);
        break;
      case 'harvest':
        this._handleHarvest(action, result);
        break;
      case 'shopBuy':
        this._handleShopBuy(action, result);
        break;
      case 'shopSell':
        this._handleShopSell(action, result);
        break;
      case 'closeShop':
        this._handleCloseShop(action, result);
        break;
      case 'craft':
        this._handleCraft(action, result);
        break;
      case 'rangedAttack':
        this._handleRangedAttack(action, result);
        break;
      case 'acceptQuest':
        this._handleAcceptQuest(action, result);
        break;
      case 'turnInQuest':
        this._handleTurnInQuest(action, result);
        break;
      case 'abandonQuest':
        this._handleAbandonQuest(action, result);
        break;
      case 'tame':
        this._handleTame(action, result);
        break;
      case 'releasePet':
        this._handleReleasePet(action, result);
        break;
      case 'renamePet':
        this._handleRenamePet(action, result);
        break;
      case 'revivePet':
        this._handleRevivePet(action, result);
        break;
      case 'gather':
        this._handleGather(action, result);
        break;
      case 'enchant':
        this._handleEnchant(action, result);
        break;
      case 'pray':
        this._handlePray(action, result);
        break;
      case 'worship':
        this._handleWorship(action, result);
        break;
      case 'offerItem':
        this._handleOfferItem(action, result);
        break;
      case 'cardShopBuy':
        this._handleCardShopBuy(action, result);
        break;
      case 'cardShopSell':
        this._handleCardShopSell(action, result);
        break;
      case 'sleep':
        this._handleSleep(action, result);
        break;
      case 'placeBed':
        this._handlePlaceBed(action, result);
        break;
      case 'placeWorkshop':
        this._handlePlaceWorkshop(action, result);
        break;
      case 'placeFurniture':
        this._handlePlaceFurniture(action, result);
        break;
      case 'pickupFurniture':
        this._handlePickupFurniture(action, result);
        break;
      case 'readRecipe':
        this._handleReadRecipe(action, result);
        break;
      default:
        result.ok = false;
        result.msg = 'Unknown action';
    }
    return result;
  }

  // â”€â”€ Movement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleMove(action, result) {
    const { dx, dy } = action;
    if (this.mode === 'worldMap') {
      const nx = this.worldX + dx;
      const ny = this.worldY + dy;
      if (nx < 0 || ny < 0 || nx >= this.worldMap[0].length || ny >= this.worldMap.length) {
        result.ok = false;
        result.msg = 'Edge of the world';
        return;
      }
      this.worldX = nx;
      this.worldY = ny;
      // 3 hours per tile, reduced by Travel skill (min 30 min)
      const travelTime = Math.max(30, 180 - (this.player.skills.travel || 0) * 3);
      this.timeWeather.advanceMinutes(travelTime);
      this._advanceTurn(result);

      const loc = Object.values(WORLD_LOCATIONS).find(l => l.x === nx && l.y === ny);
      if (loc) {
        this.addMessage(`You see ${loc.name} nearby. (Press Enter to enter)`);
        result.events.push({ type: 'nearLocation', location: loc });
      }

      if (!loc && Math.random() < 0.08) {
        this.addMessage('Robbers block your path!');
        this._enterOutdoorMap(result);
      }
    } else {
      const px = this.player.x + dx;
      const py = this.player.y + dy;
      if (!this.currentMap) return;
      const outOfBounds = px < 0 || py < 0 || px >= this.currentMap.width || py >= this.currentMap.height;
      const onEdge = !outOfBounds && (px === 0 || py === 0 || px === this.currentMap.width - 1 || py === this.currentMap.height - 1);

      // Non-dungeon maps: exit by reaching the map border
      if ((outOfBounds || onEdge) && this.currentLocation && this.currentLocation.type !== 'nefia') {
        this.addMessage('You leave the area.');
        this._handleExitToWorldMap(result);
        return;
      }
      if (outOfBounds) {
        result.ok = false;
        return;
      }
      const tile = this.currentMap.tiles[py][px];
      if (!tile.walkable) {
        result.ok = false;
        result.msg = 'Blocked';
        return;
      }
      const monster = this.currentMap.monsters.find(m => m.x === px && m.y === py && m.hp > 0);
      if (monster) {
        const combatResult = CombatSystem.meleeAttack(this.player, monster);
        this.addMessage(combatResult.message);
        if (monster.hp <= 0) {
          monster._processed = true;
          this.addMessage(`You defeated ${monster.name}!`);
          const xpGain = monster.xp || 10;
          CharacterSystem.gainExp(this.player, xpGain);
          this.fame += Math.floor(xpGain / 5);
          result.events.push({ type: 'kill', monster: monster.name, xp: xpGain });
          const drops = ItemSystem.generateDrops(monster);
          drops.forEach(item => {
            this.currentMap.items.push({ ...item, x: monster.x, y: monster.y });
          });
          this._onMonsterKilled(monster);
        }
        this._advanceTurn(result);
        return;
      }

      // Don't walk onto your own pet â€” swap positions instead
      const petOnTile = PetSystem.getPetAt(this.player, px, py);
      if (petOnTile) {
        // Swap positions with the pet
        const oldPx = this.player.x;
        const oldPy = this.player.y;
        this.player.x = px;
        this.player.y = py;
        petOnTile.x = oldPx;
        petOnTile.y = oldPy;
        this._advanceTurn(result);
        return;
      }

      this.player.x = px;
      this.player.y = py;

      const groundItems = this.currentMap.items.filter(i => i.x === px && i.y === py);
      if (groundItems.length > 0) {
        this.addMessage(`You see: ${groundItems.map(i => i.name).join(', ')}`);
      }
      const currentTile = this.currentMap.tiles[py][px];
      if (currentTile.npc) {
        if (currentTile.npc.questBoard) {
          this.addMessage('You see the Quest Board. (Press Q to browse quests)');
          result.events.push({ type: 'openQuestBoard' });
        } else if (currentTile.npc.cardMerchant) {
          // Open card shop
          this.activeCardShop = CardSystem.generateCardShopInventory(this.player);
          this.addMessage('Card Merchant: "Greetings, collector! Browse my cards or sell your duplicates."');
          result.events.push({ type: 'openCardShop' });
        } else {
          const shop = this.townShops.find(s => s.id === currentTile.npc.shopId);
          if (shop) {
            this.activeShop = shop;
            this.addMessage(`${currentTile.npc.name}: "Welcome to the ${currentTile.npc.shopName}! Browse my wares."`);
            result.events.push({ type: 'openShop', shopId: shop.id });
          } else if (currentTile.npc.dialogue) {
            // Ambient NPC with random dialogue
            const lines = currentTile.npc.dialogue;
            const line = lines[Math.floor(Math.random() * lines.length)];
            this.addMessage(`${currentTile.npc.name}: "${line}"`);
          }
        }
      } else {
        if (this.activeShop) {
          this.activeShop = null;
        }
        if (this.activeCardShop) {
          this.activeCardShop = null;
        }
      }
      if (tile.type === 'stairsDown') {
        this.addMessage('You see stairs leading down. (Press > to descend)');
      } else if (tile.type === 'stairsUp') {
        this.addMessage('You see stairs leading up. (Press < to ascend)');
      }

      // Altar detection
      if (tile.altar || tile.type === 'shrine') {
        const godName = this.player.faith && this.player.faith.godId
          ? (GOD_DEFS[this.player.faith.godId] ? GOD_DEFS[this.player.faith.godId].name : 'your god')
          : null;
        if (godName) {
          this.addMessage(`You stand at the altar. Press R to pray to ${godName}, or open the Faith tab to worship a different god.`);
        } else {
          this.addMessage('You stand at a sacred altar. Open the Faith tab to choose a god to worship.');
        }
        result.events.push({ type: 'onAltar' });
      }

      this._advanceTurn(result);
    }
  }

  _handleAttack(action, result) {
    const { targetId } = action;
    const monster = this.currentMap && this.currentMap.monsters.find(m => m.id === targetId && m.hp > 0);
    if (!monster) { result.ok = false; return; }
    const combatResult = CombatSystem.meleeAttack(this.player, monster);
    this.addMessage(combatResult.message);
    if (monster.hp <= 0) {
      monster._processed = true;
      this.addMessage(`You defeated ${monster.name}!`);
      const xpGain = monster.xp || 10;
      CharacterSystem.gainExp(this.player, xpGain);
      this.fame += Math.floor(xpGain / 5);
      const drops = ItemSystem.generateDrops(monster);
      drops.forEach(item => {
        this.currentMap.items.push({ ...item, x: monster.x, y: monster.y });
      });
      this._onMonsterKilled(monster);
    }
    this._advanceTurn(result);
  }

  _handleUseItem(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : this.player.inventory.findIndex(i => i.id === action.itemId);
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    const useResult = ItemSystem.useItem(this.player, item);
    this.addMessage(useResult.message);
    if (useResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    this._advanceTurn(result);
  }

  _handleEat(action, result) {
    let idx = -1;
    if (action.itemIndex != null) {
      idx = action.itemIndex;
    } else if (action.itemId) {
      idx = this.player.inventory.findIndex(i => i.id === action.itemId && (i.type === 'food'));
    } else {
      idx = this.player.inventory.findIndex(i => i.type === 'food');
    }
    if (idx === -1 || idx >= this.player.inventory.length) { result.ok = false; result.msg = 'No food to eat'; return; }
    const item = this.player.inventory[idx];
    if (item.type !== 'food') { result.ok = false; result.msg = 'That is not food'; return; }
    this.player.nutrition = Math.min(10000, this.player.nutrition + (item.nutrition || 1000));
    if (item.healHP) this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.healHP);
    ItemSystem.removeFromInventory(this.player, idx, 1);
    this.addMessage(`You eat the ${item.name}. Nutrition restored.`);
    this._advanceTurn(result);
  }

  _handlePickup(action, result) {
    if (!this.currentMap) return;
    const { x, y } = this.player;
    const idx = this.currentMap.items.findIndex(i => i.x === x && i.y === y);
    if (idx === -1) { result.ok = false; result.msg = 'Nothing here'; return; }
    const item = this.currentMap.items.splice(idx, 1)[0];
    delete item.x;
    delete item.y;
    // Convert gold coins directly to player gold
    if (item.type === 'currency') {
      this.player.gold = (this.player.gold || 0) + (item.value || 1);
      this.addMessage(`Picked up ${item.name}.`);
      return;
    }
    ItemSystem.addToInventory(this.player, item);
    this.addMessage(`Picked up ${item.name}.`);
    // Check gather quests
    const gatherMsgs = QuestSystem.checkGatherQuests(this.player);
    gatherMsgs.forEach(m => this.addMessage(m.text));
  }

  _handleDrop(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : this.player.inventory.findIndex(i => i.id === action.itemId);
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = ItemSystem.removeFromInventory(this.player, idx, 1);
    if (!item) { result.ok = false; return; }
    if (this.currentMap) {
      item.x = this.player.x;
      item.y = this.player.y;
      this.currentMap.items.push(item);
    }
    this.addMessage(`Dropped ${item.name}.`);
  }

  _handleEquip(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    const equipResult = ItemSystem.equipItem(this.player, item);
    this.addMessage(equipResult.message);
  }

  _handleReadSpellbook(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    if (item.type !== 'spellbook') {
      this.addMessage('That is not a spellbook.');
      result.ok = false;
      return;
    }
    MagicSystem.initSpells(this.player);
    const readResult = MagicSystem.readSpellbook(this.player, item);
    this.addMessage(readResult.message);
    if (readResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    this._advanceTurn(result);
  }

  _handleCastSpell(action, result) {
    const spellId = action.spellId;
    if (!spellId) { result.ok = false; return; }
    MagicSystem.initSpells(this.player);

    const hpBefore = this.player.hp;
    const castResult = MagicSystem.castSpell(this.player, spellId, {});
    if (!castResult.success) {
      this.addMessage(castResult.message);
      result.ok = false;
      return;
    }
    // Track mana overflow damage
    if (this.player.hp < hpBefore) {
      this._logDamage('Mana Overflow', hpBefore - this.player.hp);
    }
    this.addMessage(castResult.message);

    if (castResult.type === 'bolt' && this.currentMap) {
      const target = MagicSystem.findNearestMonster(
        this.player, this.currentMap.monsters, castResult.range
      );
      if (target) {
        const hitResult = MagicSystem.applyBoltToTarget(target, castResult.damage);
        this.addMessage(hitResult.message);
        if (hitResult.killed) {
          target._processed = true;
          const xpGain = target.xp || 10;
          CharacterSystem.gainExp(this.player, xpGain);
          this.fame += Math.floor(xpGain / 5);
          const drops = ItemSystem.generateDrops(target);
          drops.forEach(item => {
            this.currentMap.items.push({ ...item, x: target.x, y: target.y });
          });
          this._onMonsterKilled(target);
        }
      } else {
        this.addMessage('The spell finds no target.');
      }
    } else if (castResult.type === 'ball' && this.currentMap) {
      const target = MagicSystem.findNearestMonster(
        this.player, this.currentMap.monsters, castResult.range
      );
      const cx = target ? target.x : this.player.x;
      const cy = target ? target.y : this.player.y;
      const hits = MagicSystem.applyBallToArea(
        this.currentMap.monsters, cx, cy, castResult.radius, castResult.damage
      );
      if (hits.length > 0) {
        hits.forEach(h => {
          this.addMessage(`${h.name} takes ${h.damage} damage!${h.killed ? ' Destroyed!' : ''}`);
          if (h.killed) {
            const m = this.currentMap.monsters.find(m2 => m2.name === h.name && m2.hp <= 0 && !m2._processed);
            if (m) {
              m._processed = true;
              const xpGain = m.xp || 10;
              CharacterSystem.gainExp(this.player, xpGain);
              this.fame += Math.floor(xpGain / 5);
              const drops = ItemSystem.generateDrops(m);
              drops.forEach(item => {
                this.currentMap.items.push({ ...item, x: m.x, y: m.y });
              });
              this._onMonsterKilled(m);
            }
          }
        });
      } else {
        this.addMessage('The spell explodes harmlessly.');
      }
    } else if (castResult.type === 'teleport' && this.currentMap) {
      const walkable = [];
      for (let y = 0; y < this.currentMap.height; y++) {
        for (let x = 0; x < this.currentMap.width; x++) {
          if (this.currentMap.tiles[y][x].walkable) {
            const blocked = this.currentMap.monsters.some(m => m.hp > 0 && m.x === x && m.y === y);
            if (!blocked) walkable.push({ x, y });
          }
        }
      }
      if (walkable.length > 0) {
        const dest = walkable[Math.floor(Math.random() * walkable.length)];
        this.player.x = dest.x;
        this.player.y = dest.y;
        this.addMessage(`You teleport to a new location!`);
      }
    }

    if (this.player.hp <= 0) {
      this.addMessage('The mana overflow kills you...');
      this.gameOver = true;
      result.events.push({ type: 'death' });
      return;
    }

    // Faith favor for spell casting
    const castFaithMsgs = FaithSystem.onAction(this.player, 'casting', {});
    castFaithMsgs.forEach(m => this.addMessage(m));
    if (castResult.type === 'heal') {
      const healFaithMsgs = FaithSystem.onAction(this.player, 'castHeal', {});
      healFaithMsgs.forEach(m => this.addMessage(m));
    }

    this._advanceTurn(result);
  }

  _handlePlant(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot plant here'; return; }
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }
    const item = this.player.inventory[idx];
    if (item.type !== 'seed') {
      this.addMessage('That is not a seed.');
      result.ok = false;
      return;
    }
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    const season = this.timeWeather.getSeason();
    const plantResult = FarmingSystem.plantSeed(this.player, item, tile, season);
    this.addMessage(plantResult.message);
    if (plantResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    if (plantResult.success) {
      tile.crop.plantedTurn = this.turn;
    }
    this._advanceTurn(result);
  }

  _handleHarvest(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot harvest here'; return; }
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    const harvestResult = FarmingSystem.harvestCrop(this.player, tile);
    this.addMessage(harvestResult.message);
    if (harvestResult.success && harvestResult.items) {
      harvestResult.items.forEach(item => {
        ItemSystem.addToInventory(this.player, item);
      });
      this.addMessage(`Collected: ${harvestResult.items.map(i => i.name).join(', ')}`);
    }
    this._advanceTurn(result);
  }

  _handleShopBuy(action, result) {
    if (!this.activeShop) { result.ok = false; result.msg = 'No shop open'; return; }
    const buyResult = ShopSystem.buyItem(this.player, this.activeShop, action.itemId);
    this.addMessage(buyResult.message);
    if (!buyResult.success) result.ok = false;
  }

  _handleShopSell(action, result) {
    if (!this.activeShop) { result.ok = false; result.msg = 'No shop open'; return; }
    const sellResult = ShopSystem.sellItem(this.player, this.activeShop, action.itemIndex);
    this.addMessage(sellResult.message);
    if (!sellResult.success) result.ok = false;
  }

  _handleCloseShop(action, result) {
    this.activeShop = null;
    this.addMessage('You leave the shop.');
  }

  _handleCardShopBuy(action, result) {
    if (!this.activeCardShop) { result.ok = false; result.msg = 'No card shop open'; return; }
    const buyResult = CardSystem.buyCard(this.player, this.activeCardShop, action.cardIndex);
    this.addMessage(buyResult.message);
    if (!buyResult.success) result.ok = false;
  }

  _handleCardShopSell(action, result) {
    if (!this.activeCardShop) { result.ok = false; result.msg = 'No card shop open'; return; }
    const sellResult = CardSystem.sellCard(this.player, action.cardIndex);
    this.addMessage(sellResult.message);
    if (!sellResult.success) result.ok = false;
  }

  _handleCraft(action, result) {
    const nearbyWorkshops = CraftingSystem.getNearbyWorkshops(this.player, this.currentMap);
    const craftResult = CraftingSystem.craft(this.player, action.recipeId, nearbyWorkshops);
    this.addMessage(craftResult.message);
    if (!craftResult.success) result.ok = false;
    else {
      // Faith favor for crafting
      const craftFaithMsgs = FaithSystem.onAction(this.player, 'crafting', {});
      craftFaithMsgs.forEach(m => this.addMessage(m));
    }
    this._advanceTurn(result);
  }

  // â”€â”€ Place Workshop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePlaceWorkshop(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const invIdx = action.invIndex;
    const item = this.player.inventory[invIdx];
    if (!item || item.subtype !== 'workshop') {
      this.addMessage('That is not a workshop.');
      result.ok = false;
      return;
    }
    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
    if (!tile || !tile.walkable) {
      this.addMessage('You cannot place a workshop here.');
      result.ok = false;
      return;
    }
    if (tile.workshop) {
      this.player.inventory.push({ ...tile.workshop, x: undefined, y: undefined });
      this.addMessage(`You pick up the ${tile.workshop.name}.`);
    }
    tile.workshop = {
      id: item.id,
      templateId: item.templateId || item.id,
      name: item.name,
      workshopType: item.workshopType,
      char: item.char || 'Ï€',
      color: item.color || '#8a6a3a'
    };
    this.player.inventory.splice(invIdx, 1);
    this.addMessage(`You place the ${item.name}.`);
    this._advanceTurn(result);
  }

  // â”€â”€ Read Recipe Paper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleReadRecipe(action, result) {
    const idx = action.itemIndex;
    const item = this.player.inventory[idx];
    if (!item || item.type !== 'recipePaper') {
      this.addMessage('That is not a recipe paper.');
      result.ok = false;
      return;
    }
    const readResult = CraftingSystem.readRecipePaper(this.player, item.recipeId);
    this.addMessage(readResult.message);
    if (readResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    this._advanceTurn(result);
  }

  _handleRangedAttack(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const weapon = this.player.equipment ? this.player.equipment.weapon : null;
    if (!weapon || !weapon.ranged) {
      this.addMessage('You need a ranged weapon equipped to shoot.');
      result.ok = false;
      return;
    }
    const range = 8;
    let target = null;
    if (action.targetId) {
      target = this.currentMap.monsters.find(m => m.id === action.targetId && m.hp > 0);
    } else if (action.dx !== undefined && action.dy !== undefined) {
      target = MagicSystem.findBoltTarget(this.player, this.currentMap.monsters, action.dx, action.dy, range);
    } else {
      target = MagicSystem.findNearestMonster(this.player, this.currentMap.monsters, range);
    }
    if (!target) {
      this.addMessage('No target in range.');
      result.ok = false;
      return;
    }
    const combatResult = CombatSystem.rangedAttack(this.player, target, weapon);
    this.addMessage(combatResult.message);
    if (target.hp <= 0) {
      target._processed = true;
      this.addMessage(`You defeated ${target.name}!`);
      const xpGain = target.xp || 10;
      CharacterSystem.gainExp(this.player, xpGain);
      this.fame += Math.floor(xpGain / 5);
      const drops = ItemSystem.generateDrops(target);
      drops.forEach(item => {
        this.currentMap.items.push({ ...item, x: target.x, y: target.y });
      });
      this._onMonsterKilled(target);
    }
    CharacterSystem.gainSkillExp(this.player, 'marksman', 5);
    this._advanceTurn(result);
  }

  // â”€â”€ Location Entry / Exit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleEnterLocation(action, result) {
    const locId = action.locationId;
    const loc = WORLD_LOCATIONS[locId];
    const atLoc = loc || Object.values(WORLD_LOCATIONS).find(l => l.x === this.worldX && l.y === this.worldY);
    if (!atLoc) {
      // No named location â€” enter the wilderness / outdoor tile
      this._enterOutdoorMap(result);
      return;
    }

    this.currentLocation = atLoc;
    if (atLoc.type === 'home') {
      // Homestead: use persisted map if available
      if (this.homesteadMap) {
        this.currentMap = this.homesteadMap;
      } else {
        this.currentMap = MapGenerator.generateTownMap(atLoc);
        this.homesteadMap = this.currentMap;
      }
      this.townShops = [];
    } else if (atLoc.type === 'town') {
      this.currentMap = MapGenerator.generateTownMap(atLoc);
      this.townShops = ShopSystem.generateTownShops(atLoc);
      ShopSystem.restockShops(this.townShops);
      this._placeShopNPCs();
      // Place card merchant
      this._placeCardMerchant();
      // Generate quest board for this town
      this.questBoard = QuestSystem.generateBoardQuests(atLoc.id, this.player.level);
      this._placeQuestBoard();
      // Place altar for god worship
      this._placeAltar();
      // Place ambient NPCs (guards, townsfolk, etc.)
      this._placeAmbientNPCs(atLoc);
      // Check delivery quests
      const deliveryMsgs = QuestSystem.onEnterTown(this.player, atLoc.id);
      deliveryMsgs.forEach(m => this.addMessage(m.text));
    } else if (atLoc.type === 'nefia') {
      this.nefiaFloor = 1;
      this.currentMap = this.nefiaSystem.generateFloor(atLoc, 1);
    }
    // Spawn on the appropriate stair tile when entering a nefia to avoid walls
    if (atLoc.type === 'nefia' && this.currentMap.stairsUpX != null && this.currentMap.stairsUpY != null) {
      this.player.x = this.currentMap.stairsUpX;
      this.player.y = this.currentMap.stairsUpY;
    } else {
      this.player.x = Math.floor(this.currentMap.width / 2);
      this.player.y = this.currentMap.height - 2;
    }
    this.mode = 'localMap';
    this.addMessage(`You enter ${atLoc.name}.`);
    this.locationsVisited.add(atLoc.id);
    // Place pets near the player
    PetSystem.placePetsOnMap(this.player, this.currentMap);
    // Initialize fog of war for this map
    this._updateFog();
  }

  _enterOutdoorMap(result) {
    const biome = this.worldMap[this.worldY][this.worldX];
    this.currentLocation = { id: 'outdoor', type: 'outdoor', name: `${biome.name} wilderness`, danger: biome.dangerMod + 3 };
    this.currentMap = MapGenerator.generateOutdoorMap(biome, this.currentLocation.danger);
    this.player.x = Math.floor(this.currentMap.width / 2);
    this.player.y = Math.floor(this.currentMap.height / 2);
    this.mode = 'localMap';
    this.addMessage(`You enter the ${biome.name} wilderness.`);
    PetSystem.placePetsOnMap(this.player, this.currentMap);
    // Initialize fog of war for outdoor encounter
    this._updateFog();
  }

  _handleExitToWorldMap(result) {
    // Save fog state before leaving
    if (this.currentMap && this.fogSystem.fogMap) {
      FogOfWarSystem.saveFogToCache(this._getFogMapKey(), this.fogSystem);
    }
    // Persist homestead map
    if (this.currentLocation && this.currentLocation.type === 'home' && this.currentMap) {
      this.homesteadMap = this.currentMap;
    }
    this.currentMap = null;
    this.currentLocation = null;
    this.nefiaFloor = 0;
    this.mode = 'worldMap';
    this.townShops = [];
    this.activeShop = null;
    this.activeCardShop = null;
    this.cardMerchantPos = null;
    this.questBoard = [];
    this.questBoardPos = null;
    this.ambientNPCs = [];
    this.addMessage('You return to the world map.');
  }

  _placeShopNPCs() {
    if (!this.currentMap || !this.townShops || this.townShops.length === 0) return;
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        if (this.currentMap.tiles[y][x].type === 'floor') {
          floorTiles.push({ x, y });
        }
      }
    }
    const used = new Set();
    this.townShops.forEach(shop => {
      for (const tile of floorTiles) {
        const key = `${tile.x},${tile.y}`;
        if (!used.has(key)) {
          shop.x = tile.x;
          shop.y = tile.y;
          used.add(key);
          this.currentMap.tiles[tile.y][tile.x].npc = {
            shopId: shop.id,
            name: shop.npcName,
            char: shop.char,
            color: shop.color,
            shopName: shop.name
          };
          break;
        }
      }
    });
  }

  _placeQuestBoard() {
    if (!this.currentMap || !this.questBoard || this.questBoard.length === 0) return;
    // Find a floor tile that isn't occupied by an NPC
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }
    if (floorTiles.length === 0) return;
    const spot = floorTiles[Math.floor(Math.random() * floorTiles.length)];
    this.currentMap.tiles[spot.y][spot.x].npc = {
      questBoard: true,
      name: 'Quest Board',
      char: 'ğŸ“œ',
      color: '#ffa',
      shopName: 'Quest Board'
    };
    this.questBoardPos = { x: spot.x, y: spot.y };
  }

  _placeCardMerchant() {
    if (!this.currentMap) return;
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }
    if (floorTiles.length === 0) return;
    const spot = floorTiles[Math.floor(Math.random() * floorTiles.length)];
    this.currentMap.tiles[spot.y][spot.x].npc = {
      cardMerchant: true,
      name: 'Card Merchant',
      char: '\uD83C\uDCCF',
      color: '#e040fb',
      shopName: 'Card Shop'
    };
    this.cardMerchantPos = { x: spot.x, y: spot.y };
  }

  _placeAltar() {
    if (!this.currentMap) return;
    // Find a floor tile that isn't occupied by an NPC or quest board
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }
    if (floorTiles.length === 0) return;
    const spot = floorTiles[Math.floor(Math.random() * floorTiles.length)];
    const tile = this.currentMap.tiles[spot.y][spot.x];
    tile.type = 'shrine';
    tile.altar = true;
    tile.walkable = true;
    tile.char = 'â€ ';
    tile.color = '#d0d050';
    this.altarPos = { x: spot.x, y: spot.y };
  }

  _placeAmbientNPCs(location) {
    if (!this.currentMap || !location.ambientNPCs || location.ambientNPCs.length === 0) return;
    this.ambientNPCs = [];

    // Collect walkable tiles that aren't occupied (grass or road, not inside buildings)
    const openTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.walkable && !tile.npc && (tile.type === 'grass' || tile.type === 'road' || tile.type === 'stoneFloor')) {
          openTiles.push({ x, y });
        }
      }
    }
    if (openTiles.length === 0) return;

    // Also collect floor tiles inside buildings for indoor NPCs
    const floorTiles = [];
    for (let y = 2; y < this.currentMap.height - 2; y++) {
      for (let x = 2; x < this.currentMap.width - 2; x++) {
        const tile = this.currentMap.tiles[y][x];
        if (tile.type === 'floor' && !tile.npc) {
          floorTiles.push({ x, y });
        }
      }
    }

    const used = new Set();
    // Place each ambient NPC definition
    for (const npcDef of location.ambientNPCs) {
      // 60% chance outdoor, 40% chance indoor (if floor tiles exist)
      const useIndoor = floorTiles.length > 0 && Math.random() < 0.4;
      const pool = useIndoor ? floorTiles : openTiles;
      if (pool.length === 0) continue;

      // Try to find an unused spot
      let spot = null;
      for (let tries = 0; tries < 50; tries++) {
        const candidate = pool[Math.floor(Math.random() * pool.length)];
        const key = `${candidate.x},${candidate.y}`;
        if (!used.has(key)) {
          spot = candidate;
          used.add(key);
          break;
        }
      }
      if (!spot) continue;

      const npcData = {
        name: npcDef.name,
        char: npcDef.char,
        color: npcDef.color,
        dialogue: npcDef.dialogue
      };

      this.currentMap.tiles[spot.y][spot.x].npc = npcData;
      this.ambientNPCs.push({ x: spot.x, y: spot.y, ...npcData });
    }
  }

  _handleDescend(result) {
    if (!this.currentMap) return;
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    if (tile.type !== 'stairsDown') { result.ok = false; result.msg = 'No stairs here'; return; }
    if (this.currentLocation && this.currentLocation.type === 'nefia') {
      // Save fog state before changing floors
      if (this.fogSystem.fogMap) {
        FogOfWarSystem.saveFogToCache(this._getFogMapKey(), this.fogSystem);
      }
      this.nefiaFloor++;
      const maxFloors = this.currentLocation.floors || 10;
      if (this.nefiaFloor > maxFloors) {
        this.addMessage('You have conquered this Nefia!');
        this.fame += 50;
        this.karma += 5;
        this._handleExitToWorldMap(result);
        return;
      }
      this.currentMap = this.nefiaSystem.generateFloor(this.currentLocation, this.nefiaFloor);
      this.player.x = this.currentMap.stairsUpX || 1;
      this.player.y = this.currentMap.stairsUpY || 1;
      this.addMessage(`You descend to floor ${this.nefiaFloor}.`);
      if (this.nefiaFloor > this.deepestFloor) this.deepestFloor = this.nefiaFloor;
      // Notify explore quests
      const exploreMsgs = QuestSystem.onNefiaFloorReached(this.player, this.currentLocation.id, this.nefiaFloor);
      exploreMsgs.forEach(m => this.addMessage(m.text));
      PetSystem.placePetsOnMap(this.player, this.currentMap);
      // Reset fog for new floor (try loading from cache)
      const fogKey = this._getFogMapKey();
      if (!FogOfWarSystem.loadFogFromCache(fogKey, this.fogSystem)) {
        this.fogSystem.init(this.currentMap.width, this.currentMap.height, fogKey);
      }
      this._updateFog();
    }
  }

  _handleAscend(result) {
    if (!this.currentMap) return;
    const tile = this.currentMap.tiles[this.player.y][this.player.x];
    if (tile.type !== 'stairsUp') { result.ok = false; result.msg = 'No stairs here'; return; }
    if (this.nefiaFloor <= 1) {
      this._handleExitToWorldMap(result);
      return;
    }
    // Save fog state before changing floors
    if (this.fogSystem.fogMap) {
      FogOfWarSystem.saveFogToCache(this._getFogMapKey(), this.fogSystem);
    }
    this.nefiaFloor--;
    this.currentMap = this.nefiaSystem.generateFloor(this.currentLocation, this.nefiaFloor);
    this.player.x = this.currentMap.stairsDownX || this.currentMap.width - 2;
    this.player.y = this.currentMap.stairsDownY || this.currentMap.height - 2;
    this.addMessage(`You ascend to floor ${this.nefiaFloor}.`);
    PetSystem.placePetsOnMap(this.player, this.currentMap);
    // Reset fog for this floor (try loading from cache)
    const fogKey = this._getFogMapKey();
    if (!FogOfWarSystem.loadFogFromCache(fogKey, this.fogSystem)) {
      this.fogSystem.init(this.currentMap.width, this.currentMap.height, fogKey);
    }
    this._updateFog();
  }

  // â”€â”€ Sleep System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleSleep(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot sleep here.'; return; }

    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];

    // Determine comfort level: check for bed on current tile, then ground sleeping
    let comfort = 5; // 5% = bare ground
    let bedName = 'the bare ground';

    if (tile && tile.bed) {
      comfort = tile.bed.comfort || comfort;
      bedName = tile.bed.name || 'a bed';
    }

    // Check if there are hostile monsters nearby (within 5 tiles)
    const nearbyHostile = this.currentMap.monsters.some(m => {
      if (m.hp <= 0 || m.isPet || m._tamed) return false;
      const dist = Math.abs(m.x - this.player.x) + Math.abs(m.y - this.player.y);
      return dist <= 5;
    });
    if (nearbyHostile) {
      this.addMessage('You cannot sleep with enemies nearby!');
      result.ok = false;
      return;
    }

    // Sleeping advances time by 7 hours (420 minutes = 420 turns)
    const sleepTurns = 420;
    for (let i = 0; i < sleepTurns; i++) {
      this.turn++;
      this.timeWeather.advanceTurn();
      // Nutrition still drains while sleeping (at half rate)
      if (i % 2 === 0) {
        this.player.nutrition = Math.max(0, this.player.nutrition - 1);
      }
      // Farming still ticks
      if (this.currentMap && i % 10 === 0) {
        const season = this.timeWeather.getSeason();
        FarmingSystem.tickCrops(this.currentMap, season, this.timeWeather.weather);
      }
    }

    // HP and MP fully restored
    this.player.hp = this.player.maxHp;
    this.player.mp = this.player.maxMp;

    // SP restored based on comfort level (0-100%)
    const spRecovery = Math.floor(this.player.maxSp * (comfort / 100));
    this.player.sp = Math.min(this.player.maxSp, this.player.sp + spRecovery);

    // Messages
    this.addMessage(`You sleep on ${bedName} for 7 hours.`);
    this.addMessage('You feel well rested. HP and MP fully restored!');
    if (comfort > 0) {
      this.addMessage(`Sleep comfort: ${comfort}%. SP restored by ${spRecovery}.`);
    } else {
      this.addMessage('Sleeping on the ground provides no SP recovery.');
    }

    // Recipe dreaming â€” chance to learn a recipe while sleeping (max 1 per sleep)
    const dreamedRecipe = CraftingSystem.tryLearnRecipeFromSleep(this.player);
    if (dreamedRecipe) {
      this.addMessage(`ğŸ’­ In your dreams, you envision how to make: ${dreamedRecipe.name}!`);
    }
  }

  // â”€â”€ Place Bed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePlaceBed(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const invIdx = action.invIndex;
    const item = this.player.inventory[invIdx];
    if (!item || item.type !== 'furniture' || item.subtype !== 'bed') {
      this.addMessage('That is not a bed.');
      result.ok = false;
      return;
    }

    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
    if (!tile || !tile.walkable) {
      this.addMessage('You cannot place a bed here.');
      result.ok = false;
      return;
    }

    // Remove any existing bed on this tile
    if (tile.bed) {
      // Return old bed to inventory
      this.player.inventory.push({
        ...tile.bed,
        x: undefined, y: undefined
      });
      this.addMessage(`You pick up the ${tile.bed.name}.`);
    }

    // Place the bed
    tile.bed = {
      id: item.id,
      templateId: item.templateId || item.id,
      name: item.name,
      comfort: item.comfort || 0,
      char: item.char || '\u2261',
      color: item.color || '#a07040'
    };

    // Remove from inventory
    this.player.inventory.splice(invIdx, 1);
    this.addMessage(`You place the ${item.name}. (Comfort: ${item.comfort}%)`);
    this._advanceTurn(result);
  }

  // â”€â”€ Place Decoration Furniture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePlaceFurniture(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const invIdx = action.invIndex;
    const item = this.player.inventory[invIdx];
    if (!item || item.type !== 'furniture' || item.subtype !== 'decoration') {
      this.addMessage('That is not a placeable furniture item.');
      result.ok = false;
      return;
    }

    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
    if (!tile || !tile.walkable) {
      this.addMessage('You cannot place furniture here.');
      result.ok = false;
      return;
    }

    // Remove any existing furniture on this tile
    if (tile.furniture) {
      this.player.inventory.push({
        ...tile.furniture,
        x: undefined, y: undefined
      });
      this.addMessage(`You pick up the ${tile.furniture.name}.`);
    }

    // Place the furniture
    tile.furniture = {
      id: item.id,
      templateId: item.templateId || item.id,
      name: item.name,
      beauty: item.beauty || 0,
      char: item.char || 'â–¡',
      color: item.color || '#a07040',
      lightRadius: item.lightRadius || 0,
      type: item.type,
      subtype: item.subtype,
      description: item.description || ''
    };

    this.player.inventory.splice(invIdx, 1);
    const beautyText = item.beauty ? ` (Beauty: ${item.beauty})` : '';
    this.addMessage(`You place the ${item.name}.${beautyText}`);
    this._advanceTurn(result);
  }

  // â”€â”€ Pick Up Furniture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePickupFurniture(action, result) {
    if (!this.currentMap) { result.ok = false; return; }
    const tile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];

    if (tile && tile.furniture) {
      const furn = tile.furniture;
      const newItem = ItemSystem.createItem(furn.templateId || furn.id);
      if (newItem) {
        ItemSystem.addToInventory(this.player, newItem);
      } else {
        this.player.inventory.push({ ...furn, x: undefined, y: undefined });
      }
      this.addMessage(`You pick up the ${furn.name}.`);
      tile.furniture = null;
      this._advanceTurn(result);
      return;
    }

    this.addMessage('There is no furniture here to pick up.');
    result.ok = false;
  }

  // â”€â”€ Turn Advancement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _advanceTurn(result) {
    this.turn++;
    this.timeWeather.advanceTurn();

    this.player.nutrition = Math.max(0, this.player.nutrition - 2);
    if (this.player.nutrition <= 0) {
      this.player.hp -= 2;
      this._logDamage('Starvation', 2);
      if (this.turn % 10 === 0) this.addMessage('You are starving!');
    }

    if (this.player.skills.regeneration > 0 && this.turn % 5 === 0) {
      this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.floor(this.player.skills.regeneration / 3) + 1);
    }
    if (this.player.skills.meditation > 0 && this.turn % 5 === 0) {
      this.player.mp = Math.min(this.player.maxMp, this.player.mp + Math.floor(this.player.skills.meditation / 3) + 1);
    }
    // SP no longer regenerates passively â€” only through sleeping

    const expired = MagicSystem.tickBuffs(this.player);
    if (expired && expired.length > 0) {
      expired.forEach(b => this.addMessage(`The effect of ${b.name} wears off.`));
    }

    // Recipe learning from skill practice
    if (this.player._skillXpGainedThisTurn && this.player._skillXpGainedThisTurn.length > 0) {
      const uniqueSkills = [...new Set(this.player._skillXpGainedThisTurn)];
      for (const sid of uniqueSkills) {
        const learned = CraftingSystem.tryLearnRecipeFromSkill(this.player, sid);
        if (learned) {
          const sdef = SKILL_DEFS[sid];
          this.addMessage(`While practicing ${sdef ? sdef.name : sid}, you figure out: ${learned.name}!`);
        }
      }
      this.player._skillXpGainedThisTurn = [];
    }

    // Faith system tick (prayer cooldown)
    FaithSystem.tick(this.player);

    // Faith regen bonuses
    const faithBonuses = FaithSystem.getBlessingBonuses(this.player);
    if (faithBonuses.hpRegen > 0 && this.turn % 5 === 0) {
      this.player.hp = Math.min(this.player.maxHp, this.player.hp + faithBonuses.hpRegen);
    }
    if (faithBonuses.mpRegen > 0 && this.turn % 5 === 0) {
      this.player.mp = Math.min(this.player.maxMp, this.player.mp + faithBonuses.mpRegen);
    }

    if (this.currentMap) {
      const season = this.timeWeather.getSeason();
      const cropMsgs = FarmingSystem.tickCrops(this.currentMap, season, this.timeWeather.weather);
      cropMsgs.forEach(m => this.addMessage(m.text));
    }

    if (this.currentMap && this.currentMap.monsters) {
      for (const m of this.currentMap.monsters) {
        if (m.hp <= 0) continue;
        this._monsterTurn(m, result);
      }
    }

    // Pet turns: pets attack enemies and follow the player
    if (this.currentMap) {
      PetSystem.petTurn(this.player, this.currentMap, (msg) => this.addMessage(msg));
      // Check for pet kills (monsters killed by pets generate drops)
      if (this.currentMap.monsters) {
        for (const m of this.currentMap.monsters) {
          if (m.hp <= 0 && !m._processed) {
            m._processed = true;
            const drops = ItemSystem.generateDrops(m);
            drops.forEach(item => {
              this.currentMap.items.push({ ...item, x: m.x, y: m.y });
            });
            this._onMonsterKilled(m);
          }
        }
      }
    }

    // Pet regen (1 HP every turn)
    if (this.turn % 3 === 0) {
      PetSystem.regenPets(this.player);
    }

    // Check for dead pets
    PetSystem.init(this.player);
    for (const pet of this.player.pets) {
      if (pet.hp <= 0 && !pet._deathNotified) {
        pet._deathNotified = true;
        this.addMessage(`${pet.name} has fallen! Visit a town to revive them. ğŸ’€`);
      }
    }

    if (this.player.hp <= 0) {
      // Check for divine death save (Ehekatl's Nine Lives)
      const deathSave = FaithSystem.checkDeathSave(this.player);
      if (deathSave.saved) {
        this.addMessage(deathSave.message);
      } else {
        this.addMessage('You have died...');
        this.gameOver = true;
        result.events.push({ type: 'death' });
      }
    }

    // Update fog of war after all entities have moved
    this._updateFog();
  }

  _monsterTurn(monster, result) {
    // Find the closest target: player or a living pet
    let targetX = this.player.x;
    let targetY = this.player.y;
    let targetObj = this.player;
    let distToPlayer = Math.abs(this.player.x - monster.x) + Math.abs(this.player.y - monster.y);
    let bestDist = distToPlayer;

    // Check if any pet is closer
    PetSystem.init(this.player);
    for (const pet of this.player.pets) {
      if (pet.hp <= 0) continue;
      const petDist = Math.abs(pet.x - monster.x) + Math.abs(pet.y - monster.y);
      if (petDist < bestDist) {
        bestDist = petDist;
        targetX = pet.x;
        targetY = pet.y;
        targetObj = pet;
      }
    }

    const dx = targetX - monster.x;
    const dy = targetY - monster.y;
    const dist = Math.abs(dx) + Math.abs(dy);

    if (dist <= 1) {
      if (targetObj === this.player) {
        const combatResult = CombatSystem.meleeAttack(monster, this.player);
        this.addMessage(combatResult.message);
        if (combatResult.hit && combatResult.damage > 0) {
          this._logDamage(monster.name, combatResult.damage);
        }
      } else {
        // Monster attacks a pet
        let damage = CombatSystem.rollDice(monster.attack || '1d3');
        damage = Math.max(1, damage);
        const killed = PetSystem.damagePet(targetObj, damage);
        this.addMessage(`${monster.name} hits ${targetObj.name} for ${damage} damage.`);
      }
    } else if (dist < 8) {
      const mx = dx === 0 ? 0 : dx / Math.abs(dx);
      const my = dy === 0 ? 0 : dy / Math.abs(dy);
      const nx = monster.x + mx;
      const ny = monster.y + my;
      if (nx >= 0 && ny >= 0 && nx < this.currentMap.width && ny < this.currentMap.height) {
        const tile = this.currentMap.tiles[ny][nx];
        const blocked = this.currentMap.monsters.some(m2 => m2 !== monster && m2.hp > 0 && m2.x === nx && m2.y === ny);
        if (tile.walkable && !blocked && !(nx === this.player.x && ny === this.player.y)) {
          // Also don't step on pets
          const petBlocked = PetSystem.isPetAt(this.player, nx, ny);
          if (!petBlocked) {
            monster.x = nx;
            monster.y = ny;
          }
        }
      }
    }
  }

  // â”€â”€ Quest Hooks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onMonsterKilled(monster) {
    this.killCount++;
    const questMsgs = QuestSystem.onMonsterKilled(this.player, monster);
    questMsgs.forEach(m => this.addMessage(m.text));
    // Also check gather quests (monster drops may complete them)
    const gatherMsgs = QuestSystem.checkGatherQuests(this.player);
    gatherMsgs.forEach(m => this.addMessage(m.text));
    // Faith favor for kills
    const faithMsgs = FaithSystem.onAction(this.player, 'meleeKill', { monster });
    faithMsgs.forEach(m => this.addMessage(m));
    // Card drop
    const card = CardSystem.rollCardDrop(monster);
    if (card) {
      CardSystem.addCard(this.player, card);
      const ri = CardSystem.RARITY_INFO[card.rarity];
      this.addMessage(`${ri.emoji} Obtained card: ${card.monsterName} (${ri.name})!`);
    }
  }

  _handleAcceptQuest(action, result) {
    const quest = this.questBoard.find(q => q.id === action.questId);
    if (!quest) { result.ok = false; result.msg = 'Quest not found on board'; return; }
    const acceptResult = QuestSystem.acceptQuest(this.player, quest, this.turn);
    this.addMessage(acceptResult.message);
    if (!acceptResult.success) result.ok = false;
    // Remove from board
    if (acceptResult.success) {
      this.questBoard = this.questBoard.filter(q => q.id !== action.questId);
    }
  }

  _handleTurnInQuest(action, result) {
    const townId = this.currentLocation ? this.currentLocation.id : null;
    const turnInResult = QuestSystem.turnInQuest(this.player, action.questId, townId);
    this.addMessage(turnInResult.message);
    if (turnInResult.success) {
      if (turnInResult.fame) this.fame += turnInResult.fame;
      if (turnInResult.karma) this.karma += turnInResult.karma;
    } else {
      result.ok = false;
    }
  }

  _handleAbandonQuest(action, result) {
    const abandonResult = QuestSystem.abandonQuest(this.player, action.questId);
    this.addMessage(abandonResult.message);
    if (!abandonResult.success) result.ok = false;
  }

  // â”€â”€ Gathering / Mining â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleGather(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot gather here'; return; }

    const node = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
    if (!node) {
      this.addMessage('No resource node nearby. (Stand next to a tree, ore vein, herb patch, bush, or other resource)');
      result.ok = false;
      return;
    }

    const gatherResult = GatheringSystem.gather(
      this.player, node.tile, this.currentMap, node.x, node.y
    );
    if (gatherResult.skillUsed) {
      node.tile._depletedTurn = this.turn;
    }
    this.addMessage(gatherResult.message);

    if (gatherResult.success && gatherResult.items.length > 0) {
      gatherResult.items.forEach(item => {
        ItemSystem.addToInventory(this.player, item);
      });
      const names = gatherResult.items.map(i => i.name).join(', ');
      this.addMessage(`Obtained: ${names}`);
      // Check gather quests
      try {
        const gatherMsgs = QuestSystem.checkGatherQuests(this.player);
        gatherMsgs.forEach(m => this.addMessage(m.text));
      } catch (e) { /* quest system may not be active */ }
      // Faith favor for gathering
      const gatherFaithMsgs = FaithSystem.onAction(this.player, 'gathering', {});
      gatherFaithMsgs.forEach(m => this.addMessage(m));
    }

    this._advanceTurn(result);
  }

  // â”€â”€ Enchanting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleEnchant(action, result) {
    const scrollIdx = action.scrollIndex;
    const targetIdx = action.targetIndex;
    if (scrollIdx == null || targetIdx == null) { result.ok = false; result.msg = 'Missing enchant parameters'; return; }
    if (scrollIdx < 0 || scrollIdx >= this.player.inventory.length) { result.ok = false; return; }
    if (targetIdx < 0 || targetIdx >= this.player.inventory.length) { result.ok = false; return; }

    const scroll = this.player.inventory[scrollIdx];
    const target = this.player.inventory[targetIdx];

    const enchantResult = EnchantSystem.enchant(this.player, target, scroll);
    this.addMessage(enchantResult.message);

    if (enchantResult.consumed) {
      // Remove the scroll (adjust targetIdx if scroll was before target)
      ItemSystem.removeFromInventory(this.player, scrollIdx, 1);
    }

    if (enchantResult.destroyed) {
      // Find the target item again (index may have shifted)
      const newTargetIdx = this.player.inventory.findIndex(i => i.id === target.id);
      if (newTargetIdx >= 0) {
        // Unequip if equipped
        if (this.player.equipment) {
          Object.keys(this.player.equipment).forEach(slot => {
            if (this.player.equipment[slot] && this.player.equipment[slot].id === target.id) {
              this.player.equipment[slot] = null;
            }
          });
        }
        ItemSystem.removeFromInventory(this.player, newTargetIdx, 1);
      }
    }

    this._advanceTurn(result);
  }

  // â”€â”€ Faith / God Worship â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handlePray(action, result) {
    FaithSystem.init(this.player);
    const prayResult = FaithSystem.pray(this.player);
    if (prayResult.messages) {
      prayResult.messages.forEach(m => this.addMessage(m));
    } else {
      this.addMessage(prayResult.message);
    }
    if (prayResult.success) {
      this._advanceTurn(result);
    } else {
      result.ok = false;
    }
  }

  _handleWorship(action, result) {
    const godId = action.godId;
    if (!godId) { result.ok = false; result.msg = 'No god selected'; return; }

    // Must be standing on an altar tile
    if (this.currentMap) {
      const tile = this.currentMap.tiles[this.player.y][this.player.x];
      if (!tile.altar && tile.type !== 'shrine') {
        this.addMessage('You must stand at an altar to worship a god.');
        result.ok = false;
        return;
      }
    }

    const worshipResult = FaithSystem.worship(this.player, godId);
    if (worshipResult.messages) {
      worshipResult.messages.forEach(m => this.addMessage(m));
    } else {
      this.addMessage(worshipResult.message);
    }
    if (!worshipResult.success) result.ok = false;
  }

  _handleOfferItem(action, result) {
    const idx = action.itemIndex != null ? action.itemIndex : -1;
    if (idx < 0 || idx >= this.player.inventory.length) { result.ok = false; return; }

    // Must be on an altar
    if (this.currentMap) {
      const tile = this.currentMap.tiles[this.player.y][this.player.x];
      if (!tile.altar && tile.type !== 'shrine') {
        this.addMessage('You must stand at an altar to make an offering.');
        result.ok = false;
        return;
      }
    }

    const item = this.player.inventory[idx];
    const offerResult = FaithSystem.offerItem(this.player, item);
    if (offerResult.messages) {
      offerResult.messages.forEach(m => this.addMessage(m));
    } else {
      this.addMessage(offerResult.message);
    }
    if (offerResult.consumed) {
      ItemSystem.removeFromInventory(this.player, idx, 1);
    }
    if (offerResult.success) {
      this._advanceTurn(result);
    } else {
      result.ok = false;
    }
  }

  // â”€â”€ Pet Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _handleTame(action, result) {
    if (!this.currentMap) { result.ok = false; result.msg = 'Cannot tame here'; return; }
    PetSystem.init(this.player);

    // Find an adjacent hostile monster to tame
    let target = null;
    if (action.targetId) {
      target = this.currentMap.monsters.find(m => m.id === action.targetId && m.hp > 0 && !m._tamed);
    } else {
      // Auto-target nearest adjacent hostile monster
      const adj = [
        { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
        { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
      ];
      let bestDist = Infinity;
      for (const m of this.currentMap.monsters) {
        if (m.hp <= 0 || m._tamed || m.isPet) continue;
        const dist = Math.abs(m.x - this.player.x) + Math.abs(m.y - this.player.y);
        if (dist <= 1 && dist < bestDist) {
          bestDist = dist;
          target = m;
        }
      }
    }

    if (!target) {
      this.addMessage('No creature nearby to tame. (Stand adjacent to a monster)');
      result.ok = false;
      return;
    }

    const tameResult = PetSystem.attemptTame(this.player, target);
    this.addMessage(tameResult.message);

    if (tameResult.success) {
      // Remove tamed monster from the hostile monster list
      this.currentMap.monsters = this.currentMap.monsters.filter(m => !m._tamed);
      result.events.push({ type: 'petTamed', name: target.name });
    }

    this._advanceTurn(result);
  }

  _handleReleasePet(action, result) {
    const releaseResult = PetSystem.releasePet(this.player, action.petId);
    this.addMessage(releaseResult.message);
    if (!releaseResult.success) result.ok = false;
  }

  _handleRenamePet(action, result) {
    const renameResult = PetSystem.renamePet(this.player, action.petId, action.newName || 'Pet');
    this.addMessage(renameResult.message);
    if (!renameResult.success) result.ok = false;
  }

  _handleRevivePet(action, result) {
    const reviveResult = PetSystem.revivePet(this.player, action.petId);
    this.addMessage(reviveResult.message);
    if (!reviveResult.success) result.ok = false;
  }

  // â”€â”€ Messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  addMessage(msg) {
    this.messages.push({ turn: this.turn, text: msg, time: this.timeWeather.getTimeString() });
    if (this.messages.length > 100) this.messages.shift();
  }

  // â”€â”€ Fog of War â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _updateFog() {
    if (!this.currentMap || this.mode !== 'localMap') return;

    const locType = this.currentLocation ? this.currentLocation.type : 'outdoor';
    const timeState = this.timeWeather.getState();
    const mapKey = this._getFogMapKey();

    // Initialize fog for this map if needed
    this.fogSystem.init(this.currentMap.width, this.currentMap.height, mapKey);

    // If daytime and not underground, reveal everything as seen
    if (FogOfWarSystem.shouldRevealAll(locType, timeState)) {
      this.fogSystem.revealAllAsSeen();
    }

    // Calculate visibility range and update visible tiles
    const visRange = FogOfWarSystem.computeVisibilityRange(
      this.player, timeState, locType
    );
    this.fogSystem.update(
      this.player.x, this.player.y, visRange, this.currentMap.tiles
    );
  }

  _getFogMapKey() {
    const locId = this.currentLocation ? this.currentLocation.id : 'outdoor';
    return this.nefiaFloor > 0 ? `${locId}-${this.nefiaFloor}` : locId;
  }

  // â”€â”€ Client State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getClientState() {
    let dv = 0, pv = 0;
    if (this.player.equipment) {
      Object.values(this.player.equipment).forEach(item => {
        if (item && item.DV) dv += item.DV;
        if (item && item.PV) pv += item.PV;
        // Add enchantment bonuses
        dv += EnchantSystem.getEnchantDV(item);
        pv += EnchantSystem.getEnchantPV(item);
      });
    }
    if (this.player.skills && this.player.skills.evasion) {
      dv += Math.floor(this.player.skills.evasion / 3);
    }

    MagicSystem.initSpells(this.player);
    const buffBonuses = MagicSystem.getBuffBonuses(this.player);
    dv += buffBonuses.dv;
    pv += buffBonuses.pv;

    // Faith blessing bonuses
    FaithSystem.init(this.player);
    const faithBonuses = FaithSystem.getBlessingBonuses(this.player);
    dv += faithBonuses.dv;
    pv += faithBonuses.pv;

    const weaponItem = this.player.equipment ? this.player.equipment.weapon : null;
    const bodyItem = this.player.equipment ? this.player.equipment.body : null;

    const state = {
      id: this.id,
      mode: this.mode,
      turn: this.turn,
      gameOver: this.gameOver,
      dead: this.gameOver,
      deathRecap: this.gameOver ? this._buildDeathRecap() : null,
      fame: this.fame,
      karma: this.karma,
      time: this.timeWeather.getState(),
      weather: this.timeWeather.weather,
      messages: this.messages.slice(-20),
      player: {
        name: this.player.name,
        raceName: this.player.race.name,
        className: this.player.cls.name,
        level: this.player.level,
        exp: this.player.xp,
        expNext: this.player.xpNext,
        hp: this.player.hp,
        maxHp: this.player.maxHp,
        mp: this.player.mp,
        maxMp: this.player.maxMp,
        sp: this.player.sp,
        maxSp: this.player.maxSp,
        nutrition: this.player.nutrition,
        attributes: this.player.attributes,
        skills: this.player.skills,
        inventory: this.player.inventory,
        equipment: {
          weapon: weaponItem ? weaponItem.id : null,
          weaponName: weaponItem ? weaponItem.name : null,
          armor: bodyItem ? bodyItem.id : null,
          armorName: bodyItem ? bodyItem.name : null
        },
        x: this.player.x,
        y: this.player.y,
        gold: this.player.gold,
        feat: this.player.feat,
        speed: this.player.speed + buffBonuses.speed + faithBonuses.speed,
        dv,
        pv,
        spells: MagicSystem.getSpellList(this.player),
        buffs: (this.player.buffs || []).map(b => ({ type: b.type, name: b.name, turnsLeft: b.turnsLeft }))
      }
    };

    if (this.mode === 'worldMap') {
      state.worldMap = this.worldMap;
      state.worldX = this.worldX;
      state.worldY = this.worldY;
      state.locations = WORLD_LOCATIONS;
    } else if (this.mode === 'localMap' && this.currentMap) {
      // Include world map data for minimap rendering
      state.worldMap = this.worldMap;
      state.worldX = this.worldX;
      state.worldY = this.worldY;
      state.locations = WORLD_LOCATIONS;
      const locType = this.currentLocation ? this.currentLocation.type : 'outdoor';
      const timeState = this.timeWeather.getState();
      const fogActive = FogOfWarSystem.shouldUseFog(locType, timeState);

      state.localMap = {
        width: this.currentMap.width,
        height: this.currentMap.height,
        tiles: this.currentMap.tiles,
        monsters: this.currentMap.monsters.filter(m => m.hp > 0).map(m => ({
          id: m.id, templateId: m.templateId, name: m.name, x: m.x, y: m.y, hp: m.hp, maxHp: m.maxHp, level: m.level, char: m.char || 'M', color: m.color || '#c33', isBoss: m.isBoss || false
        })),
        items: this.currentMap.items.map(i => ({ id: i.id, templateId: i.templateId, name: i.name, type: i.type, subtype: i.subtype, slot: i.slot, x: i.x, y: i.y, char: i.char || '!', color: i.color || '#dd0', healMP: i.healMP })),
        locationName: this.currentLocation ? this.currentLocation.name : 'Wilderness',
        locationType: locType,
        fogActive: fogActive,
        fogMap: fogActive ? this.fogSystem.fogMap : null,
        visRange: fogActive ? FogOfWarSystem.computeVisibilityRange(this.player, timeState, locType) : 0
      };
      state.nefiaFloor = this.nefiaFloor;
      const playerTile = this.currentMap.tiles[this.player.y] && this.currentMap.tiles[this.player.y][this.player.x];
      if (playerTile && playerTile.crop) {
        state.cropInfo = FarmingSystem.getCropInfo(playerTile);
      }
      if (playerTile && playerTile.furniture) {
        state.furnitureInfo = {
          name: playerTile.furniture.name,
          beauty: playerTile.furniture.beauty || 0,
          description: playerTile.furniture.description || ''
        };
      }
      // Check for nearby gatherable nodes
      const nearbyNode = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
      if (nearbyNode) {
        state.gatherNode = GatheringSystem.getNodeInfo(nearbyNode.tile);
      }
    }

    if (this.activeShop) {
      state.shop = ShopSystem.getShopDisplay(this.activeShop);
    }

    // Card collection & card shop
    CardSystem.init(this.player);
    state.cardCollection = CardSystem.getCollectionDisplay(this.player);
    if (this.activeCardShop) {
      state.cardShop = this.activeCardShop;
    }

    if (this.mode === 'localMap') {
      state.npcs = [];
      // Add shop NPCs
      if (this.townShops && this.townShops.length > 0) {
        for (const s of this.townShops) {
          state.npcs.push({
            x: s.x, y: s.y, char: s.char, color: s.color, name: s.npcName, npcName: s.npcName, shopName: s.name
          });
        }
      }
      // Add card merchant NPC
      if (this.cardMerchantPos) {
        state.npcs.push({
          x: this.cardMerchantPos.x, y: this.cardMerchantPos.y,
          char: 'ğŸƒ', color: '#e040fb', name: 'Card Merchant', npcName: 'Card Merchant', shopName: 'Card Shop'
        });
      }
      // Add quest board NPC to the npcs list
      if (this.questBoardPos) {
        state.npcs.push({
          x: this.questBoardPos.x, y: this.questBoardPos.y,
          char: 'ğŸ“œ', color: '#ffa', name: 'Quest Board', npcName: 'Quest Board', shopName: 'Quest Board'
        });
      }
      // Add altar to the npcs list for rendering
      if (this.altarPos) {
        state.npcs.push({
          x: this.altarPos.x, y: this.altarPos.y,
          char: 'â€ ', color: '#d0d050', name: 'Altar', npcName: 'Altar', shopName: 'Altar'
        });
      }
      // Add ambient NPCs to the npcs list for rendering
      if (this.ambientNPCs && this.ambientNPCs.length > 0) {
        for (const npc of this.ambientNPCs) {
          state.npcs.push({
            x: npc.x, y: npc.y,
            char: npc.char, color: npc.color,
            name: npc.name, npcName: npc.name, shopName: ''
          });
        }
      }
    }

    const nearbyWorkshops = this.currentMap ? CraftingSystem.getNearbyWorkshops(this.player, this.currentMap) : new Set();
    state.recipes = CraftingSystem.getAvailableRecipes(this.player, nearbyWorkshops);
    state.nearbyWorkshops = Array.from(nearbyWorkshops);
    state.knownRecipeCount = this.player.knownRecipes ? this.player.knownRecipes.length : 0;
    state.totalRecipeCount = Object.keys(RECIPE_DEFS).length;

    // Quest data
    state.activeQuests = QuestSystem.getActiveQuests(this.player);
    state.completedQuestCount = QuestSystem.getCompletedQuests(this.player).length;
    state.questBoard = this.questBoard || [];
    state.currentTownId = this.currentLocation ? this.currentLocation.id : null;
    // Check if player is standing on quest board
    if (this.questBoardPos && this.player.x === this.questBoardPos.x && this.player.y === this.questBoardPos.y) {
      state.onQuestBoard = true;
    }

    const rangedWeapon = this.player.equipment ? this.player.equipment.weapon : null;
    if (rangedWeapon && rangedWeapon.ranged) {
      state.player.hasRangedWeapon = true;
    }

    // Pet data
    PetSystem.init(this.player);
    state.pets = PetSystem.getPetList(this.player);
    state.maxPets = PetSystem.getMaxPets(this.player);

    // Faith data
    state.faith = FaithSystem.getState(this.player);
    // Check if player is standing on an altar
    if (this.currentMap && this.player.y < this.currentMap.height && this.player.x < this.currentMap.width) {
      const playerTile2 = this.currentMap.tiles[this.player.y][this.player.x];
      if (playerTile2 && (playerTile2.altar || playerTile2.type === 'shrine')) {
        state.onAltar = true;
        state.altarGodId = playerTile2.altarGodId || null;
      }
    }

    // â”€â”€ Context Actions â€” what the player can do right now â”€â”€
    state.contextActions = this._getContextActions();

    return state;
  }

  // â”€â”€ Context Action Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _getContextActions() {
    const actions = [];

    // â”€ Always available â”€
    actions.push({ key: '.', label: 'Wait', action: 'wait', icon: 'â³', always: true });

    if (this.mode === 'worldMap') {
      // World-map specific
      const loc = Object.values(WORLD_LOCATIONS).find(l => l.x === this.worldX && l.y === this.worldY);
      if (loc) {
        actions.push({ key: 'Enter', label: `Enter ${loc.name}`, action: 'enterLocation', icon: 'ğŸšª', highlight: true });
      } else {
        const biome = this.worldMap && this.worldMap[this.worldY] && this.worldMap[this.worldY][this.worldX];
        const biomeName = biome ? biome.name : 'Wilderness';
        actions.push({ key: 'Enter', label: `Enter ${biomeName}`, action: 'enterLocation', icon: 'ğŸŒ¿', highlight: false });
      }
      actions.push({ key: 'Ctrl+S', label: 'Save', action: 'save', icon: 'ğŸ’¾', always: true });
      return actions;
    }

    // â”€ Local map actions â”€
    if (!this.currentMap) return actions;

    const px = this.player.x;
    const py = this.player.y;
    const tile = this.currentMap.tiles[py] && this.currentMap.tiles[py][px];

    // Pickup: items on ground
    const groundItems = this.currentMap.items.filter(i => i.x === px && i.y === py);
    if (groundItems.length > 0) {
      const itemName = groundItems.length === 1 ? groundItems[0].name : `${groundItems.length} items`;
      actions.push({ key: 'G', label: `Get (${itemName})`, action: 'pickup', icon: 'ğŸ“¦', highlight: true });
    }

    // Eat: have food in inventory
    const hasFood = this.player.inventory.some(i => i.type === 'food');
    if (hasFood) {
      actions.push({ key: 'E', label: 'Eat', action: 'eat', icon: 'ğŸ–' });
    }

    // Descend / Ascend stairs
    if (tile) {
      if (tile.type === 'stairsDown') {
        actions.push({ key: '>', label: 'Descend', action: 'descend', icon: 'â¬‡', highlight: true });
      }
      if (tile.type === 'stairsUp') {
        actions.push({ key: '<', label: 'Ascend', action: 'ascend', icon: 'â¬†', highlight: true });
      }
    }

    // Tame: adjacent monster
    const adjDirs = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
      { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
    ];
    const adjacentMonster = this.currentMap.monsters.find(m => {
      if (m.hp <= 0 || m._tamed || m.isPet) return false;
      return Math.abs(m.x - px) <= 1 && Math.abs(m.y - py) <= 1 && !(m.x === px && m.y === py);
    });
    if (adjacentMonster) {
      actions.push({ key: 'T', label: `Tame (${adjacentMonster.name})`, action: 'tame', icon: 'ğŸ¾', highlight: true });
    }

    // Gather: adjacent resource node
    const nearbyNode = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
    if (nearbyNode) {
      const nodeInfo = GatheringSystem.getNodeInfo(nearbyNode.tile);
      actions.push({ key: 'M', label: `${nodeInfo.verb} (${nodeInfo.name})`, action: 'gather', icon: nodeInfo.icon || 'â›', highlight: true });
    }

    // Harvest: standing on harvestable crop
    if (tile && tile.crop) {
      const cropInfo = FarmingSystem.getCropInfo(tile);
      if (cropInfo && cropInfo.harvestable) {
        actions.push({ key: 'H', label: `Harvest (${cropInfo.name})`, action: 'harvest', icon: 'ğŸŒ¾', highlight: true });
      }
    }

    // Plant: have seeds and on farmable tile
    const hasSeed = this.player.inventory.some(i => i.type === 'seed');
    if (hasSeed && tile && (tile.type === 'farmland' || tile.type === 'soil' || tile.type === 'grass' || tile.type === 'floor')) {
      actions.push({ key: 'P', label: 'Plant', action: 'openPlant', icon: 'ğŸŒ±' });
    }

    // Pick up placed furniture
    if (tile && tile.furniture) {
      actions.push({ key: 'Shift+U', label: `Pick up ${tile.furniture.name}`, action: 'pickupFurniture', icon: 'ğŸ ' });
    }

    // Sleep: always available on local map (comfort depends on bed)
    if (tile && tile.bed) {
      actions.push({ key: 'S', label: `Sleep (${tile.bed.name} ${tile.bed.comfort}%)`, action: 'sleep', icon: 'ğŸ’¤', highlight: true });
    } else {
      actions.push({ key: 'S', label: 'Sleep (ground 5%)', action: 'sleep', icon: 'ğŸ’¤' });
    }

    // Ranged attack: have ranged weapon and visible monster
    const rangedWeapon = this.player.equipment ? this.player.equipment.weapon : null;
    if (rangedWeapon && rangedWeapon.ranged) {
      const visibleMonster = this.currentMap.monsters.some(m => m.hp > 0);
      if (visibleMonster) {
        actions.push({ key: 'F', label: 'Shoot', action: 'rangedAttack', icon: 'ğŸ¹', highlight: true });
      }
    }

    // Pray: have a god
    if (this.player.faith && this.player.faith.godId) {
      // On altar â€” extra highlight
      const onAltar = tile && (tile.altar || tile.type === 'shrine');
      if (onAltar) {
        actions.push({ key: 'R', label: 'Pray', action: 'pray', icon: 'ğŸ™', highlight: true });
      } else {
        actions.push({ key: 'R', label: 'Pray', action: 'pray', icon: 'ğŸ™' });
      }
    }

    // On altar without a god
    if (tile && (tile.altar || tile.type === 'shrine') && !(this.player.faith && this.player.faith.godId)) {
      actions.push({ key: 'ğŸ™', label: 'Worship (open Faith tab)', action: 'openFaith', icon: 'ğŸ™', highlight: true });
    }

    // Shop: standing on NPC shop tile
    if (tile && tile.npc && tile.npc.shopId) {
      actions.push({ key: 'ğŸª', label: `Shop (${tile.npc.shopName})`, action: 'openShop', icon: 'ğŸª', highlight: true });
    }

    // Quest Board
    if (tile && tile.npc && tile.npc.questBoard) {
      actions.push({ key: 'Q', label: 'Quests', action: 'openQuests', icon: 'ğŸ“œ', highlight: true });
    }

    // Always-available panel shortcuts
    actions.push({ key: 'Z', label: 'Spells', action: 'openSpells', icon: 'âœ¨' });
    // Show nearby workshops in craft action
    const ctxWorkshops = CraftingSystem.getNearbyWorkshops(this.player, this.currentMap);
    if (ctxWorkshops.size > 0) {
      actions.push({ key: 'C', label: `Craft (${ctxWorkshops.size} workshop${ctxWorkshops.size > 1 ? 's' : ''})`, action: 'openCraft', icon: 'ğŸ”¨', highlight: true });
    } else {
      actions.push({ key: 'C', label: 'Craft (hand only)', action: 'openCraft', icon: 'ğŸ”¨' });
    }
    actions.push({ key: 'Q', label: 'Quests', action: 'openQuests', icon: 'ğŸ“œ' });

    // Exit to world map â€” walk to the map edge to leave

    // Save
    actions.push({ key: 'Ctrl+S', label: 'Save', action: 'save', icon: 'ğŸ’¾', always: true });

    return actions;
  }

  // â”€â”€ Action Timing Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  getActionContext(action) {
    const context = {};
    if (action.type === 'gather' && this.currentMap) {
      const node = GatheringSystem.findAdjacentNode(this.player, this.currentMap);
      if (node) {
        context.nodeType = GatheringSystem.getNodeType(node.tile);
      }
    }
    return context;
  }

  // â”€â”€ Save / Load â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  serialize() {
    return {
      id: this.id,
      player: this.player,
      // worldMap is deterministic â€” regenerated on load to save storage
      worldX: this.worldX,
      worldY: this.worldY,
      turn: this.turn,
      mode: this.mode,
      fame: this.fame,
      karma: this.karma,
      time: this.timeWeather.getState(),
      messages: this.messages,
      damageLog: this.damageLog,
      killCount: this.killCount,
      deepestFloor: this.deepestFloor,
      locationsVisited: Array.from(this.locationsVisited),
      homesteadMap: this.homesteadMap,
      cardCollection: this.player.cardCollection || [],
      cardStats: this.player.cardStats || { totalCollected: 0, totalSold: 0 }
    };
  }

  loadFromSave(data) {
    Object.assign(this, data);
    // Regenerate deterministic world map (not saved to reduce storage)
    this.worldMap = MapGenerator.generateWorldMap();
    // Migrate old saves: if worldX/worldY out of bounds, reset to homestead
    if (this.worldX >= MapGenerator.WORLD_WIDTH || this.worldY >= MapGenerator.WORLD_HEIGHT) {
      const home = WORLD_LOCATIONS.homestead;
      this.worldX = home.x;
      this.worldY = home.y;
    }
    this.timeWeather = new TimeWeather(data.time);
    this.nefiaSystem = new NefiaSystem();
    this.fogSystem = new FogOfWarSystem();
    this.gameOver = false;
    if (!this.player.quests) this.player.quests = [];
    if (!this.player.pets) this.player.pets = [];
    FaithSystem.init(this.player);
    this.questBoard = [];
    this.questBoardPos = null;
    // Restore death recap tracking
    this.damageLog = data.damageLog || [];
    this.killCount = data.killCount || 0;
    this.deepestFloor = data.deepestFloor || 0;
    this.locationsVisited = new Set(data.locationsVisited || []);
    this.homesteadMap = data.homesteadMap || null;
    // Initialize recipe system
    CraftingSystem.initRecipes(this.player);
    // Restore card collection
    if (data.cardCollection) this.player.cardCollection = data.cardCollection;
    if (data.cardStats) this.player.cardStats = data.cardStats;
    CardSystem.init(this.player);
  }
}

</script>

  <script>
// ============================================================
// Client-side Game Data â€” Loaded from static JSON files
// ============================================================

// These will be populated by loadGameData() before the game starts
let CLIENT_RACES = [];
let CLIENT_CLASSES = [];
let GAME_DATA = {};
let SHOP_DATA = {};
let RECIPE_DATA = {};

const ATTR_NAMES = {
  STR: 'Strength', END: 'Endurance', DEX: 'Dexterity', PER: 'Perception',
  LRN: 'Learning', WIL: 'Willpower', MAG: 'Magic', CHA: 'Charisma'
};

let WEATHER_ICONS = {
  sunny: 'â˜€ï¸', cloudy: 'â˜ï¸', rain: 'ğŸŒ§ï¸', heavyRain: 'â›ˆï¸',
  snow: 'ğŸŒ¨ï¸', heavySnow: 'â„ï¸', ether: 'âœ¨'
};

/**
 * Fetches all game data from static JSON files and populates globals.
 * Also loads the engine's global data (RACES, CLASSES, etc.).
 * Must be called (and awaited) before showing any UI that uses game data.
 */
async function loadGameData() {
  // Load engine-side globals first
  await loadAllGameData();

  // Build the GAME_DATA bundle from the engine globals
  const data = {
    races: RACES,
    classes: CLASSES,
    skills: SKILL_DEFS,
    items: ITEM_TEMPLATES,
    monsters: MONSTER_TEMPLATES,
    monsterTiers: MONSTER_TIERS,
    locations: WORLD_LOCATIONS,
    biomes: BIOMES,
    tiles: TILE_TYPES,
    weather: { types: WEATHER_TYPES, effects: WEATHER_EFFECTS },
    spells: SPELL_DEFS,
    crops: CROP_DEFS,
    shops: SHOP_DEFS,
    recipes: RECIPE_DEFS
  };
  GAME_DATA = data;

  // Build CLIENT_RACES array (format expected by UI)
  CLIENT_RACES = Object.values(data.races).map(r => ({
    id: r.id,
    name: r.name,
    desc: r.description,
    attrs: Object.entries(r.attributes).map(([id, mod]) => ({ id, mod })),
    feat: r.feat,
    featDesc: r.featDesc,
    baseLife: r.baseLife,
    baseMana: r.baseMana,
    baseSpeed: r.baseSpeed
  }));

  // Build CLIENT_CLASSES array (format expected by UI)
  CLIENT_CLASSES = Object.values(data.classes).map(c => ({
    id: c.id,
    name: c.name,
    desc: c.description,
    attrs: Object.entries(c.attributes).map(([id, mod]) => ({ id, mod })),
    feat: c.feat,
    featDesc: c.featDesc,
    domains: c.domains || []
  }));

  // Load weather icons from data if available
  if (data.weather && data.weather.icons) {
    WEATHER_ICONS = data.weather.icons;
  }

  // Store shop and recipe data
  if (data.shops) SHOP_DATA = data.shops;
  if (data.recipes) RECIPE_DATA = data.recipes;

  return data;
}

</script>

  <!-- Tile system: core manager + modular tile definitions -->
  <script>
// ============================================================
// SVGTileManager â€” Registry & loader for modular SVG tile files
// ============================================================
// Each tile category is defined in its own file under js/tiles/.
// Tile files register themselves via SVGTileManager.register().
// This allows the game to scale to thousands of tiles without
// touching a single monolithic file.
//
// PNG Override: After SVG tiles are loaded, the manager fetches
// assets/sprites/manifest.json.  For every key listed there the
// SVG tile is replaced by the PNG sprite.  SVG remains as fallback.
// ============================================================

class SVGTileManager {
  constructor(tileSize) {
    this.tileSize = tileSize || 32;
    this.cache = {};
    this.variants = {};   // key -> [Image, Image, ...]
    this.pngOverrides = {}; // key -> { img, gridWidth, gridHeight }
    this._applyRegistered();
    this._loadPNGOverrides();
  }

  // â”€â”€ PNG Override system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Fetch manifest and load PNG sprites to override SVG tiles */
  _loadPNGOverrides() {
    Promise.resolve({"_comment":"Maps tile keys to their PNG sprite filenames. Managed by the Sprite Tool.","sprites":{}})
      .then(manifest => {
        if (!manifest || !manifest.sprites) return;
        const entries = Object.entries(manifest.sprites);
        let loaded = 0;
        entries.forEach(([key, info]) => {
          const img = new Image();
          img.onload = () => {
            this.pngOverrides[key] = {
              img,
              gridWidth: info.gridWidth || 1,
              gridHeight: info.gridHeight || 1
            };
            // Also replace in the main cache so existing code works
            this.cache[key] = img;
            // Replace in variants array first entry too
            if (this.variants[key]) {
              this.variants[key][0] = img;
            }
            loaded++;
            if (loaded === entries.length) {
              console.log(`[SVGTileManager] Loaded ${loaded} PNG overrides`);
            }
          };
          img.onerror = () => {
            console.warn(`[SVGTileManager] Failed to load PNG override for "${key}": ${info.file}`);
          };
          img.src = `/assets/sprites/${info.file}`;
        });
      })
      .catch(() => {
        // No manifest or fetch error â€” SVG fallback is fine
      });
  }

  /** Check if a key has a PNG override with multi-tile size info */
  getPNGOverride(key) {
    return this.pngOverrides[key] || null;
  }

  /** Check if a tile is multi-grid (bigger than 1x1) */
  getGridSize(key) {
    const ov = this.pngOverrides[key];
    if (ov) return { w: ov.gridWidth, h: ov.gridHeight };
    return { w: 1, h: 1 };
  }

  // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /** Get a cached Image for any tile key */
  get(key) {
    return this.cache[key] || null;
  }

  /**
   * Register multiple variants for a single tile key.
   * The first variant is also stored in this.cache as the default.
   */
  addVariants(key, images) {
    if (!images || images.length === 0) return;
    this.cache[key] = images[0];
    this.variants[key] = images;
  }

  /**
   * Pick a deterministic variant based on (x, y) coordinates.
   * Uses a multi-step hash to eliminate visible patterns.
   */
  getVariant(key, x, y) {
    const arr = this.variants[key];
    if (!arr || arr.length === 0) return this.cache[key] || null;
    // Multi-step integer hash â€” breaks linear patterns
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >>> 13)) * 1274126177;
    h = (h ^ (h >>> 16)) * 2654435769;
    h = h ^ (h >>> 13);
    return arr[(h >>> 0) % arr.length];
  }

  /** Get tile image for a terrain tile type (with variant support) */
  getTile(tileId, x, y) {
    const key = `tile_${tileId}`;
    // PNG override takes priority (already in cache via _loadPNGOverrides)
    if (this.pngOverrides[key]) return this.cache[key];
    if (x !== undefined && y !== undefined && this.variants[key]) {
      return this.getVariant(key, x, y);
    }
    return this.cache[key] || null;
  }

  /** Get tile for a biome (with variant support) */
  getBiome(biomeId, x, y) {
    const key = `biome_${biomeId}`;
    if (this.pngOverrides[key]) return this.cache[key];
    if (x !== undefined && y !== undefined && this.variants[key]) {
      return this.getVariant(key, x, y);
    }
    return this.cache[key] || null;
  }

  /** Get tile for a monster by its template id */
  getMonster(monsterId) {
    return this.cache[`monster_${monsterId}`] || null;
  }

  /** Get tile for an NPC by name */
  getNpc(npcName) {
    const key = npcName ? npcName.toLowerCase().replace(/\s/g, '') : 'generic';
    return this.cache[`npc_${key}`] || this.cache['npc_generic'];
  }

  /** Get tile for a location type */
  getLocation(locationType) {
    return this.cache[`location_${locationType}`] || this.cache['location_town'];
  }

  /**
   * Draw a (possibly multi-grid) sprite onto a canvas context.
   * Multi-tile sprites (2x2, 3x2, etc.) are drawn spanning multiple grid cells.
   * The anchor is the top-left corner of the sprite.
   * Returns the grid size {w, h} so the caller can skip cells already covered.
   */
  drawSprite(ctx, key, dx, dy, ts) {
    const img = this.cache[key];
    if (!img || !img.complete || img.naturalWidth === 0) return null;

    const ov = this.pngOverrides[key];
    const gw = ov ? ov.gridWidth : 1;
    const gh = ov ? ov.gridHeight : 1;

    ctx.drawImage(img, dx, dy, ts * gw, ts * gh);
    return { w: gw, h: gh };
  }

  /** Get tile for an item (delegates to ItemTiles logic) */
  getItem(item) {
    if (!item) return null;
    const tid = item.templateId || item.id || '';

    if (item.type === 'weapon') {
      if (tid === 'brokenSword') return this.cache['item_weapon_brokenSword'] || this.cache['item_weapon_longSword'];
      const sub = item.subtype || '';
      if (sub.includes('Sword') || sub.includes('longSword')) return this.cache['item_weapon_longSword'];
      if (sub.includes('shortSword')) return this.cache['item_weapon_shortSword'];
      if (sub.includes('axe')) return this.cache['item_weapon_axe'];
      if (sub.includes('bow')) return this.cache['item_weapon_bow'];
      if (sub.includes('staff')) return this.cache['item_weapon_staff'];
      if (sub.includes('mace')) return this.cache['item_weapon_mace'];
      return this.cache['item_weapon_longSword'];
    }
    if (item.type === 'armor') {
      if (tid === 'raggedCloth') return this.cache['item_armor_raggedCloth'] || this.cache['item_armor_body'];
      if (tid === 'chainMail') return this.cache['item_armor_chainMail'] || this.cache['item_armor_body'];
      const slot = item.slot || 'body';
      return this.cache[`item_armor_${slot}`] || this.cache['item_armor_body'];
    }
    if (item.type === 'food') {
      if (tid === 'ration') return this.cache['item_food_ration'] || this.cache['item_food'];
      if (tid === 'bread') return this.cache['item_food_bread'] || this.cache['item_food'];
      if (tid === 'grandFeast') return this.cache['item_food_feast'] || this.cache['item_food'];
      if (tid === 'cropTurnip') return this.cache['item_food_turnip'] || this.cache['item_food'];
      if (tid === 'cropPotato') return this.cache['item_food_potato'] || this.cache['item_food'];
      if (tid === 'cropStrawberry') return this.cache['item_food_strawberry'] || this.cache['item_food'];
      if (tid === 'cropCorn') return this.cache['item_food_corn'] || this.cache['item_food'];
      if (tid === 'cropTomato') return this.cache['item_food_tomato'] || this.cache['item_food'];
      if (tid === 'cropCarrot') return this.cache['item_food_carrot'] || this.cache['item_food'];
      if (tid === 'cropHerb') return this.cache['item_food_cropHerb'] || this.cache['item_food_herb'];
      if (tid === 'cropPumpkin') return this.cache['item_food_pumpkin'] || this.cache['item_food'];
      if (tid === 'cropWheat') return this.cache['item_food_wheat'] || this.cache['item_food'];
      if (tid === 'berryRed') return this.cache['item_food_berryRed'] || this.cache['item_food_berry'];
      if (tid === 'berryBlue') return this.cache['item_food_berryBlue'] || this.cache['item_food_berry'];
      if (tid === 'berryPoison') return this.cache['item_food_berryPoison'] || this.cache['item_food_berry'];
      if (tid === 'mushroomPoison') return this.cache['item_food_mushroomPoison'] || this.cache['item_food_mushroom'];
      if (tid === 'rareFish') return this.cache['item_food_rareFish'] || this.cache['item_food_fish'];
      if (tid && tid.includes('herb')) return this.cache['item_food_herb'];
      if (tid && (tid.includes('berry') || tid.includes('Berry'))) return this.cache['item_food_berry'];
      if (tid && (tid.includes('mushroom') || tid.includes('Mushroom'))) return this.cache['item_food_mushroom'];
      if (tid && (tid.includes('Fish') || tid.includes('fish'))) return this.cache['item_food_fish'];
      return this.cache['item_food'];
    }
    if (item.type === 'potion') {
      if (item.healMP) return this.cache['item_potion_mana'];
      return this.cache['item_potion_heal'];
    }
    if (item.type === 'resource') {
      // Specific ores
      if (tid === 'oreIron') return this.cache['item_resource_oreIron'] || this.cache['item_resource_ore'];
      if (tid === 'oreCopper') return this.cache['item_resource_oreCopper'] || this.cache['item_resource_ore'];
      if (tid === 'oreSilver') return this.cache['item_resource_oreSilver'] || this.cache['item_resource_ore'];
      if (tid === 'oreGold') return this.cache['item_resource_oreGold'] || this.cache['item_resource_ore'];
      if (tid === 'oreMythril') return this.cache['item_resource_oreMythril'] || this.cache['item_resource_ore'];
      // Specific logs
      if (tid === 'oakLog') return this.cache['item_resource_oakLog'] || this.cache['item_resource_wood'];
      if (tid === 'pineLog') return this.cache['item_resource_pineLog'] || this.cache['item_resource_wood'];
      if (tid === 'birchLog') return this.cache['item_resource_birchLog'] || this.cache['item_resource_wood'];
      if (tid === 'mapleLog') return this.cache['item_resource_mapleLog'] || this.cache['item_resource_wood'];
      if (tid === 'yewLog') return this.cache['item_resource_yewLog'] || this.cache['item_resource_wood'];
      if (tid === 'mushroomGlow') return this.cache['item_resource_glowMushroom'] || this.cache['item_food_mushroom'];
      // Generic resource matching
      if (tid && (tid.includes('ore') || tid.includes('Ore'))) return this.cache['item_resource_ore'];
      if (tid && (tid.includes('wood') || tid.includes('Wood') || tid.includes('Log') || tid.includes('log'))) return this.cache['item_resource_wood'];
      if (tid && tid.includes('leather')) return this.cache['item_resource_leather'];
      if (tid && tid.includes('string')) return this.cache['item_resource_string'];
      if (tid && (tid.includes('Bottle') || tid.includes('bottle'))) return this.cache['item_resource_bottle'];
      if (tid && tid.includes('crystal')) return this.cache['item_resource_crystal'];
      if (tid && tid.includes('clay')) return this.cache['item_resource_clay'];
      if (tid && tid === 'sand') return this.cache['item_resource_sand'];
      if (tid && tid.includes('flint')) return this.cache['item_resource_flint'];
      if (tid && tid.includes('reeds')) return this.cache['item_resource_reeds'];
      if (tid && tid.includes('bark')) return this.cache['item_resource_bark'];
      if (tid && tid.includes('sap')) return this.cache['item_resource_sap'];
      if (tid && tid.includes('amber')) return this.cache['item_resource_amber'];
      if (tid && tid.includes('pearl')) return this.cache['item_resource_pearl'];
      if (tid && tid.includes('driftwood')) return this.cache['item_resource_driftwood'];
      if (tid && tid.includes('Glow')) return this.cache['item_resource_glowMushroom'] || this.cache['item_food_mushroom'];
      return this.cache['item_resource_ore'];
    }
    if (item.type === 'tool') {
      if (tid === 'ironAxeTool') return this.cache['item_tool_ironAxe'] || this.cache['item_tool_axe'];
      if (tid === 'steelAxeTool') return this.cache['item_tool_steelAxe'] || this.cache['item_tool_axe'];
      if (tid === 'mythrilAxeTool') return this.cache['item_tool_mythrilAxe'] || this.cache['item_tool_axe'];
      if (tid === 'stonePickaxe') return this.cache['item_tool_stonePickaxe'] || this.cache['item_tool_pickaxe'];
      if (tid === 'ironPickaxe') return this.cache['item_tool_ironPickaxe'] || this.cache['item_tool_pickaxe'];
      if (tid === 'steelPickaxe') return this.cache['item_tool_steelPickaxe'] || this.cache['item_tool_pickaxe'];
      if (tid === 'mythrilPickaxe') return this.cache['item_tool_mythrilPickaxe'] || this.cache['item_tool_pickaxe'];
      if (item.subtype === 'axeTool') return this.cache['item_tool_axe'];
      if (item.subtype === 'pickaxe') return this.cache['item_tool_pickaxe'];
      return this.cache['item_tool_pickaxe'];
    }
    if (item.type === 'currency') return this.cache['item_gold'];
    if (item.type === 'seed') {
      const cropId = item.cropId || '';
      if (cropId === 'turnip') return this.cache['item_seed_turnip'] || this.cache['item_seed'];
      if (cropId === 'potato') return this.cache['item_seed_potato'] || this.cache['item_seed'];
      if (cropId === 'strawberry') return this.cache['item_seed_strawberry'] || this.cache['item_seed'];
      if (cropId === 'corn') return this.cache['item_seed_corn'] || this.cache['item_seed'];
      if (cropId === 'tomato') return this.cache['item_seed_tomato'] || this.cache['item_seed'];
      if (cropId === 'carrot') return this.cache['item_seed_carrot'] || this.cache['item_seed'];
      if (cropId === 'herb') return this.cache['item_seed_herb'] || this.cache['item_seed'];
      if (cropId === 'pumpkin') return this.cache['item_seed_pumpkin'] || this.cache['item_seed'];
      if (cropId === 'wheat') return this.cache['item_seed_wheat'] || this.cache['item_seed'];
      return this.cache['item_seed'];
    }
    if (item.type === 'spellbook') {
      const spellId = item.spellId || '';
      const key = `item_spellbook_${spellId}`;
      return this.cache[key] || this.cache['item_spellbook'];
    }
    if (item.type === 'scroll') {
      if (tid === 'scrollEnchant') return this.cache['item_scroll_enchantWeapon'] || this.cache['item_scroll'];
      if (tid === 'scrollEnchantArmor') return this.cache['item_scroll_enchantArmor'] || this.cache['item_scroll'];
      if (tid === 'scrollGreaterEnchant') return this.cache['item_scroll_greaterEnchant'] || this.cache['item_scroll'];
      if (tid === 'scrollSupremeEnchant') return this.cache['item_scroll_supremeEnchant'] || this.cache['item_scroll'];
      if (tid === 'scrollLightningEnchant') return this.cache['item_scroll_lightning'] || this.cache['item_scroll'];
      if (tid === 'scrollHolyEnchant') return this.cache['item_scroll_holy'] || this.cache['item_scroll'];
      if (tid === 'scrollSpeedEnchant') return this.cache['item_scroll_speed'] || this.cache['item_scroll'];
      if (item.enchantType === 'fire') return this.cache['item_scroll_fire'];
      if (item.enchantType === 'ice') return this.cache['item_scroll_ice'];
      return this.cache['item_scroll'];
    }
    if (item.type === 'light') {
      if (tid === 'torch') return this.cache['item_light_torch'];
      if (tid === 'lantern') return this.cache['item_light_lantern'];
      if (tid === 'magicLight') return this.cache['item_light_magicLight'];
      return this.cache['item_light_torch'] || this.cache['item_food'];
    }

    return this.cache['item_food']; // fallback
  }

  /**
   * Returns the cache key string for an item (same logic as getItem).
   * Used by the renderer to query grid size for multi-tile items.
   */
  _getItemKey(item) {
    if (!item) return null;
    const tid = item.templateId || item.id || '';
    if (item.type === 'weapon') {
      if (tid === 'brokenSword') return 'item_weapon_brokenSword';
      const sub = item.subtype || '';
      if (sub.includes('Sword') || sub.includes('longSword')) return 'item_weapon_longSword';
      if (sub.includes('shortSword')) return 'item_weapon_shortSword';
      if (sub.includes('axe')) return 'item_weapon_axe';
      if (sub.includes('bow')) return 'item_weapon_bow';
      if (sub.includes('staff')) return 'item_weapon_staff';
      if (sub.includes('mace')) return 'item_weapon_mace';
      return 'item_weapon_longSword';
    }
    if (item.type === 'armor') {
      if (tid === 'raggedCloth') return this.cache['item_armor_raggedCloth'] ? 'item_armor_raggedCloth' : 'item_armor_body';
      if (tid === 'chainMail') return this.cache['item_armor_chainMail'] ? 'item_armor_chainMail' : 'item_armor_body';
      const slot = item.slot || 'body';
      return this.cache[`item_armor_${slot}`] ? `item_armor_${slot}` : 'item_armor_body';
    }
    if (item.type === 'food') {
      if (tid === 'ration') return 'item_food_ration';
      if (tid === 'bread') return 'item_food_bread';
      if (tid === 'grandFeast') return 'item_food_feast';
      if (tid === 'cropTurnip') return 'item_food_turnip';
      if (tid === 'cropPotato') return 'item_food_potato';
      if (tid === 'cropStrawberry') return 'item_food_strawberry';
      if (tid === 'cropCorn') return 'item_food_corn';
      if (tid === 'cropTomato') return 'item_food_tomato';
      if (tid === 'cropCarrot') return 'item_food_carrot';
      if (tid === 'cropHerb') return 'item_food_cropHerb';
      if (tid === 'cropPumpkin') return 'item_food_pumpkin';
      if (tid === 'cropWheat') return 'item_food_wheat';
      if (tid === 'berryRed') return 'item_food_berryRed';
      if (tid === 'berryBlue') return 'item_food_berryBlue';
      if (tid === 'berryPoison') return 'item_food_berryPoison';
      if (tid === 'mushroomPoison') return 'item_food_mushroomPoison';
      if (tid === 'rareFish') return 'item_food_rareFish';
      if (tid && tid.includes('herb')) return 'item_food_herb';
      if (tid && (tid.includes('berry') || tid.includes('Berry'))) return 'item_food_berry';
      if (tid && (tid.includes('mushroom') || tid.includes('Mushroom'))) return 'item_food_mushroom';
      if (tid && (tid.includes('Fish') || tid.includes('fish'))) return 'item_food_fish';
      return 'item_food';
    }
    if (item.type === 'potion') {
      return item.healMP ? 'item_potion_mana' : 'item_potion_heal';
    }
    if (item.type === 'resource') {
      if (tid === 'oreIron') return 'item_resource_oreIron';
      if (tid === 'oreCopper') return 'item_resource_oreCopper';
      if (tid === 'oreSilver') return 'item_resource_oreSilver';
      if (tid === 'oreGold') return 'item_resource_oreGold';
      if (tid === 'oreMythril') return 'item_resource_oreMythril';
      if (tid === 'oakLog') return 'item_resource_oakLog';
      if (tid === 'pineLog') return 'item_resource_pineLog';
      if (tid === 'birchLog') return 'item_resource_birchLog';
      if (tid === 'mapleLog') return 'item_resource_mapleLog';
      if (tid === 'yewLog') return 'item_resource_yewLog';
      if (tid === 'mushroomGlow') return 'item_resource_glowMushroom';
      if (tid && (tid.includes('ore') || tid.includes('Ore'))) return 'item_resource_ore';
      if (tid && (tid.includes('wood') || tid.includes('Wood') || tid.includes('Log') || tid.includes('log'))) return 'item_resource_wood';
      if (tid && tid.includes('leather')) return 'item_resource_leather';
      if (tid && tid.includes('string')) return 'item_resource_string';
      if (tid && (tid.includes('Bottle') || tid.includes('bottle'))) return 'item_resource_bottle';
      if (tid && tid.includes('crystal')) return 'item_resource_crystal';
      if (tid && tid.includes('clay')) return 'item_resource_clay';
      if (tid && tid === 'sand') return 'item_resource_sand';
      if (tid && tid.includes('flint')) return 'item_resource_flint';
      if (tid && tid.includes('reeds')) return 'item_resource_reeds';
      if (tid && tid.includes('bark')) return 'item_resource_bark';
      if (tid && tid.includes('sap')) return 'item_resource_sap';
      if (tid && tid.includes('amber')) return 'item_resource_amber';
      if (tid && tid.includes('pearl')) return 'item_resource_pearl';
      if (tid && tid.includes('driftwood')) return 'item_resource_driftwood';
      if (tid && tid.includes('Glow')) return 'item_resource_glowMushroom';
      return 'item_resource_ore';
    }
    if (item.type === 'tool') {
      if (tid === 'ironAxeTool') return 'item_tool_ironAxe';
      if (tid === 'steelAxeTool') return 'item_tool_steelAxe';
      if (tid === 'mythrilAxeTool') return 'item_tool_mythrilAxe';
      if (tid === 'stonePickaxe') return 'item_tool_stonePickaxe';
      if (tid === 'ironPickaxe') return 'item_tool_ironPickaxe';
      if (tid === 'steelPickaxe') return 'item_tool_steelPickaxe';
      if (tid === 'mythrilPickaxe') return 'item_tool_mythrilPickaxe';
      if (item.subtype === 'axeTool') return 'item_tool_axe';
      if (item.subtype === 'pickaxe') return 'item_tool_pickaxe';
      return 'item_tool_pickaxe';
    }
    if (item.type === 'currency') return 'item_gold';
    if (item.type === 'seed') {
      const cropId = item.cropId || '';
      if (cropId) return `item_seed_${cropId}`;
      return 'item_seed';
    }
    if (item.type === 'spellbook') {
      const spellId = item.spellId || '';
      return spellId ? `item_spellbook_${spellId}` : 'item_spellbook';
    }
    if (item.type === 'scroll') {
      if (tid === 'scrollEnchant') return 'item_scroll_enchantWeapon';
      if (tid === 'scrollEnchantArmor') return 'item_scroll_enchantArmor';
      if (tid === 'scrollGreaterEnchant') return 'item_scroll_greaterEnchant';
      if (tid === 'scrollSupremeEnchant') return 'item_scroll_supremeEnchant';
      if (tid === 'scrollLightningEnchant') return 'item_scroll_lightning';
      if (tid === 'scrollHolyEnchant') return 'item_scroll_holy';
      if (tid === 'scrollSpeedEnchant') return 'item_scroll_speed';
      if (item.enchantType === 'fire') return 'item_scroll_fire';
      if (item.enchantType === 'ice') return 'item_scroll_ice';
      return 'item_scroll';
    }
    if (item.type === 'light') {
      if (tid === 'torch') return 'item_light_torch';
      if (tid === 'lantern') return 'item_light_lantern';
      if (tid === 'magicLight') return 'item_light_magicLight';
      return 'item_light_torch';
    }
    return 'item_food';
  }

  /** Get a data-URI string for an item sprite (used by UI inventory) */
  getItemSpriteURL(item) {
    const img = this.getItem(item);
    return img ? img.src : null;
  }

  /** Get crop tile for a specific crop at a growth stage */
  getCrop(cropId, stage) {
    return this.cache[`crop_${cropId}_${stage}`] || this.cache[`crop_stage_${stage}`] || null;
  }

  // â”€â”€ SVG helpers (shared by all tile files) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  svgToImage(svgStr) {
    const img = new Image();
    img.src = 'data:image/svg+xml;base64,' + btoa(svgStr);
    return img;
  }

  wrap(inner, bg) {
    const s = this.tileSize;
    return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
      ${bg ? `<rect width="${s}" height="${s}" fill="${bg}"/>` : ''}
      ${inner}
    </svg>`;
  }

  // â”€â”€ Registration system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Register a tile generator function.
   * Each tile file calls this at load time.
   * @param {string}   category - e.g. 'terrain', 'biome', 'monster'
   * @param {function} generatorFn - function(manager) that populates manager.cache
   */
  static register(category, generatorFn) {
    if (!SVGTileManager._registry) SVGTileManager._registry = [];
    SVGTileManager._registry.push({ category, generatorFn });
  }

  /** Run every registered generator to populate the cache */
  _applyRegistered() {
    if (!SVGTileManager._registry) return;
    for (const { generatorFn } of SVGTileManager._registry) {
      generatorFn(this);
    }
  }
}

// Static registry â€” filled before constructor runs
SVGTileManager._registry = [];

</script>
  <script>
// ============================================================
// Terrain Tiles â€” floor, wall, grass, water, tree, door, etc.
// Multiple variants per tile type for visual variety.
// Linked to: data/tiles.json (tile properties like walkable, transparent)
// ============================================================

SVGTileManager.register('terrain', (mgr) => {
  const s = mgr.tileSize;

  // â”€â”€ Helper: tiny seededâ€random decorations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function dot(cx, cy, r, fill, opacity) {
    return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" opacity="${opacity || 1}"/>`;
  }
  function blade(x1, y1, x2, y2, stroke, sw) {
    return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${stroke}" stroke-width="${sw || 1.5}" stroke-linecap="round"/>`;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FLOOR â€” stone tile variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_floor', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/2-2}" fill="#404050" rx="1"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/2-2}" fill="#383848" rx="1"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#383848" rx="1"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#404050" rx="1"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#383848"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/2-2}" fill="#3c3c4c" rx="1"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/2-2}" fill="#424252" rx="1"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#424252" rx="1"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#3c3c4c" rx="1"/>
      ${dot(6, 6, 1, '#4a4a5a', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c3c4c"/>
      <rect x="1" y="1" width="${s/3-1}" height="${s/2-2}" fill="#424252" rx="1"/>
      <rect x="${s/3+1}" y="1" width="${s/3-1}" height="${s/2-2}" fill="#3a3a4a" rx="1"/>
      <rect x="${s*2/3+1}" y="1" width="${s/3-2}" height="${s/2-2}" fill="#404050" rx="1"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#3e3e4e" rx="1"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#444454" rx="1"/>
      ${dot(20, 22, 0.8, '#4e4e5e', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3b3b4b"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/3-1}" fill="#414151" rx="1"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/3-1}" fill="#393949" rx="1"/>
      <rect x="1" y="${s/3+1}" width="${s/3-1}" height="${s/3-1}" fill="#3d3d4d" rx="1"/>
      <rect x="${s/3+1}" y="${s/3+1}" width="${s*2/3-2}" height="${s/3-1}" fill="#434353" rx="1"/>
      <rect x="1" y="${s*2/3+1}" width="${s-2}" height="${s/3-2}" fill="#404050" rx="1"/>
      ${dot(24, 8, 0.6, '#505060', 0.3)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WALL â€” stone brick variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_wall', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#666677"/>
      <rect x="0" y="0" width="${s}" height="${s/2-1}" fill="#707080" rx="2"/>
      <rect x="${s/3}" y="${s/2+1}" width="${s*2/3}" height="${s/2-2}" fill="#606070" rx="2"/>
      <rect x="0" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#585868" rx="2"/>
      <line x1="0" y1="${s/2}" x2="${s}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s/3}" y1="0" x2="${s/3}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s*2/3}" y1="0" x2="${s*2/3}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#626272"/>
      <rect x="0" y="0" width="${s/2-1}" height="${s/2-1}" fill="#6c6c7c" rx="2"/>
      <rect x="${s/2+1}" y="0" width="${s/2-1}" height="${s/2-1}" fill="#727282" rx="2"/>
      <rect x="0" y="${s/2+1}" width="${s}" height="${s/2-2}" fill="#5e5e6e" rx="2"/>
      <line x1="0" y1="${s/2}" x2="${s}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s/2}" y1="0" x2="${s/2}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      ${dot(8, 20, 1, '#757585', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#686878"/>
      <rect x="0" y="0" width="${s*2/3}" height="${s/2-1}" fill="#747484" rx="2"/>
      <rect x="${s*2/3+1}" y="0" width="${s/3-1}" height="${s/2-1}" fill="#6a6a7a" rx="2"/>
      <rect x="0" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#606070" rx="2"/>
      <rect x="${s/3}" y="${s/2+1}" width="${s*2/3}" height="${s/2-2}" fill="#6e6e7e" rx="2"/>
      <line x1="0" y1="${s/2}" x2="${s}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s*2/3}" y1="0" x2="${s*2/3}" y2="${s/2}" stroke="#55556a" stroke-width="1"/>
      <line x1="${s/3}" y1="${s/2}" x2="${s/3}" y2="${s}" stroke="#55556a" stroke-width="1"/>
      ${dot(4, 4, 0.8, '#50506a', 0.25)}
      ${dot(26, 24, 0.6, '#7a7a8a', 0.2)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GRASS â€” lush ground with varied blades & flowers
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_grass', [
    // Variant 0 â€” standard blades
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(4, s, 6, s-8, '#5a9a3a')}
      ${blade(12, s, 10, s-7, '#4a8a2e')}
      ${blade(20, s, 22, s-9, '#5a9a3a')}
      ${blade(28, s, 26, s-6, '#4a8a2e')}
      ${blade(8, s-4, 9, s-10, '#6aaa44', 1)}
      ${blade(24, s-2, 23, s-9, '#6aaa44', 1)}
      ${dot(16, s-3, 1, '#4a7a2c')}
      ${dot(7, s-2, 0.8, '#5a8a3a')}
    `)),
    // Variant 1 â€” short dense grass
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c6c2a"/>
      ${blade(3, s, 4, s-5, '#5a9838')}
      ${blade(8, s, 7, s-6, '#4e8e30')}
      ${blade(13, s, 14, s-5, '#58962e')}
      ${blade(18, s, 17, s-7, '#529232')}
      ${blade(23, s, 24, s-5, '#5a9838')}
      ${blade(28, s, 27, s-6, '#4e8e30')}
      ${dot(6, s-8, 0.6, '#6aaa44', 0.5)}
      ${dot(20, s-9, 0.7, '#68a642', 0.5)}
      ${dot(10, s-4, 1, '#3a6228', 0.4)}
    `)),
    // Variant 2 â€” sparse with pebbles
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#396826"/>
      ${blade(5, s, 7, s-9, '#5a9a3a')}
      ${blade(22, s, 20, s-8, '#4a8a2e')}
      ${blade(15, s-3, 16, s-10, '#6aaa44', 1)}
      ${dot(10, s-4, 1.5, '#7a7a6a', 0.35)}
      ${dot(26, s-6, 1, '#8a8a7a', 0.3)}
      ${dot(4, s-2, 0.8, '#3e6e2a', 0.6)}
      ${dot(18, s-2, 0.6, '#3e6e2a', 0.5)}
    `)),
    // Variant 3 â€” with tiny yellow wildflower
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3b6b29"/>
      ${blade(4, s, 5, s-7, '#5a9a3a')}
      ${blade(10, s, 9, s-8, '#4a8a2e')}
      ${blade(20, s, 22, s-7, '#5a9a3a')}
      ${blade(27, s, 26, s-9, '#4e8e30')}
      ${blade(15, s-2, 15, s-12, '#509030', 1)}
      ${dot(15, s-13, 2, '#e8d44a', 0.85)}
      ${dot(15, s-13, 1, '#f0e060', 0.9)}
      ${dot(8, s-3, 0.7, '#4a7a2c')}
    `)),
    // Variant 4 â€” tall wispy grass
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#386826"/>
      ${blade(3, s, 5, s-12, '#5ea03c', 1.2)}
      ${blade(10, s, 8, s-11, '#4c8c2e', 1.2)}
      ${blade(17, s, 19, s-13, '#5ea03c', 1.2)}
      ${blade(24, s, 22, s-10, '#4c8c2e', 1.2)}
      ${blade(7, s-2, 6, s-8, '#6ab046', 0.8)}
      ${blade(21, s-1, 20, s-7, '#6ab046', 0.8)}
      ${dot(14, s-3, 0.6, '#3a6228', 0.4)}
      ${dot(28, s-5, 0.5, '#3a6228', 0.3)}
    `)),
    // Variant 5 â€” clover patch
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(5, s, 6, s-6, '#4a8a2e')}
      ${blade(25, s, 24, s-7, '#4a8a2e')}
      ${dot(10, s-8, 3, '#48883a', 0.5)}
      ${dot(12, s-10, 2.5, '#509040', 0.5)}
      ${dot(8, s-9, 2.5, '#449036', 0.45)}
      ${dot(18, s-6, 2, '#4a8a3a', 0.4)}
      ${dot(16, s-4, 0.8, '#3a6228')}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WATER â€” animated wave patterns
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_water', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a8a"/>
      <path d="M0,${s/3} Q${s/4},${s/3-4} ${s/2},${s/3} Q${s*3/4},${s/3+4} ${s},${s/3}" stroke="#3a7acc" stroke-width="2" fill="none" opacity="0.7"/>
      <path d="M0,${s*2/3} Q${s/4},${s*2/3-4} ${s/2},${s*2/3} Q${s*3/4},${s*2/3+4} ${s},${s*2/3}" stroke="#3a7acc" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M${-s/4},${s/2} Q0,${s/2-3} ${s/4},${s/2} Q${s/2},${s/2+3} ${s*3/4},${s/2}" stroke="#5a9aee" stroke-width="1" fill="none" opacity="0.4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1c4c8c"/>
      <path d="M0,8 Q10,4 20,8 Q30,12 ${s},8" stroke="#3878c8" stroke-width="1.8" fill="none" opacity="0.6"/>
      <path d="M0,18 Q8,14 16,18 Q24,22 ${s},18" stroke="#4a88d8" stroke-width="1.5" fill="none" opacity="0.5"/>
      <path d="M0,26 Q12,22 ${s},26" stroke="#5a9aee" stroke-width="1" fill="none" opacity="0.35"/>
      ${dot(8, 14, 1, '#5a9aee', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#184888"/>
      <path d="M0,6 Q6,2 12,6 Q18,10 24,6 Q30,2 ${s},6" stroke="#3a7acc" stroke-width="1.5" fill="none" opacity="0.65"/>
      <path d="M0,16 Q10,12 20,16 Q30,20 ${s},16" stroke="#4888cc" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M0,24 Q8,20 16,24 Q24,28 ${s},24" stroke="#3a7acc" stroke-width="1.5" fill="none" opacity="0.4"/>
      ${dot(22, 10, 1.2, '#6aadff', 0.25)}
      ${dot(6, 22, 0.8, '#6aadff', 0.2)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1e4e8e"/>
      <path d="M0,10 Q16,6 ${s},10" stroke="#4080cc" stroke-width="2" fill="none" opacity="0.55"/>
      <path d="M0,20 Q8,16 16,20 Q24,24 ${s},20" stroke="#3a78c8" stroke-width="1.8" fill="none" opacity="0.5"/>
      ${dot(14, 6, 1.5, '#5a9aee', 0.2)}
      ${dot(4, 28, 1, '#5a9aee', 0.15)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TREE â€” different tree shapes & tones
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_tree', [
    // Variant 0 â€” round canopy (original improved)
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#2d7a1e"/>
      <circle cx="${s/2-4}" cy="${s/3+4}" r="${s/4}" fill="#3a8a2a"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4}" fill="#258a18"/>
      <circle cx="${s/2}" cy="${s/4}" r="${s/5}" fill="#4a9a3a"/>
    `)),
    // Variant 1 â€” bushy wider canopy
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+4}" width="4" height="${s/2-4}" fill="#5e3e22" rx="1"/>
      <ellipse cx="${s/2}" cy="${s/3+3}" rx="${s/2.5}" ry="${s/3.5}" fill="#307820"/>
      <circle cx="${s/2-5}" cy="${s/3+1}" r="${s/5}" fill="#3c8c2c"/>
      <circle cx="${s/2+5}" cy="${s/3+2}" r="${s/5}" fill="#288a1a"/>
      <circle cx="${s/2}" cy="${s/5}" r="${s/6}" fill="#48983a"/>
      <circle cx="${s/2+2}" cy="${s/3+5}" r="${s/7}" fill="#226e16"/>
    `)),
    // Variant 2 â€” conifer / pine
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},2 ${s/2+10},${s/3+2} ${s/2-10},${s/3+2}" fill="#1e6e14"/>
      <polygon points="${s/2},${s/6} ${s/2+12},${s/2+2} ${s/2-12},${s/2+2}" fill="#267818"/>
      <polygon points="${s/2},${s/3} ${s/2+13},${s*2/3} ${s/2-13},${s*2/3}" fill="#2d7a1e"/>
      ${dot(s/2, 4, 1.2, '#4a9a3a', 0.7)}
    `)),
    // Variant 3 â€” small young tree
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-1}" y="${s/2}" width="2" height="${s/2}" fill="#6a4a2a" rx="0.5"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/4}" fill="#348a24"/>
      <circle cx="${s/2-3}" cy="${s/3+4}" r="${s/5}" fill="#3e9430"/>
      <circle cx="${s/2+3}" cy="${s/3+1}" r="${s/5}" fill="#2c7e1c"/>
      ${dot(s/2, s/4, 2, '#4ca03c', 0.6)}
    `)),
    // Variant 4 â€” autumn-tinted tree
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#3a8a2a"/>
      <circle cx="${s/2-4}" cy="${s/3+3}" r="${s/4.5}" fill="#5a9a3a"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4.5}" fill="#328228"/>
      <circle cx="${s/2+1}" cy="${s/5}" r="${s/6}" fill="#4a9a3a"/>
      ${dot(s/2-6, s/4+2, 1.5, '#8ab040', 0.5)}
      ${dot(s/2+5, s/5, 1.2, '#7aa838', 0.4)}
    `)),
    // Variant 5 â€” dark evergreen
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+3}" width="4" height="${s/2-3}" fill="#4a3018" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+1}" r="${s/3+1}" fill="#1a5e10"/>
      <circle cx="${s/2-3}" cy="${s/3+4}" r="${s/4}" fill="#226a16"/>
      <circle cx="${s/2+3}" cy="${s/3-1}" r="${s/4}" fill="#1a5e10"/>
      <circle cx="${s/2}" cy="${s/5-1}" r="${s/5}" fill="#2a7018"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DOOR â€” wooden door variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_door'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="4" y="2" width="${s-8}" height="${s-4}" fill="#8a6030" rx="3"/>
    <rect x="6" y="4" width="${s-12}" height="${s/2-4}" fill="#a57838" rx="2"/>
    <rect x="6" y="${s/2+2}" width="${s-12}" height="${s/2-6}" fill="#9a6830" rx="2"/>
    <circle cx="${s-10}" cy="${s/2}" r="2" fill="#d4a840"/>
    <line x1="4" y1="${s/2}" x2="${s-4}" y2="${s/2}" stroke="#704820" stroke-width="1"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STAIRS DOWN
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_stairsDown'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="4" y="4" width="${s-8}" height="5" fill="#888" rx="1"/>
    <rect x="7" y="11" width="${s-14}" height="5" fill="#777" rx="1"/>
    <rect x="10" y="18" width="${s-20}" height="5" fill="#666" rx="1"/>
    <polygon points="${s/2-3},${s-6} ${s/2+3},${s-6} ${s/2},${s-2}" fill="#ff0" opacity="0.8"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STAIRS UP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_stairsUp'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="10" y="4" width="${s-20}" height="5" fill="#888" rx="1"/>
    <rect x="7" y="11" width="${s-14}" height="5" fill="#777" rx="1"/>
    <rect x="4" y="18" width="${s-8}" height="5" fill="#666" rx="1"/>
    <polygon points="${s/2-3},8 ${s/2+3},8 ${s/2},3" fill="#0f0" opacity="0.8"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROAD â€” packed dirt with tracks (variants)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_road', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a89868"/>
      <rect x="0" y="${s/3}" width="${s}" height="2" fill="#988858" opacity="0.5"/>
      <rect x="0" y="${s*2/3}" width="${s}" height="2" fill="#988858" opacity="0.5"/>
      ${dot(5, 8, 1, '#b8a878', 0.5)}
      ${dot(20, 20, 1.5, '#b8a878', 0.5)}
      ${dot(14, 14, 1, '#c8b888', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a69466"/>
      <rect x="0" y="${s/4}" width="${s}" height="2" fill="#968454" opacity="0.4"/>
      <rect x="0" y="${s*3/4}" width="${s}" height="2" fill="#968454" opacity="0.4"/>
      ${dot(8, 6, 1.2, '#b8a878', 0.4)}
      ${dot(24, 16, 1, '#c0b080', 0.35)}
      ${dot(12, 26, 1.5, '#b0a070', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#aa9a6a"/>
      <rect x="0" y="${s/3+2}" width="${s}" height="1.5" fill="#9a8a5a" opacity="0.45"/>
      <rect x="0" y="${s*2/3-1}" width="${s}" height="1.5" fill="#9a8a5a" opacity="0.45"/>
      ${dot(3, 12, 0.8, '#bca880', 0.5)}
      ${dot(18, 8, 1.3, '#bca880', 0.4)}
      ${dot(26, 24, 1, '#c4b48c', 0.35)}
      ${dot(10, 22, 0.6, '#a09060', 0.3)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROCK â€” boulder variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_rock', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#777"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#888"/>
      <ellipse cx="${s/2-3}" cy="${s/2-2}" rx="${s/5}" ry="${s/6}" fill="#999" opacity="0.5"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#386828"/>
      <ellipse cx="${s/2+2}" cy="${s/2+3}" rx="${s/3+2}" ry="${s/4+1}" fill="#6e6e6e"/>
      <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/3}" ry="${s/4-1}" fill="#808080"/>
      <ellipse cx="${s/2+3}" cy="${s/2-1}" rx="${s/6}" ry="${s/7}" fill="#929292" opacity="0.45"/>
      ${dot(s/2-6, s/2+5, 1, '#666', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c6c2a"/>
      <ellipse cx="${s/2-3}" cy="${s/2+1}" rx="${s/4}" ry="${s/5}" fill="#747474"/>
      <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="${s/4-1}" ry="${s/5-1}" fill="#6a6a6a"/>
      <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/5}" ry="${s/6}" fill="#8a8a8a" opacity="0.4"/>
      <ellipse cx="${s/2+5}" cy="${s/2+1}" rx="${s/7}" ry="${s/8}" fill="#929292" opacity="0.35"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORE â€” sparkling rock variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_ore', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#666"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#777"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#daa520"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#c8a020"/>
      ${dot(s/2-2, s/2+4, 1.5, '#eab830', 0.8)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c3c4c"/>
      <ellipse cx="${s/2+1}" cy="${s/2+1}" rx="${s/3}" ry="${s/4}" fill="#606060"/>
      <ellipse cx="${s/2-1}" cy="${s/2-1}" rx="${s/3-2}" ry="${s/4-1}" fill="#727272"/>
      <polygon points="${s/2+2},${s/3+2} ${s/2+5},${s/3-2} ${s/2+7},${s/3+3}" fill="#d4a018"/>
      <polygon points="${s/2-5},${s/2+1} ${s/2-2},${s/2-2} ${s/2-1},${s/2+2}" fill="#ccaa20"/>
      ${dot(s/2+4, s/2+5, 1, '#e0b828', 0.7)}
      ${dot(s/2-3, s/3+5, 1.2, '#d8b020', 0.6)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SHRINE â€” stone altar
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_shrine'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="${s/2-6}" y="${s/2}" width="12" height="${s/2-2}" fill="#888" rx="1"/>
    <rect x="${s/2-8}" y="${s/2-2}" width="16" height="4" fill="#999" rx="1"/>
    <line x1="${s/2}" y1="4" x2="${s/2}" y2="${s/2-2}" stroke="#d0d050" stroke-width="2"/>
    <line x1="${s/2-5}" y1="${s/4}" x2="${s/2+5}" y2="${s/4}" stroke="#d0d050" stroke-width="2"/>
    <circle cx="${s/2}" cy="${s/4-2}" r="2" fill="#ff0" opacity="0.6"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CHEST â€” treasure box
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_chest'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <rect x="6" y="${s/3}" width="${s-12}" height="${s/2}" fill="#8a6020" rx="3"/>
    <rect x="6" y="${s/3}" width="${s-12}" height="${s/4}" fill="#a87828" rx="3"/>
    <rect x="${s/2-3}" y="${s/3+s/4-3}" width="6" height="6" fill="#daa520" rx="1"/>
    <line x1="6" y1="${s/3+s/4}" x2="${s-6}" y2="${s/3+s/4}" stroke="#704818" stroke-width="1"/>
    <rect x="8" y="${s/3+2}" width="4" height="3" fill="#c89830" rx="1" opacity="0.5"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TRAP â€” hidden spikes
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.cache['tile_trap'] = mgr.svgToImage(mgr.wrap(`
    <rect width="${s}" height="${s}" fill="#3a3a4a"/>
    <polygon points="8,${s-6} 10,8 12,${s-6}" fill="#cc3333" opacity="0.8"/>
    <polygon points="14,${s-6} 16,6 18,${s-6}" fill="#cc3333" opacity="0.9"/>
    <polygon points="20,${s-6} 22,8 24,${s-6}" fill="#cc3333" opacity="0.8"/>
    <line x1="4" y1="${s-6}" x2="${s-4}" y2="${s-6}" stroke="#993333" stroke-width="1"/>
  `));

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TOWN TILE â€” cobblestone variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_townTile', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#8a7a5a"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/3-1}" fill="#9a8a6a" rx="2"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/3-1}" fill="#8a7a5a" rx="2"/>
      <rect x="3" y="${s/3+1}" width="${s/3}" height="${s/3-1}" fill="#8a7a5a" rx="2"/>
      <rect x="${s/3+4}" y="${s/3+1}" width="${s/3}" height="${s/3-1}" fill="#9a8a6a" rx="2"/>
      <rect x="1" y="${s*2/3+1}" width="${s/2-2}" height="${s/3-2}" fill="#9a8a6a" rx="2"/>
      <rect x="${s/2+1}" y="${s*2/3+1}" width="${s/2-2}" height="${s/3-2}" fill="#8a7a5a" rx="2"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#887858"/>
      <rect x="1" y="1" width="${s/3-1}" height="${s/2-2}" fill="#968862" rx="2"/>
      <rect x="${s/3+1}" y="1" width="${s/3-1}" height="${s/2-2}" fill="#8c7c5c" rx="2"/>
      <rect x="${s*2/3+1}" y="1" width="${s/3-2}" height="${s/2-2}" fill="#928460" rx="2"/>
      <rect x="1" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#8c7c5c" rx="2"/>
      <rect x="${s/2+1}" y="${s/2+1}" width="${s/2-2}" height="${s/2-2}" fill="#968862" rx="2"/>
      ${dot(10, 14, 0.5, '#a09270', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#8c7c5c"/>
      <rect x="1" y="1" width="${s/2-2}" height="${s/2-2}" fill="#96886a" rx="2"/>
      <rect x="${s/2+1}" y="1" width="${s/2-2}" height="${s/2-2}" fill="#887858" rx="2"/>
      <rect x="1" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#8a7a5a" rx="2"/>
      <rect x="${s/3+1}" y="${s/2+1}" width="${s/3-1}" height="${s/2-2}" fill="#948664" rx="2"/>
      <rect x="${s*2/3+1}" y="${s/2+1}" width="${s/3-2}" height="${s/2-2}" fill="#8a7a5a" rx="2"/>
      ${dot(22, 8, 0.6, '#a09270', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FARM SOIL â€” tilled earth variants
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_farmSoil', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5a4030"/>
      <line x1="0" y1="5" x2="${s}" y2="5" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="11" x2="${s}" y2="11" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="17" x2="${s}" y2="17" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="23" x2="${s}" y2="23" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="29" x2="${s}" y2="29" stroke="#4a3020" stroke-width="2"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#584030"/>
      <line x1="0" y1="6" x2="${s}" y2="6" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="12" x2="${s}" y2="12" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="18" x2="${s}" y2="18" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="24" x2="${s}" y2="24" stroke="#4c3222" stroke-width="1.8"/>
      <line x1="0" y1="30" x2="${s}" y2="30" stroke="#4c3222" stroke-width="1.8"/>
      ${dot(8, 9, 0.8, '#6a5040', 0.3)}
      ${dot(22, 21, 0.7, '#6a5040', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HERB PATCH â€” harvestable herb cluster on grass
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_herbPatch', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(6, s-2, 4, 10, '#2a9a2a', 2)}
      ${blade(10, s-2, 12, 8, '#3aaa3a', 2)}
      ${blade(16, s-2, 14, 9, '#2aaa2a', 1.8)}
      ${blade(22, s-2, 24, 11, '#3a9a3a', 2)}
      ${blade(26, s-2, 25, 7, '#2aaa2a', 1.5)}
      ${dot(5, 8, 2, '#4aee4a', 0.6)}
      ${dot(13, 7, 2.5, '#3add3a', 0.7)}
      ${dot(23, 9, 2, '#4aee4a', 0.5)}
      ${dot(9, 14, 1.5, '#6f6', 0.5)}
      <circle cx="${s/2-2}" cy="${s-6}" r="2" fill="#5e5" opacity="0.6"/>
      <circle cx="${s/2+1}" cy="${s-7}" r="1.8" fill="#5e5" opacity="0.5"/>
      <circle cx="${s/2}" cy="${s-9}" r="1.5" fill="#6f6" opacity="0.5"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(8, s-2, 6, 11, '#3aaa3a', 2)}
      ${blade(14, s-2, 16, 7, '#2a9a2a', 2.2)}
      ${blade(20, s-2, 18, 10, '#3aaa3a', 1.8)}
      ${blade(25, s-2, 26, 9, '#2aaa2a', 1.5)}
      ${dot(7, 10, 2.5, '#3add3a', 0.65)}
      ${dot(17, 8, 2, '#4aee4a', 0.55)}
      ${dot(24, 11, 1.8, '#6f6', 0.5)}
      <circle cx="12" cy="6" r="1.5" fill="#ff8" opacity="0.4"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FISHING SPOT â€” shimmering water with fish ripples
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_fishingSpot', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a8a"/>
      <ellipse cx="${s/2}" cy="${s/3}" rx="10" ry="4" fill="#2a6acc" opacity="0.3"/>
      <ellipse cx="${s/2}" cy="${s*2/3}" rx="8" ry="3" fill="#2a6acc" opacity="0.25"/>
      <path d="M10,${s/2} Q14,${s/2-3} 18,${s/2}" stroke="#4a8aee" stroke-width="1" fill="none" opacity="0.5"/>
      <path d="M18,${s/2+4} Q22,${s/2+1} 26,${s/2+4}" stroke="#4a8aee" stroke-width="1" fill="none" opacity="0.4"/>
      ${dot(s/2, s/2-1, 1.5, '#6af', 0.6)}
      ${dot(s/2+5, s/2+3, 1, '#8cf', 0.4)}
      <path d="M${s/2-6},${s-6} Q${s/2-3},${s-9} ${s/2},${s-6}" stroke="#8cf" stroke-width="1" fill="none" opacity="0.5"/>
      <path d="M${s/2},${s-6} Q${s/2+3},${s-9} ${s/2+6},${s-6}" stroke="#8cf" stroke-width="1" fill="none" opacity="0.4"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STUMP â€” depleted tree, walkable
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_stump', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+6}" rx="6" ry="3" fill="#5a4a2a"/>
      <rect x="${s/2-5}" y="${s/2-2}" width="10" height="8" fill="#6a5a3a" rx="2"/>
      <ellipse cx="${s/2}" cy="${s/2-2}" rx="5" ry="3" fill="#7a6a4a"/>
      <circle cx="${s/2}" cy="${s/2-2}" r="2" fill="#5a4a2a" opacity="0.5"/>
      ${dot(s/2-2, s/2-1, 0.5, '#8a7a5a', 0.4)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORE VEIN â€” identical to 'ore' but explicitly named
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_oreVein', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#666677"/>
      <rect x="2" y="2" width="${s-4}" height="${s-4}" fill="#555566" rx="3"/>
      <polygon points="8,8 14,4 18,10 12,14" fill="#c8a020" opacity="0.9"/>
      <polygon points="18,16 24,12 26,20 20,22" fill="#dab030" opacity="0.8"/>
      <polygon points="6,20 10,18 12,24 8,25" fill="#b89020" opacity="0.7"/>
      ${dot(16, 8, 1.5, '#ffe060', 0.5)}
      ${dot(22, 18, 1, '#ffe060', 0.4)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // TREE VARIANTS â€” Oak, Pine, Birch, Maple, Yew
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Oak Tree â€” broad canopy, sturdy trunk, warm green
  mgr.addVariants('tile_oakTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2.5}" y="${s/2+2}" width="5" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3+1}" fill="#3a7a20"/>
      <circle cx="${s/2-5}" cy="${s/3+4}" r="${s/4}" fill="#4a8a2a"/>
      <circle cx="${s/2+5}" cy="${s/3}" r="${s/4}" fill="#358a18"/>
      <circle cx="${s/2}" cy="${s/4}" r="${s/5}" fill="#5a9a3a"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+3}" width="4" height="${s/2-3}" fill="#5e3e22" rx="1"/>
      <ellipse cx="${s/2}" cy="${s/3+3}" rx="${s/2.5}" ry="${s/3.5}" fill="#3a7820"/>
      <circle cx="${s/2-5}" cy="${s/3+1}" r="${s/5}" fill="#4c8c2c"/>
      <circle cx="${s/2+5}" cy="${s/3+2}" r="${s/5}" fill="#388a1a"/>
      <circle cx="${s/2+1}" cy="${s/5}" r="${s/6}" fill="#58983a"/>
    `)),
  ]);

  // Pine Tree â€” conical shape, dark green, tall
  mgr.addVariants('tile_pineTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a18"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},2 ${s/2+10},${s/3+2} ${s/2-10},${s/3+2}" fill="#1a5e10"/>
      <polygon points="${s/2},${s/6} ${s/2+12},${s/2+2} ${s/2-12},${s/2+2}" fill="#1e6818"/>
      <polygon points="${s/2},${s/3} ${s/2+13},${s*2/3} ${s/2-13},${s*2/3}" fill="#227018"/>
      ${dot(s/2, 4, 1.2, '#3a8a2a', 0.7)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a18"/>
      <rect x="${s/2-1.5}" y="${s*2/3+2}" width="3" height="${s/3-2}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},3 ${s/2+9},${s/3+1} ${s/2-9},${s/3+1}" fill="#1c6012"/>
      <polygon points="${s/2},${s/6+1} ${s/2+11},${s/2+1} ${s/2-11},${s/2+1}" fill="#206a16"/>
      <polygon points="${s/2},${s/3+1} ${s/2+12},${s*2/3+1} ${s/2-12},${s*2/3+1}" fill="#247218"/>
    `)),
  ]);

  // Birch Tree â€” white trunk, lighter canopy
  mgr.addVariants('tile_birchTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a2a"/>
      <rect x="${s/2-2}" y="${s/2+1}" width="4" height="${s/2-1}" fill="#d8d0c0" rx="1"/>
      <line x1="${s/2-1}" y1="${s/2+4}" x2="${s/2+1}" y2="${s/2+4}" stroke="#8a8070" stroke-width="0.8"/>
      <line x1="${s/2-1}" y1="${s/2+8}" x2="${s/2+1}" y2="${s/2+8}" stroke="#8a8070" stroke-width="0.8"/>
      <line x1="${s/2}" y1="${s/2+12}" x2="${s/2+1}" y2="${s/2+12}" stroke="#8a8070" stroke-width="0.6"/>
      <circle cx="${s/2}" cy="${s/3+1}" r="${s/3}" fill="#6aaa5a"/>
      <circle cx="${s/2-4}" cy="${s/3+3}" r="${s/4.5}" fill="#7aba6a"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4.5}" fill="#5aa04a"/>
      <circle cx="${s/2}" cy="${s/5}" r="${s/6}" fill="#8aca7a"/>
    `)),
  ]);

  // Maple Tree â€” reddish-orange canopy
  mgr.addVariants('tile_mapleTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a1a"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#6a4a2a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#aa4422"/>
      <circle cx="${s/2-5}" cy="${s/3+3}" r="${s/4.5}" fill="#cc5533"/>
      <circle cx="${s/2+5}" cy="${s/3}" r="${s/4.5}" fill="#bb3a1a"/>
      <circle cx="${s/2}" cy="${s/5}" r="${s/6}" fill="#dd6644"/>
      ${dot(s/2-3, s/3+5, 1.5, '#ee7755', 0.4)}
      ${dot(s/2+3, s/4, 1.2, '#ff8866', 0.3)}
    `)),
  ]);

  // Yew Tree â€” very dark, ancient-looking
  mgr.addVariants('tile_yewTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a3a14"/>
      <rect x="${s/2-3}" y="${s/2+1}" width="6" height="${s/2-1}" fill="#3a2a10" rx="2"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3+2}" fill="#1a3010"/>
      <circle cx="${s/2-4}" cy="${s/3+4}" r="${s/4}" fill="#223a16"/>
      <circle cx="${s/2+4}" cy="${s/3-1}" r="${s/4}" fill="#1a3010"/>
      <circle cx="${s/2}" cy="${s/5-2}" r="${s/5}" fill="#2a4018"/>
      ${dot(s/2-6, s/3+2, 1, '#3a5028', 0.4)}
      ${dot(s/2+6, s/3, 1.2, '#3a5028', 0.35)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ORE VARIANTS â€” Copper, Iron, Silver, Gold, Mythril
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Copper Ore â€” orange-brown metallic specks
  mgr.addVariants('tile_copperOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#666"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#777"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#b87333"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#a06628"/>
      ${dot(s/2-2, s/2+4, 1.5, '#cc8840', 0.8)}
      ${dot(s/2+4, s/3+2, 1, '#d09050', 0.6)}
    `)),
  ]);

  // Iron Ore â€” grey metallic veins
  mgr.addVariants('tile_ironOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a4a"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#606060"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#727272"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#8a8a8a"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#9a9a9a"/>
      ${dot(s/2-2, s/2+4, 1.5, '#aaaaaa', 0.7)}
      ${dot(s/2+4, s/3+2, 1, '#b0b0b0', 0.5)}
    `)),
  ]);

  // Silver Ore â€” bright silvery sparkles
  mgr.addVariants('tile_silverOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c3c50"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#606068"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#727280"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#c0c0d0"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#d0d0e0"/>
      ${dot(s/2, s/2-2, 2, '#e8e8f8', 0.6)}
      ${dot(s/2-5, s/2+3, 1.5, '#d8d8e8', 0.5)}
      ${dot(s/2+5, s/3, 1, '#f0f0ff', 0.4)}
    `)),
  ]);

  // Gold Ore â€” bright golden specks
  mgr.addVariants('tile_goldOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a3a48"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#5a5a60"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#6a6a70"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#ffd700"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#e8c000"/>
      <polygon points="${s/2-6},${s/2+3} ${s/2-3},${s/2+1} ${s/2-2},${s/2+5}" fill="#ffc800"/>
      ${dot(s/2, s/3-2, 2, '#ffe840', 0.7)}
      ${dot(s/2+5, s/2+5, 1.5, '#ffe040', 0.5)}
    `)),
  ]);

  // Mythril Ore â€” glowing blue-cyan veins
  mgr.addVariants('tile_mythrilOre', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a2a40"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#4a4a5a"/>
      <ellipse cx="${s/2-2}" cy="${s/2}" rx="${s/3-2}" ry="${s/4-2}" fill="#5a5a6a"/>
      <polygon points="${s/2-4},${s/3} ${s/2-1},${s/3-4} ${s/2+2},${s/3+1}" fill="#44bbee"/>
      <polygon points="${s/2+3},${s/2+2} ${s/2+6},${s/2-1} ${s/2+8},${s/2+3}" fill="#66ccff"/>
      <polygon points="${s/2-5},${s/2+4} ${s/2-3},${s/2+1} ${s/2-1},${s/2+5}" fill="#55ccee"/>
      ${dot(s/2, s/3-1, 2.5, '#88ddff', 0.7)}
      ${dot(s/2-4, s/2+5, 1.5, '#66ccff', 0.5)}
      ${dot(s/2+6, s/3+3, 1.2, '#aaeeff', 0.4)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEW GATHERABLE NODES â€” Berry Bush, Mushroom, etc.
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // Berry Bush â€” green bush with colorful berries
  mgr.addVariants('tile_berryBush', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+2}" ry="${s/4+1}" fill="#2a6a1e"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#3a8a2a"/>
      <ellipse cx="${s/2-3}" cy="${s/2-1}" rx="${s/5}" ry="${s/6}" fill="#4a9a38" opacity="0.6"/>
      ${dot(s/2-5, s/2-1, 2, '#cc3344', 0.9)}
      ${dot(s/2+3, s/2+2, 2, '#cc3344', 0.85)}
      ${dot(s/2-1, s/2+4, 1.8, '#4466cc', 0.9)}
      ${dot(s/2+6, s/2-2, 1.5, '#4466cc', 0.8)}
      ${dot(s/2-3, s/2+6, 1.5, '#cc3344', 0.7)}
    `)),
  ]);

  // Mushroom Patch â€” small mushrooms on dirt
  mgr.addVariants('tile_mushroomPatch', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a5a20"/>
      <rect x="${s/2-7}" y="${s/2+4}" width="2" height="5" fill="#c8b090" rx="0.5"/>
      <ellipse cx="${s/2-6}" cy="${s/2+3}" rx="4" ry="3" fill="#aa7744"/>
      <ellipse cx="${s/2-6}" cy="${s/2+2}" rx="3.5" ry="2" fill="#bb8855" opacity="0.6"/>
      ${dot(s/2-7, s/2+2, 1, '#fff', 0.4)}
      <rect x="${s/2+2}" y="${s/2+5}" width="2" height="4" fill="#c8b090" rx="0.5"/>
      <ellipse cx="${s/2+3}" cy="${s/2+4}" rx="3.5" ry="2.5" fill="#aa7744"/>
      <ellipse cx="${s/2+3}" cy="${s/2+3}" rx="3" ry="1.8" fill="#bb8855" opacity="0.6"/>
      ${dot(s/2+2, s/2+3, 0.8, '#fff', 0.35)}
      <rect x="${s/2-1}" y="${s/2+7}" width="1.5" height="3" fill="#c8b090" rx="0.3"/>
      <ellipse cx="${s/2-0.5}" cy="${s/2+6}" rx="2.5" ry="2" fill="#996633"/>
    `)),
  ]);

  // Clay Deposit â€” reddish-brown smooth mound
  mgr.addVariants('tile_clayDeposit', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+1}" ry="${s/4}" fill="#8a5a3a"/>
      <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/3}" ry="${s/4-1}" fill="#b07050"/>
      <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/5}" ry="${s/7}" fill="#c08060" opacity="0.5"/>
      ${dot(s/2+4, s/2+3, 1, '#905838', 0.3)}
    `)),
  ]);

  // Sand Deposit â€” pale sandy mound
  mgr.addVariants('tile_sandDeposit', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c070"/>
      <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+2}" ry="${s/4}" fill="#c8b860"/>
      <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/3}" ry="${s/4-1}" fill="#d8c878"/>
      <ellipse cx="${s/2-3}" cy="${s/2-1}" rx="${s/5}" ry="${s/7}" fill="#e0d088" opacity="0.5"/>
      ${dot(s/2+5, s/2+4, 1, '#c0b060', 0.4)}
      ${dot(s/2-4, s/2+5, 0.8, '#b8a858', 0.3)}
    `)),
  ]);

  // Flint Node â€” dark jagged stone
  mgr.addVariants('tile_flintNode', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <polygon points="${s/2-6},${s/2+4} ${s/2-2},${s/2-5} ${s/2+5},${s/2-3} ${s/2+7},${s/2+5} ${s/2+1},${s/2+7}" fill="#444438"/>
      <polygon points="${s/2-4},${s/2+3} ${s/2-1},${s/2-3} ${s/2+4},${s/2-1} ${s/2+5},${s/2+4} ${s/2},${s/2+5}" fill="#555544"/>
      ${dot(s/2-2, s/2-1, 1.2, '#666655', 0.5)}
      ${dot(s/2+3, s/2+1, 0.8, '#777766', 0.4)}
    `)),
  ]);

  // Reed Patch â€” tall reeds near water
  mgr.addVariants('tile_reedPatch', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      ${blade(5, s-2, 4, 4, '#7a9a4a', 2)}
      ${blade(9, s-2, 10, 3, '#8aaa5a', 2)}
      ${blade(14, s-2, 13, 5, '#7a9a4a', 1.8)}
      ${blade(19, s-2, 20, 3, '#8aaa5a', 2)}
      ${blade(24, s-2, 23, 4, '#7a9a4a', 1.8)}
      ${blade(28, s-2, 29, 6, '#8aaa5a', 1.5)}
      ${dot(5, 3, 1.5, '#9aba6a', 0.5)}
      ${dot(10, 2, 1.5, '#9aba6a', 0.5)}
      ${dot(20, 2, 1.5, '#9aba6a', 0.5)}
      ${dot(24, 3, 1.5, '#9aba6a', 0.5)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SNOW GROUND â€” white/pale terrain with icy accents
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_snowGround', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8d2dc"/>
      ${dot(5, 8, 2, '#dde6ee', 0.6)}
      ${dot(20, 14, 2.5, '#d8e2ea', 0.5)}
      ${dot(12, 24, 1.8, '#e0eaf2', 0.45)}
      ${dot(26, 6, 1.2, '#e8f0f8', 0.7)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c4cdd6"/>
      <ellipse cx="${s/3}" cy="${s*2/3}" rx="${s/4}" ry="${s/8}" fill="#d0dae4" opacity="0.4"/>
      ${dot(8, 10, 1.5, '#dce6ee', 0.55)}
      ${dot(22, 20, 2, '#d4dee8', 0.5)}
      ${dot(16, 6, 1, '#e4ecf4', 0.6)}
      ${dot(4, 28, 1.2, '#d8e2ea', 0.35)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cad4de"/>
      ${dot(10, 12, 2.2, '#dde8f0', 0.5)}
      ${dot(24, 8, 1.5, '#e2ecf4', 0.55)}
      ${dot(6, 22, 1.8, '#d6e0ea', 0.4)}
      ${dot(18, 28, 1, '#e0eaf2', 0.35)}
      ${dot(28, 22, 1.3, '#d0dae4', 0.45)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c6d0da"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/5}" ry="${s/8}" fill="#d4dee8" opacity="0.35"/>
      ${dot(4, 6, 1.8, '#dce6ee', 0.6)}
      ${dot(14, 18, 2, '#d8e2ea', 0.45)}
      ${dot(26, 26, 1.5, '#e4ecf4', 0.4)}
      ${dot(20, 4, 1, '#e0eaf2', 0.5)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c2ccd6"/>
      ${dot(8, 4, 1.5, '#d8e2ec', 0.5)}
      ${dot(22, 16, 2.2, '#dde8f0', 0.45)}
      ${dot(4, 20, 1.2, '#d4dee8', 0.55)}
      ${dot(16, 28, 1.8, '#e0eaf2', 0.35)}
      ${dot(28, 8, 1, '#e6eef6', 0.6)}
      <line x1="12" y1="14" x2="18" y2="14" stroke="#e0e8f0" stroke-width="0.5" opacity="0.3"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SAND â€” desert / beach ground
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_sand', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d4c478"/>
      ${dot(6, 10, 1.5, '#e0d08a', 0.5)}
      ${dot(22, 6, 1, '#dcc880', 0.4)}
      ${dot(14, 24, 1.3, '#c8b46a', 0.35)}
      ${dot(26, 20, 0.8, '#e0d08a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c074"/>
      <ellipse cx="${s/3}" cy="${s*2/3}" rx="${s/4}" ry="${s/7}" fill="#dcc880" opacity="0.35"/>
      ${dot(10, 8, 1.2, '#dcc880', 0.45)}
      ${dot(24, 18, 1.5, '#e0d08a', 0.4)}
      ${dot(4, 26, 0.8, '#c8b46a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d6c67a"/>
      ${dot(8, 14, 1.8, '#e2d28c', 0.4)}
      ${dot(22, 24, 1, '#e2d28c', 0.35)}
      ${dot(16, 4, 1.2, '#c6b468', 0.3)}
      ${dot(28, 10, 0.8, '#dcc880', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d2c276"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/5}" ry="${s/8}" fill="#dcc880" opacity="0.3"/>
      ${dot(5, 20, 1.5, '#e0d08a', 0.45)}
      ${dot(18, 12, 1, '#c8b46a', 0.35)}
      ${dot(26, 28, 1.3, '#d8c47e', 0.3)}
      ${dot(12, 28, 0.7, '#cab66c', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d8c87c"/>
      ${dot(4, 8, 1, '#e4d48e', 0.5)}
      ${dot(20, 4, 1.5, '#d0c070', 0.4)}
      ${dot(12, 20, 1.2, '#e0d08a', 0.35)}
      ${dot(26, 16, 0.8, '#ccb86e', 0.3)}
      ${dot(8, 28, 1, '#d4c478', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DIRT â€” muddy / brown earth
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_dirt', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6a5a3a"/>
      ${dot(6, 10, 1.5, '#7a6a4a', 0.5)}
      ${dot(22, 8, 1.2, '#5a4a2a', 0.4)}
      ${dot(14, 22, 1, '#7a6a4a', 0.35)}
      ${dot(26, 18, 0.8, '#8a7a5a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#685838"/>
      <ellipse cx="${s/3}" cy="${s/2}" rx="${s/5}" ry="${s/8}" fill="#7a6a4a" opacity="0.3"/>
      ${dot(10, 6, 1.2, '#5e4e2e', 0.45)}
      ${dot(24, 22, 1.5, '#7a6a4a', 0.4)}
      ${dot(4, 26, 0.8, '#584828', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6c5c3c"/>
      ${dot(8, 14, 1.8, '#7e6e4e', 0.4)}
      ${dot(20, 6, 1, '#5a4a2a', 0.35)}
      ${dot(14, 28, 1.3, '#7a6a4a', 0.3)}
      ${dot(28, 20, 0.7, '#8a7a5a', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#665636"/>
      ${dot(4, 4, 1.2, '#7a6a4a', 0.5)}
      ${dot(18, 16, 1.5, '#5e4e2e', 0.4)}
      ${dot(26, 8, 1, '#746444', 0.35)}
      ${dot(10, 24, 0.8, '#7e6e4e', 0.3)}
      ${dot(22, 28, 1.2, '#6a5a3a', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ROCKY GROUND â€” mountain / cave floor
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_rockyGround', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5a5a44"/>
      ${dot(6, 8, 2.5, '#6a6a50', 0.5)}
      ${dot(22, 14, 2, '#505038', 0.4)}
      ${dot(14, 24, 1.8, '#6a6a50', 0.35)}
      ${dot(26, 26, 1.2, '#7a7a60', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#585842"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4}" ry="${s/6}" fill="#626248" opacity="0.35"/>
      ${dot(8, 6, 1.5, '#4e4e36', 0.45)}
      ${dot(24, 20, 2, '#6e6e54', 0.4)}
      ${dot(4, 22, 1.2, '#5a5a42', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5c5c46"/>
      ${dot(10, 10, 2.2, '#6c6c52', 0.45)}
      ${dot(20, 22, 1.5, '#4c4c34', 0.4)}
      ${dot(6, 28, 1.8, '#5e5e46', 0.35)}
      ${dot(28, 8, 1, '#7a7a60', 0.3)}
      ${dot(16, 16, 0.8, '#525240', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#565640"/>
      ${dot(4, 14, 2, '#686850', 0.5)}
      ${dot(18, 6, 1.8, '#4a4a34', 0.4)}
      ${dot(26, 18, 1.5, '#6a6a50', 0.35)}
      ${dot(12, 26, 2.2, '#5c5c44', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5e5e48"/>
      <ellipse cx="${s*2/3}" cy="${s*2/3}" rx="${s/5}" ry="${s/7}" fill="#686850" opacity="0.3"/>
      ${dot(6, 6, 1.5, '#505038', 0.45)}
      ${dot(22, 12, 2, '#6e6e54', 0.4)}
      ${dot(10, 20, 1, '#747458', 0.3)}
      ${dot(28, 26, 1.8, '#5a5a42', 0.35)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // FOREST FLOOR â€” dark leafy ground with detritus
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_forestFloor', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a4a1a"/>
      ${dot(6, 8, 2, '#34561e', 0.5)}
      ${dot(20, 14, 1.5, '#3e6028', 0.4)}
      ${dot(12, 24, 1.8, '#283e14', 0.35)}
      ${dot(26, 22, 1, '#365a20', 0.3)}
      ${blade(8, s-2, 10, s-8, '#3a6a24', 1)}
      ${blade(22, s-4, 20, s-10, '#346020', 1)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2c4c1c"/>
      <ellipse cx="${s/3}" cy="${s/2}" rx="${s/5}" ry="${s/7}" fill="#34561e" opacity="0.3"/>
      ${dot(10, 6, 1.5, '#223c12', 0.45)}
      ${dot(24, 18, 2, '#3a6224', 0.4)}
      ${dot(4, 26, 1.2, '#2e4e18', 0.3)}
      ${blade(14, s-2, 16, s-7, '#386824', 1)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#284618"/>
      ${dot(8, 12, 2.2, '#365a20', 0.45)}
      ${dot(22, 8, 1.5, '#223c12', 0.4)}
      ${dot(14, 28, 1.8, '#2e4e18', 0.35)}
      ${dot(28, 24, 1, '#3e6228', 0.3)}
      ${dot(4, 4, 0.8, '#4a3a1a', 0.2)}
      ${blade(18, s-2, 20, s-9, '#346020', 1.2)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2e4e1e"/>
      ${dot(6, 18, 2, '#38581e', 0.5)}
      ${dot(20, 4, 1.8, '#243e14', 0.4)}
      ${dot(26, 16, 1.5, '#365a20', 0.35)}
      ${dot(10, 26, 1, '#3c6226', 0.3)}
      ${dot(16, 10, 0.8, '#5a4a2a', 0.15)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#264416"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/6}" ry="${s/8}" fill="#2e4e18" opacity="0.25"/>
      ${dot(4, 10, 1.5, '#345820', 0.5)}
      ${dot(18, 22, 2, '#3a6224', 0.4)}
      ${dot(28, 6, 1.2, '#223a10', 0.35)}
      ${dot(8, 28, 1.8, '#2c4c1a', 0.3)}
      ${blade(24, s-2, 26, s-8, '#3a6a24', 1)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SHALLOW WATER â€” lighter water for beach edges
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_shallowWater', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2a5a9a"/>
      <path d="M0,${s/3} Q${s/4},${s/3-3} ${s/2},${s/3} Q${s*3/4},${s/3+3} ${s},${s/3}" stroke="#4a8acc" stroke-width="1.5" fill="none" opacity="0.6"/>
      <path d="M0,${s*2/3} Q${s/4},${s*2/3-3} ${s/2},${s*2/3} Q${s*3/4},${s*2/3+3} ${s},${s*2/3}" stroke="#4a8acc" stroke-width="1.5" fill="none" opacity="0.4"/>
      ${dot(12, s/2, 1, '#6aaaee', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#2c5c9c"/>
      <path d="M0,10 Q10,6 20,10 Q30,14 ${s},10" stroke="#4888cc" stroke-width="1.3" fill="none" opacity="0.5"/>
      <path d="M0,22 Q8,18 16,22 Q24,26 ${s},22" stroke="#5a9add" stroke-width="1" fill="none" opacity="0.35"/>
      ${dot(22, 16, 1.2, '#6aaaee', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#285898"/>
      <path d="M0,8 Q12,4 ${s},8" stroke="#4a88cc" stroke-width="1.5" fill="none" opacity="0.55"/>
      <path d="M0,18 Q6,14 12,18 Q18,22 24,18 Q30,14 ${s},18" stroke="#5090cc" stroke-width="1.2" fill="none" opacity="0.4"/>
      ${dot(8, 26, 0.8, '#6aaaee', 0.2)}
      ${dot(24, 6, 1, '#7ab0ee', 0.25)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DEAD TREE â€” desert / wasteland tree
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_deadTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d4c478"/>
      <rect x="${s/2-2}" y="${s/3}" width="4" height="${s*2/3}" fill="#5a4a3a" rx="1"/>
      <line x1="${s/2}" y1="${s/3+2}" x2="${s/2-8}" y2="${s/6}" stroke="#5a4a3a" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="${s/2}" y1="${s/3+4}" x2="${s/2+7}" y2="${s/5}" stroke="#5a4a3a" stroke-width="2" stroke-linecap="round"/>
      <line x1="${s/2-8}" y1="${s/6}" x2="${s/2-10}" y2="${s/8}" stroke="#5a4a3a" stroke-width="1.5" stroke-linecap="round"/>
      <line x1="${s/2+7}" y1="${s/5}" x2="${s/2+10}" y2="${s/7}" stroke="#5a4a3a" stroke-width="1.2" stroke-linecap="round"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c074"/>
      <rect x="${s/2-1.5}" y="${s/4}" width="3" height="${s*3/4}" fill="#4e3e2e" rx="1"/>
      <line x1="${s/2}" y1="${s/4+3}" x2="${s/2-6}" y2="${s/8}" stroke="#4e3e2e" stroke-width="2" stroke-linecap="round"/>
      <line x1="${s/2}" y1="${s/3}" x2="${s/2+8}" y2="${s/5}" stroke="#4e3e2e" stroke-width="1.8" stroke-linecap="round"/>
      <line x1="${s/2+8}" y1="${s/5}" x2="${s/2+6}" y2="${s/8}" stroke="#4e3e2e" stroke-width="1" stroke-linecap="round"/>
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CACTUS â€” desert succulent
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_cactus', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d4c478"/>
      <rect x="${s/2-3}" y="${s/4}" width="6" height="${s*3/4-2}" fill="#3a7a28" rx="3"/>
      <rect x="${s/2-9}" y="${s/3}" width="6" height="${s/4}" fill="#3a7a28" rx="3"/>
      <rect x="${s/2+3}" y="${s/4+2}" width="6" height="${s/3}" fill="#3a7a28" rx="3"/>
      <line x1="${s/2-9}" y1="${s/3}" x2="${s/2-6}" y2="${s/3}" stroke="#3a7a28" stroke-width="4"/>
      <line x1="${s/2+3}" y1="${s/4+2+s/6}" x2="${s/2+6}" y2="${s/4+2+s/6}" stroke="#3a7a28" stroke-width="4"/>
      ${dot(s/2, s/3, 1, '#2a6a1a', 0.3)}
      ${dot(s/2, s/2+2, 1, '#2a6a1a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d0c074"/>
      <rect x="${s/2-2.5}" y="${s/3}" width="5" height="${s*2/3-2}" fill="#348a24" rx="2.5"/>
      <line x1="${s/2}" y1="${s/3+6}" x2="${s/2-7}" y2="${s/3+2}" stroke="#348a24" stroke-width="4" stroke-linecap="round"/>
      <line x1="${s/2}" y1="${s/2}" x2="${s/2+6}" y2="${s/3+4}" stroke="#348a24" stroke-width="3.5" stroke-linecap="round"/>
      ${dot(s/2-1, s/3+4, 0.8, '#2a7a1a', 0.3)}
      ${dot(s/2+1, s/2+4, 0.8, '#2a7a1a', 0.25)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d6c67a"/>
      <ellipse cx="${s/2}" cy="${s/2+4}" rx="4" ry="${s/3}" fill="#408a30"/>
      <ellipse cx="${s/2}" cy="${s/2+4}" rx="3" ry="${s/3-2}" fill="#4a9a3a" opacity="0.5"/>
      ${dot(s/2, s/3+2, 1, '#60b050', 0.4)}
      ${dot(s/2-1, s/2+6, 0.8, '#308020', 0.3)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SNOW TREE â€” frosted evergreen
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_snowTree', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8d2dc"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#5a3a1a" rx="1"/>
      <polygon points="${s/2},2 ${s/2+10},${s/3+2} ${s/2-10},${s/3+2}" fill="#2a5a28"/>
      <polygon points="${s/2},${s/6} ${s/2+12},${s/2+2} ${s/2-12},${s/2+2}" fill="#2e6430"/>
      <polygon points="${s/2},${s/3} ${s/2+13},${s*2/3} ${s/2-13},${s*2/3}" fill="#326a34"/>
      ${dot(s/2-5, s/3-2, 2.5, '#dce6ee', 0.7)}
      ${dot(s/2+4, s/3+6, 2, '#d8e2ea', 0.6)}
      ${dot(s/2, s/6+2, 1.5, '#e0eaf2', 0.65)}
      ${dot(s/2-8, s/2, 2, '#dce6ee', 0.5)}
      ${dot(s/2+6, s/2+4, 1.8, '#d8e2ea', 0.55)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c4cdd6"/>
      <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/2-2}" fill="#5a3a1a" rx="1"/>
      <circle cx="${s/2}" cy="${s/3+2}" r="${s/3}" fill="#2a5828"/>
      <circle cx="${s/2-4}" cy="${s/3+4}" r="${s/4}" fill="#306a2e"/>
      <circle cx="${s/2+4}" cy="${s/3}" r="${s/4}" fill="#28582a"/>
      ${dot(s/2-2, s/4, 3, '#dce6ee', 0.65)}
      ${dot(s/2+5, s/3+2, 2.5, '#d8e2ea', 0.55)}
      ${dot(s/2-6, s/3+6, 2, '#e0eaf2', 0.5)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cad4de"/>
      <rect x="${s/2-1.5}" y="${s*2/3}" width="3" height="${s/3}" fill="#4a3018" rx="1"/>
      <polygon points="${s/2},4 ${s/2+8},${s/3} ${s/2-8},${s/3}" fill="#285a26"/>
      <polygon points="${s/2},${s/5} ${s/2+10},${s/2} ${s/2-10},${s/2}" fill="#2c6230"/>
      <polygon points="${s/2},${s/3+2} ${s/2+11},${s*2/3-2} ${s/2-11},${s*2/3-2}" fill="#306634"/>
      ${dot(s/2, 6, 2, '#e0eaf2', 0.7)}
      ${dot(s/2-6, s/3+4, 2.5, '#dce6ee', 0.6)}
      ${dot(s/2+5, s/2-2, 2, '#d8e2ea', 0.55)}
      ${dot(s/2-3, s/2+6, 1.5, '#e4ecf4', 0.5)}
    `)),
  ]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BUSH â€” small shrub on grass
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  mgr.addVariants('tile_bush', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3a6a28"/>
      <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3}" ry="${s/4}" fill="#3a8a2a"/>
      <ellipse cx="${s/2-4}" cy="${s/2+2}" rx="${s/5}" ry="${s/5}" fill="#48983a"/>
      <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="${s/5}" ry="${s/5}" fill="#2e7a1e"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/5}" ry="${s/6}" fill="#50a040" opacity="0.6"/>
      ${dot(s/2-6, s/2+1, 1, '#5aaa4a', 0.4)}
      ${dot(s/2+5, s/2-1, 1, '#2a7a1a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#386828"/>
      <ellipse cx="${s/2+2}" cy="${s/2+5}" rx="${s/3-2}" ry="${s/4-1}" fill="#3c8c2c"/>
      <ellipse cx="${s/2-3}" cy="${s/2+3}" rx="${s/4}" ry="${s/5}" fill="#449436"/>
      <ellipse cx="${s/2+3}" cy="${s/2+1}" rx="${s/5}" ry="${s/6}" fill="#4ca03c" opacity="0.5"/>
      ${dot(s/2-2, s/2+6, 1.5, '#e44a4a', 0.4)}
      ${dot(s/2+4, s/2+4, 1.2, '#e44a4a', 0.35)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#3c6c2a"/>
      <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/2.8}" ry="${s/3.5}" fill="#388a28"/>
      <ellipse cx="${s/2-3}" cy="${s/2+1}" rx="${s/4}" ry="${s/5}" fill="#42942e"/>
      <ellipse cx="${s/2+5}" cy="${s/2+4}" rx="${s/5}" ry="${s/5}" fill="#2c7c1c"/>
      <ellipse cx="${s/2}" cy="${s/2-1}" rx="${s/6}" ry="${s/7}" fill="#4c9c3c" opacity="0.5"/>
    `)),
  ]);
});


</script>
  <script>
// ============================================================
// Biome Tiles â€” World map terrain (plains, forest, mountain, etc.)
// Multiple variants per biome for visual variety.
// Linked to: data/biomes.json (biome properties like dangerMod, color)
// ============================================================

SVGTileManager.register('biome', (mgr) => {
  const s = mgr.tileSize;

  function dot(cx, cy, r, fill, opacity) {
    return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fill}" opacity="${opacity || 1}"/>`;
  }

  // â”€â”€ Plains â€” rolling green â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_plains', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#4a7a30"/>
      <ellipse cx="${s/4}" cy="${s*3/4}" rx="${s/3}" ry="${s/6}" fill="#5a8a3c" opacity="0.6"/>
      <ellipse cx="${s*3/4}" cy="${s/3}" rx="${s/4}" ry="${s/8}" fill="#5a8a3c" opacity="0.4"/>
      ${dot(6, 8, 1, '#6a9a4c', 0.5)}
      ${dot(22, 24, 1, '#6a9a4c', 0.5)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#4c7c32"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/5}" fill="#568a38" opacity="0.5"/>
      <ellipse cx="${s/5}" cy="${s/4}" rx="${s/5}" ry="${s/8}" fill="#5a8e3c" opacity="0.35"/>
      ${dot(24, 8, 1, '#6a9a4c', 0.4)}
      ${dot(8, 26, 0.8, '#5c8c38', 0.45)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#488028"/>
      <ellipse cx="${s*3/4}" cy="${s*2/3}" rx="${s/3}" ry="${s/6}" fill="#5a8a3c" opacity="0.5"/>
      <ellipse cx="${s/3}" cy="${s/5}" rx="${s/4}" ry="${s/7}" fill="#528634" opacity="0.4"/>
      ${dot(14, 20, 1.2, '#6a9a4c', 0.35)}
      ${dot(4, 14, 0.8, '#5e8e3a', 0.4)}
      ${dot(28, 28, 0.6, '#6a9a4c', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#4e7e34"/>
      <ellipse cx="${s/2}" cy="${s*3/4}" rx="${s/2.5}" ry="${s/7}" fill="#588a38" opacity="0.45"/>
      ${dot(6, 6, 1.5, '#e8d44a', 0.4)}
      ${dot(7, 6, 0.8, '#f0e060', 0.5)}
      ${dot(20, 18, 0.8, '#6a9a4c', 0.35)}
    `)),
  ]);

  // â”€â”€ Forest â€” dense trees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_forest', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4a10"/>
      <circle cx="8" cy="10" r="6" fill="#2d6a1e"/>
      <circle cx="22" cy="8" r="7" fill="#256018"/>
      <circle cx="14" cy="20" r="6" fill="#2d7020"/>
      <circle cx="26" cy="22" r="5" fill="#256018"/>
      <rect x="7" y="14" width="2" height="6" fill="#5a3a1a"/>
      <rect x="21" y="13" width="2" height="7" fill="#5a3a1a"/>
      <rect x="13" y="24" width="2" height="5" fill="#5a3a1a"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1c4c12"/>
      <circle cx="6" cy="8" r="5" fill="#2a6a1c"/>
      <circle cx="18" cy="6" r="6" fill="#286418"/>
      <circle cx="28" cy="10" r="5" fill="#2e7020"/>
      <circle cx="10" cy="22" r="7" fill="#246016"/>
      <circle cx="24" cy="24" r="5" fill="#2a6a1c"/>
      <rect x="5" y="12" width="2" height="5" fill="#5a3a1a"/>
      <rect x="17" y="10" width="2" height="6" fill="#5a3a1a"/>
      <rect x="9" y="26" width="2" height="5" fill="#5a3a1a"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#184a0e"/>
      <circle cx="10" cy="12" r="7" fill="#2c6c1e"/>
      <circle cx="24" cy="10" r="6" fill="#226014"/>
      <circle cx="8" cy="6" r="4" fill="#306e20"/>
      <circle cx="20" cy="22" r="6" fill="#286818"/>
      <rect x="9" y="16" width="2" height="7" fill="#5a3a1a"/>
      <rect x="23" y="14" width="2" height="6" fill="#5a3a1a"/>
      <rect x="19" y="26" width="2" height="5" fill="#5a3a1a"/>
      ${dot(4, 28, 1, '#1e5612', 0.4)}
    `)),
    // Pine forest variant
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a4810"/>
      <polygon points="8,4 14,18 2,18" fill="#1e6414"/>
      <polygon points="22,2 30,20 14,20" fill="#1c5e12"/>
      <polygon points="14,14 22,28 6,28" fill="#206816"/>
      <rect x="7" y="17" width="2" height="5" fill="#5a3a1a"/>
      <rect x="21" y="19" width="2" height="5" fill="#5a3a1a"/>
      <rect x="13" y="27" width="2" height="4" fill="#5a3a1a"/>
    `)),
  ]);

  // â”€â”€ Mountain â€” rocky peaks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_mountain', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6a6a50"/>
      <polygon points="${s/2},2 ${s-4},${s-2} 4,${s-2}" fill="#8a7a5a"/>
      <polygon points="${s/2},2 ${s/2+2},8 ${s/2-6},${s/2}" fill="#9a8a6a" opacity="0.6"/>
      <polygon points="${s/2-2},4 ${s/2+2},4 ${s/2},0" fill="#ddd" opacity="0.7"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#686848"/>
      <polygon points="${s/2+4},4 ${s-2},${s-2} 8,${s-2}" fill="#887858"/>
      <polygon points="${s/2+4},4 ${s/2+6},10 ${s/2},${s/2+2}" fill="#988868" opacity="0.55"/>
      <polygon points="${s/2+2},6 ${s/2+5},6 ${s/2+3},2" fill="#ccc" opacity="0.6"/>
      ${dot(8, s-4, 1, '#7a7a5a', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#6c6c4e"/>
      <polygon points="6,6 18,${s-2} 0,${s-2}" fill="#847454"/>
      <polygon points="20,4 ${s},${s-2} 10,${s-2}" fill="#8a7a5a"/>
      <polygon points="6,6 8,10 2,${s/2}" fill="#948462" opacity="0.5"/>
      <polygon points="20,4 22,8 18,${s/2-2}" fill="#9a8a6a" opacity="0.5"/>
      <polygon points="5,8 7,8 6,4" fill="#ddd" opacity="0.6"/>
      <polygon points="19,6 21,6 20,2" fill="#ddd" opacity="0.65"/>
    `)),
  ]);

  // â”€â”€ Snow â€” white terrain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_snow', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8d0d8"/>
      ${dot(5, 8, 2, '#dde4ea', 0.7)}
      ${dot(20, 14, 2.5, '#dde4ea', 0.6)}
      ${dot(12, 24, 2, '#e0e8f0', 0.5)}
      ${dot(26, 6, 1.5, '#e8f0f8', 0.8)}
      ${dot(8, 20, 1, '#f0f4fa', 0.6)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cad2da"/>
      ${dot(10, 6, 2, '#dce2e8', 0.65)}
      ${dot(24, 18, 2, '#dde4ea', 0.55)}
      ${dot(6, 22, 1.5, '#e2eaf0', 0.5)}
      ${dot(18, 28, 1.8, '#e0e8f0', 0.45)}
      ${dot(28, 4, 1, '#e8f0f8', 0.7)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c6ced6"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/5}" fill="#d4dce4" opacity="0.4"/>
      ${dot(4, 10, 1.5, '#dde4ea', 0.5)}
      ${dot(22, 8, 1, '#e8f0f8', 0.6)}
      ${dot(14, 26, 2, '#e0e8f0', 0.4)}
      ${dot(28, 22, 1, '#d8e0e8', 0.5)}
    `)),
  ]);

  // â”€â”€ Sea â€” deep water â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_sea', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1a3a7a"/>
      <path d="M0,10 Q8,6 16,10 Q24,14 ${s},10" stroke="#2a5aaa" stroke-width="2" fill="none" opacity="0.6"/>
      <path d="M0,20 Q8,16 16,20 Q24,24 ${s},20" stroke="#2a5aaa" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M0,28 Q8,24 16,28 Q24,32 ${s},28" stroke="#3a6abb" stroke-width="1.5" fill="none" opacity="0.4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#1c3c7c"/>
      <path d="M0,8 Q10,4 20,8 Q30,12 ${s},8" stroke="#2858a8" stroke-width="1.8" fill="none" opacity="0.55"/>
      <path d="M0,18 Q6,14 12,18 Q18,22 24,18 Q30,14 ${s},18" stroke="#2a5aaa" stroke-width="2" fill="none" opacity="0.45"/>
      <path d="M0,26 Q12,22 ${s},26" stroke="#3a6abb" stroke-width="1.2" fill="none" opacity="0.35"/>
      ${dot(20, 14, 1, '#4a7acc', 0.2)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#183878"/>
      <path d="M0,12 Q8,8 16,12 Q24,16 ${s},12" stroke="#2c5eae" stroke-width="2" fill="none" opacity="0.5"/>
      <path d="M0,22 Q10,18 20,22 Q30,26 ${s},22" stroke="#2a5aaa" stroke-width="1.5" fill="none" opacity="0.45"/>
      ${dot(8, 6, 1.2, '#4a7acc', 0.15)}
      ${dot(26, 26, 0.8, '#4a7acc', 0.15)}
    `)),
  ]);

  // â”€â”€ Road (world map) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_road', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a89868"/>
      <rect x="4" y="0" width="${s-8}" height="${s}" fill="#b8a878"/>
      ${dot(10, 8, 1, '#c8b888', 0.4)}
      ${dot(22, 20, 1, '#c8b888', 0.4)}
      <line x1="8" y1="0" x2="8" y2="${s}" stroke="#a09060" stroke-width="0.5" stroke-dasharray="4 4"/>
      <line x1="24" y1="0" x2="24" y2="${s}" stroke="#a09060" stroke-width="0.5" stroke-dasharray="4 4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#a69666"/>
      <rect x="4" y="0" width="${s-8}" height="${s}" fill="#b6a676"/>
      ${dot(12, 12, 1.2, '#c6b686', 0.35)}
      ${dot(20, 26, 0.8, '#c6b686', 0.3)}
      <line x1="8" y1="0" x2="8" y2="${s}" stroke="#9e8e5e" stroke-width="0.5" stroke-dasharray="4 4"/>
      <line x1="24" y1="0" x2="24" y2="${s}" stroke="#9e8e5e" stroke-width="0.5" stroke-dasharray="4 4"/>
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#aa9a6a"/>
      <rect x="4" y="0" width="${s-8}" height="${s}" fill="#baaa7a"/>
      ${dot(8, 6, 0.8, '#cabb8a', 0.4)}
      ${dot(24, 16, 1, '#cabb8a', 0.35)}
      ${dot(16, 28, 0.6, '#c0b080', 0.3)}
      <line x1="8" y1="0" x2="8" y2="${s}" stroke="#a29262" stroke-width="0.5" stroke-dasharray="4 4"/>
      <line x1="24" y1="0" x2="24" y2="${s}" stroke="#a29262" stroke-width="0.5" stroke-dasharray="4 4"/>
    `)),
  ]);

  // â”€â”€ Beach â€” sandy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_beach', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d8c888"/>
      ${dot(6, 10, 1.5, '#e8d8a0', 0.6)}
      ${dot(20, 6, 1, '#e8d8a0', 0.5)}
      ${dot(14, 22, 1.5, '#c8b878', 0.4)}
      ${dot(26, 18, 1, '#e8d8a0', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#d6c686"/>
      ${dot(10, 8, 1.2, '#e6d69e', 0.55)}
      ${dot(24, 14, 1.5, '#e6d69e', 0.45)}
      ${dot(4, 24, 1, '#c6b676', 0.35)}
      ${dot(18, 28, 0.8, '#e0d098', 0.4)}
      ${dot(28, 6, 1, '#dcc890', 0.3)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#daca8a"/>
      ${dot(8, 14, 1.8, '#eadaa2', 0.5)}
      ${dot(22, 22, 1, '#eadaa2', 0.4)}
      ${dot(16, 4, 1.2, '#caba7a', 0.35)}
      ${dot(4, 28, 0.8, '#e2d29a', 0.3)}
    `)),
  ]);

  // â”€â”€ Desert â€” arid sand â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mgr.addVariants('biome_desert', [
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c8b060"/>
      <ellipse cx="${s/3}" cy="${s*2/3}" rx="${s/2}" ry="${s/5}" fill="#d8c070" opacity="0.5"/>
      <ellipse cx="${s*2/3}" cy="${s/3}" rx="${s/3}" ry="${s/6}" fill="#d8c070" opacity="0.4"/>
      ${dot(24, 24, 1, '#b8a050', 0.6)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#c6ae5e"/>
      <ellipse cx="${s/2}" cy="${s/2}" rx="${s/2.5}" ry="${s/6}" fill="#d6be6e" opacity="0.45"/>
      <ellipse cx="${s/4}" cy="${s*3/4}" rx="${s/4}" ry="${s/8}" fill="#d4bc6c" opacity="0.35"/>
      ${dot(8, 8, 1.2, '#b6a44e', 0.5)}
      ${dot(26, 20, 0.8, '#ccba62', 0.4)}
    `)),
    mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#cab262"/>
      <ellipse cx="${s*2/3}" cy="${s*2/3}" rx="${s/3}" ry="${s/5}" fill="#dac272" opacity="0.4"/>
      ${dot(6, 12, 1, '#b8a654', 0.5)}
      ${dot(20, 4, 1.5, '#d4c06a', 0.35)}
      ${dot(14, 28, 0.8, '#bca858', 0.4)}
    `)),
  ]);
});

</script>
  <script>
// ============================================================
// Item Tiles â€” weapons, armor, food, potions, resources, etc.
// Linked to: data/items.json (item properties like type, subtype, value)
// ============================================================

SVGTileManager.register('items', (mgr) => {
  const s = mgr.tileSize;

  // â”€â”€ Weapons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Long Sword â€” polished steel blade with fuller, leather-wrapped hilt, round pommel
  mgr.cache['item_weapon_longSword'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="2" fill="#000" opacity="0.15"/>
    <line x1="${s/2+6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#8a8a9a" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2+6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#c0c0e0" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="${s/2+5}" y1="${s-7}" x2="${s/2-5}" y2="6" stroke="#e8e8ff" stroke-width="0.8" stroke-linecap="round" opacity="0.6"/>
    <line x1="${s/2-1}" y1="${s/2-3}" x2="${s/2+3}" y2="${s/2+1}" stroke="#d0d0e0" stroke-width="0.5" opacity="0.4"/>
    <rect x="${s/2-5}" y="${s/2}" width="10" height="3" fill="#6a5020" rx="1" transform="rotate(-25 ${s/2} ${s/2+1})"/>
    <rect x="${s/2-5}" y="${s/2}" width="10" height="1.5" fill="#8a7030" rx="1" transform="rotate(-25 ${s/2} ${s/2+1})"/>
    <line x1="${s/2-5}" y1="${s/2+2}" x2="${s/2+5}" y2="${s/2-1}" stroke="#4a3010" stroke-width="0.5" opacity="0.5"/>
    <circle cx="${s/2+7}" cy="${s-5}" r="2.5" fill="#7a6020" stroke="#5a4010" stroke-width="0.5"/>
    <circle cx="${s/2+7}" cy="${s-5}" r="1.2" fill="#a08030" opacity="0.6"/>
    <circle cx="${s/2+6.5}" cy="${s-5.5}" r="0.6" fill="#d0b060" opacity="0.7"/>
  `));

  // Short Sword / Dagger â€” shorter blade, compact crossguard, visible edge bevel
  mgr.cache['item_weapon_shortSword'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-4}" rx="5" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2+4}" y1="${s-8}" x2="${s/2-3}" y2="9" stroke="#909098" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-8}" x2="${s/2-3}" y2="9" stroke="#c0c0d0" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2+3.5}" y1="${s-8.5}" x2="${s/2-2.5}" y2="9.5" stroke="#e0e0f0" stroke-width="0.6" opacity="0.5"/>
    <rect x="${s/2-4}" y="${s/2-1}" width="8" height="3" fill="#6a5020" rx="1" transform="rotate(-20 ${s/2} ${s/2})"/>
    <rect x="${s/2-4}" y="${s/2-1}" width="8" height="1.2" fill="#8a7030" rx="1" transform="rotate(-20 ${s/2} ${s/2})"/>
    <circle cx="${s/2+4.5}" cy="${s-7}" r="1.8" fill="#7a6020" stroke="#5a4010" stroke-width="0.5"/>
    <circle cx="${s/2+4.2}" cy="${s-7.3}" r="0.5" fill="#c0a040" opacity="0.6"/>
    <polygon points="${s/2-3},10 ${s/2-4},8 ${s/2-2},8" fill="#d0d0e0" opacity="0.4"/>
  `));

  // Battle Axe â€” oak shaft, double-headed steel blade with edge detail
  mgr.cache['item_weapon_axe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="3" stroke="#6a4a20" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="3" stroke="#8a6a3a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="${s/2+0.5}" y1="${s-4}" x2="${s/2+0.5}" y2="3" stroke="#a08050" stroke-width="0.5" opacity="0.4"/>
    <path d="M${s/2-2},5 Q${s/2-11},${s/3} ${s/2-2},${s/2-2}" fill="#a0a0b8" stroke="#707080" stroke-width="1"/>
    <path d="M${s/2+2},5 Q${s/2+11},${s/3} ${s/2+2},${s/2-2}" fill="#a0a0b8" stroke="#707080" stroke-width="1"/>
    <path d="M${s/2-2},6 Q${s/2-8},${s/3-1} ${s/2-2},${s/2-3}" fill="#c0c0d0" opacity="0.35"/>
    <path d="M${s/2+2},6 Q${s/2+8},${s/3-1} ${s/2+2},${s/2-3}" fill="#c0c0d0" opacity="0.35"/>
    <line x1="${s/2-9}" y1="${s/3}" x2="${s/2-3}" y2="${s/3}" stroke="#e0e0f0" stroke-width="0.4" opacity="0.5"/>
    <line x1="${s/2+9}" y1="${s/3}" x2="${s/2+3}" y2="${s/3}" stroke="#e0e0f0" stroke-width="0.4" opacity="0.5"/>
    <rect x="${s/2-1}" y="${s-6}" width="2" height="3" fill="#5a3a10" rx="0.5" opacity="0.5"/>
  `));

  // Short Bow â€” carved wood limbs, taut string, feathered arrow nocked
  mgr.cache['item_weapon_bow'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2-2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <path d="M${s/2-6},${s-6} Q${s/2-13},${s/2} ${s/2-6},5" stroke="#6a4a20" stroke-width="3" fill="none"/>
    <path d="M${s/2-6},${s-6} Q${s/2-13},${s/2} ${s/2-6},5" stroke="#8a6a3a" stroke-width="2" fill="none"/>
    <path d="M${s/2-5},${s-7} Q${s/2-11},${s/2} ${s/2-5},6" stroke="#a08050" stroke-width="0.5" fill="none" opacity="0.4"/>
    <line x1="${s/2-6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#ddd" stroke-width="0.8"/>
    <line x1="${s/2-6}" y1="${s-6}" x2="${s/2-6}" y2="5" stroke="#fff" stroke-width="0.3" opacity="0.4"/>
    <line x1="${s/2-4}" y1="${s/2}" x2="${s/2+9}" y2="${s/2-3}" stroke="#a0a0b0" stroke-width="1.8" stroke-linecap="round"/>
    <line x1="${s/2-4}" y1="${s/2}" x2="${s/2+9}" y2="${s/2-3}" stroke="#c0c0d0" stroke-width="0.6" opacity="0.5"/>
    <polygon points="${s/2+9},${s/2-3} ${s/2+7},${s/2-6} ${s/2+11},${s/2-4}" fill="#8a8a98" stroke="#606068" stroke-width="0.5"/>
    <line x1="${s/2+8}" y1="${s/2-3}" x2="${s/2+6}" y2="${s/2-1}" stroke="#c44" stroke-width="1" stroke-linecap="round" opacity="0.7"/>
    <line x1="${s/2+8}" y1="${s/2-4}" x2="${s/2+6}" y2="${s/2-2}" stroke="#e66" stroke-width="0.6" stroke-linecap="round" opacity="0.5"/>
  `));

  // Oak Staff â€” gnarled wood, glowing crystal orb, arcane rings
  mgr.cache['item_weapon_staff'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="8" stroke="#5a3a1a" stroke-width="4" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="8" stroke="#7a5a2a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+0.8}" y1="${s-4}" x2="${s/2+0.8}" y2="8" stroke="#9a7a4a" stroke-width="0.6" opacity="0.4"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="2" ry="0.8" fill="#4a3010" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2-4}" rx="2" ry="0.8" fill="#4a3010" opacity="0.5"/>
    <circle cx="${s/2}" cy="6" r="5" fill="#3344aa" opacity="0.2"/>
    <circle cx="${s/2}" cy="6" r="4" fill="none" stroke="#6688ff" stroke-width="1.8"/>
    <circle cx="${s/2}" cy="6" r="4" fill="none" stroke="#aaccff" stroke-width="0.5" opacity="0.5"/>
    <circle cx="${s/2}" cy="6" r="2.5" fill="#6688ff" opacity="0.6"/>
    <circle cx="${s/2}" cy="6" r="1.5" fill="#aaccff" opacity="0.8"/>
    <circle cx="${s/2-1}" cy="5" r="0.6" fill="#fff" opacity="0.9"/>
    <circle cx="${s/2+2}" cy="4" r="1" fill="#aaf" opacity="0.15"/>
    <circle cx="${s/2-3}" cy="8" r="0.8" fill="#88f" opacity="0.15"/>
  `));

  // Wooden Mace â€” thick handle, spiked iron head with rivets
  mgr.cache['item_weapon_mace'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.12"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+1}" stroke="#5a3a1a" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+1}" stroke="#8a6a3a" stroke-width="2.5" stroke-linecap="round"/>
    <line x1="${s/2+0.6}" y1="${s-4}" x2="${s/2+0.6}" y2="${s/3+1}" stroke="#a08050" stroke-width="0.5" opacity="0.35"/>
    <circle cx="${s/2}" cy="${s/4+1}" r="${s/5+1}" fill="#666" stroke="#555" stroke-width="1"/>
    <circle cx="${s/2}" cy="${s/4+1}" r="${s/5}" fill="#888" stroke="#6a6a70" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/4+1}" r="${s/7}" fill="#9a9a9a"/>
    <circle cx="${s/2-1}" cy="${s/4-1}" r="1" fill="#bbb" opacity="0.6"/>
    <polygon points="${s/2-7},${s/4+1} ${s/2-5},${s/4-1} ${s/2-5},${s/4+3}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <polygon points="${s/2+7},${s/4+1} ${s/2+5},${s/4-1} ${s/2+5},${s/4+3}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <polygon points="${s/2},${s/4-6} ${s/2-2},${s/4-3} ${s/2+2},${s/4-3}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <polygon points="${s/2},${s/4+8} ${s/2-2},${s/4+5} ${s/2+2},${s/4+5}" fill="#777" stroke="#555" stroke-width="0.3"/>
    <circle cx="${s/2-2}" cy="${s/4}" r="0.7" fill="#aaa"/>
    <circle cx="${s/2+2}" cy="${s/4+2}" r="0.7" fill="#aaa"/>
  `));

  // Broken Sword â€” chipped, shorter blade with rust
  mgr.cache['item_weapon_brokenSword'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="2" fill="#000" opacity="0.15"/>
    <line x1="${s/2+5}" y1="${s-6}" x2="${s/2-2}" y2="${s/3+2}" stroke="#7a7a7a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+5}" y1="${s-6}" x2="${s/2-2}" y2="${s/3+2}" stroke="#999" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2-2}" y1="${s/3+2}" x2="${s/2-4}" y2="${s/3-1}" stroke="#999" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>
    <line x1="${s/2-1}" y1="${s/3+1}" x2="${s/2-5}" y2="${s/3+3}" stroke="#999" stroke-width="1" opacity="0.4"/>
    <circle cx="${s/2+1}" cy="${s/2+2}" r="1" fill="#8a4a20" opacity="0.5"/>
    <circle cx="${s/2-1}" cy="${s/3+4}" r="0.7" fill="#8a4a20" opacity="0.4"/>
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="3" fill="#6a5020" rx="1" transform="rotate(-20 ${s/2} ${s/2+3})"/>
    <circle cx="${s/2+6}" cy="${s-5}" r="2" fill="#6a5020" stroke="#4a3010" stroke-width="0.5"/>
  `));

  // â”€â”€ Armor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Body Armor â€” layered leather cuirass with stitching, buckle, shoulder plates
  mgr.cache['item_armor_body'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.12"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8 L${s/2+4},4 L${s/2},6 L${s/2-4},4 Z" fill="#7a5a30" stroke="#5a3a10" stroke-width="1"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8 L${s/2+4},4 L${s/2},6 L${s/2-4},4 Z" fill="#8a6a40" opacity="0.8"/>
    <path d="M${s/2-4},4 L${s/2},6 L${s/2+4},4 L${s/2+6},6 L${s/2-6},6 Z" fill="#9a7a50" opacity="0.5"/>
    <line x1="${s/2}" y1="6" x2="${s/2}" y2="${s-8}" stroke="#6a4a20" stroke-width="1" opacity="0.4"/>
    <line x1="${s/2-4}" y1="10" x2="${s/2-6}" y2="${s-8}" stroke="#6a4a20" stroke-width="0.5" opacity="0.3" stroke-dasharray="2 2"/>
    <line x1="${s/2+4}" y1="10" x2="${s/2+6}" y2="${s-8}" stroke="#6a4a20" stroke-width="0.5" opacity="0.3" stroke-dasharray="2 2"/>
    <rect x="${s/2-1}" y="${s/2-1}" width="2" height="3" fill="#c8a040" rx="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="0.8" fill="#e8c060"/>
    <rect x="${s/2-7}" y="8" width="3" height="4" fill="#8a6a40" rx="1" opacity="0.6"/>
    <rect x="${s/2+4}" y="8" width="3" height="4" fill="#8a6a40" rx="1" opacity="0.6"/>
    <path d="M${s/2-8},${s-6} L${s/2+10},${s-6}" stroke="#9a7a50" stroke-width="0.5" opacity="0.4"/>
  `));

  // Iron Helm â€” rounded dome, nose guard, cheek plates, rivet detail
  mgr.cache['item_armor_head'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-4}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+1}" ry="${s/4+1}" fill="#707078" stroke="#606068" stroke-width="1"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3}" ry="${s/4}" fill="#888890"/>
    <ellipse cx="${s/2}" cy="${s/2-1}" rx="${s/3+2}" ry="${s/5+1}" fill="#8a8a92" stroke="#707078" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="${s/3}" ry="${s/5}" fill="#9a9aa0" opacity="0.6"/>
    <ellipse cx="${s/2-2}" cy="${s/2-3}" rx="${s/5}" ry="${s/8}" fill="#b0b0b8" opacity="0.35"/>
    <rect x="${s/2-1}" y="${s/4-1}" width="2" height="${s/3+2}" fill="#808088" rx="0.5"/>
    <rect x="${s/2-0.5}" y="${s/4}" width="1" height="${s/3}" fill="#9a9aa0" rx="0.3" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.8" fill="#aaa"/>
    <circle cx="${s/2+5}" cy="${s/2+1}" r="0.8" fill="#aaa"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="0.6" fill="#bbb" opacity="0.5"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="0.6" fill="#bbb" opacity="0.5"/>
  `));

  // Leather Boots â€” tall boots with laces, sole detail, folded cuff
  mgr.cache['item_armor_foot'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <path d="M${s/2-6},7 L${s/2-7},${s-8} L${s/2-2},${s-5} L${s/2+7},${s-5} L${s/2+7},${s-9} L${s/2+4},7 Z" fill="#6a4a20" stroke="#4a2a08" stroke-width="1"/>
    <path d="M${s/2-6},7 L${s/2-7},${s-8} L${s/2-2},${s-5} L${s/2+7},${s-5} L${s/2+7},${s-9} L${s/2+4},7 Z" fill="#7a5a30" opacity="0.7"/>
    <path d="M${s/2-6},7 L${s/2+4},7 L${s/2+3},10 L${s/2-5},10 Z" fill="#8a6a40" opacity="0.5"/>
    <line x1="${s/2-2}" y1="12" x2="${s/2+1}" y2="12" stroke="#5a3a10" stroke-width="0.6"/>
    <line x1="${s/2-2}" y1="15" x2="${s/2+1}" y2="15" stroke="#5a3a10" stroke-width="0.6"/>
    <line x1="${s/2-2}" y1="18" x2="${s/2+1}" y2="18" stroke="#5a3a10" stroke-width="0.6"/>
    <line x1="${s/2-2}" y1="21" x2="${s/2+1}" y2="21" stroke="#5a3a10" stroke-width="0.6"/>
    <path d="M${s/2-7},${s-8} L${s/2-2},${s-5} L${s/2+7},${s-5}" stroke="#4a2a08" stroke-width="1.5" fill="none"/>
    <line x1="${s/2+5}" y1="${s-5}" x2="${s/2+7}" y2="${s-5}" stroke="#8a6a40" stroke-width="2"/>
  `));

  // Wooden Shield â€” round shield with iron rim, boss, wood grain
  mgr.cache['item_armor_hand'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+1}" ry="${s/2.5+1}" fill="#6a5020" stroke="#4a3010" stroke-width="1.2"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/2.5}" fill="#8a7030"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3-1}" ry="${s/2.5-1}" fill="#9a8040" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2}" x2="${s/2+6}" y2="${s/2}" stroke="#7a6020" stroke-width="0.6" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2-8}" x2="${s/2}" y2="${s/2+8}" stroke="#7a6020" stroke-width="0.6" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="3" fill="#8a8090" stroke="#6a6060" stroke-width="0.8"/>
    <circle cx="${s/2}" cy="${s/2}" r="2" fill="#9a9098"/>
    <circle cx="${s/2-0.5}" cy="${s/2-0.5}" r="0.7" fill="#bbb" opacity="0.5"/>
    <ellipse cx="${s/2-3}" cy="${s/2-4}" rx="2" ry="1" fill="#a09040" opacity="0.25" transform="rotate(-20 ${s/2-3} ${s/2-4})"/>
  `));

  // Ragged Cloth â€” tattered body armor
  mgr.cache['item_armor_raggedCloth'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.1"/>
    <path d="M${s/2-7},8 L${s/2-9},${s-6} L${s/2+9},${s-6} L${s/2+7},8 L${s/2+3},5 L${s/2},7 L${s/2-3},5 Z" fill="#6a5030" stroke="#4a3010" stroke-width="0.8"/>
    <path d="M${s/2-7},8 L${s/2-9},${s-6} L${s/2+9},${s-6} L${s/2+7},8" fill="#8a6a40" opacity="0.6"/>
    <line x1="${s/2-4}" y1="12" x2="${s/2-6}" y2="${s-8}" stroke="#5a3a10" stroke-width="0.8" opacity="0.4"/>
    <line x1="${s/2+2}" y1="15" x2="${s/2+4}" y2="${s-10}" stroke="#5a3a10" stroke-width="0.6" opacity="0.3"/>
    <line x1="${s/2-2}" y1="${s/2}" x2="${s/2+3}" y2="${s/2+2}" stroke="#4a2a08" stroke-width="0.5" opacity="0.5"/>
    <line x1="${s/2-5}" y1="${s/2+5}" x2="${s/2}" y2="${s/2+4}" stroke="#4a2a08" stroke-width="0.5" opacity="0.4"/>
  `));

  // Chain Mail â€” heavier metallic armor
  mgr.cache['item_armor_chainMail'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.12"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8 L${s/2+4},4 L${s/2},6 L${s/2-4},4 Z" fill="#707080" stroke="#505060" stroke-width="1"/>
    <path d="M${s/2-8},8 L${s/2-10},${s-6} L${s/2+10},${s-6} L${s/2+8},8" fill="#888898" opacity="0.7"/>
    <circle cx="${s/2-4}" cy="12" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2}" cy="12" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+4}" cy="12" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2-2}" cy="15" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+2}" cy="15" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2-4}" cy="18" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2}" cy="18" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+4}" cy="18" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2-2}" cy="21" r="0.8" fill="#aaa" opacity="0.3"/>
    <circle cx="${s/2+2}" cy="21" r="0.8" fill="#aaa" opacity="0.3"/>
    <rect x="${s/2-1}" y="${s/2-1}" width="2" height="3" fill="#c8a040" rx="0.5"/>
  `));

  // â”€â”€ Food â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Bread / Ration â€” golden loaf with cross-score, sesame seeds, warm shadow
  mgr.cache['item_food'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+1}" ry="3" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+1}" ry="${s/4+1}" fill="#b08040"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#d0a050"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#dab870" opacity="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2-1}" rx="${s/4}" ry="${s/5}" fill="#e8c880" opacity="0.5"/>
    <ellipse cx="${s/2-2}" cy="${s/2-2}" rx="${s/6}" ry="${s/8}" fill="#f0d890" opacity="0.3"/>
    <line x1="${s/2-4}" y1="${s/2-1}" x2="${s/2+4}" y2="${s/2-1}" stroke="#c09040" stroke-width="0.6" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/2+2}" stroke="#c09040" stroke-width="0.6" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="0.5" fill="#c8a050" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="0.5" fill="#c8a050" opacity="0.6"/>
    <circle cx="${s/2+1}" cy="${s/2-1}" r="0.4" fill="#c8a050" opacity="0.5"/>
  `));

  // Green Herb â€” lush plant with multiple leaf shapes, veins, small flower bud
  mgr.cache['item_food_herb'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="${s/3-2}" stroke="#1a6a1a" stroke-width="2.5"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="${s/3-2}" stroke="#2a8a2a" stroke-width="1.8"/>
    <line x1="${s/2+0.5}" y1="${s-5}" x2="${s/2+0.5}" y2="${s/3-2}" stroke="#3a9a3a" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="${s/2-5}" cy="${s/3+3}" rx="4" ry="6.5" fill="#28882a" transform="rotate(-25 ${s/2-5} ${s/3+3})"/>
    <ellipse cx="${s/2-5}" cy="${s/3+3}" rx="3.5" ry="6" fill="#3aaa3a" transform="rotate(-25 ${s/2-5} ${s/3+3})" opacity="0.8"/>
    <line x1="${s/2-5}" y1="${s/3}" x2="${s/2-5}" y2="${s/3+7}" stroke="#1a7a1a" stroke-width="0.4" opacity="0.5" transform="rotate(-25 ${s/2-5} ${s/3+3})"/>
    <ellipse cx="${s/2+5}" cy="${s/3+1}" rx="4" ry="6.5" fill="#28882a" transform="rotate(25 ${s/2+5} ${s/3+1})"/>
    <ellipse cx="${s/2+5}" cy="${s/3+1}" rx="3.5" ry="6" fill="#3aaa3a" transform="rotate(25 ${s/2+5} ${s/3+1})" opacity="0.8"/>
    <line x1="${s/2+5}" y1="${s/3-2}" x2="${s/2+5}" y2="${s/3+5}" stroke="#1a7a1a" stroke-width="0.4" opacity="0.5" transform="rotate(25 ${s/2+5} ${s/3+1})"/>
    <ellipse cx="${s/2}" cy="${s/4-1}" rx="3.5" ry="5.5" fill="#30a032"/>
    <ellipse cx="${s/2}" cy="${s/4-1}" rx="3" ry="5" fill="#4aba4a" opacity="0.7"/>
    <line x1="${s/2}" y1="${s/4-4}" x2="${s/2}" y2="${s/4+3}" stroke="#1a8a1a" stroke-width="0.3" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/4-5}" r="1.5" fill="#e8e040" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/4-5}" r="0.8" fill="#fff" opacity="0.3"/>
  `));

  // Ration â€” travel pack with wrapping
  mgr.cache['item_food_ration'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <rect x="6" y="7" width="${s-12}" height="${s-14}" fill="#b09060" rx="2"/>
    <rect x="7" y="8" width="${s-14}" height="${s-16}" fill="#c8a870" rx="1.5" opacity="0.8"/>
    <line x1="${s/2-6}" y1="${s/2}" x2="${s/2+6}" y2="${s/2}" stroke="#8a6a40" stroke-width="1.5"/>
    <line x1="${s/2}" y1="8" x2="${s/2}" y2="${s-7}" stroke="#8a6a40" stroke-width="1.5"/>
    <rect x="${s/2-2}" y="${s/2-2}" width="4" height="4" fill="#907040" rx="1"/>
    <circle cx="${s/2}" cy="${s/2}" r="1.5" fill="#6a4a20"/>
  `));

  // Bread â€” golden loaf (keep existing as item_food, add specific)
  mgr.cache['item_food_bread'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+1}" ry="3" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+1}" ry="${s/4+1}" fill="#b08040"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#daa520"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/4}" fill="#e8c060" opacity="0.8"/>
    <line x1="${s/2-4}" y1="${s/2-1}" x2="${s/2+4}" y2="${s/2-1}" stroke="#c09040" stroke-width="0.8" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/2+2}" stroke="#c09040" stroke-width="0.6" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="0.6" fill="#d4a840" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="0.5" fill="#d4a840" opacity="0.5"/>
  `));

  // Grand Feast â€” large plate with multiple items
  mgr.cache['item_food_feast'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+5}" rx="${s/3+3}" ry="4" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+3}" ry="${s/4+2}" fill="#ddd" stroke="#bbb" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+2}" ry="${s/4+1}" fill="#eee" opacity="0.6"/>
    <ellipse cx="${s/2-4}" cy="${s/2}" rx="4" ry="3" fill="#b08040"/>
    <ellipse cx="${s/2-4}" cy="${s/2-1}" rx="3.5" ry="2.5" fill="#d0a050" opacity="0.8"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="3" fill="#cc3344"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="2" fill="#dd5566" opacity="0.5"/>
    <ellipse cx="${s/2+1}" cy="${s/2+2}" rx="2" ry="1.5" fill="#daa520"/>
    <circle cx="${s/2-2}" cy="${s/3}" r="1.5" fill="#3a8a3a" opacity="0.6"/>
    <circle cx="${s/2+5}" cy="${s/3+2}" r="0.8" fill="#fa4" opacity="0.7"/>
  `));

  // Generic Berries â€” red berry cluster fallback
  mgr.cache['item_food_berry'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#cc3344"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.5"/>
  `));

  // Generic Mushroom â€” brown cap, pale stem
  mgr.cache['item_food_mushroom'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#c8b090" rx="1"/>
    <rect x="${s/2-1.5}" y="${s/2+2}" width="3" height="${s/3}" fill="#d8c0a0" rx="0.5" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/4}" ry="${s/6}" fill="#aa7744"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4-1}" ry="${s/6-1}" fill="#bb8855" opacity="0.7"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/6}" ry="${s/8}" fill="#cc9966" opacity="0.4"/>
  `));

  // Generic Fish â€” simple silver fish
  mgr.cache['item_food_fish'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+2}" ry="${s/5}" fill="#6a8aaa" stroke="#5a7a9a" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3}" ry="${s/5-1}" fill="#7a9aba" opacity="0.6"/>
    <ellipse cx="${s/2-1}" cy="${s/2-1}" rx="${s/5}" ry="${s/8}" fill="#8aaacc" opacity="0.4"/>
    <polygon points="${s/2+10},${s/2} ${s/2+14},${s/2-4} ${s/2+14},${s/2+4}" fill="#5a7a9a" opacity="0.8"/>
    <circle cx="${s/2-6}" cy="${s/2-1}" r="1.2" fill="#222" opacity="0.6"/>
    <circle cx="${s/2-6}" cy="${s/2-1}" r="0.5" fill="#fff" opacity="0.5"/>
  `));

  // â”€â”€ Specific Berries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Red Berries â€” red cluster
  mgr.cache['item_food_berryRed'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#cc3344"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#cc3344"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#dd5566" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.5"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.4"/>
  `));

  // Blue Berries â€” blue cluster
  mgr.cache['item_food_berryBlue'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#2a6a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#4466cc"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#4466cc"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#4466cc"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#6688dd" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#6688dd" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#6688dd" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#fff" opacity="0.5"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.6" fill="#ccf" opacity="0.4"/>
  `));

  // Poison Berries â€” purple/green toxic
  mgr.cache['item_food_berryPoison'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2}" y1="${s/2-4}" x2="${s/2}" y2="${s/3}" stroke="#2a6a1a" stroke-width="1"/>
    <line x1="${s/2-3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#4a4a1a" stroke-width="0.8"/>
    <line x1="${s/2+3}" y1="${s/2-2}" x2="${s/2}" y2="${s/3+2}" stroke="#4a4a1a" stroke-width="0.8"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#884488"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#884488"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="3" fill="#884488"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="2" fill="#995599" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="2" fill="#995599" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+5}" r="2" fill="#995599" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="${s/2+1}" r="0.6" fill="#d8d" opacity="0.4"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.6" fill="#d8d" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/3-1}" r="1.5" fill="#a0f" opacity="0.15"/>
  `));

  // â”€â”€ Specific Mushrooms â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Glowing Mushroom â€” teal glow
  mgr.cache['item_resource_glowMushroom'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#44ddaa" opacity="0.12"/>
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#88ccaa" rx="1"/>
    <rect x="${s/2-1.5}" y="${s/2+2}" width="3" height="${s/3}" fill="#99ddbb" rx="0.5" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/4}" ry="${s/6}" fill="#33bb88"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4-1}" ry="${s/6-1}" fill="#44ddaa" opacity="0.8"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="${s/6}" ry="${s/8}" fill="#66eebb" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3}" fill="#44ddaa" opacity="0.12"/>
    <circle cx="${s/2-3}" cy="${s/2}" r="1" fill="#aaffdd" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="0.8" fill="#aaffdd" opacity="0.4"/>
  `));

  // Poison Mushroom â€” red cap with spots
  mgr.cache['item_food_mushroomPoison'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#c8b090" rx="1"/>
    <rect x="${s/2-1.5}" y="${s/2+2}" width="3" height="${s/3}" fill="#d8c0a0" rx="0.5" opacity="0.5"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="${s/4}" ry="${s/6}" fill="#cc4444"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/4-1}" ry="${s/6-1}" fill="#dd5555" opacity="0.7"/>
    <circle cx="${s/2-3}" cy="${s/2}" r="1.2" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1" fill="#fff" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.8" fill="#fff" opacity="0.4"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.7" fill="#fff" opacity="0.3"/>
  `));

  // â”€â”€ Specific Fish â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Rare Fish â€” larger, more colorful
  mgr.cache['item_food_rareFish'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+3}" ry="${s/5+1}" fill="#44aadd" stroke="#2288bb" stroke-width="0.8"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3+1}" ry="${s/5}" fill="#55bbee" opacity="0.7"/>
    <ellipse cx="${s/2-2}" cy="${s/2-2}" rx="${s/5}" ry="${s/8}" fill="#66ccff" opacity="0.5"/>
    <polygon points="${s/2+12},${s/2} ${s/2+16},${s/2-5} ${s/2+16},${s/2+5}" fill="#3399cc" opacity="0.8"/>
    <circle cx="${s/2-7}" cy="${s/2-1}" r="1.4" fill="#222" opacity="0.6"/>
    <circle cx="${s/2-7}" cy="${s/2-1}" r="0.6" fill="#fff" opacity="0.6"/>
    <line x1="${s/2-3}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2+1}" stroke="#ffd700" stroke-width="0.8" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2-2}" r="0.5" fill="#fff" opacity="0.4"/>
  `));

  // â”€â”€ Crop Foods (harvested) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Turnip â€” white/purple root vegetable
  mgr.cache['item_food_turnip'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="6" ry="7" fill="#e8e0d0"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="5.5" ry="6" fill="#f0eae0" opacity="0.8"/>
    <ellipse cx="${s/2}" cy="${s/3+1}" rx="5" ry="3" fill="#9944aa" opacity="0.5"/>
    <line x1="${s/2}" y1="4" x2="${s/2-2}" y2="1" stroke="#2a8a2a" stroke-width="1.5"/>
    <line x1="${s/2}" y1="4" x2="${s/2+2}" y2="2" stroke="#3a9a3a" stroke-width="1.2"/>
    <circle cx="${s/2-2}" cy="${s/2+2}" r="0.5" fill="#ddd" opacity="0.4"/>
  `));

  // Potato â€” brown lumpy tuber
  mgr.cache['item_food_potato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="8" ry="6" fill="#a08050"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="7" ry="5" fill="#b89060" opacity="0.8"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="4" ry="3" fill="#c8a070" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2+1}" r="0.8" fill="#8a6a40" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="0.6" fill="#8a6a40" opacity="0.4"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="0.5" fill="#8a6a40" opacity="0.3"/>
  `));

  // Strawberry â€” red heart shape with seeds
  mgr.cache['item_food_strawberry'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2},${s/3} Q${s/2-8},${s/3+2} ${s/2},${s-5} Q${s/2+8},${s/3+2} ${s/2},${s/3}" fill="#dd3344"/>
    <path d="M${s/2},${s/3} Q${s/2-6},${s/3+2} ${s/2-2},${s/2+4}" fill="#ee5566" opacity="0.5"/>
    <circle cx="${s/2-2}" cy="${s/2+1}" r="0.5" fill="#ffa" opacity="0.6"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.5" fill="#ffa" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2+4}" r="0.5" fill="#ffa" opacity="0.4"/>
    <circle cx="${s/2-3}" cy="${s/2+4}" r="0.4" fill="#ffa" opacity="0.3"/>
    <ellipse cx="${s/2}" cy="${s/3-1}" rx="4" ry="2" fill="#2a8a2a" opacity="0.6"/>
  `));

  // Corn â€” golden ear with husk
  mgr.cache['item_food_corn'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="5" ry="9" fill="#daa520"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="4.5" ry="8.5" fill="#e8c040" opacity="0.8"/>
    <line x1="${s/2}" y1="${s/3}" x2="${s/2}" y2="${s*2/3}" stroke="#c8a020" stroke-width="0.5" opacity="0.5"/>
    <line x1="${s/2-3}" y1="${s/3+1}" x2="${s/2-3}" y2="${s*2/3-1}" stroke="#c8a020" stroke-width="0.4" opacity="0.3"/>
    <line x1="${s/2+3}" y1="${s/3+1}" x2="${s/2+3}" y2="${s*2/3-1}" stroke="#c8a020" stroke-width="0.4" opacity="0.3"/>
    <path d="M${s/2-5},${s/2} Q${s/2-9},${s/3} ${s/2-4},${s/4}" fill="#5a8a2a" opacity="0.5"/>
    <path d="M${s/2+5},${s/2} Q${s/2+9},${s/3} ${s/2+4},${s/4}" fill="#5a8a2a" opacity="0.4"/>
  `));

  // Tomato â€” round red fruit with star calyx
  mgr.cache['item_food_tomato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="8" fill="#cc3322"/>
    <circle cx="${s/2}" cy="${s/2}" r="7.5" fill="#dd4433" opacity="0.8"/>
    <circle cx="${s/2-2}" cy="${s/2-2}" r="4" fill="#ee5544" opacity="0.3"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#ff8877" opacity="0.3"/>
    <polygon points="${s/2},${s/4-2} ${s/2-3},${s/4+1} ${s/2+3},${s/4+1}" fill="#2a8a2a" opacity="0.7"/>
    <polygon points="${s/2-2},${s/4-1} ${s/2-4},${s/4+2} ${s/2},${s/4+2}" fill="#3a9a3a" opacity="0.5"/>
    <polygon points="${s/2+2},${s/4-1} ${s/2+4},${s/4+2} ${s/2},${s/4+2}" fill="#3a9a3a" opacity="0.5"/>
  `));

  // Carrot â€” orange root with green top
  mgr.cache['item_food_carrot'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-3},${s/3+2} Q${s/2},${s-2} ${s/2+1},${s-4}" fill="#e87020" stroke="#c06018" stroke-width="0.5"/>
    <path d="M${s/2+3},${s/3+2} Q${s/2},${s-2} ${s/2-1},${s-4}" fill="#f08030" opacity="0.6"/>
    <line x1="${s/2}" y1="${s/2}" x2="${s/2}" y2="${s/2+4}" stroke="#c06018" stroke-width="0.3" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/3+2}" x2="${s/2-3}" y2="${s/4-2}" stroke="#2a8a2a" stroke-width="1.5"/>
    <line x1="${s/2}" y1="${s/3+2}" x2="${s/2+2}" y2="${s/4-3}" stroke="#3a9a3a" stroke-width="1.2"/>
    <line x1="${s/2}" y1="${s/3+2}" x2="${s/2+4}" y2="${s/4}" stroke="#2a8a2a" stroke-width="1"/>
  `));

  // Pumpkin â€” large orange round
  mgr.cache['item_food_pumpkin'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="9" ry="8" fill="#e80"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="8.5" ry="7.5" fill="#fa2" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/3}" x2="${s/2}" y2="${s*2/3+2}" stroke="#c60" stroke-width="1" opacity="0.4"/>
    <path d="M${s/2-5},${s/3+1} Q${s/2-5},${s/2+8} ${s/2-3},${s*2/3+2}" stroke="#c60" stroke-width="0.6" opacity="0.3" fill="none"/>
    <path d="M${s/2+5},${s/3+1} Q${s/2+5},${s/2+8} ${s/2+3},${s*2/3+2}" stroke="#c60" stroke-width="0.6" opacity="0.3" fill="none"/>
    <rect x="${s/2-1}" y="${s/3-3}" width="2" height="4" fill="#5a3a1a" rx="0.5"/>
    <ellipse cx="${s/2+2}" cy="${s/3-2}" rx="3" ry="1.5" fill="#3a9a2a" opacity="0.5"/>
  `));

  // Wheat â€” bundle of golden stalks
  mgr.cache['item_food_wheat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2-3}" y1="${s-5}" x2="${s/2-2}" y2="6" stroke="#da4" stroke-width="1.5"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="4" stroke="#da4" stroke-width="1.5"/>
    <line x1="${s/2+3}" y1="${s-5}" x2="${s/2+2}" y2="5" stroke="#da4" stroke-width="1.5"/>
    <ellipse cx="${s/2-2}" cy="5" rx="2" ry="4" fill="#da4"/>
    <ellipse cx="${s/2}" cy="3" rx="2" ry="4" fill="#eb5"/>
    <ellipse cx="${s/2+2}" cy="4" rx="2" ry="4" fill="#da4"/>
    <line x1="${s/2-3}" y1="${s-6}" x2="${s/2+3}" y2="${s-6}" stroke="#a83" stroke-width="1"/>
    <line x1="${s/2-2}" y1="${s-7}" x2="${s/2+2}" y2="${s-7}" stroke="#a83" stroke-width="0.5" opacity="0.5"/>
  `));

  // Medicinal Herb â€” specific crop herb (green, with medicinal look)
  mgr.cache['item_food_cropHerb'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="${s/3}" stroke="#1a7a1a" stroke-width="2"/>
    <ellipse cx="${s/2-5}" cy="${s/3+2}" rx="4" ry="5" fill="#0c0" transform="rotate(-20 ${s/2-5} ${s/3+2})"/>
    <ellipse cx="${s/2+5}" cy="${s/3}" rx="4" ry="5" fill="#0c0" transform="rotate(20 ${s/2+5} ${s/3})"/>
    <ellipse cx="${s/2}" cy="${s/4}" rx="3" ry="5" fill="#0e0" opacity="0.7"/>
    <circle cx="${s/2}" cy="${s/4-4}" r="2" fill="#fff" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/4-4}" r="1" fill="#f44" opacity="0.5"/>
    <line x1="${s/2-5}" y1="${s/3+2}" x2="${s/2-5}" y2="${s/3+6}" stroke="#0a0" stroke-width="0.3" opacity="0.5"/>
    <line x1="${s/2+5}" y1="${s/3}" x2="${s/2+5}" y2="${s/3+4}" stroke="#0a0" stroke-width="0.3" opacity="0.5"/>
  `));

  // â”€â”€ Potions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Potion of Healing â€” red liquid, glass bottle with cork, label, bubbles, glow
  mgr.cache['item_potion_heal'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#a02020" opacity="0.15"/>
    <rect x="${s/2-3}" y="5" width="6" height="4" fill="#999" rx="1.5"/>
    <rect x="${s/2-2.5}" y="5" width="5" height="2" fill="#b5a070" rx="1"/>
    <rect x="${s/2-2}" y="5" width="4" height="1" fill="#c8b080" rx="0.5" opacity="0.6"/>
    <path d="M${s/2-3},9 L${s/2-6},${s/2} L${s/2-6},${s-6} Q${s/2-6},${s-3} ${s/2-3},${s-3} L${s/2+3},${s-3} Q${s/2+6},${s-3} ${s/2+6},${s-6} L${s/2+6},${s/2} L${s/2+3},9 Z" fill="#b83030" stroke="#8a2020" stroke-width="0.8"/>
    <path d="M${s/2-3},9 L${s/2-5},${s/2} L${s/2-5},${s-6} Q${s/2-5},${s-4} ${s/2-3},${s-4} L${s/2-1},${s-4} L${s/2-1},${s/2} L${s/2-2},9 Z" fill="#d04040" opacity="0.4"/>
    <ellipse cx="${s/2}" cy="${s-5}" rx="4" ry="2" fill="#e06060" opacity="0.25"/>
    <circle cx="${s/2-2}" cy="${s/2+3}" r="1" fill="#e88" opacity="0.5"/>
    <circle cx="${s/2+1}" cy="${s/2+5}" r="0.7" fill="#e88" opacity="0.4"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.5" fill="#faa" opacity="0.4"/>
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="3" fill="#c8a860" rx="0.5" opacity="0.3"/>
    <line x1="${s/2-2}" y1="${s/2+3}" x2="${s/2+2}" y2="${s/2+3}" stroke="#a08040" stroke-width="0.3" opacity="0.5"/>
    <line x1="${s/2+4}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2-1}" stroke="#fcc" stroke-width="0.5" opacity="0.4"/>
  `));

  // Potion of Mana â€” blue liquid, glass bottle with cork, sparkles, glow
  mgr.cache['item_potion_mana'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#2040a0" opacity="0.15"/>
    <rect x="${s/2-3}" y="5" width="6" height="4" fill="#999" rx="1.5"/>
    <rect x="${s/2-2.5}" y="5" width="5" height="2" fill="#b5a070" rx="1"/>
    <rect x="${s/2-2}" y="5" width="4" height="1" fill="#c8b080" rx="0.5" opacity="0.6"/>
    <path d="M${s/2-3},9 L${s/2-6},${s/2} L${s/2-6},${s-6} Q${s/2-6},${s/3} ${s/2-3},${s-3} L${s/2+3},${s-3} Q${s/2+6},${s-3} ${s/2+6},${s-6} L${s/2+6},${s/2} L${s/2+3},9 Z" fill="#3050b8" stroke="#203898" stroke-width="0.8"/>
    <path d="M${s/2-3},9 L${s/2-5},${s/2} L${s/2-5},${s-6} Q${s/2-5},${s-4} ${s/2-3},${s-4} L${s/2-1},${s-4} L${s/2-1},${s/2} L${s/2-2},9 Z" fill="#4060d0" opacity="0.4"/>
    <ellipse cx="${s/2}" cy="${s-5}" rx="4" ry="2" fill="#6080e0" opacity="0.25"/>
    <circle cx="${s/2-2}" cy="${s/2+3}" r="1" fill="#88c" opacity="0.5"/>
    <circle cx="${s/2+1}" cy="${s/2+5}" r="0.7" fill="#88c" opacity="0.4"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.5" fill="#aaf" opacity="0.4"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.6" fill="#ccf" opacity="0.3"/>
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="3" fill="#a0a0d0" rx="0.5" opacity="0.2"/>
    <line x1="${s/2+4}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2-1}" stroke="#ccf" stroke-width="0.5" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+6}" r="0.4" fill="#eef" opacity="0.5"/>
  `));

  // â”€â”€ Generic Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Generic Ore â€” grey rock chunk
  mgr.cache['item_resource_ore'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#666" stroke="#444" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#777" opacity="0.5"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#888" opacity="0.4"/>
    <line x1="${s/2-5}" y1="${s/2}" x2="${s/2}" y2="${s/3}" stroke="#999" stroke-width="1" opacity="0.5"/>
  `));

  // Generic Wood Log â€” brown log cross-section
  mgr.cache['item_resource_wood'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#6a3a10" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#8a5a20" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#a07030" rx="3.5" opacity="0.4"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#5a2a08" stroke-width="0.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+5}" x2="${s-7}" y2="${s/3+5}" stroke="#5a2a08" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#5a2a08" stroke="#4a1a05" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#b08040"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#5a2a08"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#5a2a08" stroke="#4a1a05" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#b08040"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#5a2a08"/>
  `));

  // Leather â€” tanned hide piece
  mgr.cache['item_resource_leather'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <path d="M${s/2-7},${s/3} Q${s/2-8},${s/2-4} ${s/2-5},${s/2+5} Q${s/2-2},${s-5} ${s/2+4},${s-5} Q${s/2+8},${s-6} ${s/2+8},${s/2+2} Q${s/2+9},${s/3} ${s/2+5},${s/4} Q${s/2+2},${s/5} ${s/2-4},${s/3-1} Z" fill="#a86" stroke="#865" stroke-width="0.8"/>
    <path d="M${s/2-5},${s/3+1} Q${s/2-3},${s/2} ${s/2+2},${s/2+2}" fill="#c9a" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="0.5" fill="#865" opacity="0.5"/>
  `));

  // String â€” coiled twine
  mgr.cache['item_resource_string'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="5" ry="5" fill="none" stroke="#ccc" stroke-width="1.5"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="3" ry="3" fill="none" stroke="#ccc" stroke-width="1"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="1" ry="1" fill="none" stroke="#ccc" stroke-width="0.5"/>
    <circle cx="${s/2+5}" cy="${s/2}" r="0.8" fill="#ddd"/>
  `));

  // Empty Bottle â€” glass bottle
  mgr.cache['item_resource_bottle'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-2}" y="5" width="4" height="4" fill="#999" rx="1"/>
    <rect x="${s/2-1.5}" y="5" width="3" height="2" fill="#b0a070" rx="0.5"/>
    <path d="M${s/2-2},9 L${s/2-4},${s/2} L${s/2-4},${s-6} Q${s/2-4},${s-3} ${s/2},${s-3} Q${s/2+4},${s-3} ${s/2+4},${s-6} L${s/2+4},${s/2} L${s/2+2},9 Z" fill="#aaeeff" stroke="#88ccdd" stroke-width="0.5" opacity="0.5"/>
    <path d="M${s/2-2},9 L${s/2-3},${s/2} L${s/2-3},${s-6} L${s/2-1},${s-6} L${s/2-1},${s/2} Z" fill="#ccf" opacity="0.2"/>
  `));

  // Blue Crystal â€” faceted gem
  mgr.cache['item_resource_crystal'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#48f" opacity="0.15"/>
    <polygon points="${s/2},3 ${s/2+5},${s/2} ${s/2+3},${s-5} ${s/2-3},${s-5} ${s/2-5},${s/2}" fill="#48f" stroke="#36c" stroke-width="0.8"/>
    <polygon points="${s/2},3 ${s/2+5},${s/2} ${s/2},${s/2-2}" fill="#6af" opacity="0.5"/>
    <polygon points="${s/2},3 ${s/2-5},${s/2} ${s/2-2},${s/2-2}" fill="#8cf" opacity="0.3"/>
    <circle cx="${s/2-1}" cy="${s/3}" r="1" fill="#adf" opacity="0.6"/>
  `));

  // Clay â€” brown lump
  mgr.cache['item_resource_clay'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="8" ry="6" fill="#b07050"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="7" ry="5" fill="#c08060" opacity="0.7"/>
    <ellipse cx="${s/2-2}" cy="${s/2-1}" rx="4" ry="3" fill="#d09070" opacity="0.4"/>
  `));

  // Sand â€” pile of sand
  mgr.cache['item_resource_sand'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="8" ry="2" fill="#000" opacity="0.08"/>
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="9" ry="6" fill="#c8b868"/>
    <ellipse cx="${s/2}" cy="${s/2+1}" rx="8" ry="5" fill="#d8c878" opacity="0.8"/>
    <ellipse cx="${s/2-2}" cy="${s/2}" rx="5" ry="3" fill="#e8d888" opacity="0.4"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="0.4" fill="#b8a858" opacity="0.5"/>
  `));

  // Flint â€” dark chipped stone
  mgr.cache['item_resource_flint'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <polygon points="${s/2-3},5 ${s/2+5},${s/3} ${s/2+4},${s-6} ${s/2-4},${s-5} ${s/2-6},${s/2}" fill="#555544" stroke="#444433" stroke-width="0.8"/>
    <polygon points="${s/2-3},5 ${s/2+5},${s/3} ${s/2+1},${s/3+1}" fill="#666655" opacity="0.5"/>
    <line x1="${s/2-2}" y1="7" x2="${s/2+3}" y2="${s/3+2}" stroke="#777766" stroke-width="0.5" opacity="0.6"/>
  `));

  // Reeds â€” bundle of green reeds
  mgr.cache['item_resource_reeds'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <line x1="${s/2-4}" y1="${s-4}" x2="${s/2-3}" y2="4" stroke="#7a9a4a" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="3" stroke="#8aaa5a" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-4}" x2="${s/2+3}" y2="5" stroke="#7a9a4a" stroke-width="2" stroke-linecap="round"/>
    <line x1="${s/2-2}" y1="${s-5}" x2="${s/2+2}" y2="${s-5}" stroke="#6a8a3a" stroke-width="1"/>
  `));

  // Bark â€” flat strip of bark
  mgr.cache['item_resource_bark'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.08"/>
    <rect x="${s/2-6}" y="${s/3}" width="12" height="${s/3}" fill="#6a4a2a" rx="2"/>
    <rect x="${s/2-5}" y="${s/3+1}" width="10" height="${s/3-2}" fill="#7a5a3a" opacity="0.7" rx="1"/>
    <line x1="${s/2-4}" y1="${s/3+2}" x2="${s/2+4}" y2="${s/3+2}" stroke="#5a3a1a" stroke-width="0.5" opacity="0.4"/>
    <line x1="${s/2-3}" y1="${s/3+5}" x2="${s/2+3}" y2="${s/3+5}" stroke="#5a3a1a" stroke-width="0.4" opacity="0.3"/>
  `));

  // Tree Sap â€” amber droplet
  mgr.cache['item_resource_sap'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#d8a030" opacity="0.1"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="5" ry="6" fill="#d8a030"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="4" ry="5" fill="#e8b040" opacity="0.7"/>
    <ellipse cx="${s/2-1}" cy="${s/2-2}" rx="2.5" ry="3" fill="#f0c050" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2-3}" r="1" fill="#fff" opacity="0.3"/>
  `));

  // Amber â€” golden gem
  mgr.cache['item_resource_amber'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#cc8800" opacity="0.15"/>
    <polygon points="${s/2},4 ${s/2+5},${s/3} ${s/2+4},${s-5} ${s/2-4},${s-5} ${s/2-5},${s/3}" fill="#cc8800" stroke="#aa6600" stroke-width="0.8"/>
    <polygon points="${s/2},4 ${s/2+5},${s/3} ${s/2},${s/3+1}" fill="#e0a020" opacity="0.5"/>
    <polygon points="${s/2},4 ${s/2-5},${s/3} ${s/2-1},${s/3}" fill="#eebb40" opacity="0.3"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="0.8" fill="#ffd060" opacity="0.6"/>
  `));

  // Pearl â€” lustrous white sphere
  mgr.cache['item_resource_pearl'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.06"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#ddd0ee" stroke="#ccbbdd" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#eeddff" opacity="0.7"/>
    <circle cx="${s/2-2}" cy="${s/2-2}" r="2.5" fill="#fff" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2-2}" r="1" fill="#fff" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.5" fill="#ddc" opacity="0.3"/>
  `));

  // Driftwood â€” pale weathered wood
  mgr.cache['item_resource_driftwood'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M5,${s/2} Q${s/3},${s/3} ${s/2},${s/2-2} Q${s*2/3},${s/2+3} ${s-5},${s/2+1}" stroke="#9a8a6a" stroke-width="3.5" stroke-linecap="round" fill="none"/>
    <path d="M5,${s/2} Q${s/3},${s/3} ${s/2},${s/2-2} Q${s*2/3},${s/2+3} ${s-5},${s/2+1}" stroke="#b0a080" stroke-width="2.5" stroke-linecap="round" fill="none"/>
    <circle cx="${s/3}" cy="${s/3+2}" r="0.5" fill="#a09070" opacity="0.5"/>
  `));

  // Gold Coin â€” shiny gold piece
  mgr.cache['item_gold'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1" fill="#000" opacity="0.1"/>
    <circle cx="${s/2}" cy="${s/2}" r="7" fill="#c8a020" stroke="#a08010" stroke-width="1"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#e8c040" opacity="0.8"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#f0d050" opacity="0.5"/>
    <text x="${s/2}" y="${s/2+3}" text-anchor="middle" font-size="9" font-weight="bold" fill="#a08010" font-family="serif">$</text>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#ffd700" opacity="0.3"/>
    <circle cx="${s/2-1}" cy="${s/2-2}" r="0.7" fill="#fff" opacity="0.3"/>
  `));

  // â”€â”€ Individual Ore Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Iron Ore â€” grey rock with silver veins
  mgr.cache['item_resource_oreIron'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#666" stroke="#444" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#777" opacity="0.7"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#8a8a90" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#aaa" stroke-width="1" opacity="0.7"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#999" stroke-width="0.8" opacity="0.6"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="0.8" fill="#ddd" opacity="0.6"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.6" fill="#ccc" opacity="0.4"/>
  `));

  // Copper Ore â€” brownish-orange rock with green patina
  mgr.cache['item_resource_oreCopper'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#6a5040" stroke="#4a3020" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#7a6050" opacity="0.7"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#8a7060" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#b87333" stroke-width="1.2" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#b87333" stroke-width="1" opacity="0.7"/>
    <line x1="${s/2-3}" y1="${s-8}" x2="${s/2+1}" y2="${s/2+2}" stroke="#d08840" stroke-width="0.6" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2+1}" r="1.2" fill="#5a8a5a" opacity="0.35"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="0.8" fill="#e8a060" opacity="0.6"/>
  `));

  // Silver Ore â€” pale bluish-grey rock with bright veins
  mgr.cache['item_resource_oreSilver'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#7a7a8a" stroke="#5a5a6a" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#9090a0" opacity="0.6"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#a0a0b8" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#c0c0d0" stroke-width="1.2" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#c0c0e0" stroke-width="1" opacity="0.7"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="1" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.8" fill="#eef" opacity="0.5"/>
    <circle cx="${s/2+2}" cy="${s/2+3}" r="0.5" fill="#ddf" opacity="0.4"/>
  `));

  // Gold Ore â€” dark rock with gold veins and sparkle
  mgr.cache['item_resource_oreGold'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#000" opacity="0.12"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#5a5040" stroke="#3a3020" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#6a6050" opacity="0.7"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#7a7060" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#ffd700" stroke-width="1.5" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#ffd700" stroke-width="1.2" opacity="0.7"/>
    <line x1="${s/2-3}" y1="${s-8}" x2="${s/2+1}" y2="${s/2+2}" stroke="#e8c020" stroke-width="0.8" opacity="0.6"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="1" fill="#ffd700" opacity="0.7"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.8" fill="#ffe040" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2+3}" r="0.6" fill="#fff" opacity="0.5"/>
  `));

  // Mythril Ore â€” blue-silver rock with ethereal glow
  mgr.cache['item_resource_oreMythril'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="2" fill="#66ccff" opacity="0.1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#556678" stroke="#445568" stroke-width="1"/>
    <polygon points="${s/2},5 ${s/2+9},${s/2} ${s/2+5},${s-6} ${s/2-5},${s-6} ${s/2-9},${s/2}" fill="#667788" opacity="0.6"/>
    <polygon points="${s/2-2},8 ${s/2+5},${s/3+1} ${s/2+1},${s/2+1}" fill="#7788aa" opacity="0.5"/>
    <line x1="${s/2-6}" y1="${s/2+2}" x2="${s/2-2}" y2="${s/3}" stroke="#66ccff" stroke-width="1.5" opacity="0.8"/>
    <line x1="${s/2+1}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2}" stroke="#66ccff" stroke-width="1.2" opacity="0.7"/>
    <line x1="${s/2-3}" y1="${s-8}" x2="${s/2+1}" y2="${s/2+2}" stroke="#88ddff" stroke-width="0.8" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3}" fill="#66ccff" opacity="0.08"/>
    <circle cx="${s/2-1}" cy="${s/3+1}" r="1.2" fill="#aaeeff" opacity="0.7"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="0.8" fill="#ccf" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2+3}" r="0.6" fill="#fff" opacity="0.5"/>
  `));

  // â”€â”€ Individual Wood Log Resources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Generic Wood Log â€” keep existing item_resource_wood

  // Oak Log â€” darker, wider rings
  mgr.cache['item_resource_oakLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#5a3a10" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#6a4a20" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#7a5a30" rx="3.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#4a2a08" stroke-width="0.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+5}" x2="${s-7}" y2="${s/3+5}" stroke="#4a2a08" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#4a2a08" stroke="#3a1a05" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#8a6a30"/>
    <ellipse cx="5" cy="${s/2}" rx="2.2" ry="${s/8}" fill="#7a5a20" opacity="0.7"/>
    <ellipse cx="5" cy="${s/2}" rx="1.5" ry="${s/10}" fill="#6a4a18" opacity="0.5"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#4a2a08"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#4a2a08" stroke="#3a1a05" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#8a6a30"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#4a2a08"/>
  `));

  // Pine Log â€” lighter, greenish tint
  mgr.cache['item_resource_pineLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#a08050" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#b89060" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#c8a070" rx="3.5" opacity="0.5"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#8a6a40" stroke-width="0.5" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#8a6a38" stroke="#7a5a28" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#c8a060"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#8a6a38"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#8a6a38" stroke="#7a5a28" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#c8a060"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#8a6a38"/>
    <circle cx="${s/2}" cy="${s/3+3}" r="1.5" fill="#6a8a40" opacity="0.2"/>
  `));

  // Birch Log â€” pale white bark
  mgr.cache['item_resource_birchLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.08"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#c8b890" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#d8c8a0" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#e8d8b0" rx="3.5" opacity="0.5"/>
    <line x1="8" y1="${s/3+1}" x2="${s-8}" y2="${s/3+1}" stroke="#b0a070" stroke-width="0.6" opacity="0.3"/>
    <line x1="9" y1="${s/3+4}" x2="${s-9}" y2="${s/3+4}" stroke="#b0a070" stroke-width="0.5" opacity="0.2"/>
    <line x1="10" y1="${s/3+7}" x2="${s-10}" y2="${s/3+7}" stroke="#b0a070" stroke-width="0.4" opacity="0.2"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#b0a078" stroke="#a09068" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#e0d0a8"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#b0a078"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#b0a078" stroke="#a09068" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#e0d0a8"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#b0a078"/>
  `));

  // Maple Log â€” reddish-orange bark
  mgr.cache['item_resource_mapleLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.1"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#a04818" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#c06020" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#d07030" rx="3.5" opacity="0.4"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#803810" stroke-width="0.5" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#803810" stroke="#702808" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#c08040"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#803810"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#803810" stroke="#702808" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#c08040"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#803810"/>
  `));

  // Yew Log â€” very dark wood
  mgr.cache['item_resource_yewLog'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/2-3}" ry="3" fill="#000" opacity="0.12"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#3a2010" rx="3.5"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/3+2}" fill="#5a3a1a" rx="3.5" opacity="0.8"/>
    <rect x="5" y="${s/3-1}" width="${s-10}" height="${s/6+1}" fill="#6a4a2a" rx="3.5" opacity="0.4"/>
    <line x1="7" y1="${s/3+2}" x2="${s-7}" y2="${s/3+2}" stroke="#2a1008" stroke-width="0.6" opacity="0.5"/>
    <line x1="7" y1="${s/3+5}" x2="${s-7}" y2="${s/3+5}" stroke="#2a1008" stroke-width="0.4" opacity="0.4"/>
    <ellipse cx="5" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#2a1008" stroke="#1a0805" stroke-width="0.5"/>
    <ellipse cx="5" cy="${s/2}" rx="3" ry="${s/6}" fill="#6a4a28"/>
    <ellipse cx="5" cy="${s/2}" rx="2" ry="${s/8}" fill="#5a3a18" opacity="0.7"/>
    <circle cx="5" cy="${s/2}" r="0.5" fill="#2a1008"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3.5" ry="${s/6+1}" fill="#2a1008" stroke="#1a0805" stroke-width="0.5"/>
    <ellipse cx="${s-5}" cy="${s/2}" rx="3" ry="${s/6}" fill="#6a4a28"/>
    <circle cx="${s-5}" cy="${s/2}" r="0.5" fill="#2a1008"/>
  `));

  // â”€â”€ Tools â€” Tiered â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Woodcutting Axe (tool) â€” hatchet shape
  mgr.cache['item_tool_axe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-10},${s/3} ${s/2-6},${s/3+2} L${s/2-3},${s/4}" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-9},${s/3-2} ${s/2-5},${s/3}" fill="#aaa" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="8" r="0.8" fill="#ccc" opacity="0.5"/>
  `));

  // Pickaxe (tool) â€” pick head on a handle
  mgr.cache['item_tool_pickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+10},10 L${s/2+8},12 L${s/2-8},12 L${s/2-10},10 Z" fill="#777" stroke="#555" stroke-width="0.8"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+10},10 L${s/2-10},10 Z" fill="#999" opacity="0.5"/>
    <line x1="${s/2-9}" y1="10" x2="${s/2-11}" y2="11" stroke="#888" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-8}" cy="10" r="0.6" fill="#bbb" opacity="0.5"/>
    <circle cx="${s/2+8}" cy="10" r="0.6" fill="#bbb" opacity="0.5"/>
  `));

  // Iron Woodcutter's Axe â€” polished iron head
  mgr.cache['item_tool_ironAxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-11},${s/3} ${s/2-6},${s/3+2} L${s/2-3},${s/4}" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-9},${s/3-2} ${s/2-5},${s/3}" fill="#aaa" opacity="0.5"/>
    <line x1="${s/2-9}" y1="${s/3-1}" x2="${s/2-5}" y2="${s/4+1}" stroke="#ccc" stroke-width="0.4" opacity="0.5"/>
    <circle cx="${s/2-5}" cy="8" r="0.8" fill="#ddd" opacity="0.6"/>
  `));

  // Steel Woodcutter's Axe â€” shinier blade
  mgr.cache['item_tool_steelAxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-12},${s/3} ${s/2-6},${s/3+3} L${s/2-3},${s/4}" fill="#a0a0b0" stroke="#808090" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-10},${s/3-2} ${s/2-5},${s/3}" fill="#c0c0d0" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#b0b0c0" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-9}" cy="10" r="0.6" fill="#ddd" opacity="0.6"/>
    <circle cx="${s/2+9}" cy="10" r="0.6" fill="#ddd" opacity="0.6"/>
    <line x1="${s/2-6}" y1="9" x2="${s/2+6}" y2="9" stroke="#e0e0f0" stroke-width="0.3" opacity="0.4"/>
  `));

  // Mythril Woodcutter's Axe â€” blue glow
  mgr.cache['item_tool_mythrilAxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#66ccff" opacity="0.1"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2+4}" y1="${s-5}" x2="${s/2-4}" y2="6" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-6},5 Q${s/2-12},${s/3} ${s/2-6},${s/3+3} L${s/2-3},${s/4}" fill="#66aacc" stroke="#4488aa" stroke-width="0.8"/>
    <path d="M${s/2-6},5 Q${s/2-10},${s/3-2} ${s/2-5},${s/3}" fill="#88ccee" opacity="0.5"/>
    <circle cx="${s/2-7}" cy="${s/3}" r="${s/4}" fill="#66ccff" opacity="0.08"/>
    <circle cx="${s/2-5}" cy="8" r="1" fill="#aaeeff" opacity="0.7"/>
    <circle cx="${s/2-8}" cy="${s/3+1}" r="0.5" fill="#fff" opacity="0.5"/>
  `));

  // Stone Pickaxe â€” crude stone head
  mgr.cache['item_tool_stonePickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+9},10 L${s/2+7},12 L${s/2-7},12 L${s/2-9},10 Z" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-8},8 L${s/2+8},8 L${s/2+9},10 L${s/2-9},10 Z" fill="#999" opacity="0.4"/>
    <circle cx="${s/2-7}" cy="10" r="0.5" fill="#aaa" opacity="0.3"/>
  `));

  // Iron Pickaxe â€” polished iron head
  mgr.cache['item_tool_ironPickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-9},8 L${s/2+9},8 L${s/2+11},10 L${s/2+9},12 L${s/2-9},12 L${s/2-11},10 Z" fill="#888" stroke="#666" stroke-width="0.8"/>
    <path d="M${s/2-9},8 L${s/2+9},8 L${s/2+11},10 L${s/2-11},10 Z" fill="#aaa" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#999" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-9}" cy="10" r="0.6" fill="#ccc" opacity="0.5"/>
    <circle cx="${s/2+9}" cy="10" r="0.6" fill="#ccc" opacity="0.5"/>
  `));

  // Steel Pickaxe â€” gleaming steel
  mgr.cache['item_tool_steelPickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2+9},13 L${s/2-9},13 L${s/2-11},10 Z" fill="#99a" stroke="#778" stroke-width="0.8"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2-11},10 Z" fill="#bbc" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#aab" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2-9}" cy="10" r="0.7" fill="#dde" opacity="0.5"/>
    <circle cx="${s/2+9}" cy="10" r="0.7" fill="#dde" opacity="0.5"/>
    <line x1="${s/2-3}" y1="9" x2="${s/2+3}" y2="9" stroke="#fff" stroke-width="0.3" opacity="0.3"/>
  `));

  // Mythril Pickaxe â€” ethereal blue-silver
  mgr.cache['item_tool_mythrilPickaxe'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#66ccff" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#6a4a1a" stroke-width="3" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-5}" x2="${s/2}" y2="8" stroke="#8a6a3a" stroke-width="2" stroke-linecap="round"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2+9},13 L${s/2-9},13 L${s/2-11},10 Z" fill="#6699bb" stroke="#4477aa" stroke-width="0.8"/>
    <path d="M${s/2-9},7 L${s/2+9},7 L${s/2+11},10 L${s/2-11},10 Z" fill="#88bbdd" opacity="0.5"/>
    <line x1="${s/2-10}" y1="10" x2="${s/2-12}" y2="11" stroke="#88ccee" stroke-width="1.5" stroke-linecap="round"/>
    <circle cx="${s/2}" cy="10" r="${s/4}" fill="#66ccff" opacity="0.08"/>
    <circle cx="${s/2-8}" cy="9" r="1" fill="#aaeeff" opacity="0.6"/>
    <circle cx="${s/2+8}" cy="9" r="0.7" fill="#fff" opacity="0.4"/>
  `));

  // â”€â”€ Light Sources â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Torch â€” burning stick
  mgr.cache['item_light_torch'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="4" ry="1.5" fill="#000" opacity="0.1"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+2}" stroke="#5a3a10" stroke-width="3.5" stroke-linecap="round"/>
    <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s/3+2}" stroke="#7a5a20" stroke-width="2.5" stroke-linecap="round"/>
    <ellipse cx="${s/2}" cy="${s/3}" rx="3" ry="4" fill="#f80" opacity="0.6"/>
    <ellipse cx="${s/2}" cy="${s/3-1}" rx="2" ry="3" fill="#fa4" opacity="0.7"/>
    <ellipse cx="${s/2}" cy="${s/3-2}" rx="1.2" ry="2" fill="#ff8" opacity="0.8"/>
    <circle cx="${s/2}" cy="${s/3-3}" r="1" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/3+1}" r="5" fill="#f80" opacity="0.08"/>
  `));

  // Lantern â€” metal frame with glass and flame
  mgr.cache['item_light_lantern'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="${s/2-5}" y="8" width="10" height="${s-14}" fill="#888" stroke="#666" stroke-width="0.8" rx="1"/>
    <rect x="${s/2-4}" y="9" width="8" height="${s-16}" fill="#ffee88" opacity="0.3" rx="1"/>
    <rect x="${s/2-4}" y="9" width="8" height="${s-16}" fill="#ccddee" opacity="0.2" rx="1"/>
    <line x1="${s/2-5}" y1="8" x2="${s/2+5}" y2="8" stroke="#aaa" stroke-width="1.5"/>
    <line x1="${s/2-5}" y1="${s-6}" x2="${s/2+5}" y2="${s-6}" stroke="#aaa" stroke-width="1.5"/>
    <path d="M${s/2-1},6 Q${s/2},4 ${s/2+1},6" stroke="#888" stroke-width="1" fill="none"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="2" ry="3" fill="#ff4" opacity="0.6"/>
    <ellipse cx="${s/2}" cy="${s/2-1}" rx="1.2" ry="2" fill="#ffa" opacity="0.7"/>
    <circle cx="${s/2}" cy="${s/2+1}" r="0.8" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#ff4" opacity="0.06"/>
  `));

  // Everlight Orb â€” magical glowing sphere
  mgr.cache['item_light_magicLight'] = mgr.svgToImage(mgr.wrap(`
    <circle cx="${s/2}" cy="${s/2}" r="${s/3+2}" fill="#8ff" opacity="0.08"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3}" fill="#2288aa" opacity="0.2"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/4+1}" fill="#44bbdd" stroke="#2299bb" stroke-width="1"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/4}" fill="#66ddee" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/5}" fill="#88eeff" opacity="0.5"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="2" fill="#aaffff" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2-2}" r="1" fill="#fff" opacity="0.7"/>
    <circle cx="${s/2+3}" cy="${s/2+2}" r="0.6" fill="#aff" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="${s/3+4}" fill="#8ff" opacity="0.04"/>
  `));

  // â”€â”€ Seeds â€” individual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Seeds â€” small pouch with scattered seeds, soil crumbs
  mgr.cache['item_seed'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="6" ry="1.5" fill="#000" opacity="0.1"/>
    <ellipse cx="${s/2-5}" cy="${s/2+1}" rx="3.5" ry="4.5" fill="#557733" transform="rotate(-10 ${s/2-5} ${s/2+1})"/>
    <ellipse cx="${s/2-5}" cy="${s/2+1}" rx="3" ry="4" fill="#6a9944" transform="rotate(-10 ${s/2-5} ${s/2+1})" opacity="0.8"/>
    <line x1="${s/2-5}" y1="${s/2-2}" x2="${s/2-5}" y2="${s/2+4}" stroke="#446622" stroke-width="0.4" opacity="0.5" transform="rotate(-10 ${s/2-5} ${s/2+1})"/>
    <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="3.5" ry="4.5" fill="#557733" transform="rotate(15 ${s/2+4} ${s/2+3})"/>
    <ellipse cx="${s/2+4}" cy="${s/2+3}" rx="3" ry="4" fill="#6a8833" transform="rotate(15 ${s/2+4} ${s/2+3})" opacity="0.8"/>
    <line x1="${s/2+4}" y1="${s/2}" x2="${s/2+4}" y2="${s/2+6}" stroke="#446622" stroke-width="0.4" opacity="0.5" transform="rotate(15 ${s/2+4} ${s/2+3})"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="3" ry="4" fill="#668844" transform="rotate(5 ${s/2} ${s/2-2})"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="2.5" ry="3.5" fill="#7baa55" transform="rotate(5 ${s/2} ${s/2-2})" opacity="0.7"/>
    <line x1="${s/2}" y1="${s/2-5}" x2="${s/2}" y2="${s/2+1}" stroke="#446622" stroke-width="0.3" opacity="0.4" transform="rotate(5 ${s/2} ${s/2-2})"/>
    <circle cx="${s/2-5}" cy="${s/2}" r="0.5" fill="#8a7" opacity="0.5"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="0.4" fill="#8a7" opacity="0.4"/>
    <circle cx="${s/2+1}" cy="${s/2-5}" r="0.6" fill="#654" opacity="0.3"/>
    <circle cx="${s/2-3}" cy="${s/2-4}" r="0.5" fill="#654" opacity="0.2"/>
  `));

  // Turnip Seeds â€” green pouch
  mgr.cache['item_seed_turnip'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#557733" stroke="#446622" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#6a9944" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#8a6a40" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#8a6a40" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2+4}" r="0.8" fill="#8a6a40" opacity="0.5"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">T</text>
  `));

  // Potato Seeds
  mgr.cache['item_seed_potato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#557733" stroke="#446622" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#6a9944" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#ca8" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#ca8" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2+4}" r="0.8" fill="#ca8" opacity="0.5"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">P</text>
  `));

  // Strawberry Seeds
  mgr.cache['item_seed_strawberry'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#993333" stroke="#882222" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#bb4444" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#d44" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#d44" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">S</text>
  `));

  // Corn Seeds
  mgr.cache['item_seed_corn'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#998844" stroke="#887733" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#bbaa55" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#da4" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#da4" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">C</text>
  `));

  // Tomato Seeds
  mgr.cache['item_seed_tomato'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#883322" stroke="#772211" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#aa4433" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#e32" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#e32" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">To</text>
  `));

  // Carrot Seeds
  mgr.cache['item_seed_carrot'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#885522" stroke="#774411" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#aa6633" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#e82" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#e82" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">Ca</text>
  `));

  // Herb Seeds
  mgr.cache['item_seed_herb'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#227733" stroke="#116622" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#33aa44" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1" fill="#0c0" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="0.8" fill="#0c0" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">H</text>
  `));

  // Pumpkin Seeds
  mgr.cache['item_seed_pumpkin'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#886622" stroke="#775511" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#aa8833" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#e80" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#e80" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">Pu</text>
  `));

  // Wheat Seeds
  mgr.cache['item_seed_wheat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="5" ry="1.5" fill="#000" opacity="0.08"/>
    <path d="M${s/2-5},${s/2-3} Q${s/2},${s/2-8} ${s/2+5},${s/2-3} L${s/2+5},${s/2+5} Q${s/2},${s/2+8} ${s/2-5},${s/2+5} Z" fill="#998844" stroke="#887733" stroke-width="0.8"/>
    <path d="M${s/2-4},${s/2-2} Q${s/2},${s/2-6} ${s/2+4},${s/2-2}" fill="#bbaa55" opacity="0.4"/>
    <circle cx="${s/2-1}" cy="${s/2+1}" r="1.2" fill="#da4" opacity="0.7"/>
    <circle cx="${s/2+2}" cy="${s/2+2}" r="1" fill="#da4" opacity="0.6"/>
    <text x="${s/2}" y="${s/2-1}" text-anchor="middle" font-size="6" fill="#fff" opacity="0.6" font-family="sans-serif">W</text>
  `));

  // â”€â”€ Spellbooks â€” individual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Spellbook â€” ornate leather-bound tome, gold clasp, arcane glyph, glowing rune
  mgr.cache['item_spellbook'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+1}" cy="${s-2}" rx="8" ry="2" fill="#000" opacity="0.1"/>
    <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#4a2880" rx="2.5" stroke="#3a1870" stroke-width="0.8"/>
    <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#5a3890" rx="2.5" opacity="0.7"/>
    <rect x="7" y="5" width="${s-14}" height="${s-10}" fill="#6a48a0" rx="1.5"/>
    <rect x="5" y="3" width="3.5" height="${s-6}" fill="#4a2880" rx="1.5"/>
    <rect x="5" y="3" width="2.5" height="${s-6}" fill="#3a1870" rx="1" opacity="0.6"/>
    <line x1="5" y1="${s/2}" x2="8.5" y2="${s/2}" stroke="#5a3890" stroke-width="0.5" opacity="0.5"/>
    <line x1="12" y1="${s/3}" x2="${s-8}" y2="${s/3}" stroke="#aa88dd" stroke-width="0.8" opacity="0.7"/>
    <line x1="13" y1="${s/3+3}" x2="${s-9}" y2="${s/3+3}" stroke="#9978cc" stroke-width="0.5" opacity="0.4"/>
    <line x1="12" y1="${s/2+1}" x2="${s-10}" y2="${s/2+1}" stroke="#aa88dd" stroke-width="0.6" opacity="0.5"/>
    <line x1="14" y1="${s/2+4}" x2="${s-10}" y2="${s/2+4}" stroke="#9978cc" stroke-width="0.4" opacity="0.3"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3.5" fill="#3322aa" opacity="0.25"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3" fill="#ff0" opacity="0.35"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="2" fill="#ffa" opacity="0.45"/>
    <circle cx="${s/2+2}" cy="${s*2/3+1}" r="0.8" fill="#fff" opacity="0.6"/>
    <rect x="${s-10}" y="${s/2-1}" width="3" height="4" fill="#c8a040" rx="0.5" opacity="0.6"/>
    <circle cx="${s-8.5}" cy="${s/2+1}" r="0.8" fill="#e8c060" opacity="0.7"/>
    <circle cx="9" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
    <circle cx="${s-9}" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
  `));

  // Helper to create colored spellbooks
  function spellbook(glowColor, runeColor, accentColor) {
    return mgr.svgToImage(mgr.wrap(`
      <ellipse cx="${s/2+1}" cy="${s-2}" rx="8" ry="2" fill="#000" opacity="0.1"/>
      <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#4a2880" rx="2.5" stroke="#3a1870" stroke-width="0.8"/>
      <rect x="5" y="3" width="${s-10}" height="${s-6}" fill="#5a3890" rx="2.5" opacity="0.7"/>
      <rect x="7" y="5" width="${s-14}" height="${s-10}" fill="#6a48a0" rx="1.5"/>
      <rect x="5" y="3" width="3.5" height="${s-6}" fill="#4a2880" rx="1.5"/>
      <rect x="5" y="3" width="2.5" height="${s-6}" fill="#3a1870" rx="1" opacity="0.6"/>
      <line x1="12" y1="${s/3}" x2="${s-8}" y2="${s/3}" stroke="#aa88dd" stroke-width="0.8" opacity="0.5"/>
      <line x1="13" y1="${s/3+3}" x2="${s-9}" y2="${s/3+3}" stroke="#9978cc" stroke-width="0.5" opacity="0.4"/>
      <line x1="12" y1="${s/2+1}" x2="${s-10}" y2="${s/2+1}" stroke="#aa88dd" stroke-width="0.6" opacity="0.5"/>
      <line x1="14" y1="${s/2+4}" x2="${s-10}" y2="${s/2+4}" stroke="#9978cc" stroke-width="0.4" opacity="0.3"/>
      <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3.5" fill="${glowColor}" opacity="0.2"/>
      <circle cx="${s/2+2}" cy="${s*2/3+1}" r="3" fill="${runeColor}" opacity="0.45"/>
      <circle cx="${s/2+2}" cy="${s*2/3+1}" r="1.5" fill="${accentColor}" opacity="0.7"/>
      <circle cx="${s/2+1}" cy="${s*2/3}" r="0.5" fill="#fff" opacity="0.5"/>
      <rect x="${s-10}" y="${s/2-1}" width="3" height="4" fill="#c8a040" rx="0.5" opacity="0.6"/>
      <circle cx="${s-8.5}" cy="${s/2+1}" r="0.8" fill="#e8c060" opacity="0.7"/>
      <circle cx="9" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
      <circle cx="${s-9}" cy="6" r="0.5" fill="#bb99ee" opacity="0.4"/>
    `));
  }

  mgr.cache['item_spellbook_magicArrow'] = spellbook('#c8f', '#c080ff', '#e0b0ff');
  mgr.cache['item_spellbook_iceBolt'] = spellbook('#6cf', '#60b0ff', '#a0d8ff');
  mgr.cache['item_spellbook_fireBolt'] = spellbook('#f64', '#e04020', '#ff8040');
  mgr.cache['item_spellbook_lightningBolt'] = spellbook('#ff4', '#ddcc00', '#ffee44');
  mgr.cache['item_spellbook_darkBolt'] = spellbook('#a4f', '#8020c0', '#c060ff');
  mgr.cache['item_spellbook_fireBall'] = spellbook('#f84', '#e05030', '#ff9050');
  mgr.cache['item_spellbook_iceBall'] = spellbook('#8ef', '#70c0ff', '#b0e0ff');
  mgr.cache['item_spellbook_chaosBall'] = spellbook('#f0f', '#cc00cc', '#ff44ff');
  mgr.cache['item_spellbook_heal'] = spellbook('#4f4', '#20c020', '#60ff60');
  mgr.cache['item_spellbook_healCritical'] = spellbook('#2f2', '#00aa00', '#44ff44');
  mgr.cache['item_spellbook_holyLight'] = spellbook('#ffa', '#ddaa00', '#ffdd44');
  mgr.cache['item_spellbook_holyVeil'] = spellbook('#ffa', '#ccaa20', '#ffcc44');
  mgr.cache['item_spellbook_mist'] = spellbook('#aaf', '#8080dd', '#b0b0ff');
  mgr.cache['item_spellbook_speed'] = spellbook('#4ff', '#00cccc', '#44ffff');
  mgr.cache['item_spellbook_teleport'] = spellbook('#f8f', '#cc40cc', '#ff80ff');
  mgr.cache['item_spellbook_shortTeleport'] = spellbook('#88f', '#4040cc', '#8080ff');
  mgr.cache['item_spellbook_magicStorm'] = spellbook('#f4f', '#dd00dd', '#ff44ff');

  // â”€â”€ Scrolls â€” individual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Generic scroll â€” rolled parchment with glowing rune seal
  mgr.cache['item_scroll'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#f0e8c8" rx="2" opacity="0.6"/>
    <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <line x1="12" y1="10" x2="${s-12}" y2="10" stroke="#c0a870" stroke-width="0.5" opacity="0.4"/>
    <line x1="12" y1="14" x2="${s-12}" y2="14" stroke="#c0a870" stroke-width="0.5" opacity="0.3"/>
    <line x1="12" y1="18" x2="${s-14}" y2="18" stroke="#c0a870" stroke-width="0.5" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#ffa" opacity="0.4"/>
    <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="#ff8" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="1" fill="#fff" opacity="0.7"/>
    <circle cx="${s/2-1}" cy="${s/2-1}" r="0.5" fill="#fff" opacity="0.5"/>
  `));

  // Fire enchant scroll
  mgr.cache['item_scroll_fire'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
    <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#f64" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="#f84" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="1.5" fill="#fa4" opacity="0.7"/>
  `));

  // Ice enchant scroll
  mgr.cache['item_scroll_ice'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
    <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
    <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#6cf" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="#8df" opacity="0.6"/>
    <circle cx="${s/2}" cy="${s/2}" r="1" fill="#fff" opacity="0.7"/>
  `));

  // Helper to create colored scrolls with rune seal
  function scrollSprite(sealColor, sealGlow) {
    return mgr.svgToImage(mgr.wrap(`
      <ellipse cx="${s/2}" cy="${s-3}" rx="7" ry="1.5" fill="#000" opacity="0.1"/>
      <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#e8d8b0" rx="2"/>
      <rect x="8" y="4" width="${s-16}" height="${s-8}" fill="#f0e8c8" rx="2" opacity="0.5"/>
      <ellipse cx="8" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
      <ellipse cx="${s-8}" cy="${s/2}" rx="3" ry="${s/2-4}" fill="#d8c8a0" stroke="#c0b090" stroke-width="0.5"/>
      <line x1="12" y1="10" x2="${s-12}" y2="10" stroke="#c0a870" stroke-width="0.5" opacity="0.3"/>
      <line x1="12" y1="14" x2="${s-12}" y2="14" stroke="#c0a870" stroke-width="0.5" opacity="0.2"/>
      <circle cx="${s/2}" cy="${s/2}" r="4" fill="${sealGlow}" opacity="0.35"/>
      <circle cx="${s/2}" cy="${s/2}" r="2.5" fill="${sealColor}" opacity="0.6"/>
      <circle cx="${s/2}" cy="${s/2}" r="1" fill="#fff" opacity="0.6"/>
    `));
  }

  mgr.cache['item_scroll_enchantWeapon'] = scrollSprite('#ffa', '#ff8');
  mgr.cache['item_scroll_enchantArmor'] = scrollSprite('#aaf', '#88f');
  mgr.cache['item_scroll_greaterEnchant'] = scrollSprite('#ff4', '#ee2');
  mgr.cache['item_scroll_supremeEnchant'] = scrollSprite('#f4f', '#d2d');
  mgr.cache['item_scroll_lightning'] = scrollSprite('#ff4', '#dd2');
  mgr.cache['item_scroll_holy'] = scrollSprite('#ffa', '#eed');
  mgr.cache['item_scroll_speed'] = scrollSprite('#4ff', '#2dd');
  mgr.cache['item_scroll_teleport'] = scrollSprite('#f8f', '#cc40cc', '#ff80ff');
  mgr.cache['item_scroll_shortTeleport'] = scrollSprite('#88f', '#4040cc', '#8080ff');
  mgr.cache['item_scroll_magicStorm'] = scrollSprite('#f4f', '#dd00dd', '#ff44ff');
});

</script>
  <script>
// ============================================================
// Monster Tiles â€” visual representations for each monster type
// Linked to: data/monsters.json (monster properties like level, hp, ai)
// Each key here maps to monster_<id> where <id> matches monsters.json
// ============================================================

SVGTileManager.register('monsters', (mgr) => {
  const s = mgr.tileSize;

  // Putit (slime) â€” monsters.json: putit
  mgr.cache['monster_putit'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3}" ry="${s/4}" fill="#4a4" opacity="0.3"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3-2}" ry="${s/3}" fill="#44cc44"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="${s/3-4}" ry="${s/4}" fill="#66ee66" opacity="0.5"/>
    <circle cx="${s/2-4}" cy="${s/2}" r="2" fill="#fff"/>
    <circle cx="${s/2+4}" cy="${s/2}" r="2" fill="#fff"/>
    <circle cx="${s/2-4}" cy="${s/2}" r="1" fill="#222"/>
    <circle cx="${s/2+4}" cy="${s/2}" r="1" fill="#222"/>
  `));

  // Giant Rat â€” monsters.json: rat
  mgr.cache['monster_rat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/4}" fill="#8a7060"/>
    <circle cx="${s/2-6}" cy="${s/2-2}" r="4" fill="#9a8070"/>
    <circle cx="${s/2-8}" cy="${s/2-5}" r="2" fill="#a88"/>
    <circle cx="${s/2-4}" cy="${s/2-3}" r="1.5" fill="#f88" opacity="0.8"/>
    <circle cx="${s/2-3}" cy="${s/2-4}" r="1" fill="#300"/>
    <path d="M${s/2+6},${s/2+3} Q${s/2+10},${s/2+6} ${s/2+12},${s/2}" stroke="#8a7060" stroke-width="1.5" fill="none"/>
  `));

  // Cave Bat â€” monsters.json: bat
  mgr.cache['monster_bat'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2}" rx="3" ry="4" fill="#554"/>
    <path d="M${s/2-3},${s/2-2} L${s/2-14},${s/2-8} L${s/2-10},${s/2+2} L${s/2-3},${s/2+1}" fill="#665" opacity="0.9"/>
    <path d="M${s/2+3},${s/2-2} L${s/2+14},${s/2-8} L${s/2+10},${s/2+2} L${s/2+3},${s/2+1}" fill="#665" opacity="0.9"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1" fill="#f44"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1" fill="#f44"/>
  `));

  // Kobold â€” monsters.json: kobold
  mgr.cache['monster_kobold'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2}" width="8" height="${s/2-4}" fill="#8a6a40" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="5" fill="#9a7a50"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#ff0"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="1.5" fill="#ff0"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="0.7" fill="#300"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="0.7" fill="#300"/>
    <polygon points="${s/2-4},${s/2-6} ${s/2-2},${s/2-10} ${s/2-1},${s/2-5}" fill="#9a7a50"/>
    <polygon points="${s/2+4},${s/2-6} ${s/2+2},${s/2-10} ${s/2+1},${s/2-5}" fill="#9a7a50"/>
  `));

  // Goblin â€” monsters.json: goblin
  mgr.cache['monster_goblin'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="${s/2-6}" fill="#4a8a40" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#5a9a50"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="2" fill="#ff0"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="2" fill="#ff0"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="1" fill="#300"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="1" fill="#300"/>
    <polygon points="${s/2-5},${s/2-4} ${s/2-3},${s/2-10} ${s/2-1},${s/2-4}" fill="#5a9a50"/>
    <polygon points="${s/2+5},${s/2-4} ${s/2+3},${s/2-10} ${s/2+1},${s/2-4}" fill="#5a9a50"/>
    <path d="M${s/2-3},${s/2+3} Q${s/2},${s/2+6} ${s/2+3},${s/2+3}" stroke="#300" stroke-width="1" fill="none"/>
  `));

  // Wild Wolf â€” monsters.json: wolf
  mgr.cache['monster_wolf'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#707070"/>
    <circle cx="${s/2-6}" cy="${s/2}" r="5" fill="#808080"/>
    <polygon points="${s/2-8},${s/2-4} ${s/2-6},${s/2-10} ${s/2-4},${s/2-4}" fill="#808080"/>
    <polygon points="${s/2-4},${s/2-4} ${s/2-2},${s/2-10} ${s/2},${s/2-4}" fill="#808080"/>
    <circle cx="${s/2-8}" cy="${s/2-1}" r="1.2" fill="#8f8"/>
    <circle cx="${s/2-5}" cy="${s/2-1}" r="1.2" fill="#8f8"/>
    <path d="M${s/2+10},${s/2+4} Q${s/2+14},${s/2} ${s/2+12},${s/2-2}" stroke="#707070" stroke-width="2" fill="none"/>
  `));

  // Skeleton â€” monsters.json: skeleton
  mgr.cache['monster_skeleton'] = mgr.svgToImage(mgr.wrap(`
    <circle cx="${s/2}" cy="8" r="5" fill="#ddd" stroke="#bbb" stroke-width="0.5"/>
    <rect x="${s/2-1}" y="13" width="2" height="8" fill="#ddd"/>
    <line x1="${s/2-6}" y1="16" x2="${s/2+6}" y2="16" stroke="#ddd" stroke-width="2"/>
    <line x1="${s/2-2}" y1="21" x2="${s/2-4}" y2="${s-4}" stroke="#ddd" stroke-width="1.5"/>
    <line x1="${s/2+2}" y1="21" x2="${s/2+4}" y2="${s-4}" stroke="#ddd" stroke-width="1.5"/>
    <circle cx="${s/2-2}" cy="7" r="1.5" fill="#000"/>
    <circle cx="${s/2+2}" cy="7" r="1.5" fill="#000"/>
    <path d="M${s/2-2},10 L${s/2},11 L${s/2+2},10" stroke="#000" stroke-width="0.8" fill="none"/>
  `));

  // Zombie â€” monsters.json: zombie
  mgr.cache['monster_zombie'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#556a44" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="6" fill="#667a55"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="2" fill="#cc0" opacity="0.8"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1.5" fill="#cc0" opacity="0.6"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1" fill="#600"/>
    <path d="M${s/2-3},${s/2+2} Q${s/2},${s/2+4} ${s/2+4},${s/2+1}" stroke="#400" stroke-width="1" fill="none"/>
    <line x1="${s/2+5}" y1="${s/2+1}" x2="${s/2+10}" y2="${s/2+4}" stroke="#667a55" stroke-width="2" stroke-linecap="round"/>
  `));

  // Orc â€” monsters.json: orc
  mgr.cache['monster_orc'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-6}" y="${s/2+2}" width="12" height="${s/2-6}" fill="#5a8040" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-1}" r="7" fill="#6a9050"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="2" fill="#ff0"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="2" fill="#ff0"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1" fill="#300"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1" fill="#300"/>
    <polygon points="${s/2-2},${s/2+3} ${s/2},${s/2+1} ${s/2+2},${s/2+3}" fill="#fff"/>
    <rect x="${s/2-8}" y="${s/2}" width="3" height="8" fill="#6a9050" rx="1"/>
    <rect x="${s/2+5}" y="${s/2}" width="3" height="8" fill="#6a9050" rx="1"/>
  `));

  // Imp â€” monsters.json: imp
  mgr.cache['monster_imp'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2+2}" width="8" height="${s/3}" fill="#8a2020" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#aa3030"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#ff0"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#ff0"/>
    <polygon points="${s/2-4},${s/2-4} ${s/2-2},${s/2-10} ${s/2},${s/2-4}" fill="#cc2020"/>
    <polygon points="${s/2+4},${s/2-4} ${s/2+2},${s/2-10} ${s/2},${s/2-4}" fill="#cc2020"/>
    <path d="M${s/2-5},${s/2-2} L${s/2-10},${s/2-6} L${s/2-8},${s/2+2}" fill="#aa3030" opacity="0.7"/>
    <path d="M${s/2+5},${s/2-2} L${s/2+10},${s/2-6} L${s/2+8},${s/2+2}" fill="#aa3030" opacity="0.7"/>
  `));

  // Troll â€” monsters.json: troll
  mgr.cache['monster_troll'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-7}" y="${s/2}" width="14" height="${s/2-4}" fill="#5a7a4a" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="8" fill="#6a8a5a"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="2" fill="#ff4"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="2" fill="#ff4"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1" fill="#300"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="1" fill="#300"/>
    <path d="M${s/2-4},${s/2+2} Q${s/2},${s/2+5} ${s/2+4},${s/2+2}" stroke="#400" stroke-width="1.5" fill="none"/>
    <rect x="${s/2-10}" y="${s/2}" width="4" height="10" fill="#6a8a5a" rx="2"/>
    <rect x="${s/2+6}" y="${s/2}" width="4" height="10" fill="#6a8a5a" rx="2"/>
  `));

  // Minotaur â€” monsters.json: minotaur
  mgr.cache['monster_minotaur'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-7}" y="${s/2}" width="14" height="${s/2-2}" fill="#7a4a2a" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="7" fill="#8a5a3a"/>
    <path d="M${s/2-7},${s/2-4} L${s/2-12},${s/2-12} L${s/2-8},${s/2-6}" fill="#8a5a3a" stroke="#6a3a1a" stroke-width="0.5"/>
    <path d="M${s/2+7},${s/2-4} L${s/2+12},${s/2-12} L${s/2+8},${s/2-6}" fill="#8a5a3a" stroke="#6a3a1a" stroke-width="0.5"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1" fill="#400"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1" fill="#400"/>
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="3" ry="2" fill="#7a4a2a"/>
  `));

  // Drake â€” monsters.json: drake
  mgr.cache['monster_drake'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+4}" ry="${s/4}" fill="#4a2060"/>
    <circle cx="${s/2-4}" cy="${s/2-2}" r="5" fill="#6a3080"/>
    <path d="M${s/2-6},${s/2-6} L${s/2-14},${s/2-12} L${s/2-10},${s/2-2} L${s/2-6},${s/2-2}" fill="#5a2070" opacity="0.8"/>
    <path d="M${s/2+4},${s/2-4} L${s/2+14},${s/2-12} L${s/2+10},${s/2} L${s/2+4},${s/2}" fill="#5a2070" opacity="0.8"/>
    <circle cx="${s/2-6}" cy="${s/2-3}" r="1.5" fill="#f80"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1.5" fill="#f80"/>
    <polygon points="${s/2-8},${s/2} ${s/2-6},${s/2+2} ${s/2-4},${s/2}" fill="#f44" opacity="0.6"/>
    <path d="M${s/2+6},${s/2+4} Q${s/2+10},${s/2+8} ${s/2+8},${s/2+2}" stroke="#4a2060" stroke-width="2" fill="none"/>
  `));

  // â”€â”€ Desert Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Sand Viper â€” monsters.json: sandViper
  mgr.cache['monster_sandViper'] = mgr.svgToImage(mgr.wrap(`
    <path d="M${s/2-10},${s/2+4} Q${s/2-5},${s/2-4} ${s/2},${s/2+2} Q${s/2+5},${s/2+8} ${s/2+10},${s/2}" stroke="#c8a030" stroke-width="3" fill="none"/>
    <circle cx="${s/2-10}" cy="${s/2+4}" r="3" fill="#c8a030"/>
    <circle cx="${s/2-11}" cy="${s/2+3}" r="1" fill="#f00"/>
    <circle cx="${s/2-9}" cy="${s/2+3}" r="1" fill="#f00"/>
    <polygon points="${s/2-13},${s/2+5} ${s/2-12},${s/2+3} ${s/2-11},${s/2+5}" fill="#f44"/>
  `));

  // Giant Scorpion â€” monsters.json: scorpion
  mgr.cache['monster_scorpion'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3}" ry="${s/5}" fill="#8a5020"/>
    <circle cx="${s/2-5}" cy="${s/2+3}" r="2" fill="#8a5020"/>
    <circle cx="${s/2+5}" cy="${s/2+3}" r="2" fill="#8a5020"/>
    <path d="M${s/2},${s/2+1} Q${s/2+2},${s/2-8} ${s/2+6},${s/2-10}" stroke="#8a5020" stroke-width="2" fill="none"/>
    <circle cx="${s/2+6}" cy="${s/2-10}" r="2" fill="#d04040"/>
    <circle cx="${s/2-3}" cy="${s/2+1}" r="1" fill="#ff0"/>
    <circle cx="${s/2+3}" cy="${s/2+1}" r="1" fill="#ff0"/>
  `));

  // Mummy â€” monsters.json: mummy
  mgr.cache['monster_mummy'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#c8b888" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="6" fill="#d8c898"/>
    <line x1="${s/2-5}" y1="${s/2+1}" x2="${s/2+5}" y2="${s/2+1}" stroke="#b8a878" stroke-width="1.5"/>
    <line x1="${s/2-5}" y1="${s/2+4}" x2="${s/2+5}" y2="${s/2+4}" stroke="#b8a878" stroke-width="1.5"/>
    <line x1="${s/2-5}" y1="${s/2+7}" x2="${s/2+5}" y2="${s/2+7}" stroke="#b8a878" stroke-width="1.5"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="2" fill="#4a0" opacity="0.8"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="2" fill="#4a0" opacity="0.8"/>
  `));

  // Dust Wraith â€” monsters.json: dustWraith
  mgr.cache['monster_dustWraith'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3}" ry="${s/3+2}" fill="#a08050" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="5" fill="#b89060" opacity="0.7"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="2" fill="#ff4" opacity="0.9"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="2" fill="#ff4" opacity="0.9"/>
    <path d="M${s/2-6},${s/2+6} Q${s/2},${s/2+10} ${s/2+6},${s/2+6}" stroke="#a08050" stroke-width="1" fill="none" opacity="0.4"/>
  `));

  // Cactoid â€” monsters.json: cactoid
  mgr.cache['monster_cactoid'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-3}" y="${s/2-4}" width="6" height="${s/2+2}" fill="#3a8a30" rx="3"/>
    <rect x="${s/2-8}" y="${s/2-2}" width="5" height="3" fill="#3a8a30" rx="1"/>
    <rect x="${s/2+3}" y="${s/2}" width="5" height="3" fill="#3a8a30" rx="1"/>
    <circle cx="${s/2-1}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <circle cx="${s/2+1}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <circle cx="${s/2}" cy="${s/2-6}" r="1.5" fill="#f44"/>
  `));

  // â”€â”€ Snow Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Frost Wolf â€” monsters.json: frostWolf
  mgr.cache['monster_frostWolf'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#a0b8d0"/>
    <circle cx="${s/2-6}" cy="${s/2}" r="5" fill="#b0c8e0"/>
    <polygon points="${s/2-8},${s/2-4} ${s/2-6},${s/2-10} ${s/2-4},${s/2-4}" fill="#b0c8e0"/>
    <polygon points="${s/2-4},${s/2-4} ${s/2-2},${s/2-10} ${s/2},${s/2-4}" fill="#b0c8e0"/>
    <circle cx="${s/2-8}" cy="${s/2-1}" r="1.2" fill="#4af"/>
    <circle cx="${s/2-5}" cy="${s/2-1}" r="1.2" fill="#4af"/>
    <path d="M${s/2+10},${s/2+4} Q${s/2+14},${s/2} ${s/2+12},${s/2-2}" stroke="#a0b8d0" stroke-width="2" fill="none"/>
  `));

  // Ice Elemental â€” monsters.json: iceElemental
  mgr.cache['monster_iceElemental'] = mgr.svgToImage(mgr.wrap(`
    <polygon points="${s/2},${s/2-10} ${s/2+8},${s/2+2} ${s/2+4},${s/2+8} ${s/2-4},${s/2+8} ${s/2-8},${s/2+2}" fill="#6af" opacity="0.7"/>
    <polygon points="${s/2},${s/2-6} ${s/2+5},${s/2+1} ${s/2+2},${s/2+5} ${s/2-2},${s/2+5} ${s/2-5},${s/2+1}" fill="#aef" opacity="0.5"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#fff"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#fff"/>
  `));

  // Snow Harpy â€” monsters.json: snowHarpy
  mgr.cache['monster_snowHarpy'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-3}" y="${s/2+2}" width="6" height="${s/3}" fill="#c0d0e0" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#d0e0f0"/>
    <path d="M${s/2-4},${s/2-1} L${s/2-14},${s/2-6} L${s/2-10},${s/2+3} L${s/2-4},${s/2+2}" fill="#b0c0d8" opacity="0.9"/>
    <path d="M${s/2+4},${s/2-1} L${s/2+14},${s/2-6} L${s/2+10},${s/2+3} L${s/2+4},${s/2+2}" fill="#b0c0d8" opacity="0.9"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#88f"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#88f"/>
  `));

  // Yeti â€” monsters.json: yeti
  mgr.cache['monster_yeti'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-8}" y="${s/2}" width="16" height="${s/2-2}" fill="#d8d8e8" rx="4"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="8" fill="#e8e8f0"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="2" fill="#44f"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="2" fill="#44f"/>
    <circle cx="${s/2-3}" cy="${s/2-3}" r="1" fill="#113"/>
    <circle cx="${s/2+3}" cy="${s/2-3}" r="1" fill="#113"/>
    <path d="M${s/2-3},${s/2+2} Q${s/2},${s/2+4} ${s/2+3},${s/2+2}" stroke="#446" stroke-width="1.5" fill="none"/>
    <rect x="${s/2-11}" y="${s/2}" width="4" height="10" fill="#e8e8f0" rx="2"/>
    <rect x="${s/2+7}" y="${s/2}" width="4" height="10" fill="#e8e8f0" rx="2"/>
  `));

  // â”€â”€ Forest Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Forest Spider â€” monsters.json: forestSpider
  mgr.cache['monster_forestSpider'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="5" ry="4" fill="#2a4a20"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="3" fill="#3a5a30"/>
    <line x1="${s/2-4}" y1="${s/2}" x2="${s/2-10}" y2="${s/2-6}" stroke="#2a4a20" stroke-width="1.5"/>
    <line x1="${s/2+4}" y1="${s/2}" x2="${s/2+10}" y2="${s/2-6}" stroke="#2a4a20" stroke-width="1.5"/>
    <line x1="${s/2-4}" y1="${s/2+2}" x2="${s/2-10}" y2="${s/2+6}" stroke="#2a4a20" stroke-width="1.5"/>
    <line x1="${s/2+4}" y1="${s/2+2}" x2="${s/2+10}" y2="${s/2+6}" stroke="#2a4a20" stroke-width="1.5"/>
    <circle cx="${s/2-1}" cy="${s/2-3}" r="1" fill="#f44"/>
    <circle cx="${s/2+1}" cy="${s/2-3}" r="1" fill="#f44"/>
    <circle cx="${s/2-2}" cy="${s/2-2}" r="0.7" fill="#f44"/>
    <circle cx="${s/2+2}" cy="${s/2-2}" r="0.7" fill="#f44"/>
  `));

  // Treant â€” monsters.json: treant
  mgr.cache['monster_treant'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-4}" y="${s/2}" width="8" height="${s/2-2}" fill="#5a3a1a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-4}" r="8" fill="#2a6a18"/>
    <circle cx="${s/2-4}" cy="${s/2-6}" r="5" fill="#3a8a28" opacity="0.7"/>
    <circle cx="${s/2+4}" cy="${s/2-6}" r="5" fill="#3a8a28" opacity="0.7"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="2" fill="#cc4" opacity="0.8"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="2" fill="#cc4" opacity="0.8"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="1" fill="#420"/>
    <circle cx="${s/2+3}" cy="${s/2-1}" r="1" fill="#420"/>
    <path d="M${s/2-8}" y1="${s/2+2}" x2="${s/2-12}" y2="${s/2-2}" stroke="#5a3a1a" stroke-width="2" fill="none"/>
  `));

  // Will-o'-Wisp â€” monsters.json: willOWisp
  mgr.cache['monster_willOWisp'] = mgr.svgToImage(mgr.wrap(`
    <circle cx="${s/2}" cy="${s/2}" r="6" fill="#8af" opacity="0.3"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#aef" opacity="0.5"/>
    <circle cx="${s/2}" cy="${s/2}" r="2" fill="#fff" opacity="0.9"/>
    <circle cx="${s/2-5}" cy="${s/2-5}" r="1.5" fill="#8af" opacity="0.4"/>
    <circle cx="${s/2+4}" cy="${s/2+4}" r="1" fill="#8af" opacity="0.3"/>
  `));

  // Wild Bear â€” monsters.json: bear
  mgr.cache['monster_bear'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+3}" ry="${s/4}" fill="#6a4a2a"/>
    <circle cx="${s/2-4}" cy="${s/2}" r="6" fill="#7a5a3a"/>
    <circle cx="${s/2-8}" cy="${s/2-5}" r="3" fill="#7a5a3a"/>
    <circle cx="${s/2}" cy="${s/2-5}" r="3" fill="#7a5a3a"/>
    <circle cx="${s/2-6}" cy="${s/2-1}" r="1.5" fill="#300"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#300"/>
    <ellipse cx="${s/2-4}" cy="${s/2+1}" rx="2" ry="1.5" fill="#444"/>
  `));

  // Mushroom Man â€” monsters.json: mushMan
  mgr.cache['monster_mushMan'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-2}" y="${s/2+2}" width="4" height="${s/3}" fill="#c8b088"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="7" ry="5" fill="#c04040"/>
    <ellipse cx="${s/2}" cy="${s/2}" rx="5" ry="3" fill="#d06060" opacity="0.5"/>
    <circle cx="${s/2-3}" cy="${s/2-1}" r="2" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2+4}" cy="${s/2+1}" r="1.5" fill="#fff" opacity="0.6"/>
    <circle cx="${s/2-1}" cy="${s/2+2}" r="1" fill="#222"/>
    <circle cx="${s/2+1}" cy="${s/2+2}" r="1" fill="#222"/>
  `));

  // â”€â”€ Mountain Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Stone Golem â€” monsters.json: stoneGolem
  mgr.cache['monster_stoneGolem'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-8}" y="${s/2}" width="16" height="${s/2-2}" fill="#7a7a7a" rx="3"/>
    <rect x="${s/2-6}" y="${s/2-8}" width="12" height="10" fill="#8a8a8a" rx="4"/>
    <circle cx="${s/2-3}" cy="${s/2-4}" r="2" fill="#f80"/>
    <circle cx="${s/2+3}" cy="${s/2-4}" r="2" fill="#f80"/>
    <rect x="${s/2-10}" y="${s/2+1}" width="4" height="9" fill="#7a7a7a" rx="2"/>
    <rect x="${s/2+6}" y="${s/2+1}" width="4" height="9" fill="#7a7a7a" rx="2"/>
    <line x1="${s/2-4}" y1="${s/2-1}" x2="${s/2+4}" y2="${s/2-1}" stroke="#555" stroke-width="1.5"/>
  `));

  // Rock Worm â€” monsters.json: rockWorm
  mgr.cache['monster_rockWorm'] = mgr.svgToImage(mgr.wrap(`
    <path d="M${s/2-8},${s/2+6} Q${s/2-4},${s/2} ${s/2},${s/2+4} Q${s/2+4},${s/2+8} ${s/2+8},${s/2+2}" stroke="#8a7a60" stroke-width="4" fill="none"/>
    <circle cx="${s/2-8}" cy="${s/2+6}" r="3" fill="#8a7a60"/>
    <circle cx="${s/2-9}" cy="${s/2+5}" r="1" fill="#f44"/>
    <circle cx="${s/2-7}" cy="${s/2+5}" r="1" fill="#f44"/>
    <path d="M${s/2-11},${s/2+7} L${s/2-8},${s/2+8} L${s/2-5},${s/2+7}" stroke="#8a7a60" stroke-width="1" fill="none"/>
  `));

  // Griffin â€” monsters.json: griffin
  mgr.cache['monster_griffin'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#c8a040"/>
    <circle cx="${s/2-4}" cy="${s/2-1}" r="5" fill="#d8b050"/>
    <polygon points="${s/2-9},${s/2-2} ${s/2-12},${s/2-1} ${s/2-9},${s/2}" fill="#f80"/>
    <path d="M${s/2-2},${s/2-3} L${s/2-10},${s/2-12} L${s/2-6},${s/2} " fill="#c8a040" opacity="0.8"/>
    <path d="M${s/2+6},${s/2-1} L${s/2+14},${s/2-10} L${s/2+10},${s/2+3}" fill="#c8a040" opacity="0.8"/>
    <circle cx="${s/2-6}" cy="${s/2-2}" r="1.5" fill="#f80"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1.5" fill="#f80"/>
    <path d="M${s/2+8},${s/2+4} Q${s/2+12},${s/2+8} ${s/2+10},${s/2+2}" stroke="#b89030" stroke-width="2" fill="none"/>
  `));

  // Mountain Ogre â€” monsters.json: mountainOgre
  mgr.cache['monster_mountainOgre'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-7}" y="${s/2+1}" width="14" height="${s/2-3}" fill="#6a5a40" rx="3"/>
    <circle cx="${s/2}" cy="${s/2-1}" r="8" fill="#7a6a50"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="2" fill="#f44"/>
    <circle cx="${s/2-3}" cy="${s/2-2}" r="1" fill="#400"/>
    <circle cx="${s/2+3}" cy="${s/2-2}" r="1" fill="#400"/>
    <path d="M${s/2-3},${s/2+3} Q${s/2},${s/2+5} ${s/2+3},${s/2+3}" stroke="#400" stroke-width="1.5" fill="none"/>
    <rect x="${s/2+8}" y="${s/2-4}" width="3" height="14" fill="#5a4a30" rx="1"/>
  `));

  // â”€â”€ Sea / Beach Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Giant Crab â€” monsters.json: crab
  mgr.cache['monster_crab'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+2}" rx="${s/3+2}" ry="${s/5}" fill="#cc4040"/>
    <circle cx="${s/2-4}" cy="${s/2+2}" r="3" fill="#cc4040"/>
    <circle cx="${s/2+4}" cy="${s/2+2}" r="3" fill="#cc4040"/>
    <path d="M${s/2-8},${s/2} L${s/2-12},${s/2-6} L${s/2-10},${s/2-4}" stroke="#cc4040" stroke-width="2" fill="none"/>
    <path d="M${s/2+8},${s/2} L${s/2+12},${s/2-6} L${s/2+10},${s/2-4}" stroke="#cc4040" stroke-width="2" fill="none"/>
    <circle cx="${s/2-2}" cy="${s/2}" r="1" fill="#222"/>
    <circle cx="${s/2+2}" cy="${s/2}" r="1" fill="#222"/>
  `));

  // Siren â€” monsters.json: siren
  mgr.cache['monster_siren'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-3}" y="${s/2+2}" width="6" height="${s/3}" fill="#4a8aaa" rx="2"/>
    <circle cx="${s/2}" cy="${s/2}" r="5" fill="#7ab8d0"/>
    <path d="M${s/2-3},${s/2+6} Q${s/2},${s/2+10} ${s/2+3},${s/2+6}" fill="#4a8aaa"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1.5" fill="#4ff"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1.5" fill="#4ff"/>
    <path d="M${s/2-4},${s/2-4} Q${s/2-2},${s/2-8} ${s/2+2},${s/2-6} Q${s/2+5},${s/2-4} ${s/2+4},${s/2-2}" stroke="#7ab8d0" stroke-width="1" fill="none"/>
  `));

  // Sea Serpent â€” monsters.json: seaSerpent
  mgr.cache['monster_seaSerpent'] = mgr.svgToImage(mgr.wrap(`
    <path d="M${s/2-12},${s/2+2} Q${s/2-6},${s/2-6} ${s/2},${s/2+2} Q${s/2+6},${s/2+10} ${s/2+12},${s/2}" stroke="#2a6a8a" stroke-width="4" fill="none"/>
    <circle cx="${s/2-12}" cy="${s/2+2}" r="4" fill="#3a7a9a"/>
    <circle cx="${s/2-14}" cy="${s/2+1}" r="1" fill="#ff0"/>
    <circle cx="${s/2-11}" cy="${s/2+1}" r="1" fill="#ff0"/>
    <polygon points="${s/2+11},${s/2-1} ${s/2+14},${s/2-4} ${s/2+14},${s/2+2}" fill="#2a6a8a"/>
  `));

  // Man-o'-War (jellyfish) â€” monsters.json: jellyfish
  mgr.cache['monster_jellyfish'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="6" ry="4" fill="#c8a0d8" opacity="0.6"/>
    <ellipse cx="${s/2}" cy="${s/2-2}" rx="4" ry="2" fill="#d8b0e8" opacity="0.4"/>
    <line x1="${s/2-4}" y1="${s/2+2}" x2="${s/2-5}" y2="${s/2+8}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2}" y1="${s/2+2}" x2="${s/2}" y2="${s/2+10}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2+4}" y1="${s/2+2}" x2="${s/2+5}" y2="${s/2+8}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2-2}" y1="${s/2+2}" x2="${s/2-3}" y2="${s/2+9}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
    <line x1="${s/2+2}" y1="${s/2+2}" x2="${s/2+3}" y2="${s/2+9}" stroke="#c8a0d8" stroke-width="1" opacity="0.5"/>
  `));

  // â”€â”€ Plains Monsters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // Plains Stalker â€” monsters.json: plainsStalker
  mgr.cache['monster_plainsStalker'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+3}" rx="${s/3+3}" ry="${s/5-1}" fill="#b89848"/>
    <circle cx="${s/2-6}" cy="${s/2}" r="4" fill="#c8a858"/>
    <polygon points="${s/2-8},${s/2-3} ${s/2-6},${s/2-8} ${s/2-4},${s/2-3}" fill="#c8a858"/>
    <polygon points="${s/2-4},${s/2-3} ${s/2-2},${s/2-8} ${s/2},${s/2-3}" fill="#c8a858"/>
    <circle cx="${s/2-7}" cy="${s/2-1}" r="1.2" fill="#4e4"/>
    <circle cx="${s/2-5}" cy="${s/2-1}" r="1.2" fill="#4e4"/>
    <path d="M${s/2+8},${s/2+3} Q${s/2+14},${s/2} ${s/2+12},${s/2-3}" stroke="#b89848" stroke-width="2" fill="none"/>
  `));

  // Wild Boar â€” monsters.json: wildBoar
  mgr.cache['monster_wildBoar'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+3}" rx="${s/3+2}" ry="${s/5}" fill="#6a4a3a"/>
    <circle cx="${s/2-6}" cy="${s/2+1}" r="5" fill="#7a5a4a"/>
    <circle cx="${s/2-9}" cy="${s/2}" r="1" fill="#222"/>
    <ellipse cx="${s/2-9}" cy="${s/2+2}" rx="2" ry="1.5" fill="#c88a7a"/>
    <polygon points="${s/2-11},${s/2+1} ${s/2-12},${s/2-1} ${s/2-10},${s/2+1}" fill="#fff"/>
    <polygon points="${s/2-8},${s/2+1} ${s/2-7},${s/2-1} ${s/2-9},${s/2+1}" fill="#fff"/>
  `));

  // Hawk Rider Goblin â€” monsters.json: hawkRider
  mgr.cache['monster_hawkRider'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2}" cy="${s/2+4}" rx="${s/3+2}" ry="${s/5}" fill="#8a6a30"/>
    <circle cx="${s/2}" cy="${s/2}" r="4" fill="#5a9a50"/>
    <circle cx="${s/2-2}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <circle cx="${s/2+2}" cy="${s/2-1}" r="1" fill="#ff0"/>
    <path d="M${s/2-6},${s/2+2} L${s/2-14},${s/2-4} L${s/2-10},${s/2+4}" fill="#9a7a40" opacity="0.8"/>
    <path d="M${s/2+6},${s/2+2} L${s/2+14},${s/2-4} L${s/2+10},${s/2+4}" fill="#9a7a40" opacity="0.8"/>
    <polygon points="${s/2-2},${s/2+5} ${s/2-4},${s/2+4} ${s/2},${s/2+5}" fill="#8a6a30"/>
  `));

  // Centaur â€” monsters.json: centaur
  mgr.cache['monster_centaur'] = mgr.svgToImage(mgr.wrap(`
    <ellipse cx="${s/2+2}" cy="${s/2+4}" rx="${s/3+3}" ry="${s/5}" fill="#8a6a4a"/>
    <rect x="${s/2-6}" y="${s/2-2}" width="6" height="8" fill="#c0a080" rx="2"/>
    <circle cx="${s/2-3}" cy="${s/2-6}" r="4" fill="#c0a080"/>
    <circle cx="${s/2-5}" cy="${s/2-7}" r="1" fill="#300"/>
    <circle cx="${s/2-2}" cy="${s/2-7}" r="1" fill="#300"/>
    <line x1="${s/2-2}" y1="${s/2+7}" x2="${s/2-3}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
    <line x1="${s/2+2}" y1="${s/2+7}" x2="${s/2+1}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
    <line x1="${s/2+6}" y1="${s/2+7}" x2="${s/2+7}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
    <line x1="${s/2+8}" y1="${s/2+7}" x2="${s/2+9}" y2="${s/2+11}" stroke="#8a6a4a" stroke-width="2"/>
  `));
});

</script>
  <script>
// ============================================================
// NPC Tiles â€” shopkeeper, smith, mage, farmer, barkeep, etc.
// Linked to: data/shops.json (shop/NPC properties)
// ============================================================

SVGTileManager.register('npcs', (mgr) => {
  const s = mgr.tileSize;

  // Shopkeeper
  mgr.cache['npc_shopkeeper'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#6a5a40" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="6" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <path d="M${s/2-2},${s/2}" Q${s/2},${s/2+2} ${s/2+2},${s/2}" stroke="#333" stroke-width="0.8" fill="none"/>
    <rect x="${s/2-7}" y="${s/2-8}" width="14" height="4" fill="#8a6a30" rx="2"/>
    <rect x="${s/2-8}" y="${s/2-6}" width="16" height="2" fill="#a07838"/>
  `));

  // Smith (Blacksmith)
  mgr.cache['npc_smith'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-6}" y="${s/2}" width="12" height="${s/2-3}" fill="#6a3a2a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="6" fill="#cc9977"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <rect x="${s/2-8}" y="${s/2+1}" width="3" height="8" fill="#cc9977" rx="1"/>
    <rect x="${s/2+5}" y="${s/2+1}" width="3" height="8" fill="#cc9977" rx="1"/>
    <rect x="${s/2+6}" y="${s/2+4}" width="8" height="3" fill="#888" rx="1"/>
  `));

  // Mage
  mgr.cache['npc_mage'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#4040a0" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="5" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="1.5" fill="#333"/>
    <polygon points="${s/2-6},${s/2-6} ${s/2},${s/2-16} ${s/2+6},${s/2-6}" fill="#5050c0"/>
    <circle cx="${s/2}" cy="${s/2-13}" r="2" fill="#ff0" opacity="0.7"/>
    <rect x="${s/2+5}" y="${s/2-2}" width="10" height="2" fill="#8a6030" rx="1"/>
    <circle cx="${s/2+14}" cy="${s/2-2}" r="2.5" fill="#88f" opacity="0.6"/>
  `));

  // Farmer
  mgr.cache['npc_farmer'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#5a7a3a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="5" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <rect x="${s/2-7}" y="${s/2-8}" width="14" height="3" fill="#c8a848" rx="4"/>
    <rect x="${s/2-8}" y="${s/2-6}" width="16" height="2" fill="#dab858"/>
  `));

  // Barkeep
  mgr.cache['npc_barkeep'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#8a5a3a" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="6" fill="#ddaa88"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <path d="M${s/2-3},${s/2+1} Q${s/2},${s/2+3} ${s/2+3},${s/2+1}" stroke="#333" stroke-width="0.8" fill="none"/>
    <rect x="${s/2-10}" y="${s/2+4}" width="6" height="8" fill="#c8a040" rx="1"/>
    <ellipse cx="${s/2-7}" cy="${s/2+4}" rx="3" ry="1" fill="#e8c060"/>
  `));

  // Generic NPC fallback
  mgr.cache['npc_generic'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2}" width="10" height="${s/2-4}" fill="#666" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-3}" r="5" fill="#ddb888"/>
    <circle cx="${s/2-2}" cy="${s/2-4}" r="1.5" fill="#333"/>
    <circle cx="${s/2+2}" cy="${s/2-4}" r="1.5" fill="#333"/>
  `));
});

</script>
  <script>
// ============================================================
// Player Tile â€” the player character sprite
// ============================================================

SVGTileManager.register('player', (mgr) => {
  const s = mgr.tileSize;

  mgr.cache['player'] = mgr.svgToImage(mgr.wrap(`
    <rect x="${s/2-5}" y="${s/2+2}" width="10" height="${s/2-4}" fill="#3060c0" rx="2"/>
    <circle cx="${s/2}" cy="${s/2-2}" r="6" fill="#e0c8a8"/>
    <circle cx="${s/2-2}" cy="${s/2-3}" r="1.5" fill="#2244aa"/>
    <circle cx="${s/2+2}" cy="${s/2-3}" r="1.5" fill="#2244aa"/>
    <path d="M${s/2-3},${s/2+1} Q${s/2},${s/2+2} ${s/2+3},${s/2+1}" stroke="#333" stroke-width="0.8" fill="none"/>
    <rect x="${s/2-7}" y="${s/2-8}" width="14" height="5" fill="#6a4a2a" rx="2"/>
    <line x1="${s/2+5}" y1="${s/2+2}" x2="${s/2+12}" y2="${s/2-4}" stroke="#c0c0d0" stroke-width="2" stroke-linecap="round"/>
  `));
});

</script>
  <script>
// ============================================================
// Location Marker Tiles â€” world map markers (town, nefia, home)
// Linked to: data/locations/*.json (location properties like type, danger)
// ============================================================

SVGTileManager.register('locations', (mgr) => {
  const s = mgr.tileSize;

  // Town marker
  mgr.cache['location_town'] = mgr.svgToImage(mgr.wrap(`
    <rect x="4" y="${s/2-2}" width="${s-8}" height="${s/2}" fill="#aa8855" rx="2"/>
    <polygon points="${s/2},4 4,${s/2-2} ${s-4},${s/2-2}" fill="#cc9966"/>
    <rect x="${s/2-3}" y="${s/2+4}" width="6" height="${s/2-6}" fill="#6a4a2a"/>
    <rect x="8" y="${s/2+2}" width="4" height="3" fill="#aae" opacity="0.7"/>
    <rect x="${s-12}" y="${s/2+2}" width="4" height="3" fill="#aae" opacity="0.7"/>
  `));

  // Nefia (dungeon) marker
  mgr.cache['location_nefia'] = mgr.svgToImage(mgr.wrap(`
    <polygon points="${s/2},${s-4} 4,4 ${s-4},4" fill="#884444"/>
    <polygon points="${s/2},${s-8} 8,6 ${s-8},6" fill="#aa5555"/>
    <rect x="${s/2-3}" y="${s/3}" width="6" height="8" fill="#333" rx="2"/>
    <rect x="${s/2-2}" y="${s/3+2}" width="4" height="5" fill="#600"/>
  `));

  // Home marker
  mgr.cache['location_home'] = mgr.svgToImage(mgr.wrap(`
    <rect x="6" y="${s/2}" width="${s-12}" height="${s/2-4}" fill="#5a8a3a" rx="2"/>
    <polygon points="${s/2},4 4,${s/2} ${s-4},${s/2}" fill="#6aaa4a"/>
    <rect x="${s/2-3}" y="${s/2+4}" width="6" height="${s/2-6}" fill="#8a6a3a"/>
    <rect x="10" y="${s/2+2}" width="3" height="3" fill="#ffe" opacity="0.7"/>
  `));
});

</script>
  <script>
// ============================================================
// Crop Tiles â€” growth stages for each crop type
// Linked to: data/crops.json (crop properties like growthTime, stages)
// Crop colors pulled from crops.json color arrays (stage 4 color)
// ============================================================

SVGTileManager.register('crops', (mgr) => {
  const s = mgr.tileSize;

  // â”€â”€ Generic crop stages (fallback) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let stage = 0; stage <= 4; stage++) {
    const height = 2 + stage * 4;
    const green = Math.min(255, 80 + stage * 40);
    mgr.cache[`crop_stage_${stage}`] = mgr.svgToImage(mgr.wrap(`
      <rect width="${s}" height="${s}" fill="#5a4030"/>
      <line x1="0" y1="5" x2="${s}" y2="5" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="17" x2="${s}" y2="17" stroke="#4a3020" stroke-width="2"/>
      <line x1="0" y1="29" x2="${s}" y2="29" stroke="#4a3020" stroke-width="2"/>
      ${stage > 0 ? `
        <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s-4-height}" stroke="rgb(40,${green},40)" stroke-width="2" stroke-linecap="round"/>
        ${stage >= 2 ? `<ellipse cx="${s/2-3}" cy="${s-6-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${green},50)" opacity="0.8" transform="rotate(-15 ${s/2-3} ${s-6-height/2})"/>` : ''}
        ${stage >= 2 ? `<ellipse cx="${s/2+3}" cy="${s-8-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${green},50)" opacity="0.8" transform="rotate(15 ${s/2+3} ${s-8-height/2})"/>` : ''}
        ${stage >= 4 ? `<circle cx="${s/2}" cy="${s-4-height}" r="3" fill="#e44" opacity="0.8"/>` : ''}
      ` : ''}
    `));
  }

  // â”€â”€ Per-crop stages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Colors match the harvest color from data/crops.json
  const cropColors = {
    turnip:     '#2d2',   // crops.json â†’ turnip.colors[4]
    potato:     '#ca8',   // crops.json â†’ potato.colors[4]
    strawberry: '#d44',   // crops.json â†’ strawberry.colors[4]
    corn:       '#cc4',   // crops.json â†’ corn.colors[4]
    tomato:     '#e32',   // crops.json â†’ tomato.colors[4]
    carrot:     '#e82',   // crops.json â†’ carrot.colors[4]
    herb:       '#0c0',   // crops.json â†’ herb.colors[4]
    pumpkin:    '#e80',   // crops.json â†’ pumpkin.colors[4]
    wheat:      '#da4'    // crops.json â†’ wheat.colors[4]
  };

  Object.entries(cropColors).forEach(([crop, color]) => {
    for (let stage = 0; stage <= 4; stage++) {
      const height = 2 + stage * 4;
      const g = Math.min(255, 80 + stage * 40);
      mgr.cache[`crop_${crop}_${stage}`] = mgr.svgToImage(mgr.wrap(`
        <rect width="${s}" height="${s}" fill="#5a4030"/>
        <line x1="0" y1="5" x2="${s}" y2="5" stroke="#4a3020" stroke-width="2"/>
        <line x1="0" y1="17" x2="${s}" y2="17" stroke="#4a3020" stroke-width="2"/>
        <line x1="0" y1="29" x2="${s}" y2="29" stroke="#4a3020" stroke-width="2"/>
        ${stage > 0 ? `
          <line x1="${s/2}" y1="${s-4}" x2="${s/2}" y2="${s-4-height}" stroke="rgb(40,${g},40)" stroke-width="2" stroke-linecap="round"/>
          ${stage >= 2 ? `<ellipse cx="${s/2-3}" cy="${s-6-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${g},50)" opacity="0.8" transform="rotate(-15 ${s/2-3} ${s-6-height/2})"/>` : ''}
          ${stage >= 2 ? `<ellipse cx="${s/2+3}" cy="${s-8-height/2}" rx="3" ry="${height/3}" fill="rgb(50,${g},50)" opacity="0.8" transform="rotate(15 ${s/2+3} ${s-8-height/2})"/>` : ''}
          ${stage >= 4 ? `<circle cx="${s/2}" cy="${s-4-height}" r="3" fill="${color}" opacity="0.9"/>` : ''}
        ` : ''}
      `));
    }
  });
});

</script>

  <script>
// ============================================================
// Renderer â€” Canvas drawing with SVG tiles for world & local maps
// ============================================================

class Renderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.tileSize = 32;
    this.cameraX = 0;
    this.cameraY = 0;
    this.viewCols = 0;
    this.viewRows = 0;
    this.tiles = new SVGTileManager(this.tileSize);
    this._resize();
    window.addEventListener('resize', () => this._resize());
  }

  _resize() {
    const parent = this.canvas.parentElement;
    if (!parent) return;
    // Use the canvas element's own CSS-layout size, not the parent's full width.
    // The parent (#gameViewport) is a flex container shared with the side panel,
    // so parent.clientWidth includes space allocated to the side panel.
    // canvas.clientWidth respects the flex: 1 constraint and gives us just our slice.
    const w = this.canvas.clientWidth;
    const h = this.canvas.clientHeight;
    const newW = Math.max(Math.floor(w), 200);
    const newH = Math.max(Math.floor(h), 200);
    // Only resize if dimensions actually changed to avoid canvas reset / 1px drift
    if (this.canvas.width !== newW || this.canvas.height !== newH) {
      this.canvas.width = newW;
      this.canvas.height = newH;
    }
    this.viewCols = Math.floor(this.canvas.width / this.tileSize);
    this.viewRows = Math.floor(this.canvas.height / this.tileSize);
  }

  // â”€â”€ World Map Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderWorldMap(state) {
    const ctx = this.ctx;
    const ts = this.tileSize;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    if (!state.worldMap) return;

    const mapH = state.worldMap.length;
    const mapW = state.worldMap[0].length;

    // Center camera on player
    this.cameraX = Math.max(0, Math.min(state.worldX - Math.floor(this.viewCols / 2), mapW - this.viewCols));
    this.cameraY = Math.max(0, Math.min(state.worldY - Math.floor(this.viewRows / 2), mapH - this.viewRows));

    for (let row = 0; row < this.viewRows && row + this.cameraY < mapH; row++) {
      for (let col = 0; col < this.viewCols && col + this.cameraX < mapW; col++) {
        const wy = row + this.cameraY;
        const wx = col + this.cameraX;
        const biome = state.worldMap[wy][wx];
        const dx = col * ts;
        const dy = row * ts;

        // Try SVG tile first
        const biomeId = biome.id || biome.biome || '';
        const tileImg = this.tiles.getBiome(biomeId, wx, wy);
        if (tileImg && tileImg.complete && tileImg.naturalWidth > 0) {
          ctx.drawImage(tileImg, dx, dy, ts, ts);
        } else {
          // Fallback: colored rect
          ctx.fillStyle = biome.color || '#333';
          ctx.fillRect(dx, dy, ts, ts);
        }
      }
    }

    // Draw locations
    if (state.locations) {
      Object.values(state.locations).forEach(loc => {
        const sx = (loc.x - this.cameraX) * ts;
        const sy = (loc.y - this.cameraY) * ts;
        if (sx < 0 || sy < 0 || sx >= this.canvas.width || sy >= this.canvas.height) return;

        const locKey = `location_${loc.type}`;
        const locImg = this.tiles.getLocation(loc.type);
        if (locImg && locImg.complete && locImg.naturalWidth > 0) {
          // Support multi-grid location sprites
          const gs = this.tiles.getGridSize(locKey);
          ctx.drawImage(locImg, sx, sy, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = loc.type === 'town' ? '#ffd700' : loc.type === 'nefia' ? '#ff4444' : '#44ff44';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(loc.type === 'town' ? 'â– ' : loc.type === 'nefia' ? 'â–¼' : 'â™¦', sx + ts / 2, sy + ts / 2);
        }

        // Label
        ctx.fillStyle = '#fff';
        ctx.font = '10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 3;
        ctx.fillText(loc.name, sx + ts / 2, sy + ts + 8);
        ctx.shadowBlur = 0;
      });
    }

    // Draw player on world map
    const px = (state.worldX - this.cameraX) * ts;
    const py = (state.worldY - this.cameraY) * ts;
    const playerImg = this.tiles.get('player');
    if (playerImg && playerImg.complete && playerImg.naturalWidth > 0) {
      ctx.drawImage(playerImg, px, py, ts, ts);
    } else {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${ts}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('@', px + ts / 2, py + ts / 2);
    }

    // Player selection glow
    ctx.strokeStyle = 'rgba(106, 143, 223, 0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(px + 1, py + 1, ts - 2, ts - 2);

    // Mini info bar
    ctx.fillStyle = 'rgba(10, 10, 18, 0.8)';
    ctx.fillRect(0, this.canvas.height - 28, this.canvas.width, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = '11px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(`World Map â€” Use arrow keys to move, Enter to enter current tile`, 10, this.canvas.height - 12);
  }

  // â”€â”€ Local Map Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderLocalMap(state) {
    const ctx = this.ctx;
    const ts = this.tileSize;
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    if (!state.localMap) return;
    const map = state.localMap;
    const player = state.player;

    // Center camera on player
    this.cameraX = Math.max(0, Math.min(player.x - Math.floor(this.viewCols / 2), map.width - this.viewCols));
    this.cameraY = Math.max(0, Math.min(player.y - Math.floor(this.viewRows / 2), map.height - this.viewRows));

    const isNight = state.time && state.time.isNight;
    const fogActive = map.fogActive && map.fogMap;

    // Helper: get fog state for a world tile coordinate
    const getFog = (wx, wy) => {
      if (!fogActive) return 2; // No fog â†’ fully visible
      if (wy < 0 || wy >= map.height || wx < 0 || wx >= map.width) return 0;
      return map.fogMap[wy][wx];
    };

    // Draw tiles
    for (let row = 0; row < this.viewRows && row + this.cameraY < map.height; row++) {
      for (let col = 0; col < this.viewCols && col + this.cameraX < map.width; col++) {
        const ty = row + this.cameraY;
        const tx = col + this.cameraX;
        const tile = map.tiles[ty][tx];
        const dx = col * ts;
        const dy = row * ts;
        const fog = getFog(tx, ty);

        // Unseen tiles: draw pure black
        if (fog === 0) {
          ctx.fillStyle = '#0a0a0f';
          ctx.fillRect(dx, dy, ts, ts);
          continue;
        }

        // Draw the tile (seen or visible)
        // Check for crop tile
        if (tile.crop && tile.crop.cropId !== undefined) {
          const cropImg = this.tiles.getCrop(tile.crop.cropId, tile.crop.stage || 0);
          if (cropImg && cropImg.complete && cropImg.naturalWidth > 0) {
            ctx.drawImage(cropImg, dx, dy, ts, ts);
          } else {
            ctx.fillStyle = tile.color || '#333';
            ctx.fillRect(dx, dy, ts, ts);
          }
        } else {
          // Regular tile
          const tileId = tile.type || tile.tileId || tile.id || '';
          const tileImg = this.tiles.getTile(tileId, tx, ty);
          if (tileImg && tileImg.complete && tileImg.naturalWidth > 0) {
            ctx.drawImage(tileImg, dx, dy, ts, ts);
          } else {
            // Fallback to colored rect
            ctx.fillStyle = tile.color || '#333';
            ctx.fillRect(dx, dy, ts, ts);
          }
        }

        // Draw bed overlay on tile if present
        if (tile.bed && fog >= 1) {
          ctx.fillStyle = tile.bed.color || '#a07040';
          ctx.font = `${Math.floor(ts * 0.7)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.bed.char || '\u2261', dx + ts / 2, dy + ts / 2);
        }

        // Draw furniture (decoration) overlay on tile if present
        if (tile.furniture && fog >= 1) {
          ctx.fillStyle = tile.furniture.color || '#a07040';
          ctx.font = `${Math.floor(ts * 0.7)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.furniture.char || 'â–¡', dx + ts / 2, dy + ts / 2);
        }

        // Draw workshop overlay on tile if present
        if (tile.workshop && fog >= 1) {
          ctx.fillStyle = tile.workshop.color || '#8a6a3a';
          ctx.font = `${Math.floor(ts * 0.7)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tile.workshop.char || '\u03c0', dx + ts / 2, dy + ts / 2);
        }

        // Night overlay (for visible tiles only; seen tiles get darker overlay below)
        if (isNight && fog === 2) {
          ctx.fillStyle = 'rgba(0, 0, 30, 0.35)';
          ctx.fillRect(dx, dy, ts, ts);
        }

        // Fog overlays for remembered/seen tiles (state 1) â€” dim them significantly
        if (fog === 1) {
          ctx.fillStyle = 'rgba(5, 5, 15, 0.65)';
          ctx.fillRect(dx, dy, ts, ts);
        }
      }
    }

    // Draw items (only on visible tiles; on seen tiles show them dimmed)
    if (map.items) {
      map.items.forEach(item => {
        const fog = getFog(item.x, item.y);
        if (fog === 0) return; // Unseen: don't show

        const sx = (item.x - this.cameraX) * ts;
        const sy = (item.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // Item glow (only on visible tiles)
        if (fog === 2) {
          ctx.fillStyle = 'rgba(200, 200, 50, 0.12)';
          ctx.fillRect(sx, sy, ts, ts);
        }

        // Save context for dimming seen-but-not-visible items
        if (fog === 1) {
          ctx.globalAlpha = 0.35;
        }

        const itemImg = this.tiles.getItem(item);
        if (itemImg && itemImg.complete && itemImg.naturalWidth > 0) {
          // Check multi-grid size for the item's cache key
          const itemKey = this.tiles._getItemKey(item);
          const gs = itemKey ? this.tiles.getGridSize(itemKey) : { w: 1, h: 1 };
          ctx.drawImage(itemImg, sx, sy, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = item.color || '#dd0';
          ctx.font = `bold ${ts - 3}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(item.char || '!', sx + ts / 2, sy + ts / 2);
        }

        if (fog === 1) {
          ctx.globalAlpha = 1.0;
        }
      });
    }

    // Draw monsters (only if currently visible â€” fog state 2)
    if (map.monsters) {
      map.monsters.forEach(m => {
        if (fogActive && getFog(m.x, m.y) !== 2) return; // Hidden in fog

        const sx = (m.x - this.cameraX) * ts;
        const sy = (m.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // Monster background tint
        ctx.fillStyle = 'rgba(200, 50, 50, 0.15)';
        ctx.fillRect(sx, sy, ts, ts);

        const mId = m.templateId || m.id || '';
        const mKey = `monster_${mId}`;
        const monImg = this.tiles.getMonster(mId);
        if (monImg && monImg.complete && monImg.naturalWidth > 0) {
          const gs = this.tiles.getGridSize(mKey);
          // For multi-grid monsters, offset so anchor is bottom-center
          const drawX = gs.w > 1 ? sx - ts * (gs.w - 1) / 2 : sx;
          const drawY = gs.h > 1 ? sy - ts * (gs.h - 1) : sy;
          ctx.drawImage(monImg, drawX, drawY, ts * gs.w, ts * gs.h);
          // Boss: purple glow
          if (m.isBoss) {
            ctx.strokeStyle = 'rgba(180, 80, 255, 0.7)';
            ctx.lineWidth = 2;
            ctx.strokeRect(sx + 1, sy + 1, ts - 2, ts - 2);
          }
        } else {
          ctx.fillStyle = m.color || '#e44';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(m.char || 'M', sx + ts / 2, sy + ts / 2);
        }

        // HP bar
        if (m.hp < m.maxHp) {
          const hpPct = m.hp / m.maxHp;
          const barH = 4;
          ctx.fillStyle = '#300';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
          ctx.fillStyle = hpPct > 0.5 ? '#4d4' : hpPct > 0.25 ? '#dd4' : '#d44';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, (ts - 4) * hpPct, barH);
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
        }
      });
    }

    // Draw pets (player allies â€” only if currently visible)
    if (state.pets) {
      state.pets.forEach(pet => {
        if (pet.isDead) return;
        if (fogActive && getFog(pet.x, pet.y) !== 2) return;

        const sx = (pet.x - this.cameraX) * ts;
        const sy = (pet.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // Pet background glow (green-tinted)
        ctx.fillStyle = 'rgba(50, 200, 80, 0.15)';
        ctx.fillRect(sx, sy, ts, ts);

        // Use monster sprite with a green tint overlay
        const mId = pet.templateId || '';
        const petKey = `monster_${mId}`;
        const petImg = this.tiles.getMonster(mId);
        if (petImg && petImg.complete && petImg.naturalWidth > 0) {
          const gs = this.tiles.getGridSize(petKey);
          const drawX = gs.w > 1 ? sx - ts * (gs.w - 1) / 2 : sx;
          const drawY = gs.h > 1 ? sy - ts * (gs.h - 1) : sy;
          ctx.drawImage(petImg, drawX, drawY, ts * gs.w, ts * gs.h);
          // Green tint overlay to distinguish from hostiles
          ctx.fillStyle = 'rgba(50, 255, 100, 0.15)';
          ctx.fillRect(drawX, drawY, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = pet.color || '#4f4';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(pet.char || 'p', sx + ts / 2, sy + ts / 2);
        }

        // Green ally border
        ctx.strokeStyle = 'rgba(80, 220, 120, 0.7)';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(sx + 1, sy + 1, ts - 2, ts - 2);

        // HP bar
        if (pet.hp < pet.maxHp) {
          const hpPct = pet.hp / pet.maxHp;
          const barH = 4;
          ctx.fillStyle = '#030';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
          ctx.fillStyle = hpPct > 0.5 ? '#4d4' : hpPct > 0.25 ? '#dd4' : '#d44';
          ctx.fillRect(sx + 2, sy + ts - barH - 1, (ts - 4) * hpPct, barH);
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(sx + 2, sy + ts - barH - 1, ts - 4, barH);
        }

        // Pet name label
        ctx.fillStyle = '#8f8';
        ctx.font = '9px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 2;
        ctx.fillText(pet.name, sx + ts / 2, sy - 1);
        ctx.shadowBlur = 0;
      });
    }

    // Draw NPCs (shop keepers â€” only if currently visible)
    if (state.npcs) {
      state.npcs.forEach(npc => {
        if (fogActive && getFog(npc.x, npc.y) !== 2) return;

        const sx = (npc.x - this.cameraX) * ts;
        const sy = (npc.y - this.cameraY) * ts;
        if (sx < -ts || sy < -ts || sx >= this.canvas.width + ts || sy >= this.canvas.height + ts) return;

        // NPC background glow
        ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
        ctx.fillRect(sx, sy, ts, ts);

        const npcName = npc.npcName || npc.name || '';
        const npcKey = `npc_${npcName ? npcName.toLowerCase().replace(/\s/g, '') : 'generic'}`;
        const npcImg = this.tiles.getNpc(npcName);
        if (npcImg && npcImg.complete && npcImg.naturalWidth > 0) {
          const gs = this.tiles.getGridSize(npcKey);
          const drawX = gs.w > 1 ? sx - ts * (gs.w - 1) / 2 : sx;
          const drawY = gs.h > 1 ? sy - ts * (gs.h - 1) : sy;
          ctx.drawImage(npcImg, drawX, drawY, ts * gs.w, ts * gs.h);
        } else {
          ctx.fillStyle = npc.color || '#ffd700';
          ctx.font = `bold ${ts - 2}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(npc.char || 'â˜º', sx + ts / 2, sy + ts / 2);
        }

        // NPC name label
        ctx.fillStyle = '#ffd700';
        ctx.font = '9px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.shadowColor = '#000';
        ctx.shadowBlur = 2;
        ctx.fillText(npc.name, sx + ts / 2, sy - 1);
        ctx.shadowBlur = 0;
      });
    }

    // Draw player
    const ppx = (player.x - this.cameraX) * ts;
    const ppy = (player.y - this.cameraY) * ts;

    const playerImg = this.tiles.get('player');
    if (playerImg && playerImg.complete && playerImg.naturalWidth > 0) {
      const gs = this.tiles.getGridSize('player');
      const drawX = gs.w > 1 ? ppx - ts * (gs.w - 1) / 2 : ppx;
      const drawY = gs.h > 1 ? ppy - ts * (gs.h - 1) : ppy;
      ctx.drawImage(playerImg, drawX, drawY, ts * gs.w, ts * gs.h);
    } else {
      ctx.fillStyle = 'rgba(100, 150, 255, 0.15)';
      ctx.fillRect(ppx, ppy, ts, ts);
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${ts}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('@', ppx + ts / 2, ppy + ts / 2);
    }

    // Player glow
    ctx.strokeStyle = 'rgba(106, 143, 223, 0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(ppx + 1, ppy + 1, ts - 2, ts - 2);

    // â”€â”€ Atmospheric light gradient overlay (fog of war) â”€â”€
    // Draw a subtle radial light gradient around the player for immersive feel
    if (fogActive && map.visRange) {
      const centerX = ppx + ts / 2;
      const centerY = ppy + ts / 2;
      const lightPixelRadius = map.visRange * ts;

      // Create a soft vignette effect at the visibility boundary
      const gradient = ctx.createRadialGradient(
        centerX, centerY, lightPixelRadius * 0.5,
        centerX, centerY, lightPixelRadius * 1.1
      );
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(1, 'rgba(5, 5, 15, 0.3)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    // Location name bar
    ctx.fillStyle = 'rgba(10, 10, 18, 0.8)';
    ctx.fillRect(0, this.canvas.height - 28, this.canvas.width, 28);
    ctx.fillStyle = '#aaa';
    ctx.font = '11px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    const floorText = state.nefiaFloor ? ` â€” Floor ${state.nefiaFloor}` : '';
    // Show visibility range info when fog is active
    const visText = fogActive ? ` â€” Vis: ${map.visRange}` : '';
    ctx.fillText(`${map.locationName || 'Unknown'}${floorText}${visText} â€” Arrow keys to move, bump to attack`, 10, this.canvas.height - 12);

    // Draw minimap overlay
    this.renderMiniMap(state);
  }

  // â”€â”€ Mini Map Overlay (shown on local map) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderMiniMap(state) {
    if (!state.localMap) return;

    const ctx = this.ctx;
    const map = state.localMap;
    const player = state.player;
    const mapH = map.height;
    const mapW = map.width;

    // Mini map configuration â€” scale to fit a reasonable size
    const maxMiniSize = 160;
    const miniTile = Math.max(1, Math.min(Math.floor(maxMiniSize / Math.max(mapW, mapH)), 4));
    const miniW = mapW * miniTile;
    const miniH = mapH * miniTile;
    const padding = 10;
    const borderRadius = 6;

    // Position: bottom-left corner of the canvas
    const ox = padding + 4;
    const oy = this.canvas.height - miniH - padding - 34; // 34 = above the info bar

    const fogActive = map.fogActive && map.fogMap;

    // Draw background with rounded corners
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(ox - 4, oy - 4, miniW + 8, miniH + 8, borderRadius + 2);
    ctx.fillStyle = 'rgba(5, 5, 15, 0.85)';
    ctx.fill();

    // Clip to rounded rect for inner content
    ctx.beginPath();
    ctx.roundRect(ox - 2, oy - 2, miniW + 4, miniH + 4, borderRadius);
    ctx.clip();

    // Draw border
    ctx.strokeStyle = 'rgba(100, 120, 160, 0.6)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Draw tiles
    for (let row = 0; row < mapH; row++) {
      for (let col = 0; col < mapW; col++) {
        const fog = fogActive ? map.fogMap[row][col] : 2;

        if (fog === 0) {
          // Unseen
          ctx.fillStyle = '#0a0a0f';
        } else {
          const tile = map.tiles[row][col];
          ctx.fillStyle = tile.color || '#333';
        }
        ctx.fillRect(ox + col * miniTile, oy + row * miniTile, miniTile, miniTile);

        // Dim seen-but-not-visible tiles
        if (fog === 1) {
          ctx.fillStyle = 'rgba(5, 5, 15, 0.55)';
          ctx.fillRect(ox + col * miniTile, oy + row * miniTile, miniTile, miniTile);
        }
      }
    }

    // Draw monsters as red dots (only visible ones)
    if (map.monsters) {
      map.monsters.forEach(m => {
        const fog = fogActive ? (map.fogMap[m.y] && map.fogMap[m.y][m.x]) : 2;
        if (fog !== 2) return;
        ctx.fillStyle = '#e44';
        ctx.fillRect(ox + m.x * miniTile, oy + m.y * miniTile, miniTile, miniTile);
      });
    }

    // Draw NPCs as gold dots
    if (state.npcs) {
      state.npcs.forEach(npc => {
        const fog = fogActive ? (map.fogMap[npc.y] && map.fogMap[npc.y][npc.x]) : 2;
        if (fog !== 2) return;
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(ox + npc.x * miniTile, oy + npc.y * miniTile, miniTile, miniTile);
      });
    }

    // Draw pets as green dots
    if (state.pets) {
      state.pets.forEach(pet => {
        if (pet.isDead) return;
        ctx.fillStyle = '#4f4';
        ctx.fillRect(ox + pet.x * miniTile, oy + pet.y * miniTile, miniTile, miniTile);
      });
    }

    // Draw player position â€” pulsing glow
    const px = ox + player.x * miniTile;
    const py = oy + player.y * miniTile;

    // Glow effect
    const pulse = 0.6 + 0.4 * Math.sin(Date.now() / 300);
    ctx.fillStyle = `rgba(106, 143, 223, ${0.3 * pulse})`;
    const glowSize = Math.max(miniTile, 3);
    ctx.fillRect(px - glowSize, py - glowSize, glowSize * 3, glowSize * 3);

    // Player dot
    ctx.fillStyle = '#fff';
    ctx.fillRect(px, py, miniTile, miniTile);
    ctx.strokeStyle = `rgba(106, 180, 255, ${pulse})`;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(px - 0.5, py - 0.5, miniTile + 1, miniTile + 1);

    // Draw camera viewport rectangle
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 1;
    ctx.strokeRect(
      ox + this.cameraX * miniTile,
      oy + this.cameraY * miniTile,
      this.viewCols * miniTile,
      this.viewRows * miniTile
    );

    ctx.restore();

    // Label
    ctx.fillStyle = 'rgba(200, 210, 230, 0.7)';
    ctx.font = '9px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(map.locationName || 'Local Map', ox + 2, oy + miniH + 6);
  }

  // â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _lighten(hex, amt) {
    return this._adjustColor(hex, amt);
  }

  _darken(hex, amt) {
    return this._adjustColor(hex, -amt);
  }

  _adjustColor(hex, amt) {
    hex = hex.replace('#', '');
    if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    let r = parseInt(hex.substring(0, 2), 16);
    let g = parseInt(hex.substring(2, 4), 16);
    let b = parseInt(hex.substring(4, 6), 16);
    r = Math.max(0, Math.min(255, r + amt));
    g = Math.max(0, Math.min(255, g + amt));
    b = Math.max(0, Math.min(255, b + amt));
    return `rgb(${r},${g},${b})`;
  }

  getClickedTile(clientX, clientY) {
    const rect = this.canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    return {
      tileX: Math.floor(x / this.tileSize) + this.cameraX,
      tileY: Math.floor(y / this.tileSize) + this.cameraY
    };
  }
}

</script>
  <script>
// ============================================================
// UI â€” Screen management, HUD, panels, menus
// ============================================================

class UI {
  constructor() {
    // Screens
    this.screens = {
      mainMenu: document.getElementById('mainMenu'),
      charCreation: document.getElementById('charCreation'),
      gameScreen: document.getElementById('gameScreen'),
      gameOver: document.getElementById('gameOver')
    };

    // HUD elements
    this.hud = {
      name: document.getElementById('hudName'),
      level: document.getElementById('hudLevel'),
      hpBar: document.getElementById('hpFill'),
      hpText: document.getElementById('hpText'),
      mpBar: document.getElementById('mpFill'),
      mpText: document.getElementById('mpText'),
      spBar: document.getElementById('spFill'),
      spText: document.getElementById('spText'),
      foodBar: document.getElementById('foodFill'),
      foodText: document.getElementById('foodText'),
      time: document.getElementById('hudTime'),
      weather: document.getElementById('hudWeather')
    };

    // Side panel
    this.inventoryList = document.getElementById('inventoryList');
    this.characterInfo = document.getElementById('characterInfo');
    this.skillsList = document.getElementById('skillsList');
    this.spellList = document.getElementById('spellList');
    this.shopPanel = document.getElementById('shopPanel');
    this.craftPanel = document.getElementById('craftPanel');
    this.questPanel = document.getElementById('questPanel');
    this.petPanel = document.getElementById('petPanel');
    this.faithPanel = document.getElementById('faithPanel');
    this.cardBookPanel = document.getElementById('cardBookPanel');
    this.messageLog = document.getElementById('messageLog');

    // Create selects
    this.raceSelect = document.getElementById('raceSelect');
    this.classSelect = document.getElementById('classSelect');
    this.raceInfo = document.getElementById('raceInfo');
    this.classInfo = document.getElementById('classInfo');

    this._initTabs();
    this._populateCharCreation();
  }

  // â”€â”€ Screen Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  showScreen(name) {
    Object.values(this.screens).forEach(s => s.classList.add('hidden'));
    if (this.screens[name]) this.screens[name].classList.remove('hidden');
  }

  // â”€â”€ Tab Switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _initTabs() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        const panels = document.querySelectorAll('.tab-panel');
        panels.forEach(p => p.classList.remove('active'));
        const target = document.getElementById(tab.dataset.tab);
        if (target) target.classList.add('active');
      });
    });
  }

  // â”€â”€ Character Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _populateCharCreation() {
    if (!this.raceSelect || !this.classSelect) return;

    CLIENT_RACES.forEach(r => {
      const opt = document.createElement('option');
      opt.value = r.id;
      opt.textContent = r.name;
      this.raceSelect.appendChild(opt);
    });

    CLIENT_CLASSES.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = c.name;
      this.classSelect.appendChild(opt);
    });

    this.raceSelect.addEventListener('change', () => this._updateRaceInfo());
    this.classSelect.addEventListener('change', () => this._updateClassInfo());

    this._updateRaceInfo();
    this._updateClassInfo();
  }

  _updateRaceInfo() {
    const r = CLIENT_RACES.find(x => x.id === this.raceSelect.value);
    if (!r || !this.raceInfo) return;
    const attrText = r.attrs
      .filter(a => a.mod !== 0)
      .map(a => `${a.id} ${a.mod > 0 ? '+' : ''}${a.mod}`)
      .join(', ');
    this.raceInfo.innerHTML = `
      <p class="desc">${r.desc}</p>
      <p><strong>Attributes:</strong> ${attrText || 'None'}</p>
      <p><strong>Feat:</strong> ${r.feat}</p>
    `;
  }

  _updateClassInfo() {
    const c = CLIENT_CLASSES.find(x => x.id === this.classSelect.value);
    if (!c || !this.classInfo) return;
    const attrText = c.attrs
      .filter(a => a.mod !== 0)
      .map(a => `${a.id} ${a.mod > 0 ? '+' : ''}${a.mod}`)
      .join(', ');
    this.classInfo.innerHTML = `
      <p class="desc">${c.desc}</p>
      <p><strong>Attributes:</strong> ${attrText || 'None'}</p>
      <p><strong>Feat:</strong> ${c.feat}</p>
      <p><strong>Domains:</strong> ${c.domains.join(', ')}</p>
    `;
  }

  getCreationData() {
    const nameInput = document.getElementById('charName');
    return {
      name: nameInput ? nameInput.value.trim() || 'Adventurer' : 'Adventurer',
      race: this.raceSelect ? this.raceSelect.value : 'yerles',
      class: this.classSelect ? this.classSelect.value : 'warrior'
    };
  }

  // â”€â”€ HUD Updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateHUD(state) {
    if (!state || !state.player) return;
    const p = state.player;

    if (this.hud.name) this.hud.name.textContent = p.name || 'Unknown';
    if (this.hud.level) this.hud.level.textContent = `Lv. ${p.level || 1}`;

    this._updateBar(this.hud.hpBar, this.hud.hpText, p.hp, p.maxHp, 'HP');
    this._updateBar(this.hud.mpBar, this.hud.mpText, p.mp, p.maxMp, 'MP');
    this._updateBar(this.hud.spBar, this.hud.spText, p.sp, p.maxSp, 'SP');

    // Food / nutrition
    const maxNut = 15000;
    const nutPct = Math.max(0, (p.nutrition || 0) / maxNut);
    if (this.hud.foodBar) this.hud.foodBar.style.width = `${nutPct * 100}%`;
    if (this.hud.foodText) {
      let label = 'Full';
      if (nutPct < 0.1) label = 'Starving!';
      else if (nutPct < 0.25) label = 'Very Hungry';
      else if (nutPct < 0.5) label = 'Hungry';
      else if (nutPct < 0.75) label = 'Normal';
      this.hud.foodText.textContent = label;
    }

    // Time
    if (this.hud.time && state.time) {
      this.hud.time.textContent = state.time.timeString || '';
    }
    // Weather
    if (this.hud.weather && state.weather) {
      const icon = WEATHER_ICONS[state.weather] || '';
      this.hud.weather.textContent = `${icon} ${state.weather}`;
    }

    // Crop info overlay (when standing on a crop)
    let cropEl = document.getElementById('cropOverlay');
    if (state.cropInfo) {
      if (!cropEl) {
        cropEl = document.createElement('div');
        cropEl.id = 'cropOverlay';
        cropEl.style.cssText = 'position:absolute;bottom:4px;left:50%;transform:translateX(-50%);background:rgba(20,30,10,0.85);padding:4px 12px;border-radius:4px;font-size:11px;color:#bda;border:1px solid #4a4;z-index:10;white-space:nowrap;';
        document.getElementById('gameViewport').appendChild(cropEl);
      }
      const ci = state.cropInfo;
      const harvestable = ci.harvestable;
      const statusColor = harvestable ? '#4f4' : (ci.inSeason ? '#ad4' : '#a84');
      const barPct = ci.progress;
      cropEl.innerHTML = `ğŸŒ± <strong>${ci.name}</strong> â€” <span style="color:${statusColor}">${ci.stageName}</span> ` +
        `<span style="color:#888">[${barPct}%]</span>` +
        (ci.inSeason ? '' : ' <span style="color:#a64">â˜€off-season</span>') +
        (harvestable ? ' <span style="color:#4f4">âŸ¶ Press H to harvest!</span>' : '');
      cropEl.style.display = '';
    } else if (cropEl) {
      cropEl.style.display = 'none';
    }

    // Furniture info overlay (when standing on placed furniture)
    let furnEl = document.getElementById('furnitureOverlay');
    if (state.furnitureInfo) {
      if (!furnEl) {
        furnEl = document.createElement('div');
        furnEl.id = 'furnitureOverlay';
        furnEl.style.cssText = 'position:absolute;bottom:22px;left:50%;transform:translateX(-50%);background:rgba(20,20,30,0.85);padding:4px 12px;border-radius:4px;font-size:11px;color:#cba;border:1px solid #886;z-index:10;white-space:nowrap;';
        document.getElementById('gameViewport').appendChild(furnEl);
      }
      const fi = state.furnitureInfo;
      furnEl.innerHTML = `ğŸ  <strong>${fi.name}</strong>` +
        (fi.beauty ? ` â€” <span style="color:#8aaa6a">Beauty: ${fi.beauty}</span>` : '') +
        ` <span style="color:#888">(U to pick up)</span>`;
      furnEl.style.display = '';
    } else if (furnEl) {
      furnEl.style.display = 'none';
    }
  }

  _updateBar(fillEl, textEl, cur, max, label) {
    if (!fillEl) return;
    const pct = max > 0 ? Math.max(0, cur / max) : 0;
    fillEl.style.width = `${pct * 100}%`;
    if (textEl) textEl.textContent = `${label}: ${cur}/${max}`;
  }

  // â”€â”€ Context Actions Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateContextActions(contextActions, onAction) {
    const bar = document.getElementById('contextActions');
    if (!bar) return;
    bar.innerHTML = '';
    if (!contextActions || contextActions.length === 0) return;

    // Separate highlighted (contextual) from always-available
    const highlighted = contextActions.filter(a => a.highlight);
    const normal = contextActions.filter(a => !a.highlight && !a.always);
    const always = contextActions.filter(a => a.always && !a.highlight);

    // Deduplicate by action type (keep the first one with highlight priority)
    const seen = new Set();
    const deduped = [];
    for (const a of [...highlighted, ...normal, ...always]) {
      if (!seen.has(a.action)) {
        seen.add(a.action);
        deduped.push(a);
      }
    }

    // Re-separate after dedup
    const hlActions = deduped.filter(a => a.highlight);
    const restActions = deduped.filter(a => !a.highlight);

    const createActionEl = (a) => {
      const el = document.createElement('div');
      el.className = 'ctx-action' + (a.highlight ? ' ctx-highlight' : '');
      el.innerHTML = `<span class="ctx-icon">${a.icon || ''}</span><span class="ctx-key">${a.key}</span><span class="ctx-label">${a.label}</span>`;
      el.title = `${a.label} (${a.key})`;
      el.addEventListener('click', () => {
        if (onAction) onAction({ type: a.action });
      });
      return el;
    };

    // Render highlighted actions first
    hlActions.forEach(a => bar.appendChild(createActionEl(a)));

    // Separator between highlighted and rest
    if (hlActions.length > 0 && restActions.length > 0) {
      const sep = document.createElement('div');
      sep.className = 'ctx-sep';
      bar.appendChild(sep);
    }

    // Render the rest
    restActions.forEach(a => bar.appendChild(createActionEl(a)));
  }

  // â”€â”€ Messages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateMessages(messages) {
    if (!this.messageLog || !messages) return;
    this.messageLog.innerHTML = '';
    const recent = messages.slice(-60);
    recent.forEach(msg => {
      const div = document.createElement('div');
      div.className = 'message';
      if (typeof msg === 'object') {
        div.textContent = msg.text || msg;
        if (msg.type === 'damage') div.style.color = '#e44';
        else if (msg.type === 'heal') div.style.color = '#4e4';
        else if (msg.type === 'loot') div.style.color = '#dd0';
        else if (msg.type === 'important') div.style.color = '#f80';
        else if (msg.type === 'level') div.style.color = '#4af';
      } else {
        div.textContent = msg;
      }
      this.messageLog.appendChild(div);
    });
    this.messageLog.scrollTop = this.messageLog.scrollHeight;
  }

  // â”€â”€ Inventory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateInventory(player, onAction) {
    if (!this.inventoryList || !player) return;
    const inv = player.inventory || [];
    this.inventoryList.innerHTML = '';

    // Gold display
    const goldDiv = document.createElement('div');
    goldDiv.className = 'inventory-gold';
    goldDiv.textContent = `ğŸ’° ${player.gold || 0} Gold`;
    this.inventoryList.appendChild(goldDiv);

    if (inv.length === 0) {
      this.inventoryList.innerHTML += '<p style="color:#666;padding:8px;text-align:center;">Inventory is empty.</p>';
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'inv-grid';

    inv.forEach((item, idx) => {
      const cell = document.createElement('div');
      cell.className = 'inv-cell';

      const equipped = (player.equipment &&
        (player.equipment.weapon === item.id || player.equipment.armor === item.id));
      if (equipped) cell.classList.add('inv-cell-equipped');

      // Type-based border color hint
      const typeColors = {
        weapon: '#8af', armor: '#88f', potion: '#d4f', food: '#4c4',
        seed: '#6a4', spellbook: '#c8f', resource: '#a86', currency: '#ffd700',
        light: '#f80', scroll: '#ffa', tool: '#c90'
      };
      const borderColor = typeColors[item.type] || '#444';
      cell.style.borderColor = borderColor;

      // Icon â€” use SVG sprite if available
      const icon = document.createElement('div');
      icon.className = 'inv-cell-icon';
      const spriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
      if (spriteURL) {
        const img = document.createElement('img');
        img.src = spriteURL;
        img.className = 'inv-cell-sprite';
        img.alt = item.name || '';
        img.draggable = false;
        icon.appendChild(img);
      } else {
        icon.style.color = item.color || '#ccc';
        icon.textContent = item.char || '?';
      }
      cell.appendChild(icon);

      // Quantity badge (only if > 1)
      const qty = item.quantity || 1;
      if (qty > 1) {
        const badge = document.createElement('span');
        badge.className = 'inv-cell-qty';
        badge.textContent = qty;
        cell.appendChild(badge);
      }

      // Equipped badge
      if (equipped) {
        const eBadge = document.createElement('span');
        eBadge.className = 'inv-cell-equip-badge';
        eBadge.textContent = 'E';
        cell.appendChild(eBadge);
      }

      // Tooltip on hover
      cell.title = `${item.name}${qty > 1 ? ' Ã—' + qty : ''}${equipped ? ' [Equipped]' : ''}`;

      // Right-click context menu
      cell.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this._showInvContextMenu(e, item, idx, player, onAction);
      });

      // Left-click: default quick action
      cell.addEventListener('click', (e) => {
        e.preventDefault();
        this._showInvContextMenu(e, item, idx, player, onAction);
      });

      grid.appendChild(cell);
    });

    this.inventoryList.appendChild(grid);
  }

  // â”€â”€ Inventory Context Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _showInvContextMenu(e, item, idx, player, onAction) {
    // Remove existing menu
    this._closeInvContextMenu();

    const menu = document.createElement('div');
    menu.className = 'inv-context-menu';
    menu.id = 'invContextMenu';

    // Header
    const header = document.createElement('div');
    header.className = 'inv-ctx-header';
    const qty = item.quantity || 1;
    const ctxSpriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
    if (ctxSpriteURL) {
      header.innerHTML = `<img src="${ctxSpriteURL}" class="inv-ctx-sprite" alt="" draggable="false"/> ${item.name}${qty > 1 ? ' <span style="color:#888">Ã—' + qty + '</span>' : ''}`;
    } else {
      header.innerHTML = `<span style="color:${item.color || '#ccc'}">${item.char || '?'}</span> ${item.name}${qty > 1 ? ' <span style="color:#888">Ã—' + qty + '</span>' : ''}`;
    }
    menu.appendChild(header);

    // Stat info
    if (item.type === 'weapon' || item.type === 'armor') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      let stats = '';
      if (item.dice) {
        const enchDmg = item.enchantDamageBonus || 0;
        stats += `Dmg: ${item.dice}${enchDmg > 0 ? '+' + enchDmg : ''} `;
      }
      if (item.PV != null) {
        const enchPV = item.enchantPVBonus || 0;
        stats += `PV: ${item.PV + enchPV} `;
      }
      if (item.DV != null) {
        const enchDV = item.enchantDVBonus || 0;
        stats += `DV: ${item.DV + enchDV} `;
      }
      if (item.damageType) stats += `(${item.damageType})`;
      statsDiv.textContent = stats.trim();
      menu.appendChild(statsDiv);

      // Enchantment info
      if (item.enchantBonus || (item.enchantments && item.enchantments.length > 0)) {
        const enchDiv = document.createElement('div');
        enchDiv.className = 'inv-ctx-stats';
        enchDiv.style.color = '#ffa';
        let enchText = `âœ¨ +${item.enchantBonus || 0}`;
        if (item.enchantments) {
          item.enchantments.forEach(e => {
            enchText += ` | ${e.name || e.type} +${e.power}`;
          });
        }
        enchDiv.textContent = enchText;
        menu.appendChild(enchDiv);
      }
    }
    if (item.type === 'food') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.textContent = `Nutrition: ${item.nutrition || '?'}${item.healHP ? '  HP+' + item.healHP : ''}`;
      menu.appendChild(statsDiv);
    }
    if (item.type === 'potion') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      let info = '';
      if (item.healHP) info += `HP+${item.healHP} `;
      if (item.healMP) info += `MP+${item.healMP} `;
      statsDiv.textContent = info.trim();
      menu.appendChild(statsDiv);
    }
    if (item.type === 'light' || item.lightRadius) {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#ffa';
      statsDiv.textContent = `ğŸ”¥ Light radius: +${item.lightRadius}`;
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
      menu.appendChild(statsDiv);
    }
    if (item.type === 'tool') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#cc9900';
      const toolLabel = item.subtype === 'axeTool' ? 'ğŸª“ Woodcutting' : item.subtype === 'pickaxe' ? 'â› Mining' : 'ğŸ”§ Tool';
      statsDiv.textContent = `${toolLabel} Power: ${item.toolPower || 1}`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'furniture' && item.subtype === 'bed') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#6a8aaa';
      statsDiv.textContent = `ğŸ› Sleep Comfort: ${item.comfort || 0}%`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'furniture' && item.subtype === 'workshop') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#ca8';
      statsDiv.textContent = `ğŸ”¨ Workshop: ${item.workshopType || 'unknown'}`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'furniture' && item.subtype === 'decoration') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#8aaa6a';
      statsDiv.textContent = `ğŸ  Beauty: ${item.beauty || 0}${item.lightRadius ? ` | ğŸ’¡ Light: ${item.lightRadius}` : ''}`;
      menu.appendChild(statsDiv);
      if (item.description) {
        const descDiv = document.createElement('div');
        descDiv.className = 'inv-ctx-stats';
        descDiv.style.color = '#aaa';
        descDiv.textContent = item.description;
        menu.appendChild(descDiv);
      }
    }
    if (item.type === 'recipePaper') {
      const statsDiv = document.createElement('div');
      statsDiv.className = 'inv-ctx-stats';
      statsDiv.style.color = '#dda';
      statsDiv.textContent = `ğŸ“œ ${item.description || 'Read to learn a new recipe.'}`;
      menu.appendChild(statsDiv);
    }

    const equipped = (player.equipment &&
      (player.equipment.weapon === item.id || player.equipment.armor === item.id));

    // Actions based on item type
    const actions = [];

    if (item.type === 'food') {
      actions.push({ label: 'ğŸ– Eat', action: { type: 'eat', itemIndex: idx } });
    }
    if (item.type === 'potion') {
      actions.push({ label: 'ğŸ§ª Drink', action: { type: 'use', itemIndex: idx } });
    }
    if (item.type === 'spellbook') {
      actions.push({ label: 'ğŸ“– Read', action: { type: 'readSpellbook', itemIndex: idx } });
    }
    if (item.type === 'seed') {
      actions.push({ label: 'ğŸŒ± Plant', action: { type: 'plant', itemIndex: idx } });
    }
    if (item.type === 'scroll' && item.enchantTier) {
      actions.push({ label: 'âœ¨ Enchant...', action: { type: 'openEnchantTarget', scrollIndex: idx } });
    }
    if (item.type === 'furniture' && item.subtype === 'bed') {
      actions.push({ label: 'ğŸ› Place Bed', action: { type: 'placeBed', invIndex: idx } });
    }
    if (item.type === 'furniture' && item.subtype === 'workshop') {
      actions.push({ label: 'ğŸ”¨ Place Workshop', action: { type: 'placeWorkshop', invIndex: idx } });
    }
    if (item.type === 'furniture' && item.subtype === 'decoration') {
      actions.push({ label: 'ğŸ  Place Furniture', action: { type: 'placeFurniture', invIndex: idx } });
    }
    if (item.type === 'recipePaper') {
      actions.push({ label: 'ğŸ“– Read Recipe', action: { type: 'readRecipe', itemIndex: idx } });
    }
    if (item.type === 'weapon' || item.type === 'armor') {
      actions.push({
        label: equipped ? 'ğŸ”“ Unequip' : 'âš”ï¸ Equip',
        action: { type: 'equip', itemIndex: idx }
      });
    }
    actions.push({ label: 'ğŸ—‘ Drop', action: { type: 'drop', itemIndex: idx }, danger: true });

    actions.forEach(act => {
      const btn = document.createElement('div');
      btn.className = 'inv-ctx-action';
      if (act.danger) btn.classList.add('inv-ctx-danger');
      btn.textContent = act.label;
      btn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        this._closeInvContextMenu();
        onAction(act.action);
      });
      menu.appendChild(btn);
    });

    // Position the menu
    document.body.appendChild(menu);

    // Adjust position to stay on screen
    const rect = menu.getBoundingClientRect();
    let x = e.clientX;
    let y = e.clientY;
    if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 4;
    if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 4;
    if (x < 0) x = 4;
    if (y < 0) y = 4;
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Close on click outside
    const closeHandler = (ev) => {
      if (!menu.contains(ev.target)) {
        this._closeInvContextMenu();
        document.removeEventListener('mousedown', closeHandler);
      }
    };
    setTimeout(() => document.addEventListener('mousedown', closeHandler), 0);
  }

  _closeInvContextMenu() {
    const existing = document.getElementById('invContextMenu');
    if (existing) existing.remove();
  }

  // â”€â”€ Character Sheet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateCharacter(player) {
    if (!this.characterInfo || !player) return;

    const attrs = player.attributes || {};
    let html = `
      <div class="char-section">
        <h4>${player.name} â€” ${player.raceName || ''} ${player.className || ''}</h4>
        <p>Level: ${player.level || 1} &nbsp; XP: ${player.exp || 0}/${player.expNext || 100}</p>
        <p>Gold: ${player.gold || 0}</p>
      </div>
      <div class="char-section">
        <h4>Attributes</h4>
        <table style="width:100%;font-size:11px;">
    `;
    Object.entries(ATTR_NAMES).forEach(([id, name]) => {
      const val = attrs[id] || 0;
      html += `<tr><td style="color:#8af">${id}</td><td>${name}</td><td style="text-align:right">${val}</td></tr>`;
    });
    html += `</table></div>`;

    // Equipment
    html += `<div class="char-section"><h4>Equipment</h4>`;
    if (player.equipment) {
      if (player.equipment.weaponName) html += `<p>Weapon: ${player.equipment.weaponName}</p>`;
      else html += `<p>Weapon: (none)</p>`;
      if (player.equipment.armorName) html += `<p>Armor: ${player.equipment.armorName}</p>`;
      else html += `<p>Armor: (none)</p>`;
    }
    html += `</div>`;

    // Combat stats
    html += `<div class="char-section"><h4>Stats</h4>`;
    html += `<p>DV: ${player.dv || 0} &nbsp; PV: ${player.pv || 0}</p>`;
    html += `<p>Speed: ${player.speed || 100}</p>`;
    html += `</div>`;

    this.characterInfo.innerHTML = html;
  }

  // â”€â”€ Skills â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateSkills(player) {
    if (!this.skillsList || !player || !player.skills) return;
    const skills = player.skills;

    // Group skills by category
    const grouped = {};
    Object.entries(skills).forEach(([id, data]) => {
      const def = (typeof SKILL_DEFS !== 'undefined' && SKILL_DEFS[id]) || {};
      const cat = def.category || 'other';
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push({ id, data, def });
    });

    const categoryOrder = ['combat', 'weapon', 'crafting', 'general', 'other'];
    const categoryLabels = { combat: 'âš” Combat', weapon: 'ğŸ—¡ Weapon', crafting: 'ğŸ”¨ Crafting', general: 'ğŸ“‹ General', other: 'â“ Other' };

    let html = '';
    categoryOrder.forEach(cat => {
      if (!grouped[cat] || grouped[cat].length === 0) return;
      html += `<div class="skill-category-header">${categoryLabels[cat] || cat}</div>`;
      grouped[cat].forEach(({ id, data, def }) => {
        const lvl = data.level || data;
        const displayName = def.name || id;
        const attr = def.attr || '';
        html += `<div class="skill-row" data-skill-id="${id}" title="Click for details">
          <span class="skill-name">${displayName}</span>
          <span class="skill-meta"><span class="skill-attr">${attr}</span> <span class="skill-level">Lv.${lvl}</span></span>
        </div>`;
      });
    });

    this.skillsList.innerHTML = html || '<p style="color:#666">No skills yet.</p>';

    // Add click handlers for skill popups
    this.skillsList.querySelectorAll('.skill-row[data-skill-id]').forEach(row => {
      row.addEventListener('click', (e) => {
        const skillId = row.dataset.skillId;
        const def = (typeof SKILL_DEFS !== 'undefined' && SKILL_DEFS[skillId]) || {};
        const playerSkill = skills[skillId];
        const lvl = playerSkill.level || playerSkill;
        this._showSkillPopup(e, skillId, def, lvl);
      });
    });
  }

  _showSkillPopup(e, skillId, def, level) {
    // Remove any existing skill popup
    const existing = document.querySelector('.skill-popup');
    if (existing) existing.remove();

    const popup = document.createElement('div');
    popup.className = 'skill-popup';

    const displayName = def.name || skillId;
    const attr = def.attr || 'â€”';
    const category = def.category || 'other';
    const description = def.description || 'No description available.';
    const catLabels = { combat: 'âš” Combat', weapon: 'ğŸ—¡ Weapon', crafting: 'ğŸ”¨ Crafting', general: 'ğŸ“‹ General', other: 'â“ Other' };

    popup.innerHTML = `
      <div class="skill-popup-header">
        <span class="skill-popup-name">${displayName}</span>
        <span class="skill-popup-close">âœ•</span>
      </div>
      <div class="skill-popup-tags">
        <span class="skill-popup-tag">${catLabels[category] || category}</span>
        <span class="skill-popup-tag">Attr: ${attr}</span>
        <span class="skill-popup-tag">Level ${level}</span>
      </div>
      <div class="skill-popup-desc">${description}</div>
    `;

    document.body.appendChild(popup);

    // Position near click
    const rect = popup.getBoundingClientRect();
    let x = e.clientX + 10;
    let y = e.clientY - 10;
    if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 10;
    if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 10;
    if (y < 0) y = 10;
    popup.style.left = x + 'px';
    popup.style.top = y + 'px';

    // Close on click outside or close button
    const closePopup = () => { popup.remove(); document.removeEventListener('mousedown', outsideClick); };
    popup.querySelector('.skill-popup-close').addEventListener('click', closePopup);
    const outsideClick = (ev) => { if (!popup.contains(ev.target)) closePopup(); };
    setTimeout(() => document.addEventListener('mousedown', outsideClick), 0);
  }

  // â”€â”€ Spells â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateSpells(player, onCastSpell) {
    if (!this.spellList) return;
    const spells = player && player.spells ? player.spells : [];
    this.spellList.innerHTML = '';

    if (spells.length === 0) {
      this.spellList.innerHTML = '<p style="color:#666">No spells memorized.<br><span style="font-size:10px">Read a spellbook to learn spells.</span></p>';
      return;
    }

    // Active buffs display
    if (player.buffs && player.buffs.length > 0) {
      const buffDiv = document.createElement('div');
      buffDiv.style.cssText = 'padding:4px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;';
      buffDiv.innerHTML = '<strong style="color:#ffa">Active Buffs:</strong><br>' +
        player.buffs.map(b => `<span style="color:#8cf">âœ¦ ${b.name}</span> <span style="color:#666">(${b.turnsLeft}t)</span>`).join('<br>');
      this.spellList.appendChild(buffDiv);
    }

    spells.forEach(spell => {
      const div = document.createElement('div');
      div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:4px;border-bottom:1px solid #222;font-size:11px;';

      const info = document.createElement('div');
      info.style.flex = '1';
      const stockColor = spell.stock > 0 ? '#4f4' : '#f44';
      const typeIcon = { bolt: 'â†’', ball: 'â—', heal: '+', buff: 'â—‡', teleport: 'Â¤' }[spell.type] || '?';
      info.innerHTML = `
        <span style="color:${spell.color || '#c8f'}">${typeIcon}</span>
        <strong>${spell.name}</strong>
        <span style="color:#888;font-size:9px"> Lv.${spell.skillLevel}</span><br>
        <span style="color:#68c;font-size:9px">MP:${spell.manaCost}</span>
        <span style="color:${stockColor};font-size:9px"> Stock:${spell.stock}</span>
        <span style="color:#666;font-size:9px"> [${spell.domain}]</span>
      `;
      div.appendChild(info);

      if (spell.stock > 0) {
        const castBtn = document.createElement('button');
        castBtn.textContent = 'Cast';
        castBtn.className = 'btn btn-small';
        castBtn.style.cssText = 'font-size:9px;padding:2px 8px;margin-left:4px;background:#436;';
        castBtn.onclick = () => onCastSpell(spell.id);
        div.appendChild(castBtn);
      } else {
        const emptySpan = document.createElement('span');
        emptySpan.textContent = 'Empty';
        emptySpan.style.cssText = 'color:#f44;font-size:9px;padding:2px 4px;';
        div.appendChild(emptySpan);
      }

      this.spellList.appendChild(div);
    });
  }

  // â”€â”€ Shop Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateShop(state, onBuy, onSell) {
    if (!this.shopPanel) return;
    this.shopPanel.innerHTML = '';

    if (!state.shop) {
      this.shopPanel.innerHTML = '<p style="color:#666">Walk onto an NPC in a town to browse their shop.</p>';
      return;
    }

    const shop = state.shop;
    const player = state.player;

    // Header
    const header = document.createElement('div');
    header.style.cssText = 'padding:6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;text-align:center;';
    header.innerHTML = `<span style="color:${shop.color};font-size:16px">${shop.char}</span> <strong>${shop.name}</strong><br><span style="color:#888;font-size:10px">${shop.npcName} â€” Gold: <span style="color:#ffd700">${player.gold || 0}gp</span></span>`;
    this.shopPanel.appendChild(header);

    // Buy section
    const buyLabel = document.createElement('div');
    buyLabel.style.cssText = 'font-size:10px;color:#4af;padding:2px 4px;border-bottom:1px solid #333;margin-bottom:2px;font-weight:bold;';
    buyLabel.textContent = 'â”€â”€ BUY â”€â”€';
    this.shopPanel.appendChild(buyLabel);

    shop.items.forEach(item => {
      const div = document.createElement('div');
      div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:3px 4px;border-bottom:1px solid #1a1a2a;font-size:11px;';

      const info = document.createElement('span');
      info.style.flex = '1';
      const stockColor = item.stock > 0 ? '#8c8' : '#844';
      const shopBuySpriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
      const shopBuyIcon = shopBuySpriteURL
        ? `<img src="${shopBuySpriteURL}" class="shop-item-sprite" alt="" draggable="false"/>`
        : `<span style="color:${item.color}">${item.char}</span>`;
      info.innerHTML = `${shopBuyIcon} ${item.name} <span style="color:#888;font-size:9px">(${item.type})</span><br><span style="color:#ffd700;font-size:9px">${item.buyPrice}gp</span> <span style="color:${stockColor};font-size:9px">Ã—${item.stock}</span>`;
      div.appendChild(info);

      if (item.stock > 0) {
        const buyBtn = document.createElement('button');
        buyBtn.textContent = 'Buy';
        buyBtn.className = 'btn btn-small';
        buyBtn.style.cssText = 'font-size:9px;padding:2px 8px;margin-left:4px;background:#254;';
        const canAfford = (player.gold || 0) >= item.buyPrice;
        if (!canAfford) {
          buyBtn.style.opacity = '0.4';
          buyBtn.title = 'Not enough gold';
        }
        buyBtn.onclick = () => onBuy(item.itemId);
        div.appendChild(buyBtn);
      } else {
        const oos = document.createElement('span');
        oos.textContent = 'Sold Out';
        oos.style.cssText = 'color:#844;font-size:9px;';
        div.appendChild(oos);
      }

      this.shopPanel.appendChild(div);
    });

    // Sell section
    const sellLabel = document.createElement('div');
    sellLabel.style.cssText = 'font-size:10px;color:#fa4;padding:4px 4px 2px;border-bottom:1px solid #333;margin:6px 0 2px;font-weight:bold;';
    sellLabel.textContent = 'â”€â”€ SELL â”€â”€';
    this.shopPanel.appendChild(sellLabel);

    const inv = player.inventory || [];
    if (inv.length === 0) {
      const empty = document.createElement('p');
      empty.style.cssText = 'color:#666;font-size:10px;padding:4px;';
      empty.textContent = 'No items to sell.';
      this.shopPanel.appendChild(empty);
    } else {
      inv.forEach((item, idx) => {
        const sellPrice = Math.max(1, Math.floor((item.value || 1) * (shop.items[0] ? 0.3 : 0.3)));
        const equipped = (player.equipment &&
          (player.equipment.weapon === item.id || player.equipment.armor === item.id));
        if (equipped) return; // skip equipped items

        const div = document.createElement('div');
        div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:2px 4px;border-bottom:1px solid #1a1a2a;font-size:10px;';

        const info = document.createElement('span');
        const shopSellSpriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
        const shopSellIcon = shopSellSpriteURL
          ? `<img src="${shopSellSpriteURL}" class="shop-item-sprite" alt="" draggable="false"/>`
          : `<span style="color:${item.color || '#ccc'}">${item.char || '?'}</span>`;
        info.innerHTML = `${shopSellIcon} ${item.name} <span style="color:#ffd700">${sellPrice}gp</span>`;
        div.appendChild(info);

        const sellBtn = document.createElement('button');
        sellBtn.textContent = 'Sell';
        sellBtn.className = 'btn btn-small';
        sellBtn.style.cssText = 'font-size:9px;padding:1px 6px;margin-left:4px;background:#542;';
        sellBtn.onclick = () => onSell(idx);
        div.appendChild(sellBtn);

        this.shopPanel.appendChild(div);
      });
    }
  }

  // â”€â”€ Crafting Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateCrafting(state, onCraft) {
    if (!this.craftPanel) return;
    this.craftPanel.innerHTML = '';

    const recipes = state.recipes || [];
    const nearbyWorkshops = state.nearbyWorkshops || [];
    const knownCount = state.knownRecipeCount || 0;
    const totalCount = state.totalRecipeCount || 0;

    // Header with recipe/workshop info
    const header = document.createElement('div');
    header.style.cssText = 'padding:4px 6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;color:#888;text-align:center;';
    let headerHtml = `ğŸ“– Recipes: <span style="color:#4af">${knownCount}/${totalCount}</span>`;
    if (nearbyWorkshops.length > 0) {
      headerHtml += `<br>ğŸ”¨ Nearby: <span style="color:#4c4">${nearbyWorkshops.join(', ')}</span>`;
    } else {
      headerHtml += `<br><span style="color:#a86">No workshops nearby â€” hand-craft only</span>`;
    }
    header.innerHTML = headerHtml;
    this.craftPanel.appendChild(header);

    if (recipes.length === 0) {
      this.craftPanel.innerHTML += '<p style="color:#666;font-size:10px;padding:4px;">No known recipes. Sleep to dream of new recipes, or find recipe papers.</p>';
      return;
    }

    // Group by workshop requirement
    const byWorkshop = {};
    recipes.forEach(r => {
      const wsKey = r.workshopNeeded || '_hand';
      if (!byWorkshop[wsKey]) byWorkshop[wsKey] = [];
      byWorkshop[wsKey].push(r);
    });

    // Sort workshop groups: hand first, then available workshops, then unavailable
    const wsOrder = ['_hand', ...nearbyWorkshops];
    const sortedKeys = Object.keys(byWorkshop).sort((a, b) => {
      const ai = wsOrder.indexOf(a);
      const bi = wsOrder.indexOf(b);
      if (ai >= 0 && bi >= 0) return ai - bi;
      if (ai >= 0) return -1;
      if (bi >= 0) return 1;
      return a.localeCompare(b);
    });

    sortedKeys.forEach(wsKey => {
      const recs = byWorkshop[wsKey];
      const wsAvailable = wsKey === '_hand' || nearbyWorkshops.includes(wsKey);

      const groupLabel = document.createElement('div');
      groupLabel.style.cssText = 'font-size:10px;padding:4px 4px 2px;border-bottom:1px solid #333;margin-top:4px;font-weight:bold;';
      if (wsKey === '_hand') {
        groupLabel.style.color = '#8c8';
        groupLabel.textContent = 'â”€â”€ âœ‹ Hand Craft â”€â”€';
      } else {
        const wsName = recs[0].workshopName || wsKey;
        groupLabel.style.color = wsAvailable ? '#4af' : '#666';
        groupLabel.textContent = `â”€â”€ ${wsAvailable ? 'âœ“' : 'âœ—'} ${wsName} â”€â”€`;
      }
      this.craftPanel.appendChild(groupLabel);

      recs.forEach(recipe => {
        const div = document.createElement('div');
        div.style.cssText = 'padding:4px;border-bottom:1px solid #1a1a2a;font-size:11px;';
        if (!wsAvailable) div.style.opacity = '0.5';

        const canColor = recipe.canCraft ? '#4f4' : '#844';
        const skillColor = recipe.meetsSkill ? '#8c8' : '#f44';
        const wsColor = recipe.hasWorkshop ? '#8c8' : '#f66';

        let html = `<div style="display:flex;justify-content:space-between;align-items:center;">`;
        html += `<div style="flex:1;">`;
        html += `<strong style="color:${canColor}">${recipe.name}</strong>`;
        html += ` <span style="color:#888;font-size:9px">â†’ ${recipe.resultCount}Ã— ${recipe.resultName}</span><br>`;
        html += `<span style="color:${skillColor};font-size:9px">${recipe.skill} Lv.${recipe.skillReq}</span>`;
        html += ` <span style="color:#888;font-size:9px">(${recipe.successChance}%)</span>`;
        if (!recipe.hasWorkshop && recipe.workshopName) {
          html += ` <span style="color:${wsColor};font-size:9px">âš  need ${recipe.workshopName}</span>`;
        }
        html += `</div>`;

        if (recipe.canCraft) {
          html += `<button class="btn btn-small craft-btn" data-recipe="${recipe.id}" style="font-size:9px;padding:2px 8px;background:#354;">Craft</button>`;
        } else {
          html += `<span style="color:#666;font-size:9px;padding:2px 4px;">â€”</span>`;
        }
        html += `</div>`;

        // Ingredients
        html += `<div style="font-size:9px;color:#888;padding-top:2px;">`;
        recipe.ingredients.forEach(ing => {
          const iColor = ing.enough ? '#8c8' : '#f66';
          html += `<span style="color:${iColor}">â€¢ ${ing.name} ${ing.have}/${ing.needed}</span> `;
        });
        html += `</div>`;

        div.innerHTML = html;

        const craftBtn = div.querySelector('.craft-btn');
        if (craftBtn) {
          craftBtn.addEventListener('click', () => onCraft(recipe.id));
        }

        this.craftPanel.appendChild(div);
      });
    });
  }

  // â”€â”€ Auto-switch to Shop Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToShopTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const shopTab = document.querySelector('[data-tab="shopTab"]');
    if (shopTab) shopTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const shopPanel = document.getElementById('shopTab');
    if (shopPanel) shopPanel.classList.add('active');
  }

  // â”€â”€ Quest Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateQuests(state, onAccept, onTurnIn, onAbandon) {
    if (!this.questPanel) return;
    this.questPanel.innerHTML = '';

    const activeQuests = state.activeQuests || [];
    const questBoard = state.questBoard || [];
    const currentTownId = state.currentTownId;
    const onBoard = state.onQuestBoard;
    const completedCount = state.completedQuestCount || 0;

    // Summary header
    const summary = document.createElement('div');
    summary.style.cssText = 'padding:4px 6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;color:#888;text-align:center;';
    summary.innerHTML = `ğŸ“œ Active: <span style="color:#4af">${activeQuests.length}/5</span> &nbsp; Completed: <span style="color:#4c4">${completedCount}</span>`;
    this.questPanel.appendChild(summary);

    // â”€â”€ Active Quests â”€â”€
    const activeLabel = document.createElement('div');
    activeLabel.style.cssText = 'font-size:10px;color:#4af;padding:2px 4px;border-bottom:1px solid #333;margin-bottom:2px;font-weight:bold;';
    activeLabel.textContent = 'â”€â”€ ACTIVE QUESTS â”€â”€';
    this.questPanel.appendChild(activeLabel);

    if (activeQuests.length === 0) {
      const empty = document.createElement('p');
      empty.style.cssText = 'color:#666;font-size:10px;padding:4px;text-align:center;';
      empty.textContent = 'No active quests. Visit a quest board in town.';
      this.questPanel.appendChild(empty);
    } else {
      activeQuests.forEach(quest => {
        const div = document.createElement('div');
        div.style.cssText = 'padding:5px;border-bottom:1px solid #1a1a2a;font-size:11px;margin-bottom:2px;';

        const readyColor = quest.isComplete ? '#4f4' : '#ca8';
        const progressPct = quest.targetCount > 0 ? Math.floor((quest.progress / quest.targetCount) * 100) : 0;

        let html = `<div style="display:flex;justify-content:space-between;align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<span style="color:${quest.color}">${quest.icon}</span> `;
        html += `<strong style="color:${readyColor}">${quest.name}</strong><br>`;
        html += `<span style="color:#888;font-size:9px">${quest.description}</span><br>`;

        // Progress bar
        html += `<div style="display:flex;align-items:center;margin-top:3px;">`;
        html += `<div style="flex:1;height:6px;background:#1a1a2e;border-radius:3px;overflow:hidden;margin-right:6px;">`;
        html += `<div style="width:${progressPct}%;height:100%;background:${quest.isComplete ? '#4c4' : '#ca8'};border-radius:3px;"></div>`;
        html += `</div>`;
        html += `<span style="color:#888;font-size:9px;white-space:nowrap;">${quest.progressText}</span>`;
        html += `</div>`;

        // Rewards preview
        html += `<div style="font-size:9px;color:#666;margin-top:2px;">`;
        html += `<span style="color:#ffd700">${quest.goldReward}gp</span>`;
        html += ` <span style="color:#4af">${quest.xpReward}xp</span>`;
        if (quest.bonusItem) html += ` <span style="color:#8c8">+item</span>`;
        html += `</div>`;

        html += `</div>`;
        html += `<div style="display:flex;flex-direction:column;gap:2px;margin-left:4px;">`;

        // Turn-in button (if complete and in the right town)
        if (quest.isComplete && quest.townId === currentTownId) {
          html += `<button class="btn btn-small quest-turnin-btn" data-quest="${quest.id}" style="font-size:9px;padding:2px 6px;background:#254;color:#4f4;">âœ“ Turn In</button>`;
        } else if (quest.isComplete) {
          html += `<span style="font-size:8px;color:#ca8;text-align:center;">Return to<br>${quest.townId}</span>`;
        }

        html += `<button class="btn btn-small quest-abandon-btn" data-quest="${quest.id}" style="font-size:8px;padding:1px 4px;background:#422;color:#a66;">âœ• Drop</button>`;
        html += `</div></div>`;

        div.innerHTML = html;

        // Wire up buttons
        const turnInBtn = div.querySelector('.quest-turnin-btn');
        if (turnInBtn) {
          turnInBtn.addEventListener('click', () => onTurnIn(quest.id));
        }
        const abandonBtn = div.querySelector('.quest-abandon-btn');
        if (abandonBtn) {
          abandonBtn.addEventListener('click', () => onAbandon(quest.id));
        }

        this.questPanel.appendChild(div);
      });
    }

    // â”€â”€ Quest Board (if in town and standing on it) â”€â”€
    if (onBoard && questBoard.length > 0) {
      const boardLabel = document.createElement('div');
      boardLabel.style.cssText = 'font-size:10px;color:#ffa;padding:4px 4px 2px;border-bottom:1px solid #555;margin-top:8px;margin-bottom:2px;font-weight:bold;';
      boardLabel.textContent = 'â”€â”€ QUEST BOARD â”€â”€';
      this.questPanel.appendChild(boardLabel);

      questBoard.forEach(quest => {
        const div = document.createElement('div');
        div.style.cssText = 'padding:5px;border-bottom:1px solid #1a1a2a;font-size:11px;margin-bottom:2px;background:#141420;border-radius:3px;';

        let html = `<div style="display:flex;justify-content:space-between;align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<span style="color:${quest.color}">${quest.icon}</span> `;
        html += `<strong style="color:#ddd">${quest.name}</strong>`;
        html += ` <span style="color:#888;font-size:9px">[${quest.typeName}]</span><br>`;
        html += `<span style="color:#888;font-size:9px">${quest.description}</span><br>`;
        html += `<div style="font-size:9px;color:#666;margin-top:2px;">`;
        html += `Rewards: <span style="color:#ffd700">${quest.goldReward}gp</span>`;
        html += ` <span style="color:#4af">${quest.xpReward}xp</span>`;
        html += ` <span style="color:#8af">+${quest.fameReward} fame</span>`;
        if (quest.bonusItem) html += ` <span style="color:#8c8">+bonus item</span>`;
        html += `</div>`;
        html += `</div>`;

        html += `<button class="btn btn-small quest-accept-btn" data-quest="${quest.id}" style="font-size:9px;padding:3px 8px;background:#243;color:#8f8;margin-left:4px;">Accept</button>`;
        html += `</div>`;

        div.innerHTML = html;

        const acceptBtn = div.querySelector('.quest-accept-btn');
        if (acceptBtn) {
          acceptBtn.addEventListener('click', () => onAccept(quest.id));
        }

        this.questPanel.appendChild(div);
      });
    } else if (questBoard.length === 0 && onBoard) {
      const noQuests = document.createElement('div');
      noQuests.style.cssText = 'font-size:10px;color:#ffa;padding:4px 4px 2px;border-bottom:1px solid #555;margin-top:8px;margin-bottom:2px;font-weight:bold;';
      noQuests.textContent = 'â”€â”€ QUEST BOARD â”€â”€';
      this.questPanel.appendChild(noQuests);
      const emptyBoard = document.createElement('p');
      emptyBoard.style.cssText = 'color:#666;font-size:10px;padding:4px;text-align:center;';
      emptyBoard.textContent = 'No quests available. Check back later.';
      this.questPanel.appendChild(emptyBoard);
    }
  }

  // â”€â”€ Auto-switch to Quest Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToQuestTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const questTab = document.querySelector('[data-tab="questTab"]');
    if (questTab) questTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const questPanel = document.getElementById('questTab');
    if (questPanel) questPanel.classList.add('active');
  }

  // â”€â”€ Pets Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updatePets(state, onRelease, onRename, onRevive) {
    if (!this.petPanel) return;
    this.petPanel.innerHTML = '';

    const pets = state.pets || [];
    const maxPets = state.maxPets || 2;

    // Summary header
    const summary = document.createElement('div');
    summary.style.cssText = 'padding:4px 6px;margin-bottom:6px;background:#1a1a2e;border-radius:3px;font-size:10px;color:#888;text-align:center;';
    summary.innerHTML = `ğŸ¾ Pets: <span style="color:#4af">${pets.length}/${maxPets}</span> &nbsp; <span style="color:#666;font-size:9px">(CHA increases max)</span>`;
    this.petPanel.appendChild(summary);

    // How to tame hint
    const hint = document.createElement('div');
    hint.style.cssText = 'font-size:9px;color:#666;text-align:center;padding:2px 4px;margin-bottom:6px;';
    hint.textContent = 'Stand next to a wounded monster and press T to tame it.';
    this.petPanel.appendChild(hint);

    if (pets.length === 0) {
      const empty = document.createElement('p');
      empty.style.cssText = 'color:#555;font-size:11px;padding:12px;text-align:center;';
      empty.textContent = 'No pets yet. Tame monsters to gain allies!';
      this.petPanel.appendChild(empty);
      return;
    }

    pets.forEach(pet => {
      const div = document.createElement('div');
      div.style.cssText = `padding:6px;border-bottom:1px solid #1a1a2a;font-size:11px;margin-bottom:2px;${pet.isDead ? 'opacity:0.6;' : ''}`;

      const hpPct = pet.maxHp > 0 ? Math.floor((pet.hp / pet.maxHp) * 100) : 0;
      const hpColor = pet.isDead ? '#f44' : hpPct > 50 ? '#4d4' : hpPct > 25 ? '#dd4' : '#d44';
      const xpPct = pet.xpNext > 0 ? Math.floor((pet.xp / pet.xpNext) * 100) : 0;
      const loyaltyColor = (pet.loyalty || 0) >= 70 ? '#4f4' : (pet.loyalty || 0) >= 40 ? '#dd4' : '#f44';

      // Try to get monster sprite
      const spriteURL = window._tileManager && window._tileManager.getMonster(pet.templateId);
      let iconHtml;
      if (spriteURL && spriteURL.src) {
        iconHtml = `<img src="${spriteURL.src}" style="width:28px;height:28px;vertical-align:middle;margin-right:6px;border:1px solid #4a4;border-radius:3px;" draggable="false"/>`;
      } else {
        iconHtml = `<span style="color:${pet.color || '#4f4'};font-size:18px;margin-right:6px;vertical-align:middle;">${pet.char || 'p'}</span>`;
      }

      let html = `<div style="display:flex;align-items:flex-start;">`;
      html += `<div style="flex-shrink:0;">${iconHtml}</div>`;
      html += `<div style="flex:1;">`;
      html += `<strong style="color:${pet.isDead ? '#f44' : '#8f8'}">${pet.name}</strong>`;
      html += ` <span style="color:#888;font-size:9px">Lv.${pet.level}</span>`;
      if (pet.isDead) html += ` <span style="color:#f44;font-size:9px">ğŸ’€ DEAD</span>`;
      html += `<br>`;

      // HP bar
      html += `<div style="display:flex;align-items:center;margin-top:2px;">`;
      html += `<span style="color:#888;font-size:9px;width:20px;">HP</span>`;
      html += `<div style="flex:1;height:6px;background:#1a1a2e;border-radius:3px;overflow:hidden;margin-right:4px;">`;
      html += `<div style="width:${hpPct}%;height:100%;background:${hpColor};border-radius:3px;"></div>`;
      html += `</div>`;
      html += `<span style="color:#888;font-size:9px;">${pet.hp}/${pet.maxHp}</span>`;
      html += `</div>`;

      // XP bar
      html += `<div style="display:flex;align-items:center;margin-top:1px;">`;
      html += `<span style="color:#888;font-size:9px;width:20px;">XP</span>`;
      html += `<div style="flex:1;height:4px;background:#1a1a2e;border-radius:2px;overflow:hidden;margin-right:4px;">`;
      html += `<div style="width:${xpPct}%;height:100%;background:#48f;border-radius:2px;"></div>`;
      html += `</div>`;
      html += `<span style="color:#888;font-size:8px;">${pet.xp}/${pet.xpNext}</span>`;
      html += `</div>`;

      // Stats line
      html += `<div style="font-size:9px;color:#666;margin-top:2px;">`;
      html += `Atk: <span style="color:#c88">${pet.attack}</span>`;
      html += ` &nbsp; Loyalty: <span style="color:${loyaltyColor}">${pet.loyalty || 0}%</span>`;
      html += `</div>`;

      html += `</div>`; // end flex:1

      // Action buttons column
      html += `<div style="display:flex;flex-direction:column;gap:2px;margin-left:4px;flex-shrink:0;">`;
      if (pet.isDead) {
        html += `<button class="btn btn-small pet-revive-btn" data-pet="${pet.id}" style="font-size:8px;padding:2px 5px;background:#254;color:#4f4;">âœ¦ Revive</button>`;
      }
      html += `<button class="btn btn-small pet-rename-btn" data-pet="${pet.id}" style="font-size:8px;padding:1px 4px;background:#334;color:#8af;">âœ Name</button>`;
      html += `<button class="btn btn-small pet-release-btn" data-pet="${pet.id}" style="font-size:8px;padding:1px 4px;background:#422;color:#a66;">âœ• Free</button>`;
      html += `</div>`;
      html += `</div>`; // end flex container

      div.innerHTML = html;

      // Wire up buttons
      const reviveBtn = div.querySelector('.pet-revive-btn');
      if (reviveBtn) {
        reviveBtn.addEventListener('click', () => onRevive(pet.id));
      }
      const renameBtn = div.querySelector('.pet-rename-btn');
      if (renameBtn) {
        renameBtn.addEventListener('click', () => {
          const newName = prompt(`Rename ${pet.name}:`, pet.name);
          if (newName && newName.trim()) {
            onRename(pet.id, newName.trim());
          }
        });
      }
      const releaseBtn = div.querySelector('.pet-release-btn');
      if (releaseBtn) {
        releaseBtn.addEventListener('click', () => {
          if (confirm(`Release ${pet.name} into the wild?`)) {
            onRelease(pet.id);
          }
        });
      }

      this.petPanel.appendChild(div);
    });
  }

  // â”€â”€ Auto-switch to Pets Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToPetsTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const petsTab = document.querySelector('[data-tab="petsTab"]');
    if (petsTab) petsTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const petsPanel = document.getElementById('petsTab');
    if (petsPanel) petsPanel.classList.add('active');
  }

  // â”€â”€ Faith Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateFaith(state, onWorship, onOffer, onPray) {
    if (!this.faithPanel) return;
    this.faithPanel.innerHTML = '';

    const faith = state.faith || {};
    const onAltar = state.onAltar || false;
    const player = state.player || {};

    // â”€â”€ Current God Info â”€â”€
    if (faith.godId) {
      const godHeader = document.createElement('div');
      godHeader.style.cssText = 'padding:8px;margin-bottom:6px;background:#1a1a2e;border-radius:5px;text-align:center;border:1px solid ' + (faith.godColor || '#444') + ';';

      const favorPct = Math.min(100, Math.floor((faith.favor / 1500) * 100));
      const blessingColor = faith.activeBlessingKey === 'major' ? '#f4f' :
                            faith.activeBlessingKey === 'moderate' ? '#4af' :
                            faith.activeBlessingKey === 'minor' ? '#8c8' : '#555';

      let godHtml = `<span style="font-size:24px">${faith.godIcon || '?'}</span><br>`;
      godHtml += `<strong style="color:${faith.godColor || '#ccc'};font-size:13px;">${faith.godName}</strong><br>`;
      godHtml += `<span style="color:#888;font-size:10px;">${faith.godTitle || ''}</span><br>`;

      // Favor bar
      godHtml += `<div style="margin-top:6px;">`;
      godHtml += `<div style="display:flex;justify-content:space-between;font-size:9px;color:#888;margin-bottom:2px;">`;
      godHtml += `<span>Favor</span><span style="color:${faith.godColor || '#ccc'}">${faith.favor}</span>`;
      godHtml += `</div>`;
      godHtml += `<div style="height:8px;background:#111;border-radius:4px;overflow:hidden;border:1px solid #333;">`;
      godHtml += `<div style="width:${favorPct}%;height:100%;background:${faith.godColor || '#888'};border-radius:4px;transition:width 0.3s;"></div>`;
      godHtml += `</div></div>`;

      // Active blessing
      if (faith.activeBlessing) {
        godHtml += `<div style="margin-top:6px;padding:4px;background:#0a0a1a;border-radius:3px;border:1px solid ${blessingColor};">`;
        godHtml += `<span style="color:${blessingColor};font-size:10px;font-weight:bold;">âœ¦ ${faith.activeBlessing.name}</span><br>`;
        godHtml += `<span style="color:#888;font-size:9px;">${faith.activeBlessing.description}</span>`;
        godHtml += `</div>`;
      }

      // Next blessing
      if (faith.nextBlessing && faith.nextThreshold > 0) {
        const remaining = faith.nextThreshold - faith.favor;
        godHtml += `<div style="margin-top:3px;font-size:9px;color:#666;">`;
        godHtml += `Next: <span style="color:#aaa">${faith.nextBlessing.name}</span> in <span style="color:${faith.godColor || '#888'}">${remaining}</span> favor`;
        godHtml += `</div>`;
      }

      godHeader.innerHTML = godHtml;
      this.faithPanel.appendChild(godHeader);

      // Prayer button
      const prayDiv = document.createElement('div');
      prayDiv.style.cssText = 'text-align:center;margin-bottom:6px;';
      const prayBtn = document.createElement('button');
      prayBtn.className = 'btn btn-small';
      const canPray = faith.prayerCooldown <= 0;
      prayBtn.style.cssText = `font-size:11px;padding:6px 16px;background:${canPray ? '#243' : '#222'};color:${canPray ? '#8f8' : '#555'};border:1px solid ${canPray ? '#4a4' : '#333'};`;
      prayBtn.textContent = canPray ? `ğŸ™ Pray to ${faith.godName.split(' ')[0]}` : `ğŸ™ Prayer cooldown (${faith.prayerCooldown}t)`;
      if (canPray) {
        prayBtn.addEventListener('click', () => onPray());
      }
      prayDiv.appendChild(prayBtn);
      this.faithPanel.appendChild(prayDiv);

      // Offer item (only if on altar)
      if (onAltar) {
        const offerLabel = document.createElement('div');
        offerLabel.style.cssText = 'font-size:10px;color:#ffa;padding:2px 4px;border-bottom:1px solid #333;margin-bottom:2px;font-weight:bold;';
        offerLabel.textContent = 'â”€â”€ OFFER ITEM â”€â”€';
        this.faithPanel.appendChild(offerLabel);

        const inv = player.inventory || [];
        const offerableItems = [];
        inv.forEach((item, idx) => {
          // Can't offer equipped items or currency
          const equipped = player.equipment &&
            (player.equipment.weapon === item.id || player.equipment.armor === item.id);
          if (!equipped && item.type !== 'currency') {
            offerableItems.push({ item, idx });
          }
        });

        if (offerableItems.length === 0) {
          const noItems = document.createElement('p');
          noItems.style.cssText = 'color:#666;font-size:10px;padding:4px;text-align:center;';
          noItems.textContent = 'No items to offer.';
          this.faithPanel.appendChild(noItems);
        } else {
          offerableItems.slice(0, 10).forEach(({ item, idx }) => {
            const div = document.createElement('div');
            div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:3px 4px;border-bottom:1px solid #1a1a2a;font-size:10px;';

            const info = document.createElement('span');
            const favorGain = Math.max(5, Math.floor((item.value || 10) * 0.3) + 3);
            info.innerHTML = `<span style="color:${item.color || '#ccc'}">${item.char || '?'}</span> ${item.name} <span style="color:${faith.godColor || '#888'}">+${favorGain}</span>`;
            div.appendChild(info);

            const offerBtn = document.createElement('button');
            offerBtn.className = 'btn btn-small';
            offerBtn.style.cssText = 'font-size:9px;padding:1px 6px;background:#332;color:#ffa;';
            offerBtn.textContent = 'Offer';
            offerBtn.addEventListener('click', () => onOffer(idx));
            div.appendChild(offerBtn);

            this.faithPanel.appendChild(div);
          });
        }
      }

      // Description
      if (faith.godDescription) {
        const descDiv = document.createElement('div');
        descDiv.style.cssText = 'margin-top:6px;padding:4px;font-size:9px;color:#666;font-style:italic;text-align:center;';
        descDiv.textContent = faith.godDescription;
        this.faithPanel.appendChild(descDiv);
      }
    } else {
      // No god worshipped
      const noGod = document.createElement('div');
      noGod.style.cssText = 'text-align:center;padding:12px;color:#888;font-size:11px;';
      noGod.innerHTML = 'ğŸ™ You worship no god.<br><span style="font-size:9px;color:#666;">Visit an altar (â€ ) in a town to choose a deity.</span>';
      this.faithPanel.appendChild(noGod);
    }

    // â”€â”€ God Selection (when on altar) â”€â”€
    if (onAltar && faith.allGods) {
      const godsLabel = document.createElement('div');
      godsLabel.style.cssText = 'font-size:10px;color:#d0d050;padding:4px 4px 2px;border-bottom:1px solid #555;margin-top:8px;margin-bottom:2px;font-weight:bold;';
      godsLabel.textContent = 'â”€â”€ GODS OF THE WORLD â”€â”€';
      this.faithPanel.appendChild(godsLabel);

      faith.allGods.forEach(god => {
        const div = document.createElement('div');
        const isCurrentGod = faith.godId === god.id;
        div.style.cssText = `padding:6px;border-bottom:1px solid #1a1a2a;font-size:11px;${isCurrentGod ? 'background:#1a1a2e;border-left:2px solid ' + god.color + ';' : ''}`;

        let html = `<div style="display:flex;justify-content:space-between;align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<span style="font-size:16px">${god.icon}</span> `;
        html += `<strong style="color:${god.color}">${god.name}</strong>`;
        if (isCurrentGod) html += ` <span style="color:#4f4;font-size:9px;">â˜… Worshipped</span>`;
        html += `<br>`;
        html += `<span style="color:#888;font-size:9px;">${god.description}</span>`;
        html += `</div>`;

        if (!isCurrentGod) {
          html += `<button class="btn btn-small worship-btn" data-god="${god.id}" style="font-size:9px;padding:3px 8px;background:#332;color:${god.color};border:1px solid ${god.color};margin-left:4px;white-space:nowrap;">Worship</button>`;
        }
        html += `</div>`;

        div.innerHTML = html;

        const worshipBtn = div.querySelector('.worship-btn');
        if (worshipBtn) {
          worshipBtn.addEventListener('click', () => {
            if (faith.godId) {
              if (confirm(`Abandon ${faith.godName} and worship ${god.name}? Your old god may punish you!`)) {
                onWorship(god.id);
              }
            } else {
              onWorship(god.id);
            }
          });
        }

        this.faithPanel.appendChild(div);
      });
    } else if (!onAltar && !faith.godId) {
      // Hint about finding altars
      const hint = document.createElement('div');
      hint.style.cssText = 'text-align:center;padding:8px;font-size:9px;color:#555;';
      hint.innerHTML = 'Look for the <span style="color:#d0d050">â€ </span> altar tile in towns.';
      this.faithPanel.appendChild(hint);
    }
  }

  // â”€â”€ Auto-switch to Faith Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToFaithTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const faithTab = document.querySelector('[data-tab="faithTab"]');
    if (faithTab) faithTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const faithPanel = document.getElementById('faithTab');
    if (faithPanel) faithPanel.classList.add('active');
  }

  // â”€â”€ Auto-switch to Card Book Tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  switchToCardBookTab() {
    const tabs = document.querySelectorAll('.tab-btn');
    tabs.forEach(t => t.classList.remove('active'));
    const cardTab = document.querySelector('[data-tab="cardBookTab"]');
    if (cardTab) cardTab.classList.add('active');
    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    const cardPanel = document.getElementById('cardBookTab');
    if (cardPanel) cardPanel.classList.add('active');
  }

  // â”€â”€ Card Book Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateCardBook(state, onBuyCard, onSellCard) {
    if (!this.cardBookPanel) return;
    this.cardBookPanel.innerHTML = '';

    const collection = state.cardCollection;
    if (!collection) return;

    // Completion header
    const header = document.createElement('div');
    header.className = 'card-book-header';
    const pct = collection.totalMonsters > 0 ? Math.round((collection.totalUnique / collection.totalMonsters) * 100) : 0;
    header.innerHTML = `
      <div class="card-book-stats">
        <span>ğŸ“– Collection: <strong>${collection.totalUnique}</strong> / ${collection.totalMonsters} (${pct}%)</span>
        <span>Total Cards: <strong>${collection.totalCards}</strong></span>
      </div>
      <div class="card-book-progress">
        <div class="card-book-bar" style="width:${pct}%"></div>
      </div>
    `;
    this.cardBookPanel.appendChild(header);

    // Card shop section (if near card merchant)
    const cardShop = state.cardShop;
    if (cardShop && cardShop.length > 0) {
      const shopSection = document.createElement('div');
      shopSection.className = 'card-shop-section';
      shopSection.innerHTML = '<h4>ğŸª Card Merchant</h4>';

      // Buy section
      const buyHeader = document.createElement('div');
      buyHeader.className = 'card-subsection-header';
      buyHeader.textContent = 'â€” Buy Cards â€”';
      shopSection.appendChild(buyHeader);

      cardShop.forEach((card, idx) => {
        if (card.stock <= 0) return;
        const ri = this._getCardRarityInfo(card.rarity);
        const buyMonsterImg = window._tileManager && window._tileManager.getMonster(card.monsterId);
        const buyMonsterHtml = buyMonsterImg && buyMonsterImg.src
          ? `<img src="${buyMonsterImg.src}" style="width:24px;height:24px;vertical-align:middle;image-rendering:pixelated;" draggable="false"/>`
          : `<span style="color:${card.color}">${card.char || 'M'}</span>`;
        const div = document.createElement('div');
        div.className = `card-shop-item card-rarity-${card.rarity}`;
        div.innerHTML = `
          <span class="card-preview">${buyMonsterHtml}</span>
          <span class="card-info">
            <span class="card-name" style="color:${ri.color}">${ri.emoji} ${card.monsterName}</span>
            <span class="card-detail">Lv.${card.monsterLevel} ${ri.name}</span>
          </span>
          <button class="btn-card-buy" data-idx="${idx}">${card.buyPrice}gp</button>
        `;
        div.querySelector('.btn-card-buy').addEventListener('click', () => onBuyCard(idx));
        shopSection.appendChild(div);
      });

      // Sell section
      const sellHeader = document.createElement('div');
      sellHeader.className = 'card-subsection-header';
      sellHeader.textContent = 'â€” Sell Cards â€”';
      shopSection.appendChild(sellHeader);

      if (collection.cards.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'card-empty';
        empty.textContent = 'No cards to sell.';
        shopSection.appendChild(empty);
      } else {
        collection.cards.forEach((card, idx) => {
          const ri = this._getCardRarityInfo(card.rarity);
          const sellPrice = Math.max(1, Math.floor(card.value * 0.6));
          const sellMonsterImg = window._tileManager && window._tileManager.getMonster(card.monsterId);
          const sellMonsterHtml = sellMonsterImg && sellMonsterImg.src
            ? `<img src="${sellMonsterImg.src}" style="width:24px;height:24px;vertical-align:middle;image-rendering:pixelated;" draggable="false"/>`
            : `<span style="color:${card.color}">${card.char || 'M'}</span>`;
          const div = document.createElement('div');
          div.className = `card-shop-item card-rarity-${card.rarity}`;
          div.innerHTML = `
            <span class="card-preview">${sellMonsterHtml}</span>
            <span class="card-info">
              <span class="card-name" style="color:${ri.color}">${ri.emoji} ${card.monsterName} x${card.quantity || 1}</span>
              <span class="card-detail">Lv.${card.monsterLevel} ${ri.name}</span>
            </span>
            <button class="btn-card-sell" data-idx="${idx}">Sell ~${sellPrice}gp</button>
          `;
          div.querySelector('.btn-card-sell').addEventListener('click', () => onSellCard(idx));
          shopSection.appendChild(div);
        });
      }

      this.cardBookPanel.appendChild(shopSection);
    }

    // Collection grid
    const gridLabel = document.createElement('div');
    gridLabel.className = 'card-subsection-header';
    gridLabel.textContent = 'â€” Collection â€”';
    this.cardBookPanel.appendChild(gridLabel);

    if (collection.cards.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'card-empty';
      empty.textContent = 'No cards collected yet. Defeat monsters to collect their cards!';
      this.cardBookPanel.appendChild(empty);
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'card-grid';

    collection.cards.forEach(card => {
      const ri = this._getCardRarityInfo(card.rarity);
      const monsterImg = window._tileManager && window._tileManager.getMonster(card.monsterId);
      const monsterHtml = monsterImg && monsterImg.src
        ? `<img src="${monsterImg.src}" class="card-monster-sprite" draggable="false"/>`
        : `<span style="color:${card.color};font-size:1.6rem">${card.char || 'M'}</span>`;
      const cardEl = document.createElement('div');
      cardEl.className = `card-item card-rarity-${card.rarity}`;
      cardEl.innerHTML = `
        <div class="card-frame" style="border-color:${ri.border}">
          <div class="card-monster">${monsterHtml}</div>
          <div class="card-name-plate" style="background:${ri.border}22">
            <span style="color:${ri.color}">${card.monsterName}</span>
          </div>
          <div class="card-meta">
            <span>Lv.${card.monsterLevel}</span>
            <span style="color:${ri.color}">${ri.emoji} ${ri.name}</span>
          </div>
          ${(card.quantity || 1) > 1 ? `<div class="card-qty">x${card.quantity}</div>` : ''}
        </div>
      `;
      grid.appendChild(cardEl);
    });

    this.cardBookPanel.appendChild(grid);
  }

  _getCardRarityInfo(rarity) {
    const info = {
      normal:    { name: 'Normal',     color: '#ccc',    border: '#666',    emoji: 'ğŸƒ' },
      rare:      { name: 'Rare',       color: '#ffd740', border: '#ffa000', emoji: 'âœ¨' },
      superFoil: { name: 'Super Foil', color: '#e040fb', border: '#aa00ff', emoji: 'ğŸŒŸ' }
    };
    return info[rarity] || info.normal;
  }

  // â”€â”€ Enchant Target Picker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  showEnchantTargetPicker(targets, onSelect) {
    // Remove any existing picker
    this._closeEnchantPicker();

    const overlay = document.createElement('div');
    overlay.id = 'enchantPicker';
    overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6);z-index:200;display:flex;align-items:center;justify-content:center;';

    const panel = document.createElement('div');
    panel.style.cssText = 'background:#1a1a2e;border:2px solid #ffa;border-radius:8px;padding:16px;max-width:360px;width:90%;max-height:70vh;overflow-y:auto;';

    const title = document.createElement('div');
    title.style.cssText = 'text-align:center;font-size:14px;color:#ffa;margin-bottom:12px;font-weight:bold;';
    title.textContent = 'âœ¨ Choose item to enchant';
    panel.appendChild(title);

    targets.forEach(({ item, index }) => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:8px;border-bottom:1px solid #333;cursor:pointer;border-radius:4px;';
      row.addEventListener('mouseenter', () => row.style.background = '#2a2a4e');
      row.addEventListener('mouseleave', () => row.style.background = 'transparent');

      const info = document.createElement('div');
      info.style.flex = '1';
      const spriteURL = window._tileManager && window._tileManager.getItemSpriteURL(item);
      const iconHtml = spriteURL
        ? `<img src="${spriteURL}" style="width:20px;height:20px;vertical-align:middle;margin-right:4px;" draggable="false"/>`
        : `<span style="color:${item.color || '#ccc'};margin-right:4px;">${item.char || '?'}</span>`;

      let statsText = '';
      if (item.dice) statsText += `Dmg:${item.dice} `;
      if (item.PV != null) statsText += `PV:${item.PV + (item.enchantPVBonus || 0)} `;
      if (item.DV != null) statsText += `DV:${item.DV + (item.enchantDVBonus || 0)} `;
      const bonusText = item.enchantBonus ? ` <span style="color:#ffa">+${item.enchantBonus}</span>` : '';

      info.innerHTML = `${iconHtml}<strong style="color:#ddd">${item.name}</strong>${bonusText}<br>` +
        `<span style="color:#888;font-size:10px">${item.type} â€” ${statsText}</span>`;
      row.appendChild(info);

      const btn = document.createElement('button');
      btn.className = 'btn btn-small';
      btn.style.cssText = 'font-size:10px;padding:4px 10px;background:#443;color:#ffa;border:1px solid #664;';
      btn.textContent = 'Enchant';
      btn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        this._closeEnchantPicker();
        onSelect(index);
      });
      row.appendChild(btn);

      panel.appendChild(row);
    });

    // Cancel button
    const cancelRow = document.createElement('div');
    cancelRow.style.cssText = 'text-align:center;margin-top:12px;';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-small';
    cancelBtn.style.cssText = 'font-size:10px;padding:4px 16px;background:#422;color:#a88;';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.addEventListener('click', () => this._closeEnchantPicker());
    cancelRow.appendChild(cancelBtn);
    panel.appendChild(cancelRow);

    overlay.appendChild(panel);

    // Close on overlay click
    overlay.addEventListener('click', (ev) => {
      if (ev.target === overlay) this._closeEnchantPicker();
    });

    document.body.appendChild(overlay);
  }

  _closeEnchantPicker() {
    const existing = document.getElementById('enchantPicker');
    if (existing) existing.remove();
  }

  // â”€â”€ Gather Node Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  updateGatherOverlay(state) {
    let gatherEl = document.getElementById('gatherOverlay');
    if (state.gatherNode) {
      if (!gatherEl) {
        gatherEl = document.createElement('div');
        gatherEl.id = 'gatherOverlay';
        gatherEl.style.cssText = 'position:absolute;top:4px;left:50%;transform:translateX(-50%);background:rgba(20,25,40,0.88);padding:4px 14px;border-radius:4px;font-size:11px;color:#adf;border:1px solid #48a;z-index:10;white-space:nowrap;';
        document.getElementById('gameViewport').appendChild(gatherEl);
      }
      const node = state.gatherNode;
      gatherEl.innerHTML = `${node.icon} <strong>${node.name}</strong> â€” <span style="color:#888">${node.skill}</span> <span style="color:#6af">âŸ¶ Press M to ${node.verb}!</span>`;
      gatherEl.style.display = '';
    } else if (gatherEl) {
      gatherEl.style.display = 'none';
    }
  }

  // â”€â”€ Save List (main menu) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  populateSaveList(saves, onLoad) {
    const list = document.getElementById('saveList');
    if (!list) return;
    list.innerHTML = '';
    if (!saves || saves.length === 0) {
      list.innerHTML = '<p style="color:#666">No saved games found.</p>';
      return;
    }
    saves.forEach(s => {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.display = 'block';
      btn.style.width = '100%';
      btn.style.marginBottom = '6px';
      btn.textContent = `${s.playerName || s.id} â€” Lv.${s.level || '?'} â€” ${s.savedAt ? new Date(s.savedAt).toLocaleDateString() : 'Unknown'}`;
      btn.onclick = () => onLoad(s.id);
      list.appendChild(btn);
    });
  }

  // â”€â”€ Game Over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  showGameOver(state) {
    this.showScreen('gameOver');
    const deathMsg = document.getElementById('deathMessage');
    if (deathMsg && state && state.player) {
      deathMsg.textContent = `${state.player.name} the ${state.player.raceName} ${state.player.className} has died at level ${state.player.level || 1}.`;
    }

    const recapEl = document.getElementById('deathRecap');
    const recap = state && state.deathRecap;
    if (!recapEl || !recap) return;

    recapEl.style.display = '';

    // Killer banner
    const killerEl = document.getElementById('recapKiller');
    if (killerEl) {
      const locText = recap.floor > 0
        ? `${recap.location} (Floor ${recap.floor})`
        : recap.location;
      killerEl.innerHTML = `â˜  Slain by <strong>${recap.killedBy}</strong> in ${locText} on turn ${recap.turn}`;
    }

    // Last hits
    const lastHitsEl = document.getElementById('recapLastHits');
    if (lastHitsEl) {
      if (recap.lastHits.length === 0) {
        lastHitsEl.innerHTML = '<span style="color:var(--text-dim)">No data</span>';
      } else {
        lastHitsEl.innerHTML = recap.lastHits.map(h =>
          `<div class="recap-list-item">` +
            `<span class="source">${h.source}</span>` +
            `<span><span class="damage">-${h.damage}</span><span class="turn-num">T${h.turn}</span></span>` +
          `</div>`
        ).join('');
      }
    }

    // Top damage sources
    const topEl = document.getElementById('recapTopSources');
    if (topEl) {
      if (recap.topDamageSources.length === 0) {
        topEl.innerHTML = '<span style="color:var(--text-dim)">No data</span>';
      } else {
        topEl.innerHTML = recap.topDamageSources.map(s => {
          const pct = recap.totalDamageTaken > 0
            ? Math.round(s.total / recap.totalDamageTaken * 100) : 0;
          return `<div class="recap-list-item">` +
            `<span class="source">${s.source}</span>` +
            `<span><span class="damage">${s.total}</span> <span class="turn-num">${pct}%</span></span>` +
          `</div>`;
        }).join('');
      }
    }

    // Adventure summary stats
    const statsEl = document.getElementById('recapStats');
    if (statsEl) {
      const stats = [
        { label: 'Turns Survived', value: recap.turn },
        { label: 'Time Alive', value: recap.timeAlive || 'â€”' },
        { label: 'Monsters Slain', value: recap.killCount },
        { label: 'Deepest Floor', value: recap.deepestFloor > 0 ? `B${recap.deepestFloor}` : 'â€”' },
        { label: 'Locations Visited', value: recap.locationsVisited },
        { label: 'Fame', value: recap.fame },
        { label: 'Karma', value: recap.karma },
        { label: 'Gold', value: `${recap.gold} gp` },
      ];
      statsEl.innerHTML = stats.map(s =>
        `<div class="recap-stat">` +
          `<span class="label">${s.label}</span>` +
          `<span class="value">${s.value}</span>` +
        `</div>`
      ).join('');
    }

    // Card collection summary
    const cardsEl = document.getElementById('recapCards');
    if (cardsEl && recap.cardSummary) {
      const cs = recap.cardSummary;
      let html = `
        <div class="recap-stat-grid" style="margin-bottom:0.6rem">
          <div class="recap-stat"><span class="label">Unique Collected</span><span class="value">${cs.uniqueCollected} / ${cs.totalMonsters} (${cs.completionPct}%)</span></div>
          <div class="recap-stat"><span class="label">Total Cards</span><span class="value">${cs.totalCards}</span></div>
          <div class="recap-stat"><span class="label">âœ¨ Rare Cards</span><span class="value" style="color:#ffd740">${cs.rareCount}</span></div>
          <div class="recap-stat"><span class="label">ğŸŒŸ Super Foil</span><span class="value" style="color:#e040fb">${cs.foilCount}</span></div>
        </div>`;
      if (cs.topCards && cs.topCards.length > 0) {
        html += '<div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:0.3rem">Top Cards:</div>';
        html += cs.topCards.map(c => {
          const ri = this._getCardRarityInfo(c.rarity);
          return `<div style="display:flex;align-items:center;gap:0.4rem;padding:0.15rem 0;font-size:0.78rem">` +
            `<span style="color:${c.color}">${c.char || 'M'}</span>` +
            `<span style="color:${ri.color}">${ri.emoji} ${c.monsterName}</span>` +
            `<span style="color:var(--text-dim);font-size:0.7rem">(${ri.name}) x${c.quantity || 1}</span>` +
          `</div>`;
        }).join('');
      }
      cardsEl.innerHTML = html;
    } else if (cardsEl) {
      cardsEl.innerHTML = '<span style="color:var(--text-dim);font-size:0.78rem">No cards collected.</span>';
    }
  }
}

</script>
  <script>
// ============================================================
// Input â€” Keyboard & mouse input handling
// ============================================================

class InputHandler {
  constructor(canvas, onAction) {
    this.onAction = onAction; // callback: (action) => void
    this.canvas = canvas;
    this.enabled = false;
    this.mode = 'localMap'; // 'worldMap' | 'localMap'

    // Track currently held keys for timed-action system
    this.heldKeys = new Set();

    // Callbacks for the timed-action system
    this.onActionStart = null;  // (action, key) => void â€” called on keydown
    this.onActionCancel = null; // (key) => void â€” called on keyup, returns true if it cancelled something

    this._keyDownHandler = this._onKeyDown.bind(this);
    this._keyUpHandler = this._onKeyUp.bind(this);
    this._clickHandler = this._onClick.bind(this);
  }

  enable() {
    if (this.enabled) return;
    this.enabled = true;
    document.addEventListener('keydown', this._keyDownHandler);
    document.addEventListener('keyup', this._keyUpHandler);
    this.canvas.addEventListener('click', this._clickHandler);
  }

  disable() {
    this.enabled = false;
    this.heldKeys.clear();
    document.removeEventListener('keydown', this._keyDownHandler);
    document.removeEventListener('keyup', this._keyUpHandler);
    this.canvas.removeEventListener('click', this._clickHandler);
  }

  setMode(mode) {
    this.mode = mode;
  }

  isKeyHeld(key) {
    return this.heldKeys.has(key);
  }

  // â”€â”€ Key Up â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onKeyUp(e) {
    const key = e.key.toLowerCase();
    this.heldKeys.delete(key);
    this.heldKeys.delete(e.code);
    if (this.onActionCancel) {
      this.onActionCancel(key);
    }
  }

  // â”€â”€ Keyboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onKeyDown(e) {
    if (!this.enabled) return;

    // Ignore repeated keydown events (key held)
    if (e.repeat) return;

    // Track held key
    const keyLower = e.key.toLowerCase();
    this.heldKeys.add(keyLower);
    this.heldKeys.add(e.code);

    // Prevent default for game keys
    const gameKeys = [
      'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
      'Numpad1', 'Numpad2', 'Numpad3', 'Numpad4',
      'Numpad5', 'Numpad6', 'Numpad7', 'Numpad8', 'Numpad9',
      'Period', 'Comma', 'Enter', 'Escape',
    ];
    const letter = e.key.toLowerCase();

    // Movement directions
    const moveMap = {
      'ArrowUp': { dx: 0, dy: -1 },
      'ArrowDown': { dx: 0, dy: 1 },
      'ArrowLeft': { dx: -1, dy: 0 },
      'ArrowRight': { dx: 1, dy: 0 },
      'Numpad8': { dx: 0, dy: -1 },
      'Numpad2': { dx: 0, dy: 1 },
      'Numpad4': { dx: -1, dy: 0 },
      'Numpad6': { dx: 1, dy: 0 },
      'Numpad7': { dx: -1, dy: -1 },
      'Numpad9': { dx: 1, dy: -1 },
      'Numpad1': { dx: -1, dy: 1 },
      'Numpad3': { dx: 1, dy: 1 },
    };

    // Vi keys
    const viMap = {
      'k': { dx: 0, dy: -1 },
      'j': { dx: 0, dy: 1 },
      'h': { dx: -1, dy: 0 },
      'l': { dx: 1, dy: 0 },
      'y': { dx: -1, dy: -1 },
      'u': { dx: 1, dy: -1 },
      'b': { dx: -1, dy: 1 },
      'n': { dx: 1, dy: 1 },
    };

    // Check movement
    let dir = moveMap[e.code] || viMap[letter];
    if (dir) {
      e.preventDefault();
      this.onAction({ type: 'move', dx: dir.dx, dy: dir.dy });
      return;
    }

    // Other actions
    switch (letter) {
      case 'g': // Pickup
        e.preventDefault();
        this._dispatchTimedAction({ type: 'pickup' }, letter);
        break;
      case 'e': // Eat (first edible)
        e.preventDefault();
        this._dispatchTimedAction({ type: 'eat' }, letter);
        break;
      case '.': // Wait (also Numpad5)
        e.preventDefault();
        this.onAction({ type: 'wait' });
        break;
      case 's': // Save (Ctrl+S) or Sleep
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          this.onAction({ type: 'save' });
        } else {
          e.preventDefault();
          this._dispatchTimedAction({ type: 'sleep' }, letter);
        }
        break;
      case 'z': // Open spell menu / cast
        e.preventDefault();
        this.onAction({ type: 'openSpells' });
        break;
      case 'f': // Fire ranged weapon
        e.preventDefault();
        this._dispatchTimedAction({ type: 'rangedAttack' }, letter);
        break;
      case 'c': // Open crafting
        e.preventDefault();
        this.onAction({ type: 'openCraft' });
        break;
      case 'q': // Open quests
        e.preventDefault();
        this.onAction({ type: 'openQuests' });
        break;
      case 't': // Tame adjacent monster
        e.preventDefault();
        this._dispatchTimedAction({ type: 'tame' }, letter);
        break;
      case 'm': // Mine / gather resources
        e.preventDefault();
        this._dispatchTimedAction({ type: 'gather' }, letter);
        break;
      case 'p': // Plant seed
        e.preventDefault();
        this._dispatchTimedAction({ type: 'openPlant' }, letter);
        break;
      case 'r': // Pray to god
        e.preventDefault();
        this._dispatchTimedAction({ type: 'pray' }, letter);
        break;
      case 'b': // Open card book
        e.preventDefault();
        this.onAction({ type: 'openCardBook' });
        break;
      default:
        break;
    }

    // Shift keys
    if (e.shiftKey && e.key === 'H') {
      e.preventDefault();
      this._dispatchTimedAction({ type: 'harvest' }, 'h');
    }
    if (e.shiftKey && e.key === 'U') {
      e.preventDefault();
      this.onAction({ type: 'pickupFurniture' });
    }

    // Special keys by code
    switch (e.code) {
      case 'Numpad5': // Wait
        e.preventDefault();
        this.onAction({ type: 'wait' });
        break;
      case 'Enter':
        e.preventDefault();
        if (this.mode === 'worldMap') {
          this.onAction({ type: 'enterLocation' });
        }
        break;
      case 'Escape':
        e.preventDefault();
        // Cancel timed action only â€” map exit is handled by walking to the edge
        if (this.onActionCancel) {
          this.onActionCancel('__escape__');
        }
        break;
      case 'Period': // > descend
        if (e.shiftKey) {
          e.preventDefault();
          this.onAction({ type: 'descend' });
        }
        break;
      case 'Comma': // < ascend
        if (e.shiftKey) {
          e.preventDefault();
          this.onAction({ type: 'ascend' });
        }
        break;
    }
  }

  // â”€â”€ Dispatch action through timed system or directly â”€â”€
  _dispatchTimedAction(action, key) {
    if (this.onActionStart) {
      this.onActionStart(action, key);
    } else {
      this.onAction(action);
    }
  }

  // â”€â”€ Mouse Click â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _onClick(e) {
    if (!this.enabled) return;
    // We'll let app.js handle translating clicks to tile coordinates
    // via renderer.getClickedTile
    const event = new CustomEvent('tileClick', {
      detail: { clientX: e.clientX, clientY: e.clientY }
    });
    this.canvas.dispatchEvent(event);
  }
}

</script>
  <script>
// ============================================================
// App â€” Main entry point, local engine, state management
// (No server required â€” all game logic runs in the browser)
// ============================================================

(async function () {
  'use strict';

  // Load all game data from static JSON files before initializing UI
  await loadGameData();

  // Core systems
  const canvas = document.getElementById('gameCanvas');
  const renderer = new Renderer(canvas);
  const ui = new UI();

  // Expose tile manager for UI sprite access
  window._tileManager = renderer.tiles;

  // Local game engine (replaces server-side socket.io)
  let engine = null;

  // Current game state
  let gameState = null;

  const input = new InputHandler(canvas, handleAction);

  // â”€â”€ Timed Action System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Tracks the currently progressing timed action
  let timedAction = null; // { action, timing, key, ticksDone, ticksTotal, timer }

  const progressOverlay = document.getElementById('actionProgressOverlay');
  const progressIcon = document.getElementById('actionProgressIcon');
  const progressLabel = document.getElementById('actionProgressLabel');
  const progressFill = document.getElementById('actionProgressFill');
  const progressTicks = document.getElementById('actionProgressTicks');

  // How fast each tick progresses (ms per tick) â€” feels snappy
  const BASE_TICK_MS = 180;

  function showProgressBar(timing) {
    progressIcon.textContent = timing.icon || 'â³';
    progressLabel.textContent = timing.label || 'Working...';
    progressFill.style.width = '0%';
    // Color speed indicator
    progressFill.className = 'action-progress-fill';
    if (timing.ticks <= 2) progressFill.classList.add('fill-fast');
    else if (timing.ticks >= 5) progressFill.classList.add('fill-slow');
    progressTicks.textContent = `0 / ${timing.ticks}`;
    progressOverlay.classList.remove('hidden');
  }

  function updateProgressBar(done, total) {
    const pct = Math.min(100, (done / total) * 100);
    progressFill.style.width = pct + '%';
    progressTicks.textContent = `${done} / ${total}`;
  }

  function hideProgressBar() {
    progressOverlay.classList.add('hidden');
  }

  function cancelTimedAction(showMessage) {
    if (!timedAction) return;
    clearInterval(timedAction.timer);
    if (showMessage && engine && gameState) {
      engine.addMessage('Action cancelled.');
      gameState = engine.getClientState();
      ui.updateMessages(gameState.messages);
    }
    timedAction = null;
    hideProgressBar();
  }

  function startTimedAction(action, key) {
    if (!engine || !gameState) return;

    // Get timing info
    const context = engine.getActionContext(action);
    const timing = ActionTimingSystem.getActionTiming(action, engine.player, context);

    // Instant actions â€” execute immediately
    if (timing.instant || timing.ticks <= 1) {
      handleAction(action);
      return;
    }

    // Cancel any existing timed action
    if (timedAction) {
      cancelTimedAction(false);
    }

    // Start timed action with progress bar
    showProgressBar(timing);

    // Show a message about the action starting
    const tickMsg = timing.ticks <= 2 ? '(quick)' : timing.ticks <= 4 ? '' : '(slow)';
    engine.addMessage(`${timing.label || 'Working...'} [${timing.ticks} ticks] ${tickMsg}`);
    gameState = engine.getClientState();
    ui.updateMessages(gameState.messages);

    const ta = {
      action,
      timing,
      key,
      ticksDone: 0,
      ticksTotal: timing.ticks,
      timer: null
    };

    ta.timer = setInterval(() => {
      // Check if key is still held (for keyboard actions)
      if (key && !input.isKeyHeld(key)) {
        cancelTimedAction(true);
        return;
      }

      ta.ticksDone++;
      updateProgressBar(ta.ticksDone, ta.ticksTotal);

      if (ta.ticksDone >= ta.ticksTotal) {
        // Action complete â€” execute it
        clearInterval(ta.timer);
        timedAction = null;
        hideProgressBar();
        handleAction(action);
      }
    }, BASE_TICK_MS);

    timedAction = ta;
  }

  // Wire up the timed action system to input handler
  input.onActionStart = (action, key) => {
    startTimedAction(action, key);
  };

  input.onActionCancel = (key) => {
    if (timedAction && (timedAction.key === key || key === '__escape__')) {
      cancelTimedAction(true);
      return true;
    }
    return false;
  };

  // â”€â”€ Screen: Main Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ui.showScreen('mainMenu');

  // New Game button
  document.getElementById('btnNewGame').addEventListener('click', () => {
    ui.showScreen('charCreation');
  });

  // Load Game button
  document.getElementById('btnLoadGame').addEventListener('click', () => {
    const saves = SaveManager.listSaves();
    ui.populateSaveList(saves, (saveId) => {
      const saveData = SaveManager.load(saveId);
      if (saveData) {
        engine = new GameEngine();
        engine.loadFromSave(saveData);
        applyGameState(engine.getClientState());
      } else {
        console.error('Save not found:', saveId);
      }
    });
  });

  // â”€â”€ Screen: Character Creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('btnStartGame').addEventListener('click', () => {
    const data = ui.getCreationData();
    engine = new GameEngine();
    engine.createNewGame(data);
    applyGameState(engine.getClientState());
  });

  document.getElementById('btnBackToMenu').addEventListener('click', () => {
    ui.showScreen('mainMenu');
  });

  // â”€â”€ Screen: Game Over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('btnReturnMenu').addEventListener('click', () => {
    gameState = null;
    engine = null;
    input.disable();
    ui.showScreen('mainMenu');
  });

  // â”€â”€ Action Bar Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Actions that go through the timed system when triggered via button
  const timedBtnActions = new Set([
    'pickup', 'eat', 'rangedAttack', 'tame', 'gather', 'pray',
    'openPlant', 'harvest'
  ]);

  const actionBtns = {
    btnPickup: { type: 'pickup' },
    btnWait: { type: 'wait' },
    btnEat: { type: 'eat' },
    btnMagic: { type: 'openSpells' },
    btnShoot: { type: 'rangedAttack' },
    btnCraft: { type: 'openCraft' },
    btnQuest: { type: 'openQuests' },
    btnTame: { type: 'tame' },
    btnGather: { type: 'gather' },
    btnPray: { type: 'pray' },
    btnPlant: { type: 'openPlant' },
    btnHarvest: { type: 'harvest' },
    btnDescend: { type: 'descend' },
    btnAscend: { type: 'ascend' },
    btnSave: { type: 'save' },
    btnEnter: { type: 'enterLocation' }
  };
  Object.entries(actionBtns).forEach(([id, action]) => {
    const btn = document.getElementById(id);
    if (btn) {
      if (timedBtnActions.has(action.type)) {
        // For timed actions via button click: auto-complete with progress bar
        btn.addEventListener('click', () => handleTimedOrDirect(action));
      } else {
        btn.addEventListener('click', () => handleAction(action));
      }
    }
  });

  // â”€â”€ Handle Player Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Route UI-triggered actions through timed system (auto-completes, no key hold needed)
  function handleTimedOrDirect(action) {
    if (!engine || !gameState) return;
    const context = engine.getActionContext(action);
    const timing = ActionTimingSystem.getActionTiming(action, engine.player, context);
    if (timing.instant || timing.ticks <= 1) {
      handleAction(action);
      return;
    }
    // For UI-triggered timed actions: auto-complete (no key hold required)
    if (timedAction) cancelTimedAction(false);
    showProgressBar(timing);
    const ta = {
      action,
      timing,
      key: null, // null = auto-complete (UI-triggered)
      ticksDone: 0,
      ticksTotal: timing.ticks,
      timer: null
    };
    ta.timer = setInterval(() => {
      ta.ticksDone++;
      updateProgressBar(ta.ticksDone, ta.ticksTotal);
      if (ta.ticksDone >= ta.ticksTotal) {
        clearInterval(ta.timer);
        timedAction = null;
        hideProgressBar();
        handleAction(action);
      }
    }, BASE_TICK_MS);
    timedAction = ta;
  }

  function handleAction(action) {
    if (!gameState || !engine) return;

    // Cancel any active timed action if the player does something else
    if (timedAction && action.type !== timedAction.action.type) {
      cancelTimedAction(false);
    }

    if (action.type === 'save') {
      const id = SaveManager.save(engine.serialize());
      console.log('Game saved:', id);
      if (gameState && gameState.messages) {
        gameState.messages.push({ text: 'â€” Game saved â€”', type: 'important' });
        ui.updateMessages(gameState.messages);
      }
      return;
    }

    if (action.type === 'openSpells') {
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(t => t.classList.remove('active'));
      const spellTab = document.querySelector('[data-tab="spellsTab"]');
      if (spellTab) spellTab.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const spellPanel = document.getElementById('spellsTab');
      if (spellPanel) spellPanel.classList.add('active');
      return;
    }

    if (action.type === 'openCraft') {
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(t => t.classList.remove('active'));
      const craftTab = document.querySelector('[data-tab="craftTab"]');
      if (craftTab) craftTab.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const craftPanel = document.getElementById('craftTab');
      if (craftPanel) craftPanel.classList.add('active');
      return;
    }

    if (action.type === 'openQuests') {
      ui.switchToQuestTab();
      return;
    }

    if (action.type === 'openCardBook') {
      ui.switchToCardBookTab();
      return;
    }

    if (action.type === 'openFaith') {
      ui.switchToFaithTab();
      return;
    }

    // Worship a god (from faith panel)
    if (action.type === 'worship') {
      engine.processAction({ type: 'worship', godId: action.godId });
      applyGameState(engine.getClientState());
      return;
    }

    // Offer an item at an altar (from faith panel)
    if (action.type === 'offerItem') {
      engine.processAction({ type: 'offerItem', itemIndex: action.itemIndex });
      applyGameState(engine.getClientState());
      return;
    }

    if (action.type === 'openPlant') {
      if (gameState && gameState.player && gameState.player.inventory) {
        const seedIdx = gameState.player.inventory.findIndex(i => i.type === 'seed');
        if (seedIdx >= 0) {
          handleTimedOrDirect({ type: 'plant', itemIndex: seedIdx });
          return;
        }
      }
      const tabs = document.querySelectorAll('.tab-btn');
      tabs.forEach(t => t.classList.remove('active'));
      const invTab = document.querySelector('[data-tab="inventory"]');
      if (invTab) invTab.classList.add('active');
      document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
      const invPanel = document.getElementById('inventory');
      if (invPanel) invPanel.classList.add('active');
      return;
    }

    // Enchant target selection â€” show a picker to choose a weapon/armor target
    if (action.type === 'openEnchantTarget') {
      const scrollIdx = action.scrollIndex;
      if (!gameState || !gameState.player) return;
      const inv = gameState.player.inventory;
      // Find all enchantable items (weapons and armor)
      const targets = [];
      inv.forEach((item, i) => {
        if (i !== scrollIdx && (item.type === 'weapon' || item.type === 'armor')) {
          targets.push({ item, index: i });
        }
      });
      if (targets.length === 0) {
        if (gameState.messages) {
          gameState.messages.push({ text: 'You have no weapons or armor to enchant.', type: 'important' });
          ui.updateMessages(gameState.messages);
        }
        return;
      }
      ui.showEnchantTargetPicker(targets, (targetIdx) => {
        engine.processAction({ type: 'enchant', scrollIndex: scrollIdx, targetIndex: targetIdx });
        applyGameState(engine.getClientState());
      });
      return;
    }

    // All other actions go directly to the engine
    engine.processAction(action);
    applyGameState(engine.getClientState());
  }

  // â”€â”€ Canvas Click â†’ Movement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  canvas.addEventListener('tileClick', (e) => {
    if (!gameState || !gameState.player) return;
    const { clientX, clientY } = e.detail;
    const tile = renderer.getClickedTile(clientX, clientY);

    let px, py;
    if (gameState.mode === 'worldMap') {
      px = gameState.worldX;
      py = gameState.worldY;
    } else {
      px = gameState.player.x;
      py = gameState.player.y;
    }

    const rawDx = tile.tileX - px;
    const rawDy = tile.tileY - py;
    const absDx = Math.abs(rawDx);
    const absDy = Math.abs(rawDy);

    if (absDx === 0 && absDy === 0) return;

    let dx, dy;
    // If the distances are close (ratio within ~1.5), allow diagonal
    if (absDx > 0 && absDy > 0 && Math.max(absDx, absDy) / Math.min(absDx, absDy) <= 1.5) {
      dx = Math.sign(rawDx);
      dy = Math.sign(rawDy);
    } else if (absDx >= absDy) {
      // Dominant horizontal â€” move only left/right
      dx = Math.sign(rawDx);
      dy = 0;
    } else {
      // Dominant vertical â€” move only up/down
      dx = 0;
      dy = Math.sign(rawDy);
    }

    handleAction({ type: 'move', dx, dy });
  });

  // â”€â”€ Apply Game State (replaces socket.on('gameState')) â”€â”€
  function applyGameState(state) {
    gameState = state;

    if (state.dead) {
      input.disable();
      ui.showGameOver(state);
      return;
    }

    ui.showScreen('gameScreen');
    renderer._resize();
    input.enable();
    input.setMode(state.mode);

    // Update UI
    ui.updateHUD(state);
    ui.updateMessages(state.messages);
    ui.updateGatherOverlay(state);
    ui.updateContextActions(state.contextActions, handleAction);
    ui.updateInventory(
      state.player,
      (action) => {
        if (action.type === 'plant') {
          handleTimedOrDirect(action);
        } else if (action.type === 'readSpellbook') {
          handleTimedOrDirect(action);
        } else if (action.type === 'openEnchantTarget') {
          handleAction(action);
        } else if (action.type === 'use') {
          handleTimedOrDirect(action);
        } else if (action.type === 'eat') {
          handleTimedOrDirect(action);
        } else if (action.type === 'readRecipe') {
          handleAction(action);
        } else if (action.type === 'placeWorkshop') {
          handleAction(action);
        } else {
          handleAction(action);
        }
      }
    );
    ui.updateCharacter(state.player);
    ui.updateSkills(state.player);
    ui.updateSpells(
      state.player,
      (spellId) => handleTimedOrDirect({ type: 'castSpell', spellId })
    );
    ui.updateShop(
      state,
      (itemId) => {
        engine.processAction({ type: 'shopBuy', itemId });
        applyGameState(engine.getClientState());
      },
      (itemIndex) => {
        engine.processAction({ type: 'shopSell', itemIndex });
        applyGameState(engine.getClientState());
      }
    );
    ui.updateCrafting(
      state,
      (recipeId) => {
        handleTimedOrDirect({ type: 'craft', recipeId });
      }
    );
    ui.updateQuests(
      state,
      (questId) => {
        engine.processAction({ type: 'acceptQuest', questId });
        applyGameState(engine.getClientState());
      },
      (questId) => {
        engine.processAction({ type: 'turnInQuest', questId });
        applyGameState(engine.getClientState());
      },
      (questId) => {
        engine.processAction({ type: 'abandonQuest', questId });
        applyGameState(engine.getClientState());
      }
    );
    ui.updateFaith(
      state,
      (godId) => handleAction({ type: 'worship', godId }),
      (itemIndex) => handleAction({ type: 'offerItem', itemIndex }),
      () => handleAction({ type: 'pray' })
    );
    ui.updatePets(
      state,
      (petId) => {
        engine.processAction({ type: 'releasePet', petId });
        applyGameState(engine.getClientState());
      },
      (petId, newName) => {
        engine.processAction({ type: 'renamePet', petId, newName });
        applyGameState(engine.getClientState());
      },
      (petId) => {
        engine.processAction({ type: 'revivePet', petId });
        applyGameState(engine.getClientState());
      }
    );
    ui.updateCardBook(
      state,
      (cardIndex) => {
        engine.processAction({ type: 'cardShopBuy', cardIndex });
        applyGameState(engine.getClientState());
      },
      (cardIndex) => {
        engine.processAction({ type: 'cardShopSell', cardIndex });
        applyGameState(engine.getClientState());
      }
    );

    // Auto-open shop tab when near NPC
    if (state.shop && !ui._shopTabOpened) {
      ui.switchToShopTab();
      ui._shopTabOpened = true;
    } else if (!state.shop) {
      ui._shopTabOpened = false;
    }

    // Auto-open quest tab when on quest board
    if (state.onQuestBoard && !ui._questTabOpened) {
      ui.switchToQuestTab();
      ui._questTabOpened = true;
    } else if (!state.onQuestBoard) {
      ui._questTabOpened = false;
    }

    // Auto-open pets tab when a pet is newly tamed
    if (state.pets && state.pets.length > 0 && !ui._petTabShown) {
      ui._petTabShown = state.pets.length;
    }
    if (state.pets && state.pets.length > (ui._petTabShown || 0)) {
      ui.switchToPetsTab();
      ui._petTabShown = state.pets.length;
    }

    // Auto-open faith tab when on altar
    if (state.onAltar && !ui._faithTabOpened) {
      ui.switchToFaithTab();
      ui._faithTabOpened = true;
    } else if (!state.onAltar) {
      ui._faithTabOpened = false;
    }

    // Auto-open card book tab when near card merchant
    if (state.cardShop && !ui._cardShopOpened) {
      ui.switchToCardBookTab();
      ui._cardShopOpened = true;
    } else if (!state.cardShop) {
      ui._cardShopOpened = false;
    }

    // Render
    if (state.mode === 'worldMap') {
      renderer.renderWorldMap(state);
    } else {
      renderer.renderLocalMap(state);
    }
  }

  // â”€â”€ Window Focus â†’ Resize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  window.addEventListener('focus', () => {
    renderer._resize();
    if (gameState) {
      if (gameState.mode === 'worldMap') renderer.renderWorldMap(gameState);
      else renderer.renderLocalMap(gameState);
    }
  });

})();

</script>
</body>
</html>
